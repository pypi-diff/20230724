# Comparing `tmp/azure-mgmt-kusto-3.1.0b1.zip` & `tmp/azure-mgmt-kusto-3.2.0.zip`

## zipinfo {}

```diff
@@ -1,77 +1,79 @@
-Zip file size: 195357 bytes, number of entries: 75
-drwxrwxr-x  2.0 unx        0 b- stor 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/azure_mgmt_kusto.egg-info/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/azure/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/tests/
--rw-rw-r--  2.0 unx       38 b- defN 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/setup.cfg
--rw-rw-r--  2.0 unx     1074 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/LICENSE
--rw-rw-r--  2.0 unx     2816 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/setup.py
--rw-rw-r--  2.0 unx    13131 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/CHANGELOG.md
--rw-rw-r--  2.0 unx      211 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/MANIFEST.in
--rw-rw-r--  2.0 unx      630 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/_meta.json
--rw-rw-r--  2.0 unx     2152 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/README.md
--rw-rw-r--  2.0 unx    16168 b- defN 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/PKG-INFO
--rw-rw-r--  2.0 unx      116 b- defN 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/azure_mgmt_kusto.egg-info/requires.txt
--rw-rw-r--  2.0 unx        1 b- defN 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/azure_mgmt_kusto.egg-info/not-zip-safe
--rw-rw-r--  2.0 unx     2911 b- defN 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/azure_mgmt_kusto.egg-info/SOURCES.txt
--rw-rw-r--  2.0 unx        6 b- defN 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/azure_mgmt_kusto.egg-info/top_level.txt
--rw-rw-r--  2.0 unx        1 b- defN 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/azure_mgmt_kusto.egg-info/dependency_links.txt
--rw-rw-r--  2.0 unx    16168 b- defN 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/azure_mgmt_kusto.egg-info/PKG-INFO
-drwxrwxr-x  2.0 unx        0 b- stor 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/azure/mgmt/
--rw-rw-r--  2.0 unx       65 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/
--rw-rw-r--  2.0 unx       65 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/models/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/
--rw-rw-r--  2.0 unx     8830 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_kusto_management_client.py
--rw-rw-r--  2.0 unx      488 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_version.py
--rw-rw-r--  2.0 unx       26 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/py.typed
--rw-rw-r--  2.0 unx     1169 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_vendor.py
--rw-rw-r--  2.0 unx     1530 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_patch.py
--rw-rw-r--  2.0 unx      903 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/__init__.py
--rw-rw-r--  2.0 unx     3850 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_configuration.py
--rw-rw-r--  2.0 unx    77872 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_serialization.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Dec-28 08:13 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/
--rw-rw-r--  2.0 unx     9013 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/_kusto_management_client.py
--rw-rw-r--  2.0 unx     1530 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/_patch.py
--rw-rw-r--  2.0 unx      850 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/__init__.py
--rw-rw-r--  2.0 unx     3898 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/_configuration.py
--rw-rw-r--  2.0 unx     4791 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_operations_results_operations.py
--rw-rw-r--  2.0 unx     6151 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_skus_operations.py
--rw-rw-r--  2.0 unx    45703 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_managed_private_endpoints_operations.py
--rw-rw-r--  2.0 unx    46131 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_scripts_operations.py
--rw-rw-r--  2.0 unx    36061 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_database_principal_assignments_operations.py
--rw-rw-r--  2.0 unx    34810 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_attached_database_configurations_operations.py
--rw-rw-r--  2.0 unx     5891 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_operations.py
--rw-rw-r--  2.0 unx     9539 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_private_link_resources_operations.py
--rw-rw-r--  2.0 unx     4684 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_operations_results_location_operations.py
--rw-rw-r--  2.0 unx    27598 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_private_endpoint_connections_operations.py
--rw-rw-r--  2.0 unx    34052 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_cluster_principal_assignments_operations.py
--rw-rw-r--  2.0 unx    59624 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_data_connections_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     2209 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    65144 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_databases_operations.py
--rw-rw-r--  2.0 unx   117906 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_clusters_operations.py
--rw-rw-r--  2.0 unx    11522 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/models/_kusto_management_client_enums.py
--rw-rw-r--  2.0 unx   190878 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/models/_models_py3.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/models/_patch.py
--rw-rw-r--  2.0 unx     9817 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/models/__init__.py
--rw-rw-r--  2.0 unx     6082 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_operations_results_operations.py
--rw-rw-r--  2.0 unx     7251 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_skus_operations.py
--rw-rw-r--  2.0 unx    54703 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_managed_private_endpoints_operations.py
--rw-rw-r--  2.0 unx    55412 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_scripts_operations.py
--rw-rw-r--  2.0 unx    43962 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_database_principal_assignments_operations.py
--rw-rw-r--  2.0 unx    42347 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_attached_database_configurations_operations.py
--rw-rw-r--  2.0 unx     6606 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_operations.py
--rw-rw-r--  2.0 unx    12285 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_private_link_resources_operations.py
--rw-rw-r--  2.0 unx     5727 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_operations_results_location_operations.py
--rw-rw-r--  2.0 unx    33522 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_private_endpoint_connections_operations.py
--rw-rw-r--  2.0 unx    41290 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_cluster_principal_assignments_operations.py
--rw-rw-r--  2.0 unx    70689 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_data_connections_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_patch.py
--rw-rw-r--  2.0 unx     2209 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/__init__.py
--rw-rw-r--  2.0 unx    78739 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_databases_operations.py
--rw-rw-r--  2.0 unx   141044 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_clusters_operations.py
--rw-rw-r--  2.0 unx    11841 b- defN 22-Dec-28 08:12 azure-mgmt-kusto-3.1.0b1/tests/disable_test_cli_mgmt_kusto.py
-75 files, 1493754 bytes uncompressed, 179811 bytes compressed:  88.0%
+Zip file size: 203830 bytes, number of entries: 77
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/azure/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/tests/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/azure_mgmt_kusto.egg-info/
+-rw-rw-r--  2.0 unx      211 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/MANIFEST.in
+-rw-rw-r--  2.0 unx    14217 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/CHANGELOG.md
+-rw-rw-r--  2.0 unx     2130 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/README.md
+-rw-rw-r--  2.0 unx      630 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/_meta.json
+-rw-rw-r--  2.0 unx    17243 b- defN 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/PKG-INFO
+-rw-rw-r--  2.0 unx     2849 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/setup.py
+-rw-rw-r--  2.0 unx       38 b- defN 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/setup.cfg
+-rw-rw-r--  2.0 unx     1074 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/LICENSE
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/azure/mgmt/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/models/
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_vendor.py
+-rw-rw-r--  2.0 unx     3481 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_configuration.py
+-rw-rw-r--  2.0 unx     8985 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_kusto_management_client.py
+-rw-rw-r--  2.0 unx    78836 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_serialization.py
+-rw-rw-r--  2.0 unx      903 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/__init__.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_version.py
+-rw-rw-r--  2.0 unx       26 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/py.typed
+-rw-rw-r--  2.0 unx     1530 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_patch.py
+-rw-rw-r--  2.0 unx    34370 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_private_endpoint_connections_operations.py
+-rw-rw-r--  2.0 unx     7135 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_skus_operations.py
+-rw-rw-r--  2.0 unx    56961 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_scripts_operations.py
+-rw-rw-r--  2.0 unx    81762 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_databases_operations.py
+-rw-rw-r--  2.0 unx    10862 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_database_operations.py
+-rw-rw-r--  2.0 unx     5752 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_operations_results_location_operations.py
+-rw-rw-r--  2.0 unx    42413 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_cluster_principal_assignments_operations.py
+-rw-rw-r--  2.0 unx   157893 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_clusters_operations.py
+-rw-rw-r--  2.0 unx     2288 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/__init__.py
+-rw-rw-r--  2.0 unx    56203 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_managed_private_endpoints_operations.py
+-rw-rw-r--  2.0 unx    45172 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_database_principal_assignments_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_patch.py
+-rw-rw-r--  2.0 unx    72665 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_data_connections_operations.py
+-rw-rw-r--  2.0 unx     5980 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_operations_results_operations.py
+-rw-rw-r--  2.0 unx    43621 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_attached_database_configurations_operations.py
+-rw-rw-r--  2.0 unx     6466 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_operations.py
+-rw-rw-r--  2.0 unx    12432 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_private_link_resources_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/
+-rw-rw-r--  2.0 unx     3529 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/_configuration.py
+-rw-rw-r--  2.0 unx     9177 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/_kusto_management_client.py
+-rw-rw-r--  2.0 unx      850 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/__init__.py
+-rw-rw-r--  2.0 unx     1530 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/_patch.py
+-rw-rw-r--  2.0 unx    28139 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_private_endpoint_connections_operations.py
+-rw-rw-r--  2.0 unx     6025 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_skus_operations.py
+-rw-rw-r--  2.0 unx    47126 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_scripts_operations.py
+-rw-rw-r--  2.0 unx    67162 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_databases_operations.py
+-rw-rw-r--  2.0 unx     9076 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_database_operations.py
+-rw-rw-r--  2.0 unx     4685 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_operations_results_location_operations.py
+-rw-rw-r--  2.0 unx    34738 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_cluster_principal_assignments_operations.py
+-rw-rw-r--  2.0 unx   132354 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_clusters_operations.py
+-rw-rw-r--  2.0 unx     2288 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    46751 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_managed_private_endpoints_operations.py
+-rw-rw-r--  2.0 unx    36749 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_database_principal_assignments_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    60965 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_data_connections_operations.py
+-rw-rw-r--  2.0 unx     4665 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_operations_results_operations.py
+-rw-rw-r--  2.0 unx    35713 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_attached_database_configurations_operations.py
+-rw-rw-r--  2.0 unx     5769 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_operations.py
+-rw-rw-r--  2.0 unx     9519 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_private_link_resources_operations.py
+-rw-rw-r--  2.0 unx   201663 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/models/_models_py3.py
+-rw-rw-r--  2.0 unx    10448 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/models/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/models/_patch.py
+-rw-rw-r--  2.0 unx    11718 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/models/_kusto_management_client_enums.py
+-rw-rw-r--  2.0 unx    11841 b- defN 23-Jul-24 04:01 azure-mgmt-kusto-3.2.0/tests/disable_test_cli_mgmt_kusto.py
+-rw-rw-r--  2.0 unx        1 b- defN 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/azure_mgmt_kusto.egg-info/not-zip-safe
+-rw-rw-r--  2.0 unx      124 b- defN 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/azure_mgmt_kusto.egg-info/requires.txt
+-rw-rw-r--  2.0 unx    17243 b- defN 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/azure_mgmt_kusto.egg-info/PKG-INFO
+-rw-rw-r--  2.0 unx     3019 b- defN 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/azure_mgmt_kusto.egg-info/SOURCES.txt
+-rw-rw-r--  2.0 unx        6 b- defN 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/azure_mgmt_kusto.egg-info/top_level.txt
+-rw-rw-r--  2.0 unx        1 b- defN 23-Jul-24 04:02 azure-mgmt-kusto-3.2.0/azure_mgmt_kusto.egg-info/dependency_links.txt
+77 files, 1580942 bytes uncompressed, 188128 bytes compressed:  88.1%
```

## zipnote {}

```diff
@@ -1,226 +1,232 @@
-Filename: azure-mgmt-kusto-3.1.0b1/
+Filename: azure-mgmt-kusto-3.2.0/
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure_mgmt_kusto.egg-info/
+Filename: azure-mgmt-kusto-3.2.0/azure/
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/
+Filename: azure-mgmt-kusto-3.2.0/tests/
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/tests/
+Filename: azure-mgmt-kusto-3.2.0/azure_mgmt_kusto.egg-info/
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/setup.cfg
+Filename: azure-mgmt-kusto-3.2.0/MANIFEST.in
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/LICENSE
+Filename: azure-mgmt-kusto-3.2.0/CHANGELOG.md
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/setup.py
+Filename: azure-mgmt-kusto-3.2.0/README.md
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/CHANGELOG.md
+Filename: azure-mgmt-kusto-3.2.0/_meta.json
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/MANIFEST.in
+Filename: azure-mgmt-kusto-3.2.0/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/_meta.json
+Filename: azure-mgmt-kusto-3.2.0/setup.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/README.md
+Filename: azure-mgmt-kusto-3.2.0/setup.cfg
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/PKG-INFO
+Filename: azure-mgmt-kusto-3.2.0/LICENSE
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure_mgmt_kusto.egg-info/requires.txt
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure_mgmt_kusto.egg-info/not-zip-safe
+Filename: azure-mgmt-kusto-3.2.0/azure/__init__.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure_mgmt_kusto.egg-info/SOURCES.txt
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure_mgmt_kusto.egg-info/top_level.txt
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/__init__.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure_mgmt_kusto.egg-info/dependency_links.txt
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure_mgmt_kusto.egg-info/PKG-INFO
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/models/
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/__init__.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/__init__.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_kusto_management_client.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_serialization.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/models/
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/__init__.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_version.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_kusto_management_client.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/py.typed
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_version.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_patch.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/py.typed
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_private_endpoint_connections_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_vendor.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_skus_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_patch.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_scripts_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/__init__.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_databases_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_configuration.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_database_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_serialization.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_operations_results_location_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_cluster_principal_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/_kusto_management_client.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_clusters_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/_patch.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/__init__.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_managed_private_endpoints_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/_configuration.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_database_principal_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_operations_results_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_skus_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_data_connections_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_managed_private_endpoints_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_operations_results_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_scripts_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_attached_database_configurations_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_database_principal_assignments_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_attached_database_configurations_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_private_link_resources_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_private_link_resources_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_operations_results_location_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/_kusto_management_client.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_private_endpoint_connections_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_cluster_principal_assignments_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_data_connections_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_private_endpoint_connections_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_patch.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_skus_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/__init__.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_scripts_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_databases_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_databases_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_clusters_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_database_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/models/_kusto_management_client_enums.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_operations_results_location_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/models/_models_py3.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_cluster_principal_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/models/_patch.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_clusters_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/models/__init__.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_operations_results_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_managed_private_endpoints_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_skus_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_database_principal_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_managed_private_endpoints_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_scripts_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_data_connections_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_database_principal_assignments_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_operations_results_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_attached_database_configurations_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_attached_database_configurations_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_private_link_resources_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_private_link_resources_operations.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_operations_results_location_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_private_endpoint_connections_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_cluster_principal_assignments_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_data_connections_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/models/_kusto_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_patch.py
+Filename: azure-mgmt-kusto-3.2.0/tests/disable_test_cli_mgmt_kusto.py
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/__init__.py
+Filename: azure-mgmt-kusto-3.2.0/azure_mgmt_kusto.egg-info/not-zip-safe
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_databases_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure_mgmt_kusto.egg-info/requires.txt
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_clusters_operations.py
+Filename: azure-mgmt-kusto-3.2.0/azure_mgmt_kusto.egg-info/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-kusto-3.1.0b1/tests/disable_test_cli_mgmt_kusto.py
+Filename: azure-mgmt-kusto-3.2.0/azure_mgmt_kusto.egg-info/SOURCES.txt
+Comment: 
+
+Filename: azure-mgmt-kusto-3.2.0/azure_mgmt_kusto.egg-info/top_level.txt
+Comment: 
+
+Filename: azure-mgmt-kusto-3.2.0/azure_mgmt_kusto.egg-info/dependency_links.txt
 Comment: 
 
 Zip file comment:
```

## Comparing `azure-mgmt-kusto-3.1.0b1/LICENSE` & `azure-mgmt-kusto-3.2.0/LICENSE`

 * *Files identical despite different names*

## Comparing `azure-mgmt-kusto-3.1.0b1/setup.py` & `azure-mgmt-kusto-3.2.0/setup.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,79 +1,83 @@
 #!/usr/bin/env python
 
-#-------------------------------------------------------------------------
+# -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
-#--------------------------------------------------------------------------
+# --------------------------------------------------------------------------
 
 import re
 import os.path
 from io import open
 from setuptools import find_packages, setup
 
 # Change the PACKAGE_NAME only to change folder and different name
 PACKAGE_NAME = "azure-mgmt-kusto"
 PACKAGE_PPRINT_NAME = "Kusto Management"
 
 # a-b-c => a/b/c
-package_folder_path = PACKAGE_NAME.replace('-', '/')
+package_folder_path = PACKAGE_NAME.replace("-", "/")
 # a-b-c => a.b.c
-namespace_name = PACKAGE_NAME.replace('-', '.')
+namespace_name = PACKAGE_NAME.replace("-", ".")
 
 # Version extraction inspired from 'requests'
-with open(os.path.join(package_folder_path, 'version.py')
-          if os.path.exists(os.path.join(package_folder_path, 'version.py'))
-          else os.path.join(package_folder_path, '_version.py'), 'r') as fd:
-    version = re.search(r'^VERSION\s*=\s*[\'"]([^\'"]*)[\'"]',
-                        fd.read(), re.MULTILINE).group(1)
+with open(
+    os.path.join(package_folder_path, "version.py")
+    if os.path.exists(os.path.join(package_folder_path, "version.py"))
+    else os.path.join(package_folder_path, "_version.py"),
+    "r",
+) as fd:
+    version = re.search(r'^VERSION\s*=\s*[\'"]([^\'"]*)[\'"]', fd.read(), re.MULTILINE).group(1)
 
 if not version:
-    raise RuntimeError('Cannot find version information')
+    raise RuntimeError("Cannot find version information")
 
-with open('README.md', encoding='utf-8') as f:
+with open("README.md", encoding="utf-8") as f:
     readme = f.read()
-with open('CHANGELOG.md', encoding='utf-8') as f:
+with open("CHANGELOG.md", encoding="utf-8") as f:
     changelog = f.read()
 
 setup(
     name=PACKAGE_NAME,
     version=version,
-    description='Microsoft Azure {} Client Library for Python'.format(PACKAGE_PPRINT_NAME),
-    long_description=readme + '\n\n' + changelog,
-    long_description_content_type='text/markdown',
-    license='MIT License',
-    author='Microsoft Corporation',
-    author_email='azpysdkhelp@microsoft.com',
-    url='https://github.com/Azure/azure-sdk-for-python',
+    description="Microsoft Azure {} Client Library for Python".format(PACKAGE_PPRINT_NAME),
+    long_description=readme + "\n\n" + changelog,
+    long_description_content_type="text/markdown",
+    license="MIT License",
+    author="Microsoft Corporation",
+    author_email="azpysdkhelp@microsoft.com",
+    url="https://github.com/Azure/azure-sdk-for-python",
     keywords="azure, azure sdk",  # update with search keywords relevant to the azure service / product
     classifiers=[
-        'Development Status :: 4 - Beta',
-        'Programming Language :: Python',
-        'Programming Language :: Python :: 3 :: Only',
-        'Programming Language :: Python :: 3',
-        'Programming Language :: Python :: 3.7',
-        'Programming Language :: Python :: 3.8',
-        'Programming Language :: Python :: 3.9',
-        'Programming Language :: Python :: 3.10',
-        'Programming Language :: Python :: 3.11',
-        'License :: OSI Approved :: MIT License',
+        "Development Status :: 5 - Production/Stable",
+        "Programming Language :: Python",
+        "Programming Language :: Python :: 3 :: Only",
+        "Programming Language :: Python :: 3",
+        "Programming Language :: Python :: 3.7",
+        "Programming Language :: Python :: 3.8",
+        "Programming Language :: Python :: 3.9",
+        "Programming Language :: Python :: 3.10",
+        "Programming Language :: Python :: 3.11",
+        "License :: OSI Approved :: MIT License",
     ],
     zip_safe=False,
-    packages=find_packages(exclude=[
-        'tests',
-        # Exclude packages that will be covered by PEP420 or nspkg
-        'azure',
-        'azure.mgmt',
-    ]),
+    packages=find_packages(
+        exclude=[
+            "tests",
+            # Exclude packages that will be covered by PEP420 or nspkg
+            "azure",
+            "azure.mgmt",
+        ]
+    ),
     include_package_data=True,
     package_data={
-        'pytyped': ['py.typed'],
+        "pytyped": ["py.typed"],
     },
     install_requires=[
-        "msrest>=0.7.1",
+        "isodate<1.0.0,>=0.6.1",
         "azure-common~=1.1",
         "azure-mgmt-core>=1.3.2,<2.0.0",
         "typing-extensions>=4.3.0; python_version<'3.8.0'",
     ],
-    python_requires=">=3.7"
+    python_requires=">=3.7",
 )
```

## Comparing `azure-mgmt-kusto-3.1.0b1/CHANGELOG.md` & `azure-mgmt-kusto-3.2.0/CHANGELOG.md`

 * *Files 5% similar despite different names*

```diff
@@ -1,9 +1,34 @@
 # Release History
 
+## 3.2.0 (2023-07-21)
+
+### Features Added
+
+  - Added operation ClustersOperations.begin_migrate
+  - Added operation group DatabaseOperations
+  - Model Cluster has a new parameter migration_cluster
+  - Model ClusterUpdate has a new parameter migration_cluster
+  - Model DatabaseListResult has a new parameter next_link
+  - Model ReadOnlyFollowingDatabase has a new parameter suspension_details
+  - Model ReadWriteDatabase has a new parameter key_vault_properties
+  - Model ReadWriteDatabase has a new parameter suspension_details
+  - Operation DatabasesOperations.list_by_cluster has a new optional parameter skiptoken
+  - Operation DatabasesOperations.list_by_cluster has a new optional parameter top
+
+## 3.1.0 (2023-02-15)
+
+### Features Added
+
+  - Added operation group SkusOperations
+  - Model LanguageExtension has a new parameter language_extension_image_name
+  - Model SkuLocationInfoItem has a new parameter zone_details
+  - Model TableLevelSharingProperties has a new parameter functions_to_exclude
+  - Model TableLevelSharingProperties has a new parameter functions_to_include
+
 ## 3.1.0b1 (2022-12-27)
 
 ### Features Added
 
   - Added operation group SkusOperations
   - Model LanguageExtension has a new parameter language_extension_image_name
   - Model SkuLocationInfoItem has a new parameter zone_details
```

## Comparing `azure-mgmt-kusto-3.1.0b1/_meta.json` & `azure-mgmt-kusto-3.2.0/_meta.json`

 * *Files 8% similar despite different names*

### Pretty-printed

 * *Similarity: 0.7777777777777777%*

 * *Differences: {"'autorest_command'": "'autorest specification/azure-kusto/resource-manager/readme.md "*

 * *                       '--generate-sample=True --include-x-ms-examples-original-file=True --python '*

 * *                       '--python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk '*

 * *                       '--use=@autorest/python@6.6.0 --use=@autorest/modelerfour@4.24.3 '*

 * *                       "--version=3.9.2 --version-tolerant=False'",*

 * * "'commit'": "'de93ae3897babd397a59d3c9dcb894855d0db1c3'",*

 * * "'use'": "{ins [â€¦]*

```diff
@@ -1,11 +1,11 @@
 {
     "autorest": "3.9.2",
-    "autorest_command": "autorest specification/azure-kusto/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.2.7 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
-    "commit": "89a9bf17524904e7670f0fd2d62ac882ca00d85c",
+    "autorest_command": "autorest specification/azure-kusto/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.6.0 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
+    "commit": "de93ae3897babd397a59d3c9dcb894855d0db1c3",
     "readme": "specification/azure-kusto/resource-manager/readme.md",
     "repository_url": "https://github.com/Azure/azure-rest-api-specs",
     "use": [
-        "@autorest/python@6.2.7",
+        "@autorest/python@6.6.0",
         "@autorest/modelerfour@4.24.3"
     ]
 }
```

## Comparing `azure-mgmt-kusto-3.1.0b1/README.md` & `azure-mgmt-kusto-3.2.0/README.md`

 * *Files 14% similar despite different names*

```diff
@@ -24,15 +24,15 @@
 
 ### Authentication
 
 By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
 
 - `AZURE_CLIENT_ID` for Azure client ID.
 - `AZURE_TENANT_ID` for Azure tenant ID.
-- `AZURE_CLIENT_SECRET` or `AZURE_CLIENT_CERTIFICATE_PATH` for client secret or client certificate.
+- `AZURE_CLIENT_SECRET` for Azure client secret.
 
 In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
 
 With above configuration, client can be authenticated by following code:
 
 ```python
 from azure.identity import DefaultAzureCredential
@@ -41,16 +41,17 @@
 
 sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
 client = KustoManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
 ```
 
 ## Examples
 
-
-Code samples for this package can be found at [Kusto Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com and [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+Code samples for this package can be found at:
+- [Search Kusto Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
 
 
 ## Troubleshooting
 
 ## Next steps
 
 ## Provide Feedback
```

## Comparing `azure-mgmt-kusto-3.1.0b1/PKG-INFO` & `azure-mgmt-kusto-3.2.0/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-kusto
-Version: 3.1.0b1
+Version: 3.2.0
 Summary: Microsoft Azure Kusto Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
-Classifier: Development Status :: 4 - Beta
+Classifier: Development Status :: 5 - Production/Stable
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
@@ -47,15 +47,15 @@
 
 ### Authentication
 
 By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
 
 - `AZURE_CLIENT_ID` for Azure client ID.
 - `AZURE_TENANT_ID` for Azure tenant ID.
-- `AZURE_CLIENT_SECRET` or `AZURE_CLIENT_CERTIFICATE_PATH` for client secret or client certificate.
+- `AZURE_CLIENT_SECRET` for Azure client secret.
 
 In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
 
 With above configuration, client can be authenticated by following code:
 
 ```python
 from azure.identity import DefaultAzureCredential
@@ -64,16 +64,17 @@
 
 sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
 client = KustoManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
 ```
 
 ## Examples
 
-
-Code samples for this package can be found at [Kusto Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com and [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+Code samples for this package can be found at:
+- [Search Kusto Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
 
 
 ## Troubleshooting
 
 ## Next steps
 
 ## Provide Feedback
@@ -84,14 +85,39 @@
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-kusto%2FREADME.png)
 
 
 # Release History
 
+## 3.2.0 (2023-07-21)
+
+### Features Added
+
+  - Added operation ClustersOperations.begin_migrate
+  - Added operation group DatabaseOperations
+  - Model Cluster has a new parameter migration_cluster
+  - Model ClusterUpdate has a new parameter migration_cluster
+  - Model DatabaseListResult has a new parameter next_link
+  - Model ReadOnlyFollowingDatabase has a new parameter suspension_details
+  - Model ReadWriteDatabase has a new parameter key_vault_properties
+  - Model ReadWriteDatabase has a new parameter suspension_details
+  - Operation DatabasesOperations.list_by_cluster has a new optional parameter skiptoken
+  - Operation DatabasesOperations.list_by_cluster has a new optional parameter top
+
+## 3.1.0 (2023-02-15)
+
+### Features Added
+
+  - Added operation group SkusOperations
+  - Model LanguageExtension has a new parameter language_extension_image_name
+  - Model SkuLocationInfoItem has a new parameter zone_details
+  - Model TableLevelSharingProperties has a new parameter functions_to_exclude
+  - Model TableLevelSharingProperties has a new parameter functions_to_include
+
 ## 3.1.0b1 (2022-12-27)
 
 ### Features Added
 
   - Added operation group SkusOperations
   - Model LanguageExtension has a new parameter language_extension_image_name
   - Model SkuLocationInfoItem has a new parameter zone_details
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure_mgmt_kusto.egg-info/SOURCES.txt` & `azure-mgmt-kusto-3.2.0/azure_mgmt_kusto.egg-info/SOURCES.txt`

 * *Files 2% similar despite different names*

```diff
@@ -19,14 +19,15 @@
 azure/mgmt/kusto/aio/_kusto_management_client.py
 azure/mgmt/kusto/aio/_patch.py
 azure/mgmt/kusto/aio/operations/__init__.py
 azure/mgmt/kusto/aio/operations/_attached_database_configurations_operations.py
 azure/mgmt/kusto/aio/operations/_cluster_principal_assignments_operations.py
 azure/mgmt/kusto/aio/operations/_clusters_operations.py
 azure/mgmt/kusto/aio/operations/_data_connections_operations.py
+azure/mgmt/kusto/aio/operations/_database_operations.py
 azure/mgmt/kusto/aio/operations/_database_principal_assignments_operations.py
 azure/mgmt/kusto/aio/operations/_databases_operations.py
 azure/mgmt/kusto/aio/operations/_managed_private_endpoints_operations.py
 azure/mgmt/kusto/aio/operations/_operations.py
 azure/mgmt/kusto/aio/operations/_operations_results_location_operations.py
 azure/mgmt/kusto/aio/operations/_operations_results_operations.py
 azure/mgmt/kusto/aio/operations/_patch.py
@@ -39,14 +40,15 @@
 azure/mgmt/kusto/models/_models_py3.py
 azure/mgmt/kusto/models/_patch.py
 azure/mgmt/kusto/operations/__init__.py
 azure/mgmt/kusto/operations/_attached_database_configurations_operations.py
 azure/mgmt/kusto/operations/_cluster_principal_assignments_operations.py
 azure/mgmt/kusto/operations/_clusters_operations.py
 azure/mgmt/kusto/operations/_data_connections_operations.py
+azure/mgmt/kusto/operations/_database_operations.py
 azure/mgmt/kusto/operations/_database_principal_assignments_operations.py
 azure/mgmt/kusto/operations/_databases_operations.py
 azure/mgmt/kusto/operations/_managed_private_endpoints_operations.py
 azure/mgmt/kusto/operations/_operations.py
 azure/mgmt/kusto/operations/_operations_results_location_operations.py
 azure/mgmt/kusto/operations/_operations_results_operations.py
 azure/mgmt/kusto/operations/_patch.py
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure_mgmt_kusto.egg-info/PKG-INFO` & `azure-mgmt-kusto-3.2.0/azure_mgmt_kusto.egg-info/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-kusto
-Version: 3.1.0b1
+Version: 3.2.0
 Summary: Microsoft Azure Kusto Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
-Classifier: Development Status :: 4 - Beta
+Classifier: Development Status :: 5 - Production/Stable
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
@@ -47,15 +47,15 @@
 
 ### Authentication
 
 By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
 
 - `AZURE_CLIENT_ID` for Azure client ID.
 - `AZURE_TENANT_ID` for Azure tenant ID.
-- `AZURE_CLIENT_SECRET` or `AZURE_CLIENT_CERTIFICATE_PATH` for client secret or client certificate.
+- `AZURE_CLIENT_SECRET` for Azure client secret.
 
 In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
 
 With above configuration, client can be authenticated by following code:
 
 ```python
 from azure.identity import DefaultAzureCredential
@@ -64,16 +64,17 @@
 
 sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
 client = KustoManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
 ```
 
 ## Examples
 
-
-Code samples for this package can be found at [Kusto Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com and [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+Code samples for this package can be found at:
+- [Search Kusto Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
 
 
 ## Troubleshooting
 
 ## Next steps
 
 ## Provide Feedback
@@ -84,14 +85,39 @@
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-kusto%2FREADME.png)
 
 
 # Release History
 
+## 3.2.0 (2023-07-21)
+
+### Features Added
+
+  - Added operation ClustersOperations.begin_migrate
+  - Added operation group DatabaseOperations
+  - Model Cluster has a new parameter migration_cluster
+  - Model ClusterUpdate has a new parameter migration_cluster
+  - Model DatabaseListResult has a new parameter next_link
+  - Model ReadOnlyFollowingDatabase has a new parameter suspension_details
+  - Model ReadWriteDatabase has a new parameter key_vault_properties
+  - Model ReadWriteDatabase has a new parameter suspension_details
+  - Operation DatabasesOperations.list_by_cluster has a new optional parameter skiptoken
+  - Operation DatabasesOperations.list_by_cluster has a new optional parameter top
+
+## 3.1.0 (2023-02-15)
+
+### Features Added
+
+  - Added operation group SkusOperations
+  - Model LanguageExtension has a new parameter language_extension_image_name
+  - Model SkuLocationInfoItem has a new parameter zone_details
+  - Model TableLevelSharingProperties has a new parameter functions_to_exclude
+  - Model TableLevelSharingProperties has a new parameter functions_to_include
+
 ## 3.1.0b1 (2022-12-27)
 
 ### Features Added
 
   - Added operation group SkusOperations
   - Model LanguageExtension has a new parameter language_extension_image_name
   - Model SkuLocationInfoItem has a new parameter zone_details
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_kusto_management_client.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_kusto_management_client.py`

 * *Files 4% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 from ._configuration import KustoManagementClientConfiguration
 from ._serialization import Deserializer, Serializer
 from .operations import (
     AttachedDatabaseConfigurationsOperations,
     ClusterPrincipalAssignmentsOperations,
     ClustersOperations,
     DataConnectionsOperations,
+    DatabaseOperations,
     DatabasePrincipalAssignmentsOperations,
     DatabasesOperations,
     ManagedPrivateEndpointsOperations,
     Operations,
     OperationsResultsLocationOperations,
     OperationsResultsOperations,
     PrivateEndpointConnectionsOperations,
@@ -53,14 +54,16 @@
     :vartype databases: azure.mgmt.kusto.operations.DatabasesOperations
     :ivar attached_database_configurations: AttachedDatabaseConfigurationsOperations operations
     :vartype attached_database_configurations:
      azure.mgmt.kusto.operations.AttachedDatabaseConfigurationsOperations
     :ivar managed_private_endpoints: ManagedPrivateEndpointsOperations operations
     :vartype managed_private_endpoints:
      azure.mgmt.kusto.operations.ManagedPrivateEndpointsOperations
+    :ivar database: DatabaseOperations operations
+    :vartype database: azure.mgmt.kusto.operations.DatabaseOperations
     :ivar database_principal_assignments: DatabasePrincipalAssignmentsOperations operations
     :vartype database_principal_assignments:
      azure.mgmt.kusto.operations.DatabasePrincipalAssignmentsOperations
     :ivar scripts: ScriptsOperations operations
     :vartype scripts: azure.mgmt.kusto.operations.ScriptsOperations
     :ivar private_endpoint_connections: PrivateEndpointConnectionsOperations operations
     :vartype private_endpoint_connections:
@@ -74,20 +77,19 @@
     :ivar operations_results: OperationsResultsOperations operations
     :vartype operations_results: azure.mgmt.kusto.operations.OperationsResultsOperations
     :ivar operations_results_location: OperationsResultsLocationOperations operations
     :vartype operations_results_location:
      azure.mgmt.kusto.operations.OperationsResultsLocationOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
-    :param subscription_id: Gets subscription credentials which uniquely identify Microsoft Azure
-     subscription. The subscription ID forms part of the URI for every service call. Required.
+    :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2022-11-11". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2023-05-02". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
@@ -96,15 +98,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = KustoManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.clusters = ClustersOperations(self._client, self._config, self._serialize, self._deserialize)
         self.cluster_principal_assignments = ClusterPrincipalAssignmentsOperations(
@@ -114,14 +116,15 @@
         self.databases = DatabasesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.attached_database_configurations = AttachedDatabaseConfigurationsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.managed_private_endpoints = ManagedPrivateEndpointsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
+        self.database = DatabaseOperations(self._client, self._config, self._serialize, self._deserialize)
         self.database_principal_assignments = DatabasePrincipalAssignmentsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.scripts = ScriptsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.private_endpoint_connections = PrivateEndpointConnectionsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
@@ -164,9 +167,9 @@
     def close(self) -> None:
         self._client.close()
 
     def __enter__(self) -> "KustoManagementClient":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details) -> None:
+    def __exit__(self, *exc_details: Any) -> None:
         self._client.__exit__(*exc_details)
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_vendor.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_vendor.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,16 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+from typing import List, cast
+
 from azure.core.pipeline.transport import HttpRequest
 
 
 def _convert_request(request, files=None):
     data = request.content if not files else None
     request = HttpRequest(method=request.method, url=request.url, headers=request.headers, data=data)
     if files:
@@ -18,10 +20,11 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            formatted_components = template.split("/")
+            # Need the cast, as for some reasons "split" is typed as list[str | Any]
+            formatted_components = cast(List[str], template.split("/"))
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_patch.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/__init__.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_configuration.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_configuration.py`

 * *Files 15% similar despite different names*

```diff
@@ -2,52 +2,45 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class KustoManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for KustoManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
-    :param subscription_id: Gets subscription credentials which uniquely identify Microsoft Azure
-     subscription. The subscription ID forms part of the URI for every service call. Required.
+    :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-11-11". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2023-05-02". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(KustoManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2022-11-11"] = kwargs.pop("api_version", "2022-11-11")
+        api_version: str = kwargs.pop("api_version", "2023-05-02")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/_serialization.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/_serialization.py`

 * *Files 2% similar despite different names*

```diff
@@ -34,30 +34,47 @@
 import email
 from enum import Enum
 import json
 import logging
 import re
 import sys
 import codecs
-from typing import Optional, Union, AnyStr, IO, Mapping
+from typing import (
+    Dict,
+    Any,
+    cast,
+    Optional,
+    Union,
+    AnyStr,
+    IO,
+    Mapping,
+    Callable,
+    TypeVar,
+    MutableMapping,
+    Type,
+    List,
+    Mapping,
+)
 
 try:
     from urllib import quote  # type: ignore
 except ImportError:
     from urllib.parse import quote
 import xml.etree.ElementTree as ET
 
 import isodate  # type: ignore
 
-from typing import Dict, Any, cast
-
 from azure.core.exceptions import DeserializationError, SerializationError, raise_with_traceback
+from azure.core.serialization import NULL as AzureCoreNull
 
 _BOM = codecs.BOM_UTF8.decode(encoding="utf-8")
 
+ModelType = TypeVar("ModelType", bound="Model")
+JSON = MutableMapping[str, Any]
+
 
 class RawDeserializer:
 
     # Accept "text" because we're open minded people...
     JSON_REGEXP = re.compile(r"^(application|text)/([a-z+.]+\+)?json$")
 
     # Name used in context
@@ -273,43 +290,43 @@
     serialization and deserialization.
     """
 
     _subtype_map: Dict[str, Dict[str, Any]] = {}
     _attribute_map: Dict[str, Dict[str, Any]] = {}
     _validation: Dict[str, Dict[str, Any]] = {}
 
-    def __init__(self, **kwargs):
-        self.additional_properties = {}
+    def __init__(self, **kwargs: Any) -> None:
+        self.additional_properties: Dict[str, Any] = {}
         for k in kwargs:
             if k not in self._attribute_map:
                 _LOGGER.warning("%s is not a known attribute of class %s and will be ignored", k, self.__class__)
             elif k in self._validation and self._validation[k].get("readonly", False):
                 _LOGGER.warning("Readonly attribute %s will be ignored in class %s", k, self.__class__)
             else:
                 setattr(self, k, kwargs[k])
 
-    def __eq__(self, other):
+    def __eq__(self, other: Any) -> bool:
         """Compare objects by comparing all attributes."""
         if isinstance(other, self.__class__):
             return self.__dict__ == other.__dict__
         return False
 
-    def __ne__(self, other):
+    def __ne__(self, other: Any) -> bool:
         """Compare objects by comparing all attributes."""
         return not self.__eq__(other)
 
-    def __str__(self):
+    def __str__(self) -> str:
         return str(self.__dict__)
 
     @classmethod
-    def enable_additional_properties_sending(cls):
+    def enable_additional_properties_sending(cls) -> None:
         cls._attribute_map["additional_properties"] = {"key": "", "type": "{object}"}
 
     @classmethod
-    def is_xml_model(cls):
+    def is_xml_model(cls) -> bool:
         try:
             cls._xml_map  # type: ignore
         except AttributeError:
             return False
         return True
 
     @classmethod
@@ -318,30 +335,35 @@
         try:
             xml_map = cls._xml_map  # type: ignore
         except AttributeError:
             xml_map = {}
 
         return _create_xml_node(xml_map.get("name", cls.__name__), xml_map.get("prefix", None), xml_map.get("ns", None))
 
-    def serialize(self, keep_readonly=False, **kwargs):
+    def serialize(self, keep_readonly: bool = False, **kwargs: Any) -> JSON:
         """Return the JSON that would be sent to azure from this model.
 
         This is an alias to `as_dict(full_restapi_key_transformer, keep_readonly=False)`.
 
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param bool keep_readonly: If you want to serialize the readonly attributes
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
         return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)
 
-    def as_dict(self, keep_readonly=True, key_transformer=attribute_transformer, **kwargs):
-        """Return a dict that can be JSONify using json.dump.
+    def as_dict(
+        self,
+        keep_readonly: bool = True,
+        key_transformer: Callable[[str, Dict[str, Any], Any], Any] = attribute_transformer,
+        **kwargs: Any
+    ) -> JSON:
+        """Return a dict that can be serialized using json.dump.
 
         Advanced usage might optionally use a callback as parameter:
 
         .. code::python
 
             def my_key_transformer(key, attr_desc, value):
                 return key
@@ -380,41 +402,46 @@
                 raise ValueError("Not Autorest generated code")
         except Exception:
             # Assume it's not Autorest generated (tests?). Add ourselves as dependencies.
             client_models = {cls.__name__: cls}
         return client_models
 
     @classmethod
-    def deserialize(cls, data, content_type=None):
+    def deserialize(cls: Type[ModelType], data: Any, content_type: Optional[str] = None) -> ModelType:
         """Parse a str using the RestAPI syntax and return a model.
 
         :param str data: A str using RestAPI structure. JSON by default.
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
         return deserializer(cls.__name__, data, content_type=content_type)
 
     @classmethod
-    def from_dict(cls, data, key_extractors=None, content_type=None):
+    def from_dict(
+        cls: Type[ModelType],
+        data: Any,
+        key_extractors: Optional[Callable[[str, Dict[str, Any], Any], Any]] = None,
+        content_type: Optional[str] = None,
+    ) -> ModelType:
         """Parse a dict using given key extractor return a model.
 
         By default consider key
         extractors (rest_key_case_insensitive_extractor, attribute_key_case_insensitive_extractor
         and last_rest_key_case_insensitive_extractor)
 
         :param dict data: A dict using RestAPI structure
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
-        deserializer.key_extractors = (
-            [
+        deserializer.key_extractors = (  # type: ignore
+            [  # type: ignore
                 attribute_key_case_insensitive_extractor,
                 rest_key_case_insensitive_extractor,
                 last_rest_key_case_insensitive_extractor,
             ]
             if key_extractors is None
             else key_extractors
         )
@@ -514,15 +541,15 @@
         "min_items": lambda x, y: len(x) < y,
         "max_items": lambda x, y: len(x) > y,
         "pattern": lambda x, y: not re.match(y, x, re.UNICODE),
         "unique": lambda x, y: len(x) != len(set(x)),
         "multiple": lambda x, y: x % y != 0,
     }
 
-    def __init__(self, classes=None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
         self.serialize_type = {
             "iso-8601": Serializer.serialize_iso,
             "rfc-1123": Serializer.serialize_rfc,
             "unix-time": Serializer.serialize_unix,
             "duration": Serializer.serialize_duration,
             "date": Serializer.serialize_date,
             "time": Serializer.serialize_time,
@@ -530,15 +557,15 @@
             "long": Serializer.serialize_long,
             "bytearray": Serializer.serialize_bytearray,
             "base64": Serializer.serialize_base64,
             "object": self.serialize_object,
             "[]": self.serialize_iter,
             "{}": self.serialize_dict,
         }
-        self.dependencies = dict(classes) if classes else {}
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
         self.key_transformer = full_restapi_key_transformer
         self.client_side_validation = True
 
     def _serialize(self, target_obj, data_type=None, **kwargs):
         """Serialize data into a string according to type.
 
         :param target_obj: The data to be serialized.
@@ -598,15 +625,15 @@
                         xml_desc = attr_desc.get("xml", {})
                         xml_name = xml_desc.get("name", attr_desc["key"])
                         xml_prefix = xml_desc.get("prefix", None)
                         xml_ns = xml_desc.get("ns", None)
                         if xml_desc.get("attr", False):
                             if xml_ns:
                                 ET.register_namespace(xml_prefix, xml_ns)
-                                xml_name = "{}{}".format(xml_ns, xml_name)
+                                xml_name = "{{{}}}{}".format(xml_ns, xml_name)
                             serialized.set(xml_name, new_attr)  # type: ignore
                             continue
                         if xml_desc.get("text", False):
                             serialized.text = new_attr  # type: ignore
                             continue
                         if isinstance(new_attr, list):
                             serialized.extend(new_attr)  # type: ignore
@@ -622,16 +649,15 @@
                         else:  # That's a basic type
                             # Integrate namespace if necessary
                             local_node = _create_xml_node(xml_name, xml_prefix, xml_ns)
                             local_node.text = unicode_str(new_attr)
                             serialized.append(local_node)  # type: ignore
                     else:  # JSON
                         for k in reversed(keys):  # type: ignore
-                            unflattened = {k: new_attr}
-                            new_attr = unflattened
+                            new_attr = {k: new_attr}
 
                         _new_attr = new_attr
                         _serialized = serialized
                         for k in keys:  # type: ignore
                             if k not in _serialized:
                                 _serialized.update(_new_attr)  # type: ignore
                             _new_attr = _new_attr[k]  # type: ignore
@@ -652,16 +678,16 @@
         :param str data_type: The type to be serialized from.
         :rtype: dict
         :raises: SerializationError if serialization fails.
         :raises: ValueError if data is None
         """
 
         # Just in case this is a dict
-        internal_data_type = data_type.strip("[]{}")
-        internal_data_type = self.dependencies.get(internal_data_type, None)
+        internal_data_type_str = data_type.strip("[]{}")
+        internal_data_type = self.dependencies.get(internal_data_type_str, None)
         try:
             is_xml_model_serialization = kwargs["is_xml"]
         except KeyError:
             if internal_data_type and issubclass(internal_data_type, Model):
                 is_xml_model_serialization = kwargs.setdefault("is_xml", internal_data_type.is_xml_model())
             else:
                 is_xml_model_serialization = False
@@ -773,14 +799,16 @@
         :raises: ValueError if data is None
         :raises: SerializationError if serialization fails.
         """
         if data is None:
             raise ValueError("No value for given attribute")
 
         try:
+            if data is AzureCoreNull:
+                return None
             if data_type in self.basic_types.values():
                 return self.serialize_basic(data, data_type, **kwargs)
 
             elif data_type in self.serialize_type:
                 return self.serialize_type[data_type](data, **kwargs)
 
             # If dependencies is empty, try with current data class
@@ -1157,15 +1185,16 @@
 
 
 def rest_key_extractor(attr, attr_desc, data):
     key = attr_desc["key"]
     working_data = data
 
     while "." in key:
-        dict_keys = _FLATTEN.split(key)
+        # Need the cast, as for some reasons "split" is typed as list[str | Any]
+        dict_keys = cast(List[str], _FLATTEN.split(key))
         if len(dict_keys) == 1:
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = working_data.get(working_key, data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
@@ -1238,15 +1267,15 @@
     :rtype: tuple
     :returns: A tuple XML name + namespace dict
     """
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
     xml_name = internal_type_xml_map.get("name", internal_type.__name__)
     xml_ns = internal_type_xml_map.get("ns", None)
     if xml_ns:
-        xml_name = "{}{}".format(xml_ns, xml_name)
+        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
     return xml_name
 
 
 def xml_key_extractor(attr, attr_desc, data):
     if isinstance(data, dict):
         return None
 
@@ -1262,15 +1291,15 @@
     is_wrapped = xml_desc.get("wrapped", False)
     internal_type = attr_desc.get("internalType", None)
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
 
     # Integrate namespace if necessary
     xml_ns = xml_desc.get("ns", internal_type_xml_map.get("ns", None))
     if xml_ns:
-        xml_name = "{}{}".format(xml_ns, xml_name)
+        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
 
     # If it's an attribute, that's simple
     if xml_desc.get("attr", False):
         return data.get(xml_name)
 
     # If it's x-ms-text, that's simple too
     if xml_desc.get("text", False):
@@ -1328,15 +1357,15 @@
     :ivar list key_extractors: Ordered list of extractors to be used by this deserializer.
     """
 
     basic_types = {str: "str", int: "int", bool: "bool", float: "float"}
 
     valid_date = re.compile(r"\d{4}[-]\d{2}[-]\d{2}T\d{2}:\d{2}:\d{2}" r"\.?\d*Z?[-+]?[\d{2}]?:?[\d{2}]?")
 
-    def __init__(self, classes=None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
         self.deserialize_type = {
             "iso-8601": Deserializer.deserialize_iso,
             "rfc-1123": Deserializer.deserialize_rfc,
             "unix-time": Deserializer.deserialize_unix,
             "duration": Deserializer.deserialize_duration,
             "date": Deserializer.deserialize_date,
             "time": Deserializer.deserialize_time,
@@ -1348,15 +1377,15 @@
             "[]": self.deserialize_iter,
             "{}": self.deserialize_dict,
         }
         self.deserialize_expected_types = {
             "duration": (isodate.Duration, datetime.timedelta),
             "iso-8601": (datetime.datetime),
         }
-        self.dependencies = dict(classes) if classes else {}
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
         self.key_extractors = [rest_key_extractor, xml_key_extractor]
         # Additional properties only works if the "rest_key_extractor" is used to
         # extract the keys. Making it to work whatever the key extractor is too much
         # complicated, with no real scenario for now.
         # So adding a flag to disable additional properties detection. This flag should be
         # used if your expect the deserialization to NOT come from a JSON REST syntax.
         # Otherwise, result are unexpected
@@ -1467,40 +1496,40 @@
 
     def _classify_target(self, target, data):
         """Check to see whether the deserialization target object can
         be classified into a subclass.
         Once classification has been determined, initialize object.
 
         :param str target: The target object type to deserialize to.
-        :param str/dict data: The response data to deseralize.
+        :param str/dict data: The response data to deserialize.
         """
         if target is None:
             return None, None
 
         if isinstance(target, basestring):
             try:
                 target = self.dependencies[target]
             except KeyError:
                 return target, target
 
         try:
             target = target._classify(data, self.dependencies)
         except AttributeError:
             pass  # Target is not a Model, no classify
-        return target, target.__class__.__name__
+        return target, target.__class__.__name__  # type: ignore
 
     def failsafe_deserialize(self, target_obj, data, content_type=None):
         """Ignores any errors encountered in deserialization,
         and falls back to not deserializing the object. Recommended
         for use in error deserialization, as we want to return the
         HttpResponseError to users, and not have them deal with
         a deserialization error.
 
         :param str target_obj: The target object type to deserialize to.
-        :param str/dict data: The response data to deseralize.
+        :param str/dict data: The response data to deserialize.
         :param str content_type: Swagger "produces" if available.
         """
         try:
             return self(target_obj, data, content_type=content_type)
         except:
             _LOGGER.debug(
                 "Ran into a deserialization error. Ignoring since this is failsafe deserialization", exc_info=True
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/_kusto_management_client.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/_kusto_management_client.py`

 * *Files 9% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 from .._serialization import Deserializer, Serializer
 from ._configuration import KustoManagementClientConfiguration
 from .operations import (
     AttachedDatabaseConfigurationsOperations,
     ClusterPrincipalAssignmentsOperations,
     ClustersOperations,
     DataConnectionsOperations,
+    DatabaseOperations,
     DatabasePrincipalAssignmentsOperations,
     DatabasesOperations,
     ManagedPrivateEndpointsOperations,
     Operations,
     OperationsResultsLocationOperations,
     OperationsResultsOperations,
     PrivateEndpointConnectionsOperations,
@@ -53,14 +54,16 @@
     :vartype databases: azure.mgmt.kusto.aio.operations.DatabasesOperations
     :ivar attached_database_configurations: AttachedDatabaseConfigurationsOperations operations
     :vartype attached_database_configurations:
      azure.mgmt.kusto.aio.operations.AttachedDatabaseConfigurationsOperations
     :ivar managed_private_endpoints: ManagedPrivateEndpointsOperations operations
     :vartype managed_private_endpoints:
      azure.mgmt.kusto.aio.operations.ManagedPrivateEndpointsOperations
+    :ivar database: DatabaseOperations operations
+    :vartype database: azure.mgmt.kusto.aio.operations.DatabaseOperations
     :ivar database_principal_assignments: DatabasePrincipalAssignmentsOperations operations
     :vartype database_principal_assignments:
      azure.mgmt.kusto.aio.operations.DatabasePrincipalAssignmentsOperations
     :ivar scripts: ScriptsOperations operations
     :vartype scripts: azure.mgmt.kusto.aio.operations.ScriptsOperations
     :ivar private_endpoint_connections: PrivateEndpointConnectionsOperations operations
     :vartype private_endpoint_connections:
@@ -74,20 +77,19 @@
     :ivar operations_results: OperationsResultsOperations operations
     :vartype operations_results: azure.mgmt.kusto.aio.operations.OperationsResultsOperations
     :ivar operations_results_location: OperationsResultsLocationOperations operations
     :vartype operations_results_location:
      azure.mgmt.kusto.aio.operations.OperationsResultsLocationOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
-    :param subscription_id: Gets subscription credentials which uniquely identify Microsoft Azure
-     subscription. The subscription ID forms part of the URI for every service call. Required.
+    :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2022-11-11". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2023-05-02". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
@@ -96,15 +98,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = KustoManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.clusters = ClustersOperations(self._client, self._config, self._serialize, self._deserialize)
         self.cluster_principal_assignments = ClusterPrincipalAssignmentsOperations(
@@ -114,14 +116,15 @@
         self.databases = DatabasesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.attached_database_configurations = AttachedDatabaseConfigurationsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.managed_private_endpoints = ManagedPrivateEndpointsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
+        self.database = DatabaseOperations(self._client, self._config, self._serialize, self._deserialize)
         self.database_principal_assignments = DatabasePrincipalAssignmentsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.scripts = ScriptsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.private_endpoint_connections = PrivateEndpointConnectionsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
@@ -164,9 +167,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "KustoManagementClient":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details) -> None:
+    async def __aexit__(self, *exc_details: Any) -> None:
         await self._client.__aexit__(*exc_details)
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/_patch.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/__init__.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/_configuration.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/_configuration.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,52 +2,45 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class KustoManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for KustoManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
-    :param subscription_id: Gets subscription credentials which uniquely identify Microsoft Azure
-     subscription. The subscription ID forms part of the URI for every service call. Required.
+    :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-11-11". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2023-05-02". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(KustoManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2022-11-11"] = kwargs.pop("api_version", "2022-11-11")
+        api_version: str = kwargs.pop("api_version", "2023-05-02")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_operations_results_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_operations_results_location_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -22,97 +21,96 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._operations_results_operations import build_get_request
+from ...operations._operations_results_location_operations import build_get_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class OperationsResultsOperations:
+class OperationsResultsLocationOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.kusto.aio.KustoManagementClient`'s
-        :attr:`operations_results` attribute.
+        :attr:`operations_results_location` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace_async
-    async def get(self, location: str, operation_id: str, **kwargs: Any) -> _models.OperationResult:
+    async def get(  # pylint: disable=inconsistent-return-statements
+        self, location: str, operation_id: str, **kwargs: Any
+    ) -> None:
         """Returns operation results.
 
-        :param location: Azure location (region) name. Required.
+        :param location: The name of Azure region. Required.
         :type location: str
-        :param operation_id: The Guid of the operation ID. Required.
+        :param operation_id: The ID of an ongoing async operation. Required.
         :type operation_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: OperationResult or the result of cls(response)
-        :rtype: ~azure.mgmt.kusto.models.OperationResult
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
-        cls: ClsType[_models.OperationResult] = kwargs.pop("cls", None)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_get_request(
             location=location,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200]:
+        if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("OperationResult", pipeline_response)
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, None, response_headers)
 
     get.metadata = {
         "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/locations/{location}/operationResults/{operationId}"
     }
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_skus_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -24,76 +23,66 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._skus_operations import build_list_request
+from ...operations._operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class SkusOperations:
+class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.kusto.aio.KustoManagementClient`'s
-        :attr:`skus` attribute.
+        :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list(self, location: str, **kwargs: Any) -> AsyncIterable["_models.SkuDescription"]:
-        """Lists eligible region SKUs for Kusto resource provider by Azure region.
+    def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
+        """Lists available operations for the Microsoft.Kusto provider.
 
-        :param location: Azure location (region) name. Required.
-        :type location: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either SkuDescription or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.SkuDescription]
+        :return: An iterator like instance of either Operation or the result of cls(response)
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
-        cls: ClsType[_models.SkuDescriptionList] = kwargs.pop("cls", None)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
-                    location=location,
-                    subscription_id=self._config.subscription_id,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
@@ -113,30 +102,32 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("SkuDescriptionList", pipeline_response)
+            deserialized = self._deserialize("OperationListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/locations/{location}/skus"}
+    list.metadata = {"url": "/providers/Microsoft.Kusto/operations"}
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_managed_private_endpoints_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_managed_private_endpoints_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -36,18 +36,14 @@
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_list_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ManagedPrivateEndpointsOperations:
     """
     .. warning::
@@ -75,15 +71,15 @@
         resource_name: _models.ManagedPrivateEndpointsCheckNameRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the managed private endpoints resource name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param resource_name: The name of the resource. Required.
         :type resource_name: ~azure.mgmt.kusto.models.ManagedPrivateEndpointsCheckNameRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
@@ -103,15 +99,15 @@
         resource_name: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the managed private endpoints resource name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param resource_name: The name of the resource. Required.
         :type resource_name: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -129,20 +125,21 @@
         resource_group_name: str,
         cluster_name: str,
         resource_name: Union[_models.ManagedPrivateEndpointsCheckNameRequest, IO],
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the managed private endpoints resource name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param resource_name: The name of the resource. Is either a model type or a IO type. Required.
+        :param resource_name: The name of the resource. Is either a
+         ManagedPrivateEndpointsCheckNameRequest type or a IO type. Required.
         :type resource_name: ~azure.mgmt.kusto.models.ManagedPrivateEndpointsCheckNameRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.CheckNameResult
@@ -155,24 +152,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(resource_name, (IO, bytes)):
+        if isinstance(resource_name, (IOBase, bytes)):
             _content = resource_name
         else:
             _json = self._serialize.body(resource_name, "ManagedPrivateEndpointsCheckNameRequest")
 
         request = build_check_name_availability_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -184,23 +179,25 @@
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -211,32 +208,30 @@
 
     @distributed_trace
     def list(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> AsyncIterable["_models.ManagedPrivateEndpoint"]:
         """Returns the list of managed private endpoints.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ManagedPrivateEndpoint or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.ManagedPrivateEndpoint]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ManagedPrivateEndpointListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -282,22 +277,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/managedPrivateEndpoints"
@@ -305,15 +302,15 @@
 
     @distributed_trace_async
     async def get(
         self, resource_group_name: str, cluster_name: str, managed_private_endpoint_name: str, **kwargs: Any
     ) -> _models.ManagedPrivateEndpoint:
         """Gets a managed private endpoint.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param managed_private_endpoint_name: The name of the managed private endpoint. Required.
         :type managed_private_endpoint_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -328,17 +325,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ManagedPrivateEndpoint] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             managed_private_endpoint_name=managed_private_endpoint_name,
             subscription_id=self._config.subscription_id,
@@ -346,23 +341,25 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ManagedPrivateEndpoint", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -386,24 +383,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ManagedPrivateEndpoint] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ManagedPrivateEndpoint")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -416,35 +411,42 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("ManagedPrivateEndpoint", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("ManagedPrivateEndpoint", pipeline_response)
 
         if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
             deserialized = self._deserialize("ManagedPrivateEndpoint", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_or_update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/managedPrivateEndpoints/{managedPrivateEndpointName}"
     }
 
@@ -457,15 +459,15 @@
         parameters: _models.ManagedPrivateEndpoint,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.ManagedPrivateEndpoint]:
         """Creates a managed private endpoint.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param managed_private_endpoint_name: The name of the managed private endpoint. Required.
         :type managed_private_endpoint_name: str
         :param parameters: The managed private endpoint parameters. Required.
@@ -496,15 +498,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.ManagedPrivateEndpoint]:
         """Creates a managed private endpoint.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param managed_private_endpoint_name: The name of the managed private endpoint. Required.
         :type managed_private_endpoint_name: str
         :param parameters: The managed private endpoint parameters. Required.
@@ -533,23 +535,23 @@
         cluster_name: str,
         managed_private_endpoint_name: str,
         parameters: Union[_models.ManagedPrivateEndpoint, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.ManagedPrivateEndpoint]:
         """Creates a managed private endpoint.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param managed_private_endpoint_name: The name of the managed private endpoint. Required.
         :type managed_private_endpoint_name: str
-        :param parameters: The managed private endpoint parameters. Is either a model type or a IO
-         type. Required.
+        :param parameters: The managed private endpoint parameters. Is either a ManagedPrivateEndpoint
+         type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.ManagedPrivateEndpoint or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -562,17 +564,15 @@
          of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.kusto.models.ManagedPrivateEndpoint]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ManagedPrivateEndpoint] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -592,15 +592,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("ManagedPrivateEndpoint", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -629,24 +631,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ManagedPrivateEndpoint] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ManagedPrivateEndpoint")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -659,23 +659,25 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("ManagedPrivateEndpoint", pipeline_response)
 
         if response.status_code == 202:
             response_headers["Azure-AsyncOperation"] = self._deserialize(
@@ -702,15 +704,15 @@
         parameters: _models.ManagedPrivateEndpoint,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.ManagedPrivateEndpoint]:
         """Updates a managed private endpoint.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param managed_private_endpoint_name: The name of the managed private endpoint. Required.
         :type managed_private_endpoint_name: str
         :param parameters: The managed private endpoint parameters. Required.
@@ -741,15 +743,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.ManagedPrivateEndpoint]:
         """Updates a managed private endpoint.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param managed_private_endpoint_name: The name of the managed private endpoint. Required.
         :type managed_private_endpoint_name: str
         :param parameters: The managed private endpoint parameters. Required.
@@ -778,23 +780,23 @@
         cluster_name: str,
         managed_private_endpoint_name: str,
         parameters: Union[_models.ManagedPrivateEndpoint, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.ManagedPrivateEndpoint]:
         """Updates a managed private endpoint.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param managed_private_endpoint_name: The name of the managed private endpoint. Required.
         :type managed_private_endpoint_name: str
-        :param parameters: The managed private endpoint parameters. Is either a model type or a IO
-         type. Required.
+        :param parameters: The managed private endpoint parameters. Is either a ManagedPrivateEndpoint
+         type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.ManagedPrivateEndpoint or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -807,17 +809,15 @@
          of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.kusto.models.ManagedPrivateEndpoint]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ManagedPrivateEndpoint] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -837,15 +837,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("ManagedPrivateEndpoint", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -869,17 +871,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             managed_private_endpoint_name=managed_private_endpoint_name,
             subscription_id=self._config.subscription_id,
@@ -887,38 +887,46 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/managedPrivateEndpoints/{managedPrivateEndpointName}"
     }
 
     @distributed_trace_async
     async def begin_delete(
         self, resource_group_name: str, cluster_name: str, managed_private_endpoint_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Deletes a managed private endpoint.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param managed_private_endpoint_name: The name of the managed private endpoint. Required.
         :type managed_private_endpoint_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -932,17 +940,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -957,15 +963,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_scripts_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_scripts_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -36,18 +36,14 @@
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_list_by_database_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ScriptsOperations:
     """
     .. warning::
@@ -69,32 +65,30 @@
 
     @distributed_trace
     def list_by_database(
         self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
     ) -> AsyncIterable["_models.Script"]:
         """Returns the list of database scripts for given database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Script or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.Script]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ScriptListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -141,22 +135,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_by_database.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/scripts"
@@ -164,15 +160,15 @@
 
     @distributed_trace_async
     async def get(
         self, resource_group_name: str, cluster_name: str, database_name: str, script_name: str, **kwargs: Any
     ) -> _models.Script:
         """Gets a Kusto cluster database script.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the Kusto database script. Required.
@@ -189,17 +185,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Script] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             database_name=database_name,
             script_name=script_name,
@@ -208,23 +202,25 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("Script", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -249,24 +245,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Script] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Script")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -280,35 +274,42 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("Script", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("Script", pipeline_response)
 
         if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
             deserialized = self._deserialize("Script", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_or_update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/scripts/{scriptName}"
     }
 
@@ -322,15 +323,15 @@
         parameters: _models.Script,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Script]:
         """Creates a Kusto database script.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the Kusto database script. Required.
@@ -364,15 +365,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Script]:
         """Creates a Kusto database script.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the Kusto database script. Required.
@@ -404,24 +405,24 @@
         database_name: str,
         script_name: str,
         parameters: Union[_models.Script, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Script]:
         """Creates a Kusto database script.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the Kusto database script. Required.
         :type script_name: str
-        :param parameters: The Kusto Script parameters contains the KQL to run. Is either a model type
+        :param parameters: The Kusto Script parameters contains the KQL to run. Is either a Script type
          or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.Script or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -435,17 +436,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.kusto.models.Script]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Script] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -466,15 +465,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Script", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -504,24 +505,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Script] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Script")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -535,23 +534,25 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("Script", pipeline_response)
 
         if response.status_code == 202:
             response_headers["Azure-AsyncOperation"] = self._deserialize(
@@ -579,15 +580,15 @@
         parameters: _models.Script,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Script]:
         """Updates a database script.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the Kusto database script. Required.
@@ -621,15 +622,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Script]:
         """Updates a database script.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the Kusto database script. Required.
@@ -661,24 +662,24 @@
         database_name: str,
         script_name: str,
         parameters: Union[_models.Script, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Script]:
         """Updates a database script.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the Kusto database script. Required.
         :type script_name: str
-        :param parameters: The Kusto Script parameters contains to the KQL to run. Is either a model
+        :param parameters: The Kusto Script parameters contains to the KQL to run. Is either a Script
          type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.Script or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -692,17 +693,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.kusto.models.Script]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Script] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -723,15 +722,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Script", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -755,17 +756,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             database_name=database_name,
             script_name=script_name,
@@ -774,38 +773,46 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/scripts/{scriptName}"
     }
 
     @distributed_trace_async
     async def begin_delete(
         self, resource_group_name: str, cluster_name: str, database_name: str, script_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
-        """Deletes a Kusto principalAssignment.
+        """Deletes a Kusto database script.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the Kusto database script. Required.
@@ -821,17 +828,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -847,15 +852,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -878,15 +885,15 @@
         script_name: _models.ScriptCheckNameRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the script name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the script. Required.
@@ -909,15 +916,15 @@
         script_name: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the script name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the script. Required.
@@ -938,22 +945,23 @@
         cluster_name: str,
         database_name: str,
         script_name: Union[_models.ScriptCheckNameRequest, IO],
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the script name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
-        :param script_name: The name of the script. Is either a model type or a IO type. Required.
+        :param script_name: The name of the script. Is either a ScriptCheckNameRequest type or a IO
+         type. Required.
         :type script_name: ~azure.mgmt.kusto.models.ScriptCheckNameRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.CheckNameResult
@@ -966,24 +974,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(script_name, (IO, bytes)):
+        if isinstance(script_name, (IOBase, bytes)):
             _content = script_name
         else:
             _json = self._serialize.body(script_name, "ScriptCheckNameRequest")
 
         request = build_check_name_availability_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -996,23 +1002,25 @@
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_database_principal_assignments_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_database_principal_assignments_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -35,18 +35,14 @@
     build_check_name_availability_request,
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class DatabasePrincipalAssignmentsOperations:
     """
     .. warning::
@@ -75,15 +71,15 @@
         principal_assignment_name: _models.DatabasePrincipalAssignmentCheckNameRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the database principal assignment is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param principal_assignment_name: The name of the resource. Required.
@@ -107,15 +103,15 @@
         principal_assignment_name: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the database principal assignment is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param principal_assignment_name: The name of the resource. Required.
@@ -136,23 +132,23 @@
         cluster_name: str,
         database_name: str,
         principal_assignment_name: Union[_models.DatabasePrincipalAssignmentCheckNameRequest, IO],
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the database principal assignment is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
-        :param principal_assignment_name: The name of the resource. Is either a model type or a IO
-         type. Required.
+        :param principal_assignment_name: The name of the resource. Is either a
+         DatabasePrincipalAssignmentCheckNameRequest type or a IO type. Required.
         :type principal_assignment_name:
          ~azure.mgmt.kusto.models.DatabasePrincipalAssignmentCheckNameRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
@@ -166,24 +162,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(principal_assignment_name, (IO, bytes)):
+        if isinstance(principal_assignment_name, (IOBase, bytes)):
             _content = principal_assignment_name
         else:
             _json = self._serialize.body(principal_assignment_name, "DatabasePrincipalAssignmentCheckNameRequest")
 
         request = build_check_name_availability_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -196,23 +190,25 @@
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -228,15 +224,15 @@
         cluster_name: str,
         database_name: str,
         principal_assignment_name: str,
         **kwargs: Any
     ) -> _models.DatabasePrincipalAssignment:
         """Gets a Kusto cluster database principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
@@ -253,17 +249,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DatabasePrincipalAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             database_name=database_name,
             principal_assignment_name=principal_assignment_name,
@@ -272,23 +266,25 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("DatabasePrincipalAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -313,24 +309,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.DatabasePrincipalAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "DatabasePrincipalAssignment")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -344,23 +338,25 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("DatabasePrincipalAssignment", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("DatabasePrincipalAssignment", pipeline_response)
 
@@ -383,15 +379,15 @@
         parameters: _models.DatabasePrincipalAssignment,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.DatabasePrincipalAssignment]:
         """Creates a Kusto cluster database principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
@@ -427,15 +423,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.DatabasePrincipalAssignment]:
         """Creates a Kusto cluster database principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
@@ -469,25 +465,25 @@
         database_name: str,
         principal_assignment_name: str,
         parameters: Union[_models.DatabasePrincipalAssignment, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.DatabasePrincipalAssignment]:
         """Creates a Kusto cluster database principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
         :type principal_assignment_name: str
         :param parameters: The Kusto principalAssignments parameters supplied for the operation. Is
-         either a model type or a IO type. Required.
+         either a DatabasePrincipalAssignment type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.DatabasePrincipalAssignment or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -501,17 +497,15 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.kusto.models.DatabasePrincipalAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.DatabasePrincipalAssignment] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -532,15 +526,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("DatabasePrincipalAssignment", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -569,17 +565,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             database_name=database_name,
             principal_assignment_name=principal_assignment_name,
@@ -588,26 +582,34 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}"
     }
 
     @distributed_trace_async
     async def begin_delete(
@@ -616,15 +618,15 @@
         cluster_name: str,
         database_name: str,
         principal_assignment_name: str,
         **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Deletes a Kusto principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
@@ -640,17 +642,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -666,15 +666,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -690,15 +692,15 @@
 
     @distributed_trace
     def list(
         self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
     ) -> AsyncIterable["_models.DatabasePrincipalAssignment"]:
         """Lists all Kusto cluster database principalAssignments.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -707,17 +709,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.DatabasePrincipalAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DatabasePrincipalAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -764,22 +764,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments"
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_attached_database_configurations_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_attached_database_configurations_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -35,18 +35,14 @@
     build_check_name_availability_request,
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_list_by_cluster_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AttachedDatabaseConfigurationsOperations:
     """
     .. warning::
@@ -75,15 +71,15 @@
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the attached database configuration resource name is valid and is not already in
         use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param resource_name: The name of the resource. Required.
         :type resource_name: ~azure.mgmt.kusto.models.AttachedDatabaseConfigurationsCheckNameRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
@@ -104,15 +100,15 @@
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the attached database configuration resource name is valid and is not already in
         use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param resource_name: The name of the resource. Required.
         :type resource_name: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -131,20 +127,21 @@
         cluster_name: str,
         resource_name: Union[_models.AttachedDatabaseConfigurationsCheckNameRequest, IO],
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the attached database configuration resource name is valid and is not already in
         use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param resource_name: The name of the resource. Is either a model type or a IO type. Required.
+        :param resource_name: The name of the resource. Is either a
+         AttachedDatabaseConfigurationsCheckNameRequest type or a IO type. Required.
         :type resource_name: ~azure.mgmt.kusto.models.AttachedDatabaseConfigurationsCheckNameRequest or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
@@ -158,24 +155,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(resource_name, (IO, bytes)):
+        if isinstance(resource_name, (IOBase, bytes)):
             _content = resource_name
         else:
             _json = self._serialize.body(resource_name, "AttachedDatabaseConfigurationsCheckNameRequest")
 
         request = build_check_name_availability_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -187,23 +182,25 @@
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -214,32 +211,30 @@
 
     @distributed_trace
     def list_by_cluster(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> AsyncIterable["_models.AttachedDatabaseConfiguration"]:
         """Returns the list of attached database configurations of the given Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AttachedDatabaseConfiguration or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.AttachedDatabaseConfiguration]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AttachedDatabaseConfigurationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -285,22 +280,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_by_cluster.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/attachedDatabaseConfigurations"
@@ -308,15 +305,15 @@
 
     @distributed_trace_async
     async def get(
         self, resource_group_name: str, cluster_name: str, attached_database_configuration_name: str, **kwargs: Any
     ) -> _models.AttachedDatabaseConfiguration:
         """Returns an attached database configuration.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param attached_database_configuration_name: The name of the attached database configuration.
          Required.
         :type attached_database_configuration_name: str
@@ -332,17 +329,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AttachedDatabaseConfiguration] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             attached_database_configuration_name=attached_database_configuration_name,
             subscription_id=self._config.subscription_id,
@@ -350,23 +345,25 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("AttachedDatabaseConfiguration", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -390,24 +387,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AttachedDatabaseConfiguration] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "AttachedDatabaseConfiguration")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -420,35 +415,42 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("AttachedDatabaseConfiguration", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("AttachedDatabaseConfiguration", pipeline_response)
 
         if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
             deserialized = self._deserialize("AttachedDatabaseConfiguration", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_or_update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/attachedDatabaseConfigurations/{attachedDatabaseConfigurationName}"
     }
 
@@ -461,15 +463,15 @@
         parameters: _models.AttachedDatabaseConfiguration,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.AttachedDatabaseConfiguration]:
         """Creates or updates an attached database configuration.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param attached_database_configuration_name: The name of the attached database configuration.
          Required.
         :type attached_database_configuration_name: str
@@ -502,15 +504,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.AttachedDatabaseConfiguration]:
         """Creates or updates an attached database configuration.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param attached_database_configuration_name: The name of the attached database configuration.
          Required.
         :type attached_database_configuration_name: str
@@ -541,24 +543,24 @@
         cluster_name: str,
         attached_database_configuration_name: str,
         parameters: Union[_models.AttachedDatabaseConfiguration, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.AttachedDatabaseConfiguration]:
         """Creates or updates an attached database configuration.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param attached_database_configuration_name: The name of the attached database configuration.
          Required.
         :type attached_database_configuration_name: str
         :param parameters: The database parameters supplied to the CreateOrUpdate operation. Is either
-         a model type or a IO type. Required.
+         a AttachedDatabaseConfiguration type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.AttachedDatabaseConfiguration or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -572,17 +574,15 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.kusto.models.AttachedDatabaseConfiguration]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AttachedDatabaseConfiguration] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -602,15 +602,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("AttachedDatabaseConfiguration", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -634,17 +636,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             attached_database_configuration_name=attached_database_configuration_name,
             subscription_id=self._config.subscription_id,
@@ -652,38 +652,46 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/attachedDatabaseConfigurations/{attachedDatabaseConfigurationName}"
     }
 
     @distributed_trace_async
     async def begin_delete(
         self, resource_group_name: str, cluster_name: str, attached_database_configuration_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Deletes the attached database configuration with the given name.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param attached_database_configuration_name: The name of the attached database configuration.
          Required.
         :type attached_database_configuration_name: str
@@ -698,17 +706,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -723,15 +729,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,80 +2,95 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._operations import build_list_request
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request
+
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_list_request(**kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop("template_url", "/providers/Microsoft.Kusto/operations")
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.kusto.aio.KustoManagementClient`'s
+        :class:`~azure.mgmt.kusto.KustoManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
+    def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
         """Lists available operations for the Microsoft.Kusto provider.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.Operation]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -108,31 +123,33 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
+        def extract_data(pipeline_response):
             deserialized = self._deserialize("OperationListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/providers/Microsoft.Kusto/operations"}
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_private_link_resources_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_private_link_resources_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -27,18 +26,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._private_link_resources_operations import build_get_request, build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class PrivateLinkResourcesOperations:
     """
     .. warning::
@@ -60,30 +55,28 @@
 
     @distributed_trace
     def list(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> AsyncIterable["_models.PrivateLinkResource"]:
         """Returns the list of private link resources.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either PrivateLinkResource or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.PrivateLinkResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateLinkResourceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -129,22 +122,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/privateLinkResources"
@@ -152,15 +147,15 @@
 
     @distributed_trace_async
     async def get(
         self, resource_group_name: str, cluster_name: str, private_link_resource_name: str, **kwargs: Any
     ) -> _models.PrivateLinkResource:
         """Gets a private link resource.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param private_link_resource_name: The name of the private link resource. Required.
         :type private_link_resource_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -175,17 +170,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateLinkResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             private_link_resource_name=private_link_resource_name,
             subscription_id=self._config.subscription_id,
@@ -193,23 +186,25 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("PrivateLinkResource", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_operations_results_location_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_operations_results_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -22,95 +21,93 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._operations_results_location_operations import build_get_request
+from ...operations._operations_results_operations import build_get_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class OperationsResultsLocationOperations:
+class OperationsResultsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.kusto.aio.KustoManagementClient`'s
-        :attr:`operations_results_location` attribute.
+        :attr:`operations_results` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace_async
-    async def get(  # pylint: disable=inconsistent-return-statements
-        self, location: str, operation_id: str, **kwargs: Any
-    ) -> None:
+    async def get(self, location: str, operation_id: str, **kwargs: Any) -> _models.OperationResult:
         """Returns operation results.
 
-        :param location: Azure location (region) name. Required.
+        :param location: The name of Azure region. Required.
         :type location: str
-        :param operation_id: The Guid of the operation ID. Required.
+        :param operation_id: The ID of an ongoing async operation. Required.
         :type operation_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: None or the result of cls(response)
-        :rtype: None
+        :return: OperationResult or the result of cls(response)
+        :rtype: ~azure.mgmt.kusto.models.OperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.OperationResult] = kwargs.pop("cls", None)
 
         request = build_get_request(
             location=location,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        deserialized = self._deserialize("OperationResult", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
     get.metadata = {
         "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/locations/{location}/operationResults/{operationId}"
     }
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_private_endpoint_connections_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_private_endpoint_connections_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -34,18 +34,14 @@
 from ...operations._private_endpoint_connections_operations import (
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class PrivateEndpointConnectionsOperations:
     """
     .. warning::
@@ -67,32 +63,30 @@
 
     @distributed_trace
     def list(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> AsyncIterable["_models.PrivateEndpointConnection"]:
         """Returns the list of private endpoint connections.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either PrivateEndpointConnection or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.PrivateEndpointConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateEndpointConnectionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -138,22 +132,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/privateEndpointConnections"
@@ -161,15 +157,15 @@
 
     @distributed_trace_async
     async def get(
         self, resource_group_name: str, cluster_name: str, private_endpoint_connection_name: str, **kwargs: Any
     ) -> _models.PrivateEndpointConnection:
         """Gets a private endpoint connection.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -184,17 +180,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             private_endpoint_connection_name=private_endpoint_connection_name,
             subscription_id=self._config.subscription_id,
@@ -202,23 +196,25 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("PrivateEndpointConnection", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -242,24 +238,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "PrivateEndpointConnection")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -272,23 +266,25 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("PrivateEndpointConnection", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("PrivateEndpointConnection", pipeline_response)
 
@@ -310,15 +306,15 @@
         parameters: _models.PrivateEndpointConnection,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.PrivateEndpointConnection]:
         """Approve or reject a private endpoint connection with a given name.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
         :param parameters: Required.
@@ -349,15 +345,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.PrivateEndpointConnection]:
         """Approve or reject a private endpoint connection with a given name.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
         :param parameters: Required.
@@ -386,22 +382,22 @@
         cluster_name: str,
         private_endpoint_connection_name: str,
         parameters: Union[_models.PrivateEndpointConnection, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.PrivateEndpointConnection]:
         """Approve or reject a private endpoint connection with a given name.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
-        :param parameters: Is either a model type or a IO type. Required.
+        :param parameters: Is either a PrivateEndpointConnection type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.PrivateEndpointConnection or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -414,17 +410,15 @@
          result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.kusto.models.PrivateEndpointConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -444,15 +438,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("PrivateEndpointConnection", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -476,17 +472,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             private_endpoint_connection_name=private_endpoint_connection_name,
             subscription_id=self._config.subscription_id,
@@ -494,38 +488,46 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/privateEndpointConnections/{privateEndpointConnectionName}"
     }
 
     @distributed_trace_async
     async def begin_delete(
         self, resource_group_name: str, cluster_name: str, private_endpoint_connection_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Deletes a private endpoint connection with a given name.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -539,17 +541,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -564,15 +564,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_cluster_principal_assignments_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_cluster_principal_assignments_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -35,18 +35,14 @@
     build_check_name_availability_request,
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ClusterPrincipalAssignmentsOperations:
     """
     .. warning::
@@ -74,15 +70,15 @@
         principal_assignment_name: _models.ClusterPrincipalAssignmentCheckNameRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the principal assignment name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param principal_assignment_name: The name of the principal assignment. Required.
         :type principal_assignment_name:
          ~azure.mgmt.kusto.models.ClusterPrincipalAssignmentCheckNameRequest
@@ -103,15 +99,15 @@
         principal_assignment_name: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the principal assignment name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param principal_assignment_name: The name of the principal assignment. Required.
         :type principal_assignment_name: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -129,21 +125,21 @@
         resource_group_name: str,
         cluster_name: str,
         principal_assignment_name: Union[_models.ClusterPrincipalAssignmentCheckNameRequest, IO],
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the principal assignment name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param principal_assignment_name: The name of the principal assignment. Is either a model type
-         or a IO type. Required.
+        :param principal_assignment_name: The name of the principal assignment. Is either a
+         ClusterPrincipalAssignmentCheckNameRequest type or a IO type. Required.
         :type principal_assignment_name:
          ~azure.mgmt.kusto.models.ClusterPrincipalAssignmentCheckNameRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
@@ -157,24 +153,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(principal_assignment_name, (IO, bytes)):
+        if isinstance(principal_assignment_name, (IOBase, bytes)):
             _content = principal_assignment_name
         else:
             _json = self._serialize.body(principal_assignment_name, "ClusterPrincipalAssignmentCheckNameRequest")
 
         request = build_check_name_availability_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -186,23 +180,25 @@
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -213,15 +209,15 @@
 
     @distributed_trace_async
     async def get(
         self, resource_group_name: str, cluster_name: str, principal_assignment_name: str, **kwargs: Any
     ) -> _models.ClusterPrincipalAssignment:
         """Gets a Kusto cluster principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
         :type principal_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -236,17 +232,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ClusterPrincipalAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             principal_assignment_name=principal_assignment_name,
             subscription_id=self._config.subscription_id,
@@ -254,23 +248,25 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ClusterPrincipalAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -294,24 +290,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ClusterPrincipalAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ClusterPrincipalAssignment")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -324,23 +318,25 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("ClusterPrincipalAssignment", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("ClusterPrincipalAssignment", pipeline_response)
 
@@ -362,15 +358,15 @@
         parameters: _models.ClusterPrincipalAssignment,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.ClusterPrincipalAssignment]:
         """Create a Kusto cluster principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
         :type principal_assignment_name: str
         :param parameters: The Kusto cluster principalAssignment's parameters supplied for the
@@ -402,15 +398,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.ClusterPrincipalAssignment]:
         """Create a Kusto cluster principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
         :type principal_assignment_name: str
         :param parameters: The Kusto cluster principalAssignment's parameters supplied for the
@@ -440,23 +436,23 @@
         cluster_name: str,
         principal_assignment_name: str,
         parameters: Union[_models.ClusterPrincipalAssignment, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.ClusterPrincipalAssignment]:
         """Create a Kusto cluster principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
         :type principal_assignment_name: str
         :param parameters: The Kusto cluster principalAssignment's parameters supplied for the
-         operation. Is either a model type or a IO type. Required.
+         operation. Is either a ClusterPrincipalAssignment type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.ClusterPrincipalAssignment or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -469,17 +465,15 @@
          result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.kusto.models.ClusterPrincipalAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ClusterPrincipalAssignment] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -499,15 +493,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("ClusterPrincipalAssignment", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -531,17 +527,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             principal_assignment_name=principal_assignment_name,
             subscription_id=self._config.subscription_id,
@@ -549,38 +543,46 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}"
     }
 
     @distributed_trace_async
     async def begin_delete(
         self, resource_group_name: str, cluster_name: str, principal_assignment_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Deletes a Kusto cluster principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
         :type principal_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -594,17 +596,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -619,15 +619,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -643,32 +645,30 @@
 
     @distributed_trace
     def list(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> AsyncIterable["_models.ClusterPrincipalAssignment"]:
         """Lists all Kusto cluster principalAssignments.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ClusterPrincipalAssignment or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.ClusterPrincipalAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ClusterPrincipalAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -714,22 +714,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments"
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_data_connections_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_data_connections_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -37,18 +37,14 @@
     build_data_connection_validation_request,
     build_delete_request,
     build_get_request,
     build_list_by_database_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class DataConnectionsOperations:
     """
     .. warning::
@@ -70,32 +66,30 @@
 
     @distributed_trace
     def list_by_database(
         self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
     ) -> AsyncIterable["_models.DataConnection"]:
         """Returns the list of data connections of the given Kusto database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DataConnection or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.DataConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DataConnectionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -142,22 +136,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_by_database.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/dataConnections"
@@ -178,24 +174,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.DataConnectionValidationListResult]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "DataConnectionValidation")
 
         request = build_data_connection_validation_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -208,30 +202,38 @@
             template_url=self._data_connection_validation_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
+        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("DataConnectionValidationListResult", pipeline_response)
 
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _data_connection_validation_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/dataConnectionValidation"
     }
 
@@ -244,15 +246,15 @@
         parameters: _models.DataConnectionValidation,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.DataConnectionValidationListResult]:
         """Checks that the data connection parameters are valid.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param parameters: The data connection parameters supplied to the CreateOrUpdate operation.
@@ -285,15 +287,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.DataConnectionValidationListResult]:
         """Checks that the data connection parameters are valid.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param parameters: The data connection parameters supplied to the CreateOrUpdate operation.
@@ -324,23 +326,23 @@
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.DataConnectionValidation, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.DataConnectionValidationListResult]:
         """Checks that the data connection parameters are valid.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param parameters: The data connection parameters supplied to the CreateOrUpdate operation. Is
-         either a model type or a IO type. Required.
+         either a DataConnectionValidation type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.DataConnectionValidation or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -354,17 +356,15 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.kusto.models.DataConnectionValidationListResult]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.DataConnectionValidationListResult] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._data_connection_validation_initial(
@@ -417,15 +417,15 @@
         data_connection_name: _models.DataConnectionCheckNameRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the data connection name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
@@ -448,15 +448,15 @@
         data_connection_name: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the data connection name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
@@ -477,23 +477,23 @@
         cluster_name: str,
         database_name: str,
         data_connection_name: Union[_models.DataConnectionCheckNameRequest, IO],
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the data connection name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
-        :param data_connection_name: The name of the data connection. Is either a model type or a IO
-         type. Required.
+        :param data_connection_name: The name of the data connection. Is either a
+         DataConnectionCheckNameRequest type or a IO type. Required.
         :type data_connection_name: ~azure.mgmt.kusto.models.DataConnectionCheckNameRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.CheckNameResult
@@ -506,24 +506,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(data_connection_name, (IO, bytes)):
+        if isinstance(data_connection_name, (IOBase, bytes)):
             _content = data_connection_name
         else:
             _json = self._serialize.body(data_connection_name, "DataConnectionCheckNameRequest")
 
         request = build_check_name_availability_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -536,23 +534,25 @@
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -563,15 +563,15 @@
 
     @distributed_trace_async
     async def get(
         self, resource_group_name: str, cluster_name: str, database_name: str, data_connection_name: str, **kwargs: Any
     ) -> _models.DataConnection:
         """Returns a data connection.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
@@ -588,17 +588,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DataConnection] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             database_name=database_name,
             data_connection_name=data_connection_name,
@@ -607,23 +605,25 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("DataConnection", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -648,24 +648,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.DataConnection] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "DataConnection")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -679,35 +677,42 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("DataConnection", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("DataConnection", pipeline_response)
 
         if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
             deserialized = self._deserialize("DataConnection", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_or_update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/dataConnections/{dataConnectionName}"
     }
 
@@ -721,15 +726,15 @@
         parameters: _models.DataConnection,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.DataConnection]:
         """Creates or updates a data connection.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
@@ -764,15 +769,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.DataConnection]:
         """Creates or updates a data connection.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
@@ -805,25 +810,25 @@
         database_name: str,
         data_connection_name: str,
         parameters: Union[_models.DataConnection, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.DataConnection]:
         """Creates or updates a data connection.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
         :type data_connection_name: str
         :param parameters: The data connection parameters supplied to the CreateOrUpdate operation. Is
-         either a model type or a IO type. Required.
+         either a DataConnection type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.DataConnection or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -836,17 +841,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.kusto.models.DataConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.DataConnection] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -867,15 +870,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("DataConnection", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -905,24 +910,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.DataConnection] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "DataConnection")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -936,23 +939,25 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("DataConnection", pipeline_response)
 
         if response.status_code == 201:
             response_headers["Azure-AsyncOperation"] = self._deserialize(
@@ -987,15 +992,15 @@
         parameters: _models.DataConnection,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.DataConnection]:
         """Updates a data connection.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
@@ -1029,15 +1034,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.DataConnection]:
         """Updates a data connection.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
@@ -1069,25 +1074,25 @@
         database_name: str,
         data_connection_name: str,
         parameters: Union[_models.DataConnection, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.DataConnection]:
         """Updates a data connection.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
         :type data_connection_name: str
         :param parameters: The data connection parameters supplied to the Update operation. Is either a
-         model type or a IO type. Required.
+         DataConnection type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.DataConnection or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -1100,17 +1105,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.kusto.models.DataConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.DataConnection] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -1131,15 +1134,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("DataConnection", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -1163,17 +1168,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             database_name=database_name,
             data_connection_name=data_connection_name,
@@ -1182,38 +1185,46 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/dataConnections/{dataConnectionName}"
     }
 
     @distributed_trace_async
     async def begin_delete(
         self, resource_group_name: str, cluster_name: str, database_name: str, data_connection_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Deletes the data connection with the given name.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
@@ -1229,17 +1240,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1255,15 +1264,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_patch.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/__init__.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -8,14 +8,15 @@
 
 from ._clusters_operations import ClustersOperations
 from ._cluster_principal_assignments_operations import ClusterPrincipalAssignmentsOperations
 from ._skus_operations import SkusOperations
 from ._databases_operations import DatabasesOperations
 from ._attached_database_configurations_operations import AttachedDatabaseConfigurationsOperations
 from ._managed_private_endpoints_operations import ManagedPrivateEndpointsOperations
+from ._database_operations import DatabaseOperations
 from ._database_principal_assignments_operations import DatabasePrincipalAssignmentsOperations
 from ._scripts_operations import ScriptsOperations
 from ._private_endpoint_connections_operations import PrivateEndpointConnectionsOperations
 from ._private_link_resources_operations import PrivateLinkResourcesOperations
 from ._data_connections_operations import DataConnectionsOperations
 from ._operations import Operations
 from ._operations_results_operations import OperationsResultsOperations
@@ -28,14 +29,15 @@
 __all__ = [
     "ClustersOperations",
     "ClusterPrincipalAssignmentsOperations",
     "SkusOperations",
     "DatabasesOperations",
     "AttachedDatabaseConfigurationsOperations",
     "ManagedPrivateEndpointsOperations",
+    "DatabaseOperations",
     "DatabasePrincipalAssignmentsOperations",
     "ScriptsOperations",
     "PrivateEndpointConnectionsOperations",
     "PrivateLinkResourcesOperations",
     "DataConnectionsOperations",
     "Operations",
     "OperationsResultsOperations",
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_databases_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_databases_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -39,18 +39,14 @@
     build_get_request,
     build_list_by_cluster_request,
     build_list_principals_request,
     build_remove_principals_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class DatabasesOperations:
     """
     .. warning::
@@ -78,15 +74,15 @@
         resource_name: _models.CheckNameRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the databases resource name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param resource_name: The name of the resource. Required.
         :type resource_name: ~azure.mgmt.kusto.models.CheckNameRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
@@ -106,15 +102,15 @@
         resource_name: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the databases resource name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param resource_name: The name of the resource. Required.
         :type resource_name: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -132,20 +128,21 @@
         resource_group_name: str,
         cluster_name: str,
         resource_name: Union[_models.CheckNameRequest, IO],
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the databases resource name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param resource_name: The name of the resource. Is either a model type or a IO type. Required.
+        :param resource_name: The name of the resource. Is either a CheckNameRequest type or a IO type.
+         Required.
         :type resource_name: ~azure.mgmt.kusto.models.CheckNameRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.CheckNameResult
@@ -158,24 +155,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(resource_name, (IO, bytes)):
+        if isinstance(resource_name, (IOBase, bytes)):
             _content = resource_name
         else:
             _json = self._serialize.body(resource_name, "CheckNameRequest")
 
         request = build_check_name_availability_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -187,57 +182,69 @@
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     check_name_availability.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/checkNameAvailability"
     }
 
     @distributed_trace
     def list_by_cluster(
-        self, resource_group_name: str, cluster_name: str, **kwargs: Any
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        top: Optional[int] = None,
+        skiptoken: Optional[str] = None,
+        **kwargs: Any
     ) -> AsyncIterable["_models.Database"]:
         """Returns the list of databases of the given Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
+        :param top: limit the number of results. Default value is None.
+        :type top: int
+        :param skiptoken: Skiptoken is only used if a previous operation returned a partial result. If
+         a previous response contains a nextLink element, the value of the nextLink element will include
+         a skiptoken parameter that specifies a starting point to use for subsequent calls. Default
+         value is None.
+        :type skiptoken: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Database or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DatabaseListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -247,14 +254,16 @@
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_by_cluster_request(
                     resource_group_name=resource_group_name,
                     cluster_name=cluster_name,
                     subscription_id=self._config.subscription_id,
+                    top=top,
+                    skiptoken=skiptoken,
                     api_version=api_version,
                     template_url=self.list_by_cluster.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
@@ -278,27 +287,29 @@
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("DatabaseListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_by_cluster.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases"
@@ -306,15 +317,15 @@
 
     @distributed_trace_async
     async def get(
         self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
     ) -> _models.Database:
         """Returns a database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -329,17 +340,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             database_name=database_name,
             subscription_id=self._config.subscription_id,
@@ -347,23 +356,25 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("Database", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -388,24 +399,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Database")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -419,35 +428,42 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("Database", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("Database", pipeline_response)
 
         if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
             deserialized = self._deserialize("Database", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_or_update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}"
     }
 
@@ -461,15 +477,15 @@
         caller_role: Union[str, _models.CallerRole] = "Admin",
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Database]:
         """Creates or updates a database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param parameters: The database parameters supplied to the CreateOrUpdate operation. Required.
@@ -505,15 +521,15 @@
         caller_role: Union[str, _models.CallerRole] = "Admin",
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Database]:
         """Creates or updates a database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param parameters: The database parameters supplied to the CreateOrUpdate operation. Required.
@@ -547,23 +563,23 @@
         database_name: str,
         parameters: Union[_models.Database, IO],
         caller_role: Union[str, _models.CallerRole] = "Admin",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Database]:
         """Creates or updates a database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param parameters: The database parameters supplied to the CreateOrUpdate operation. Is either
-         a model type or a IO type. Required.
+         a Database type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.Database or IO
         :param caller_role: By default, any user who run operation on a database become an Admin on it.
          This property allows the caller to exclude the caller from Admins list. Known values are:
          "Admin" and "None". Default value is "Admin".
         :type caller_role: str or ~azure.mgmt.kusto.models.CallerRole
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -580,17 +596,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.kusto.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -611,15 +625,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Database", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -649,24 +665,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Database")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -680,23 +694,25 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("Database", pipeline_response)
 
         if response.status_code == 201:
             response_headers["Azure-AsyncOperation"] = self._deserialize(
@@ -731,15 +747,15 @@
         caller_role: Union[str, _models.CallerRole] = "Admin",
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Database]:
         """Updates a database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param parameters: The database parameters supplied to the Update operation. Required.
@@ -775,15 +791,15 @@
         caller_role: Union[str, _models.CallerRole] = "Admin",
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Database]:
         """Updates a database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param parameters: The database parameters supplied to the Update operation. Required.
@@ -817,23 +833,23 @@
         database_name: str,
         parameters: Union[_models.Database, IO],
         caller_role: Union[str, _models.CallerRole] = "Admin",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Database]:
         """Updates a database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
-        :param parameters: The database parameters supplied to the Update operation. Is either a model
-         type or a IO type. Required.
+        :param parameters: The database parameters supplied to the Update operation. Is either a
+         Database type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.Database or IO
         :param caller_role: By default, any user who run operation on a database become an Admin on it.
          This property allows the caller to exclude the caller from Admins list. Known values are:
          "Admin" and "None". Default value is "Admin".
         :type caller_role: str or ~azure.mgmt.kusto.models.CallerRole
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -850,17 +866,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.kusto.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -881,15 +895,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Database", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -913,17 +929,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             database_name=database_name,
             subscription_id=self._config.subscription_id,
@@ -931,38 +945,46 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}"
     }
 
     @distributed_trace_async
     async def begin_delete(
         self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Deletes the database with the given name.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -976,17 +998,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1001,15 +1021,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -1025,32 +1047,30 @@
 
     @distributed_trace
     def list_principals(
         self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
     ) -> AsyncIterable["_models.DatabasePrincipal"]:
         """Returns a list of database principals of the given Kusto cluster and database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DatabasePrincipal or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.DatabasePrincipal]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DatabasePrincipalListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1097,22 +1117,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_principals.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/listPrincipals"
@@ -1127,15 +1149,15 @@
         database_principals_to_add: _models.DatabasePrincipalListRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.DatabasePrincipalListResult:
         """Add Database principals permissions.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param database_principals_to_add: List of database principals to add. Required.
@@ -1158,15 +1180,15 @@
         database_principals_to_add: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.DatabasePrincipalListResult:
         """Add Database principals permissions.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param database_principals_to_add: List of database principals to add. Required.
@@ -1187,23 +1209,23 @@
         cluster_name: str,
         database_name: str,
         database_principals_to_add: Union[_models.DatabasePrincipalListRequest, IO],
         **kwargs: Any
     ) -> _models.DatabasePrincipalListResult:
         """Add Database principals permissions.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
-        :param database_principals_to_add: List of database principals to add. Is either a model type
-         or a IO type. Required.
+        :param database_principals_to_add: List of database principals to add. Is either a
+         DatabasePrincipalListRequest type or a IO type. Required.
         :type database_principals_to_add: ~azure.mgmt.kusto.models.DatabasePrincipalListRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DatabasePrincipalListResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.DatabasePrincipalListResult
@@ -1216,24 +1238,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.DatabasePrincipalListResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(database_principals_to_add, (IO, bytes)):
+        if isinstance(database_principals_to_add, (IOBase, bytes)):
             _content = database_principals_to_add
         else:
             _json = self._serialize.body(database_principals_to_add, "DatabasePrincipalListRequest")
 
         request = build_add_principals_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1246,23 +1266,25 @@
             template_url=self.add_principals.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("DatabasePrincipalListResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -1280,15 +1302,15 @@
         database_principals_to_remove: _models.DatabasePrincipalListRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.DatabasePrincipalListResult:
         """Remove Database principals permissions.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param database_principals_to_remove: List of database principals to remove. Required.
@@ -1311,15 +1333,15 @@
         database_principals_to_remove: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.DatabasePrincipalListResult:
         """Remove Database principals permissions.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param database_principals_to_remove: List of database principals to remove. Required.
@@ -1340,23 +1362,23 @@
         cluster_name: str,
         database_name: str,
         database_principals_to_remove: Union[_models.DatabasePrincipalListRequest, IO],
         **kwargs: Any
     ) -> _models.DatabasePrincipalListResult:
         """Remove Database principals permissions.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
-        :param database_principals_to_remove: List of database principals to remove. Is either a model
-         type or a IO type. Required.
+        :param database_principals_to_remove: List of database principals to remove. Is either a
+         DatabasePrincipalListRequest type or a IO type. Required.
         :type database_principals_to_remove: ~azure.mgmt.kusto.models.DatabasePrincipalListRequest or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DatabasePrincipalListResult or the result of cls(response)
@@ -1370,24 +1392,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.DatabasePrincipalListResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(database_principals_to_remove, (IO, bytes)):
+        if isinstance(database_principals_to_remove, (IOBase, bytes)):
             _content = database_principals_to_remove
         else:
             _json = self._serialize.body(database_principals_to_remove, "DatabasePrincipalListRequest")
 
         request = build_remove_principals_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1400,23 +1420,25 @@
             template_url=self.remove_principals.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("DatabasePrincipalListResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/aio/operations/_clusters_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_clusters_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -42,24 +42,21 @@
     build_list_by_resource_group_request,
     build_list_follower_databases_request,
     build_list_language_extensions_request,
     build_list_outbound_network_dependencies_endpoints_request,
     build_list_request,
     build_list_skus_by_resource_request,
     build_list_skus_request,
+    build_migrate_request,
     build_remove_language_extensions_request,
     build_start_request,
     build_stop_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ClustersOperations:  # pylint: disable=too-many-public-methods
     """
     .. warning::
@@ -79,15 +76,15 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace_async
     async def get(self, resource_group_name: str, cluster_name: str, **kwargs: Any) -> _models.Cluster:
         """Gets a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Cluster or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.Cluster
@@ -100,40 +97,40 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("Cluster", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -158,24 +155,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Cluster")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -189,23 +184,25 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("Cluster", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("Cluster", pipeline_response)
 
@@ -228,15 +225,15 @@
         if_none_match: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Cluster]:
         """Create or update a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param parameters: The Kusto cluster parameters supplied to the CreateOrUpdate operation.
          Required.
         :type parameters: ~azure.mgmt.kusto.models.Cluster
@@ -275,15 +272,15 @@
         if_none_match: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Cluster]:
         """Create or update a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param parameters: The Kusto cluster parameters supplied to the CreateOrUpdate operation.
          Required.
         :type parameters: IO
@@ -320,21 +317,21 @@
         parameters: Union[_models.Cluster, IO],
         if_match: Optional[str] = None,
         if_none_match: Optional[str] = None,
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Cluster]:
         """Create or update a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param parameters: The Kusto cluster parameters supplied to the CreateOrUpdate operation. Is
-         either a model type or a IO type. Required.
+         either a Cluster type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.Cluster or IO
         :param if_match: The ETag of the cluster. Omit this value to always overwrite the current
          cluster. Specify the last-seen ETag value to prevent accidentally overwriting concurrent
          changes. Default value is None.
         :type if_match: str
         :param if_none_match: Set to '*' to allow a new cluster to be created, but to prevent updating
          an existing cluster. Other values will result in a 412 Pre-condition Failed response. Default
@@ -355,17 +352,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.kusto.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -386,15 +381,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Cluster", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -423,24 +420,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ClusterUpdate")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -453,23 +448,25 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("Cluster", pipeline_response)
 
         if response.status_code == 201:
             response_headers["Azure-AsyncOperation"] = self._deserialize(
@@ -503,15 +500,15 @@
         if_match: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Cluster]:
         """Update a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param parameters: The Kusto cluster parameters supplied to the Update operation. Required.
         :type parameters: ~azure.mgmt.kusto.models.ClusterUpdate
         :param if_match: The ETag of the cluster. Omit this value to always overwrite the current
@@ -544,15 +541,15 @@
         if_match: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Cluster]:
         """Update a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param parameters: The Kusto cluster parameters supplied to the Update operation. Required.
         :type parameters: IO
         :param if_match: The ETag of the cluster. Omit this value to always overwrite the current
@@ -583,21 +580,21 @@
         cluster_name: str,
         parameters: Union[_models.ClusterUpdate, IO],
         if_match: Optional[str] = None,
         **kwargs: Any
     ) -> AsyncLROPoller[_models.Cluster]:
         """Update a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param parameters: The Kusto cluster parameters supplied to the Update operation. Is either a
-         model type or a IO type. Required.
+         ClusterUpdate type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.ClusterUpdate or IO
         :param if_match: The ETag of the cluster. Omit this value to always overwrite the current
          cluster. Specify the last-seen ETag value to prevent accidentally overwriting concurrent
          changes. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -614,17 +611,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.kusto.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
@@ -644,15 +639,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Cluster", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -676,53 +673,59 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}"
     }
 
     @distributed_trace_async
     async def begin_delete(self, resource_group_name: str, cluster_name: str, **kwargs: Any) -> AsyncLROPoller[None]:
         """Deletes a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -734,17 +737,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -758,15 +759,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -790,53 +793,59 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._stop_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _stop_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/stop"
     }
 
     @distributed_trace_async
     async def begin_stop(self, resource_group_name: str, cluster_name: str, **kwargs: Any) -> AsyncLROPoller[None]:
         """Stops a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -848,17 +857,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._stop_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -872,15 +879,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -904,53 +913,59 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_start_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._start_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _start_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/start"
     }
 
     @distributed_trace_async
     async def begin_start(self, resource_group_name: str, cluster_name: str, **kwargs: Any) -> AsyncLROPoller[None]:
         """Starts a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -962,17 +977,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._start_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -986,15 +999,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -1004,39 +1019,258 @@
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_start.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/start"
     }
 
+    async def _migrate_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        cluster_migrate_request: Union[_models.ClusterMigrateRequest, IO],
+        **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(cluster_migrate_request, (IOBase, bytes)):
+            _content = cluster_migrate_request
+        else:
+            _json = self._serialize.body(cluster_migrate_request, "ClusterMigrateRequest")
+
+        request = build_migrate_request(
+            resource_group_name=resource_group_name,
+            cluster_name=cluster_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._migrate_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200, 202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    _migrate_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/migrate"
+    }
+
+    @overload
+    async def begin_migrate(
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        cluster_migrate_request: _models.ClusterMigrateRequest,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Migrate data from a Kusto cluster to another cluster.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param cluster_name: The name of the Kusto cluster. Required.
+        :type cluster_name: str
+        :param cluster_migrate_request: The cluster migrate request parameters. Required.
+        :type cluster_migrate_request: ~azure.mgmt.kusto.models.ClusterMigrateRequest
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    async def begin_migrate(
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        cluster_migrate_request: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Migrate data from a Kusto cluster to another cluster.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param cluster_name: The name of the Kusto cluster. Required.
+        :type cluster_name: str
+        :param cluster_migrate_request: The cluster migrate request parameters. Required.
+        :type cluster_migrate_request: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @distributed_trace_async
+    async def begin_migrate(
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        cluster_migrate_request: Union[_models.ClusterMigrateRequest, IO],
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Migrate data from a Kusto cluster to another cluster.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param cluster_name: The name of the Kusto cluster. Required.
+        :type cluster_name: str
+        :param cluster_migrate_request: The cluster migrate request parameters. Is either a
+         ClusterMigrateRequest type or a IO type. Required.
+        :type cluster_migrate_request: ~azure.mgmt.kusto.models.ClusterMigrateRequest or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = await self._migrate_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                cluster_name=cluster_name,
+                cluster_migrate_request=cluster_migrate_request,
+                api_version=api_version,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
+
+        if polling is True:
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_migrate.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/migrate"
+    }
+
     @distributed_trace
     def list_follower_databases(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> AsyncIterable["_models.FollowerDatabaseDefinition"]:
         """Returns a list of databases that are owned by this cluster and were followed by another
         cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either FollowerDatabaseDefinition or the result of
          cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.FollowerDatabaseDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.FollowerDatabaseListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1082,22 +1316,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_follower_databases.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/listFollowerDatabases"
@@ -1117,24 +1353,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(follower_database_to_remove, (IO, bytes)):
+        if isinstance(follower_database_to_remove, (IOBase, bytes)):
             _content = follower_database_to_remove
         else:
             _json = self._serialize.body(follower_database_to_remove, "FollowerDatabaseDefinition")
 
         request = build_detach_follower_databases_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1146,26 +1380,34 @@
             template_url=self._detach_follower_databases_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _detach_follower_databases_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/detachFollowerDatabases"
     }
 
     @overload
     async def begin_detach_follower_databases(
@@ -1175,15 +1417,15 @@
         follower_database_to_remove: _models.FollowerDatabaseDefinition,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Detaches all followers of a database owned by this cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param follower_database_to_remove: The follower databases properties to remove. Required.
         :type follower_database_to_remove: ~azure.mgmt.kusto.models.FollowerDatabaseDefinition
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
@@ -1210,15 +1452,15 @@
         follower_database_to_remove: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Detaches all followers of a database owned by this cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param follower_database_to_remove: The follower databases properties to remove. Required.
         :type follower_database_to_remove: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -1243,21 +1485,21 @@
         resource_group_name: str,
         cluster_name: str,
         follower_database_to_remove: Union[_models.FollowerDatabaseDefinition, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Detaches all followers of a database owned by this cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param follower_database_to_remove: The follower databases properties to remove. Is either a
-         model type or a IO type. Required.
+         FollowerDatabaseDefinition type or a IO type. Required.
         :type follower_database_to_remove: ~azure.mgmt.kusto.models.FollowerDatabaseDefinition or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -1269,17 +1511,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._detach_follower_databases_initial(  # type: ignore
@@ -1296,15 +1536,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -1328,62 +1570,68 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[Optional[_models.DiagnoseVirtualNetworkResult]] = kwargs.pop("cls", None)
 
         request = build_diagnose_virtual_network_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._diagnose_virtual_network_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
+        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("DiagnoseVirtualNetworkResult", pipeline_response)
 
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _diagnose_virtual_network_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/diagnoseVirtualNetwork"
     }
 
     @distributed_trace_async
     async def begin_diagnose_virtual_network(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> AsyncLROPoller[_models.DiagnoseVirtualNetworkResult]:
         """Diagnoses network connectivity status for external resources on which the service is dependent
         on.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -1397,17 +1645,15 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.kusto.models.DiagnoseVirtualNetworkResult]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DiagnoseVirtualNetworkResult] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._diagnose_virtual_network_initial(
                 resource_group_name=resource_group_name,
@@ -1447,28 +1693,26 @@
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/diagnoseVirtualNetwork"
     }
 
     @distributed_trace
     def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.Cluster"]:
         """Lists all Kusto clusters within a resource group.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Cluster or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ClusterListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1513,22 +1757,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_by_resource_group.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters"
@@ -1542,17 +1788,15 @@
         :return: An iterator like instance of either Cluster or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ClusterListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1596,22 +1840,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/clusters"}
 
@@ -1623,17 +1869,15 @@
         :return: An iterator like instance of either SkuDescription or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.SkuDescription]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SkuDescriptionList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1677,22 +1921,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_skus.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/skus"}
 
@@ -1703,15 +1949,15 @@
         cluster_name: _models.ClusterCheckNameRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the cluster name is valid and is not already in use.
 
-        :param location: Azure location (region) name. Required.
+        :param location: The name of Azure region. Required.
         :type location: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: ~azure.mgmt.kusto.models.ClusterCheckNameRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1722,15 +1968,15 @@
 
     @overload
     async def check_name_availability(
         self, location: str, cluster_name: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the cluster name is valid and is not already in use.
 
-        :param location: Azure location (region) name. Required.
+        :param location: The name of Azure region. Required.
         :type location: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1741,17 +1987,18 @@
 
     @distributed_trace_async
     async def check_name_availability(
         self, location: str, cluster_name: Union[_models.ClusterCheckNameRequest, IO], **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the cluster name is valid and is not already in use.
 
-        :param location: Azure location (region) name. Required.
+        :param location: The name of Azure region. Required.
         :type location: str
-        :param cluster_name: The name of the cluster. Is either a model type or a IO type. Required.
+        :param cluster_name: The name of the cluster. Is either a ClusterCheckNameRequest type or a IO
+         type. Required.
         :type cluster_name: ~azure.mgmt.kusto.models.ClusterCheckNameRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.CheckNameResult
@@ -1764,24 +2011,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(cluster_name, (IO, bytes)):
+        if isinstance(cluster_name, (IOBase, bytes)):
             _content = cluster_name
         else:
             _json = self._serialize.body(cluster_name, "ClusterCheckNameRequest")
 
         request = build_check_name_availability_request(
             location=location,
             subscription_id=self._config.subscription_id,
@@ -1792,23 +2037,25 @@
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -1819,30 +2066,28 @@
 
     @distributed_trace
     def list_skus_by_resource(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> AsyncIterable["_models.AzureResourceSku"]:
         """Returns the SKUs available for the provided resource.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AzureResourceSku or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.AzureResourceSku]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ListResourceSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1888,22 +2133,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_skus_by_resource.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/skus"
@@ -1911,32 +2158,30 @@
 
     @distributed_trace
     def list_outbound_network_dependencies_endpoints(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> AsyncIterable["_models.OutboundNetworkDependenciesEndpoint"]:
         """Gets the network endpoints of all outbound dependencies of a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either OutboundNetworkDependenciesEndpoint or the result
          of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.OutboundNetworkDependenciesEndpoint]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OutboundNetworkDependenciesEndpointListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1982,22 +2227,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_outbound_network_dependencies_endpoints.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/outboundNetworkDependenciesEndpoints"
@@ -2005,30 +2252,28 @@
 
     @distributed_trace
     def list_language_extensions(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> AsyncIterable["_models.LanguageExtension"]:
         """Returns a list of language extensions that can run within KQL queries.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either LanguageExtension or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.LanguageExtension]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.LanguageExtensionsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -2074,22 +2319,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_language_extensions.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/listLanguageExtensions"
@@ -2109,24 +2356,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(language_extensions_to_add, (IO, bytes)):
+        if isinstance(language_extensions_to_add, (IOBase, bytes)):
             _content = language_extensions_to_add
         else:
             _json = self._serialize.body(language_extensions_to_add, "LanguageExtensionsList")
 
         request = build_add_language_extensions_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -2138,26 +2383,34 @@
             template_url=self._add_language_extensions_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _add_language_extensions_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/addLanguageExtensions"
     }
 
     @overload
     async def begin_add_language_extensions(
@@ -2167,15 +2420,15 @@
         language_extensions_to_add: _models.LanguageExtensionsList,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Add a list of language extensions that can run within KQL queries.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param language_extensions_to_add: The language extensions to add. Required.
         :type language_extensions_to_add: ~azure.mgmt.kusto.models.LanguageExtensionsList
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
@@ -2202,15 +2455,15 @@
         language_extensions_to_add: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Add a list of language extensions that can run within KQL queries.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param language_extensions_to_add: The language extensions to add. Required.
         :type language_extensions_to_add: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -2235,21 +2488,21 @@
         resource_group_name: str,
         cluster_name: str,
         language_extensions_to_add: Union[_models.LanguageExtensionsList, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Add a list of language extensions that can run within KQL queries.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param language_extensions_to_add: The language extensions to add. Is either a model type or a
-         IO type. Required.
+        :param language_extensions_to_add: The language extensions to add. Is either a
+         LanguageExtensionsList type or a IO type. Required.
         :type language_extensions_to_add: ~azure.mgmt.kusto.models.LanguageExtensionsList or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -2261,17 +2514,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._add_language_extensions_initial(  # type: ignore
@@ -2288,15 +2539,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -2324,24 +2577,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(language_extensions_to_remove, (IO, bytes)):
+        if isinstance(language_extensions_to_remove, (IOBase, bytes)):
             _content = language_extensions_to_remove
         else:
             _json = self._serialize.body(language_extensions_to_remove, "LanguageExtensionsList")
 
         request = build_remove_language_extensions_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -2353,26 +2604,34 @@
             template_url=self._remove_language_extensions_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _remove_language_extensions_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/removeLanguageExtensions"
     }
 
     @overload
     async def begin_remove_language_extensions(
@@ -2382,15 +2641,15 @@
         language_extensions_to_remove: _models.LanguageExtensionsList,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Remove a list of language extensions that can run within KQL queries.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param language_extensions_to_remove: The language extensions to remove. Required.
         :type language_extensions_to_remove: ~azure.mgmt.kusto.models.LanguageExtensionsList
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
@@ -2417,15 +2676,15 @@
         language_extensions_to_remove: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Remove a list of language extensions that can run within KQL queries.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param language_extensions_to_remove: The language extensions to remove. Required.
         :type language_extensions_to_remove: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -2450,21 +2709,21 @@
         resource_group_name: str,
         cluster_name: str,
         language_extensions_to_remove: Union[_models.LanguageExtensionsList, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[None]:
         """Remove a list of language extensions that can run within KQL queries.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param language_extensions_to_remove: The language extensions to remove. Is either a model type
-         or a IO type. Required.
+        :param language_extensions_to_remove: The language extensions to remove. Is either a
+         LanguageExtensionsList type or a IO type. Required.
         :type language_extensions_to_remove: ~azure.mgmt.kusto.models.LanguageExtensionsList or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -2476,17 +2735,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._remove_language_extensions_initial(  # type: ignore
@@ -2503,15 +2760,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(AsyncPollingMethod, AsyncARMPolling(lro_delay, **kwargs))
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
                 polling_method=polling_method,
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/models/_kusto_management_client_enums.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/models/_kusto_management_client_enums.py`

 * *Files 2% similar despite different names*

```diff
@@ -37,16 +37,18 @@
     STANDARD_L4_S = "Standard_L4s"
     STANDARD_L8_S = "Standard_L8s"
     STANDARD_L16_S = "Standard_L16s"
     STANDARD_L8_S_V2 = "Standard_L8s_v2"
     STANDARD_L16_S_V2 = "Standard_L16s_v2"
     STANDARD_L8_S_V3 = "Standard_L8s_v3"
     STANDARD_L16_S_V3 = "Standard_L16s_v3"
+    STANDARD_L32_S_V3 = "Standard_L32s_v3"
     STANDARD_L8_AS_V3 = "Standard_L8as_v3"
     STANDARD_L16_AS_V3 = "Standard_L16as_v3"
+    STANDARD_L32_AS_V3 = "Standard_L32as_v3"
     STANDARD_E64_I_V3 = "Standard_E64i_v3"
     STANDARD_E80_IDS_V4 = "Standard_E80ids_v4"
     STANDARD_E2_A_V4 = "Standard_E2a_v4"
     STANDARD_E4_A_V4 = "Standard_E4a_v4"
     STANDARD_E8_A_V4 = "Standard_E8a_v4"
     STANDARD_E16_A_V4 = "Standard_E16a_v4"
     STANDARD_E8_AS_V4_1_TB_PS = "Standard_E8as_v4+1TB_PS"
@@ -281,26 +283,31 @@
 
 
 class LanguageExtensionImageName(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Language extension image name."""
 
     R = "R"
     PYTHON3_6_5 = "Python3_6_5"
-    PYTHON3_9_12 = "Python3_9_12"
-    PYTHON3_9_12_INCLUDE_DEEP_LEARNING = "Python3_9_12IncludeDeepLearning"
     PYTHON3_10_8 = "Python3_10_8"
 
 
 class LanguageExtensionName(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Language extension that can run within KQL query."""
 
     PYTHON = "PYTHON"
     R = "R"
 
 
+class MigrationClusterRole(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """The role of the cluster in the migration process."""
+
+    SOURCE = "Source"
+    DESTINATION = "Destination"
+
+
 class PrincipalsModificationKind(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The principals modification kind of the database."""
 
     UNION = "Union"
     REPLACE = "Replace"
     NONE = "None"
 
@@ -356,14 +363,15 @@
     RUNNING = "Running"
     DELETING = "Deleting"
     DELETED = "Deleted"
     STOPPING = "Stopping"
     STOPPED = "Stopped"
     STARTING = "Starting"
     UPDATING = "Updating"
+    MIGRATED = "Migrated"
 
 
 class Status(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The status of operation."""
 
     SUCCEEDED = "Succeeded"
     CANCELED = "Canceled"
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/models/_models_py3.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/models/_models_py3.py`

 * *Files 2% similar despite different names*

```diff
@@ -31,15 +31,15 @@
     :vartype value: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "str"},
     }
 
-    def __init__(self, *, value: Optional[str] = None, **kwargs):
+    def __init__(self, *, value: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword value: GUID or valid URL representing an accepted audience.
         :paramtype value: str
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -67,24 +67,25 @@
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.name = None
         self.type = None
 
 
 class ProxyResource(Resource):
-    """The resource model definition for a Azure Resource Manager proxy resource. It will not have tags and a location.
+    """The resource model definition for a Azure Resource Manager proxy resource. It will not have
+    tags and a location.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: Fully qualified resource ID for the resource. Ex -
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
@@ -102,15 +103,15 @@
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
 
 
 class AttachedDatabaseConfiguration(ProxyResource):  # pylint: disable=too-many-instance-attributes
     """Class representing an attached database configuration.
 
@@ -185,16 +186,16 @@
         location: Optional[str] = None,
         database_name: Optional[str] = None,
         cluster_resource_id: Optional[str] = None,
         default_principals_modification_kind: Optional[Union[str, "_models.DefaultPrincipalsModificationKind"]] = None,
         table_level_sharing_properties: Optional["_models.TableLevelSharingProperties"] = None,
         database_name_override: Optional[str] = None,
         database_name_prefix: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword location: Resource location.
         :paramtype location: str
         :keyword database_name: The name of the database which you would like to attach, use * if you
          want to follow all current and future databases.
         :paramtype database_name: str
         :keyword cluster_resource_id: The resource id of the cluster where the databases you would like
@@ -233,15 +234,15 @@
     :vartype value: list[~azure.mgmt.kusto.models.AttachedDatabaseConfiguration]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[AttachedDatabaseConfiguration]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.AttachedDatabaseConfiguration"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.AttachedDatabaseConfiguration"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of attached database configurations.
         :paramtype value: list[~azure.mgmt.kusto.models.AttachedDatabaseConfiguration]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -269,15 +270,15 @@
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
     type = "Microsoft.Kusto/clusters/attachedDatabaseConfigurations"
 
-    def __init__(self, *, name: str, **kwargs):
+    def __init__(self, *, name: str, **kwargs: Any) -> None:
         """
         :keyword name: Attached database resource name. Required.
         :paramtype name: str
         """
         super().__init__(**kwargs)
         self.name = name
 
@@ -308,16 +309,22 @@
         "scale_type": {"key": "scaleType", "type": "str"},
         "minimum": {"key": "minimum", "type": "int"},
         "maximum": {"key": "maximum", "type": "int"},
         "default": {"key": "default", "type": "int"},
     }
 
     def __init__(
-        self, *, scale_type: Union[str, "_models.AzureScaleType"], minimum: int, maximum: int, default: int, **kwargs
-    ):
+        self,
+        *,
+        scale_type: Union[str, "_models.AzureScaleType"],
+        minimum: int,
+        maximum: int,
+        default: int,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword scale_type: Scale type. Required. Known values are: "automatic", "manual", and "none".
         :paramtype scale_type: str or ~azure.mgmt.kusto.models.AzureScaleType
         :keyword minimum: Minimum allowed capacity. Required.
         :paramtype minimum: int
         :keyword maximum: Maximum allowed capacity. Required.
         :paramtype maximum: int
@@ -350,16 +357,16 @@
 
     def __init__(
         self,
         *,
         resource_type: Optional[str] = None,
         sku: Optional["_models.AzureSku"] = None,
         capacity: Optional["_models.AzureCapacity"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword resource_type: Resource Namespace and Type.
         :paramtype resource_type: str
         :keyword sku: The SKU details.
         :paramtype sku: ~azure.mgmt.kusto.models.AzureSku
         :keyword capacity: The number of instances of the cluster.
         :paramtype capacity: ~azure.mgmt.kusto.models.AzureCapacity
@@ -376,27 +383,28 @@
     All required parameters must be populated in order to send to Azure.
 
     :ivar name: SKU name. Required. Known values are: "Dev(No SLA)_Standard_D11_v2", "Dev(No
      SLA)_Standard_E2a_v4", "Standard_D11_v2", "Standard_D12_v2", "Standard_D13_v2",
      "Standard_D14_v2", "Standard_D32d_v4", "Standard_D16d_v5", "Standard_D32d_v5",
      "Standard_DS13_v2+1TB_PS", "Standard_DS13_v2+2TB_PS", "Standard_DS14_v2+3TB_PS",
      "Standard_DS14_v2+4TB_PS", "Standard_L4s", "Standard_L8s", "Standard_L16s", "Standard_L8s_v2",
-     "Standard_L16s_v2", "Standard_L8s_v3", "Standard_L16s_v3", "Standard_L8as_v3",
-     "Standard_L16as_v3", "Standard_E64i_v3", "Standard_E80ids_v4", "Standard_E2a_v4",
-     "Standard_E4a_v4", "Standard_E8a_v4", "Standard_E16a_v4", "Standard_E8as_v4+1TB_PS",
-     "Standard_E8as_v4+2TB_PS", "Standard_E16as_v4+3TB_PS", "Standard_E16as_v4+4TB_PS",
-     "Standard_E8as_v5+1TB_PS", "Standard_E8as_v5+2TB_PS", "Standard_E16as_v5+3TB_PS",
-     "Standard_E16as_v5+4TB_PS", "Standard_E2ads_v5", "Standard_E4ads_v5", "Standard_E8ads_v5",
-     "Standard_E16ads_v5", "Standard_EC8as_v5+1TB_PS", "Standard_EC8as_v5+2TB_PS",
-     "Standard_EC16as_v5+3TB_PS", "Standard_EC16as_v5+4TB_PS", "Standard_EC8ads_v5",
-     "Standard_EC16ads_v5", "Standard_E8s_v4+1TB_PS", "Standard_E8s_v4+2TB_PS",
-     "Standard_E16s_v4+3TB_PS", "Standard_E16s_v4+4TB_PS", "Standard_E8s_v5+1TB_PS",
-     "Standard_E8s_v5+2TB_PS", "Standard_E16s_v5+3TB_PS", "Standard_E16s_v5+4TB_PS",
-     "Standard_E2d_v4", "Standard_E4d_v4", "Standard_E8d_v4", "Standard_E16d_v4", "Standard_E2d_v5",
-     "Standard_E4d_v5", "Standard_E8d_v5", and "Standard_E16d_v5".
+     "Standard_L16s_v2", "Standard_L8s_v3", "Standard_L16s_v3", "Standard_L32s_v3",
+     "Standard_L8as_v3", "Standard_L16as_v3", "Standard_L32as_v3", "Standard_E64i_v3",
+     "Standard_E80ids_v4", "Standard_E2a_v4", "Standard_E4a_v4", "Standard_E8a_v4",
+     "Standard_E16a_v4", "Standard_E8as_v4+1TB_PS", "Standard_E8as_v4+2TB_PS",
+     "Standard_E16as_v4+3TB_PS", "Standard_E16as_v4+4TB_PS", "Standard_E8as_v5+1TB_PS",
+     "Standard_E8as_v5+2TB_PS", "Standard_E16as_v5+3TB_PS", "Standard_E16as_v5+4TB_PS",
+     "Standard_E2ads_v5", "Standard_E4ads_v5", "Standard_E8ads_v5", "Standard_E16ads_v5",
+     "Standard_EC8as_v5+1TB_PS", "Standard_EC8as_v5+2TB_PS", "Standard_EC16as_v5+3TB_PS",
+     "Standard_EC16as_v5+4TB_PS", "Standard_EC8ads_v5", "Standard_EC16ads_v5",
+     "Standard_E8s_v4+1TB_PS", "Standard_E8s_v4+2TB_PS", "Standard_E16s_v4+3TB_PS",
+     "Standard_E16s_v4+4TB_PS", "Standard_E8s_v5+1TB_PS", "Standard_E8s_v5+2TB_PS",
+     "Standard_E16s_v5+3TB_PS", "Standard_E16s_v5+4TB_PS", "Standard_E2d_v4", "Standard_E4d_v4",
+     "Standard_E8d_v4", "Standard_E16d_v4", "Standard_E2d_v5", "Standard_E4d_v5", "Standard_E8d_v5",
+     and "Standard_E16d_v5".
     :vartype name: str or ~azure.mgmt.kusto.models.AzureSkuName
     :ivar capacity: The number of instances of the cluster.
     :vartype capacity: int
     :ivar tier: SKU tier. Required. Known values are: "Basic" and "Standard".
     :vartype tier: str or ~azure.mgmt.kusto.models.AzureSkuTier
     """
 
@@ -413,35 +421,36 @@
 
     def __init__(
         self,
         *,
         name: Union[str, "_models.AzureSkuName"],
         tier: Union[str, "_models.AzureSkuTier"],
         capacity: Optional[int] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name: SKU name. Required. Known values are: "Dev(No SLA)_Standard_D11_v2", "Dev(No
          SLA)_Standard_E2a_v4", "Standard_D11_v2", "Standard_D12_v2", "Standard_D13_v2",
          "Standard_D14_v2", "Standard_D32d_v4", "Standard_D16d_v5", "Standard_D32d_v5",
          "Standard_DS13_v2+1TB_PS", "Standard_DS13_v2+2TB_PS", "Standard_DS14_v2+3TB_PS",
          "Standard_DS14_v2+4TB_PS", "Standard_L4s", "Standard_L8s", "Standard_L16s", "Standard_L8s_v2",
-         "Standard_L16s_v2", "Standard_L8s_v3", "Standard_L16s_v3", "Standard_L8as_v3",
-         "Standard_L16as_v3", "Standard_E64i_v3", "Standard_E80ids_v4", "Standard_E2a_v4",
-         "Standard_E4a_v4", "Standard_E8a_v4", "Standard_E16a_v4", "Standard_E8as_v4+1TB_PS",
-         "Standard_E8as_v4+2TB_PS", "Standard_E16as_v4+3TB_PS", "Standard_E16as_v4+4TB_PS",
-         "Standard_E8as_v5+1TB_PS", "Standard_E8as_v5+2TB_PS", "Standard_E16as_v5+3TB_PS",
-         "Standard_E16as_v5+4TB_PS", "Standard_E2ads_v5", "Standard_E4ads_v5", "Standard_E8ads_v5",
-         "Standard_E16ads_v5", "Standard_EC8as_v5+1TB_PS", "Standard_EC8as_v5+2TB_PS",
-         "Standard_EC16as_v5+3TB_PS", "Standard_EC16as_v5+4TB_PS", "Standard_EC8ads_v5",
-         "Standard_EC16ads_v5", "Standard_E8s_v4+1TB_PS", "Standard_E8s_v4+2TB_PS",
-         "Standard_E16s_v4+3TB_PS", "Standard_E16s_v4+4TB_PS", "Standard_E8s_v5+1TB_PS",
-         "Standard_E8s_v5+2TB_PS", "Standard_E16s_v5+3TB_PS", "Standard_E16s_v5+4TB_PS",
-         "Standard_E2d_v4", "Standard_E4d_v4", "Standard_E8d_v4", "Standard_E16d_v4", "Standard_E2d_v5",
-         "Standard_E4d_v5", "Standard_E8d_v5", and "Standard_E16d_v5".
+         "Standard_L16s_v2", "Standard_L8s_v3", "Standard_L16s_v3", "Standard_L32s_v3",
+         "Standard_L8as_v3", "Standard_L16as_v3", "Standard_L32as_v3", "Standard_E64i_v3",
+         "Standard_E80ids_v4", "Standard_E2a_v4", "Standard_E4a_v4", "Standard_E8a_v4",
+         "Standard_E16a_v4", "Standard_E8as_v4+1TB_PS", "Standard_E8as_v4+2TB_PS",
+         "Standard_E16as_v4+3TB_PS", "Standard_E16as_v4+4TB_PS", "Standard_E8as_v5+1TB_PS",
+         "Standard_E8as_v5+2TB_PS", "Standard_E16as_v5+3TB_PS", "Standard_E16as_v5+4TB_PS",
+         "Standard_E2ads_v5", "Standard_E4ads_v5", "Standard_E8ads_v5", "Standard_E16ads_v5",
+         "Standard_EC8as_v5+1TB_PS", "Standard_EC8as_v5+2TB_PS", "Standard_EC16as_v5+3TB_PS",
+         "Standard_EC16as_v5+4TB_PS", "Standard_EC8ads_v5", "Standard_EC16ads_v5",
+         "Standard_E8s_v4+1TB_PS", "Standard_E8s_v4+2TB_PS", "Standard_E16s_v4+3TB_PS",
+         "Standard_E16s_v4+4TB_PS", "Standard_E8s_v5+1TB_PS", "Standard_E8s_v5+2TB_PS",
+         "Standard_E16s_v5+3TB_PS", "Standard_E16s_v5+4TB_PS", "Standard_E2d_v4", "Standard_E4d_v4",
+         "Standard_E8d_v4", "Standard_E16d_v4", "Standard_E2d_v5", "Standard_E4d_v5", "Standard_E8d_v5",
+         and "Standard_E16d_v5".
         :paramtype name: str or ~azure.mgmt.kusto.models.AzureSkuName
         :keyword capacity: The number of instances of the cluster.
         :paramtype capacity: int
         :keyword tier: SKU tier. Required. Known values are: "Basic" and "Standard".
         :paramtype tier: str or ~azure.mgmt.kusto.models.AzureSkuTier
         """
         super().__init__(**kwargs)
@@ -469,15 +478,15 @@
     }
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, *, name: str, type: Union[str, "_models.Type"], **kwargs):
+    def __init__(self, *, name: str, type: Union[str, "_models.Type"], **kwargs: Any) -> None:
         """
         :keyword name: Resource name. Required.
         :paramtype name: str
         :keyword type: The type of resource, for instance Microsoft.Kusto/clusters/databases. Required.
          Known values are: "Microsoft.Kusto/clusters/databases" and
          "Microsoft.Kusto/clusters/attachedDatabaseConfigurations".
         :paramtype type: str or ~azure.mgmt.kusto.models.Type
@@ -512,16 +521,16 @@
     def __init__(
         self,
         *,
         name_available: Optional[bool] = None,
         name: Optional[str] = None,
         message: Optional[str] = None,
         reason: Optional[Union[str, "_models.Reason"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name_available: Specifies a Boolean value that indicates if the name is available.
         :paramtype name_available: bool
         :keyword name: The name that was checked.
         :paramtype name: str
         :keyword message: Message indicating an unavailable name due to a conflict, or a description of
          the naming rules that are violated.
@@ -533,68 +542,17 @@
         super().__init__(**kwargs)
         self.name_available = name_available
         self.name = name
         self.message = message
         self.reason = reason
 
 
-class CloudErrorBody(_serialization.Model):
-    """An error response from Kusto.
-
-    :ivar code: An identifier for the error. Codes are invariant and are intended to be consumed
-     programmatically.
-    :vartype code: str
-    :ivar message: A message describing the error, intended to be suitable for displaying in a user
-     interface.
-    :vartype message: str
-    :ivar target: The target of the particular error. For example, the name of the property in
-     error.
-    :vartype target: str
-    :ivar details: A list of additional details about the error.
-    :vartype details: list[~azure.mgmt.kusto.models.CloudErrorBody]
-    """
-
-    _attribute_map = {
-        "code": {"key": "code", "type": "str"},
-        "message": {"key": "message", "type": "str"},
-        "target": {"key": "target", "type": "str"},
-        "details": {"key": "details", "type": "[CloudErrorBody]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        code: Optional[str] = None,
-        message: Optional[str] = None,
-        target: Optional[str] = None,
-        details: Optional[List["_models.CloudErrorBody"]] = None,
-        **kwargs
-    ):
-        """
-        :keyword code: An identifier for the error. Codes are invariant and are intended to be consumed
-         programmatically.
-        :paramtype code: str
-        :keyword message: A message describing the error, intended to be suitable for displaying in a
-         user interface.
-        :paramtype message: str
-        :keyword target: The target of the particular error. For example, the name of the property in
-         error.
-        :paramtype target: str
-        :keyword details: A list of additional details about the error.
-        :paramtype details: list[~azure.mgmt.kusto.models.CloudErrorBody]
-        """
-        super().__init__(**kwargs)
-        self.code = code
-        self.message = message
-        self.target = target
-        self.details = details
-
-
 class TrackedResource(Resource):
-    """The resource model definition for an Azure Resource Manager tracked top level resource which has 'tags' and a 'location'.
+    """The resource model definition for an Azure Resource Manager tracked top level resource which
+    has 'tags' and a 'location'.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar id: Fully qualified resource ID for the resource. Ex -
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
@@ -621,15 +579,15 @@
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
     }
 
-    def __init__(self, *, location: str, tags: Optional[Dict[str, str]] = None, **kwargs):
+    def __init__(self, *, location: str, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         """
         super().__init__(**kwargs)
@@ -663,15 +621,15 @@
     :ivar zones: The availability zones of the cluster.
     :vartype zones: list[str]
     :ivar identity: The identity of the cluster, if configured.
     :vartype identity: ~azure.mgmt.kusto.models.Identity
     :ivar etag: A unique read-only string that changes whenever the resource is updated.
     :vartype etag: str
     :ivar state: The state of the resource. Known values are: "Creating", "Unavailable", "Running",
-     "Deleting", "Deleted", "Stopping", "Stopped", "Starting", and "Updating".
+     "Deleting", "Deleted", "Stopping", "Stopped", "Starting", "Updating", and "Migrated".
     :vartype state: str or ~azure.mgmt.kusto.models.State
     :ivar provisioning_state: The provisioned state of the resource. Known values are: "Running",
      "Creating", "Deleting", "Succeeded", "Failed", "Moving", and "Canceled".
     :vartype provisioning_state: str or ~azure.mgmt.kusto.models.ProvisioningState
     :ivar uri: The cluster URI.
     :vartype uri: str
     :ivar data_ingestion_uri: The cluster data ingestion URI.
@@ -723,14 +681,17 @@
     :ivar public_ip_type: Indicates what public IP type to create - IPv4 (default), or DualStack
      (both IPv4 and IPv6). Known values are: "IPv4" and "DualStack".
     :vartype public_ip_type: str or ~azure.mgmt.kusto.models.PublicIPType
     :ivar virtual_cluster_graduation_properties: Virtual Cluster graduation properties.
     :vartype virtual_cluster_graduation_properties: str
     :ivar private_endpoint_connections: A list of private endpoint connections.
     :vartype private_endpoint_connections: list[~azure.mgmt.kusto.models.PrivateEndpointConnection]
+    :ivar migration_cluster: Properties of the peer cluster involved in a migration to/from this
+     cluster.
+    :vartype migration_cluster: ~azure.mgmt.kusto.models.MigrationClusterProperties
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "location": {"required": True},
@@ -739,14 +700,15 @@
         "etag": {"readonly": True},
         "state": {"readonly": True},
         "provisioning_state": {"readonly": True},
         "uri": {"readonly": True},
         "data_ingestion_uri": {"readonly": True},
         "state_reason": {"readonly": True},
         "private_endpoint_connections": {"readonly": True},
+        "migration_cluster": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "tags": {"key": "tags", "type": "{str}"},
@@ -785,14 +747,15 @@
             "key": "properties.virtualClusterGraduationProperties",
             "type": "str",
         },
         "private_endpoint_connections": {
             "key": "properties.privateEndpointConnections",
             "type": "[PrivateEndpointConnection]",
         },
+        "migration_cluster": {"key": "properties.migrationCluster", "type": "MigrationClusterProperties"},
     }
 
     def __init__(  # pylint: disable=too-many-locals
         self,
         *,
         location: str,
         sku: "_models.AzureSku",
@@ -813,16 +776,16 @@
         engine_type: Union[str, "_models.EngineType"] = "V3",
         accepted_audiences: Optional[List["_models.AcceptedAudiences"]] = None,
         enable_auto_stop: bool = True,
         restrict_outbound_network_access: Union[str, "_models.ClusterNetworkAccessFlag"] = "Disabled",
         allowed_fqdn_list: Optional[List[str]] = None,
         public_ip_type: Union[str, "_models.PublicIPType"] = "IPv4",
         virtual_cluster_graduation_properties: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         :keyword sku: The SKU of the cluster. Required.
         :paramtype sku: ~azure.mgmt.kusto.models.AzureSku
@@ -905,14 +868,15 @@
         self.accepted_audiences = accepted_audiences
         self.enable_auto_stop = enable_auto_stop
         self.restrict_outbound_network_access = restrict_outbound_network_access
         self.allowed_fqdn_list = allowed_fqdn_list
         self.public_ip_type = public_ip_type
         self.virtual_cluster_graduation_properties = virtual_cluster_graduation_properties
         self.private_endpoint_connections = None
+        self.migration_cluster = None
 
 
 class ClusterCheckNameRequest(_serialization.Model):
     """The result returned from a cluster check name availability request.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
@@ -933,15 +897,15 @@
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
     type = "Microsoft.Kusto/clusters"
 
-    def __init__(self, *, name: str, **kwargs):
+    def __init__(self, *, name: str, **kwargs: Any) -> None:
         """
         :keyword name: Cluster name. Required.
         :paramtype name: str
         """
         super().__init__(**kwargs)
         self.name = name
 
@@ -953,23 +917,49 @@
     :vartype value: list[~azure.mgmt.kusto.models.Cluster]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Cluster]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.Cluster"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.Cluster"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of Kusto clusters.
         :paramtype value: list[~azure.mgmt.kusto.models.Cluster]
         """
         super().__init__(**kwargs)
         self.value = value
 
 
+class ClusterMigrateRequest(_serialization.Model):
+    """A cluster migrate request.
+
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar cluster_resource_id: Resource ID of the destination cluster or kusto pool. Required.
+    :vartype cluster_resource_id: str
+    """
+
+    _validation = {
+        "cluster_resource_id": {"required": True},
+    }
+
+    _attribute_map = {
+        "cluster_resource_id": {"key": "clusterResourceId", "type": "str"},
+    }
+
+    def __init__(self, *, cluster_resource_id: str, **kwargs: Any) -> None:
+        """
+        :keyword cluster_resource_id: Resource ID of the destination cluster or kusto pool. Required.
+        :paramtype cluster_resource_id: str
+        """
+        super().__init__(**kwargs)
+        self.cluster_resource_id = cluster_resource_id
+
+
 class ClusterPrincipalAssignment(ProxyResource):  # pylint: disable=too-many-instance-attributes
     """Class representing a cluster principal assignment.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: Fully qualified resource ID for the resource. Ex -
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
@@ -1027,16 +1017,16 @@
     def __init__(
         self,
         *,
         principal_id: Optional[str] = None,
         role: Optional[Union[str, "_models.ClusterPrincipalRole"]] = None,
         tenant_id: Optional[str] = None,
         principal_type: Optional[Union[str, "_models.PrincipalType"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword principal_id: The principal ID assigned to the cluster principal. It can be a user
          email, application ID, or security group name.
         :paramtype principal_id: str
         :keyword role: Cluster principal role. Known values are: "AllDatabasesAdmin" and
          "AllDatabasesViewer".
         :paramtype role: str or ~azure.mgmt.kusto.models.ClusterPrincipalRole
@@ -1078,15 +1068,15 @@
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
     type = "Microsoft.Kusto/clusters/principalAssignments"
 
-    def __init__(self, *, name: str, **kwargs):
+    def __init__(self, *, name: str, **kwargs: Any) -> None:
         """
         :keyword name: Principal Assignment resource name. Required.
         :paramtype name: str
         """
         super().__init__(**kwargs)
         self.name = name
 
@@ -1098,15 +1088,15 @@
     :vartype value: list[~azure.mgmt.kusto.models.ClusterPrincipalAssignment]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[ClusterPrincipalAssignment]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.ClusterPrincipalAssignment"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.ClusterPrincipalAssignment"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of Kusto cluster principal assignments.
         :paramtype value: list[~azure.mgmt.kusto.models.ClusterPrincipalAssignment]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -1129,15 +1119,15 @@
     :ivar location: Resource location.
     :vartype location: str
     :ivar sku: The SKU of the cluster.
     :vartype sku: ~azure.mgmt.kusto.models.AzureSku
     :ivar identity: The identity of the cluster, if configured.
     :vartype identity: ~azure.mgmt.kusto.models.Identity
     :ivar state: The state of the resource. Known values are: "Creating", "Unavailable", "Running",
-     "Deleting", "Deleted", "Stopping", "Stopped", "Starting", and "Updating".
+     "Deleting", "Deleted", "Stopping", "Stopped", "Starting", "Updating", and "Migrated".
     :vartype state: str or ~azure.mgmt.kusto.models.State
     :ivar provisioning_state: The provisioned state of the resource. Known values are: "Running",
      "Creating", "Deleting", "Succeeded", "Failed", "Moving", and "Canceled".
     :vartype provisioning_state: str or ~azure.mgmt.kusto.models.ProvisioningState
     :ivar uri: The cluster URI.
     :vartype uri: str
     :ivar data_ingestion_uri: The cluster data ingestion URI.
@@ -1189,26 +1179,30 @@
     :ivar public_ip_type: Indicates what public IP type to create - IPv4 (default), or DualStack
      (both IPv4 and IPv6). Known values are: "IPv4" and "DualStack".
     :vartype public_ip_type: str or ~azure.mgmt.kusto.models.PublicIPType
     :ivar virtual_cluster_graduation_properties: Virtual Cluster graduation properties.
     :vartype virtual_cluster_graduation_properties: str
     :ivar private_endpoint_connections: A list of private endpoint connections.
     :vartype private_endpoint_connections: list[~azure.mgmt.kusto.models.PrivateEndpointConnection]
+    :ivar migration_cluster: Properties of the peer cluster involved in a migration to/from this
+     cluster.
+    :vartype migration_cluster: ~azure.mgmt.kusto.models.MigrationClusterProperties
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "state": {"readonly": True},
         "provisioning_state": {"readonly": True},
         "uri": {"readonly": True},
         "data_ingestion_uri": {"readonly": True},
         "state_reason": {"readonly": True},
         "private_endpoint_connections": {"readonly": True},
+        "migration_cluster": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "tags": {"key": "tags", "type": "{str}"},
@@ -1244,14 +1238,15 @@
             "key": "properties.virtualClusterGraduationProperties",
             "type": "str",
         },
         "private_endpoint_connections": {
             "key": "properties.privateEndpointConnections",
             "type": "[PrivateEndpointConnection]",
         },
+        "migration_cluster": {"key": "properties.migrationCluster", "type": "MigrationClusterProperties"},
     }
 
     def __init__(  # pylint: disable=too-many-locals
         self,
         *,
         tags: Optional[Dict[str, str]] = None,
         location: Optional[str] = None,
@@ -1271,16 +1266,16 @@
         engine_type: Union[str, "_models.EngineType"] = "V3",
         accepted_audiences: Optional[List["_models.AcceptedAudiences"]] = None,
         enable_auto_stop: bool = True,
         restrict_outbound_network_access: Union[str, "_models.ClusterNetworkAccessFlag"] = "Disabled",
         allowed_fqdn_list: Optional[List[str]] = None,
         public_ip_type: Union[str, "_models.PublicIPType"] = "IPv4",
         virtual_cluster_graduation_properties: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: Resource location.
         :paramtype location: str
         :keyword sku: The SKU of the cluster.
         :paramtype sku: ~azure.mgmt.kusto.models.AzureSku
@@ -1360,14 +1355,15 @@
         self.accepted_audiences = accepted_audiences
         self.enable_auto_stop = enable_auto_stop
         self.restrict_outbound_network_access = restrict_outbound_network_access
         self.allowed_fqdn_list = allowed_fqdn_list
         self.public_ip_type = public_ip_type
         self.virtual_cluster_graduation_properties = virtual_cluster_graduation_properties
         self.private_endpoint_connections = None
+        self.migration_cluster = None
 
 
 class ComponentsSgqdofSchemasIdentityPropertiesUserassignedidentitiesAdditionalproperties(_serialization.Model):
     """ComponentsSgqdofSchemasIdentityPropertiesUserassignedidentitiesAdditionalproperties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
@@ -1383,15 +1379,15 @@
     }
 
     _attribute_map = {
         "principal_id": {"key": "principalId", "type": "str"},
         "client_id": {"key": "clientId", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.principal_id = None
         self.client_id = None
 
 
 class DataConnection(ProxyResource):
@@ -1439,15 +1435,15 @@
             "CosmosDb": "CosmosDbDataConnection",
             "EventGrid": "EventGridDataConnection",
             "EventHub": "EventHubDataConnection",
             "IotHub": "IotHubDataConnection",
         }
     }
 
-    def __init__(self, *, location: Optional[str] = None, **kwargs):
+    def __init__(self, *, location: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword location: Resource location.
         :paramtype location: str
         """
         super().__init__(**kwargs)
         self.location = location
         self.kind: Optional[str] = None
@@ -1532,16 +1528,16 @@
         table_name: Optional[str] = None,
         mapping_rule_name: Optional[str] = None,
         managed_identity_resource_id: Optional[str] = None,
         cosmos_db_account_resource_id: Optional[str] = None,
         cosmos_db_database: Optional[str] = None,
         cosmos_db_container: Optional[str] = None,
         retrieval_start_date: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword location: Resource location.
         :paramtype location: str
         :keyword table_name: The case-sensitive name of the existing target table in your cluster.
          Retrieved data is ingested into this table.
         :paramtype table_name: str
         :keyword mapping_rule_name: The name of an existing mapping rule to use when ingesting the
@@ -1612,41 +1608,109 @@
         "type": {"key": "type", "type": "str"},
         "location": {"key": "location", "type": "str"},
         "kind": {"key": "kind", "type": "str"},
     }
 
     _subtype_map = {"kind": {"ReadOnlyFollowing": "ReadOnlyFollowingDatabase", "ReadWrite": "ReadWriteDatabase"}}
 
-    def __init__(self, *, location: Optional[str] = None, **kwargs):
+    def __init__(self, *, location: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword location: Resource location.
         :paramtype location: str
         """
         super().__init__(**kwargs)
         self.location = location
         self.kind: Optional[str] = None
 
 
+class DatabaseInviteFollowerRequest(_serialization.Model):
+    """The request to invite a follower to a database.
+
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar invitee_email: The email of the invited user for which the follower invitation is
+     generated. Required.
+    :vartype invitee_email: str
+    :ivar table_level_sharing_properties: Table level sharing specifications.
+    :vartype table_level_sharing_properties: ~azure.mgmt.kusto.models.TableLevelSharingProperties
+    """
+
+    _validation = {
+        "invitee_email": {"required": True},
+    }
+
+    _attribute_map = {
+        "invitee_email": {"key": "inviteeEmail", "type": "str"},
+        "table_level_sharing_properties": {"key": "tableLevelSharingProperties", "type": "TableLevelSharingProperties"},
+    }
+
+    def __init__(
+        self,
+        *,
+        invitee_email: str,
+        table_level_sharing_properties: Optional["_models.TableLevelSharingProperties"] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword invitee_email: The email of the invited user for which the follower invitation is
+         generated. Required.
+        :paramtype invitee_email: str
+        :keyword table_level_sharing_properties: Table level sharing specifications.
+        :paramtype table_level_sharing_properties: ~azure.mgmt.kusto.models.TableLevelSharingProperties
+        """
+        super().__init__(**kwargs)
+        self.invitee_email = invitee_email
+        self.table_level_sharing_properties = table_level_sharing_properties
+
+
+class DatabaseInviteFollowerResult(_serialization.Model):
+    """The result returned from a follower invitation generation request.
+
+    :ivar generated_invitation: The generated invitation token.
+    :vartype generated_invitation: str
+    """
+
+    _attribute_map = {
+        "generated_invitation": {"key": "generatedInvitation", "type": "str"},
+    }
+
+    def __init__(self, *, generated_invitation: Optional[str] = None, **kwargs: Any) -> None:
+        """
+        :keyword generated_invitation: The generated invitation token.
+        :paramtype generated_invitation: str
+        """
+        super().__init__(**kwargs)
+        self.generated_invitation = generated_invitation
+
+
 class DatabaseListResult(_serialization.Model):
     """The list Kusto databases operation response.
 
+    :ivar next_link: Link to the next page of results.
+    :vartype next_link: str
     :ivar value: The list of Kusto databases.
     :vartype value: list[~azure.mgmt.kusto.models.Database]
     """
 
     _attribute_map = {
+        "next_link": {"key": "nextLink", "type": "str"},
         "value": {"key": "value", "type": "[Database]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.Database"]] = None, **kwargs):
+    def __init__(
+        self, *, next_link: Optional[str] = None, value: Optional[List["_models.Database"]] = None, **kwargs: Any
+    ) -> None:
         """
+        :keyword next_link: Link to the next page of results.
+        :paramtype next_link: str
         :keyword value: The list of Kusto databases.
         :paramtype value: list[~azure.mgmt.kusto.models.Database]
         """
         super().__init__(**kwargs)
+        self.next_link = next_link
         self.value = value
 
 
 class DatabasePrincipal(_serialization.Model):
     """A class representing database principal entity.
 
     Variables are only populated by the server, and will be ignored when sending a request.
@@ -1692,16 +1756,16 @@
         *,
         role: Union[str, "_models.DatabasePrincipalRole"],
         name: str,
         type: Union[str, "_models.DatabasePrincipalType"],
         fqn: Optional[str] = None,
         email: Optional[str] = None,
         app_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword role: Database principal role. Required. Known values are: "Admin", "Ingestor",
          "Monitor", "User", "UnrestrictedViewer", and "Viewer".
         :paramtype role: str or ~azure.mgmt.kusto.models.DatabasePrincipalRole
         :keyword name: Database principal name. Required.
         :paramtype name: str
         :keyword type: Database principal type. Required. Known values are: "App", "Group", and "User".
@@ -1784,16 +1848,16 @@
     def __init__(
         self,
         *,
         principal_id: Optional[str] = None,
         role: Optional[Union[str, "_models.DatabasePrincipalRole"]] = None,
         tenant_id: Optional[str] = None,
         principal_type: Optional[Union[str, "_models.PrincipalType"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword principal_id: The principal ID assigned to the database principal. It can be a user
          email, application ID, or security group name.
         :paramtype principal_id: str
         :keyword role: Database principal role. Known values are: "Admin", "Ingestor", "Monitor",
          "User", "UnrestrictedViewer", and "Viewer".
         :paramtype role: str or ~azure.mgmt.kusto.models.DatabasePrincipalRole
@@ -1835,15 +1899,15 @@
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
     type = "Microsoft.Kusto/clusters/databases/principalAssignments"
 
-    def __init__(self, *, name: str, **kwargs):
+    def __init__(self, *, name: str, **kwargs: Any) -> None:
         """
         :keyword name: Principal Assignment resource name. Required.
         :paramtype name: str
         """
         super().__init__(**kwargs)
         self.name = name
 
@@ -1855,15 +1919,15 @@
     :vartype value: list[~azure.mgmt.kusto.models.DatabasePrincipalAssignment]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DatabasePrincipalAssignment]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.DatabasePrincipalAssignment"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.DatabasePrincipalAssignment"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of Kusto database principal assignments.
         :paramtype value: list[~azure.mgmt.kusto.models.DatabasePrincipalAssignment]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -1875,15 +1939,15 @@
     :vartype value: list[~azure.mgmt.kusto.models.DatabasePrincipal]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DatabasePrincipal]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.DatabasePrincipal"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.DatabasePrincipal"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of Kusto database principals.
         :paramtype value: list[~azure.mgmt.kusto.models.DatabasePrincipal]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -1895,15 +1959,15 @@
     :vartype value: list[~azure.mgmt.kusto.models.DatabasePrincipal]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DatabasePrincipal]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.DatabasePrincipal"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.DatabasePrincipal"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of Kusto database principals.
         :paramtype value: list[~azure.mgmt.kusto.models.DatabasePrincipal]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -1915,15 +1979,15 @@
     :vartype size: float
     """
 
     _attribute_map = {
         "size": {"key": "size", "type": "float"},
     }
 
-    def __init__(self, *, size: Optional[float] = None, **kwargs):
+    def __init__(self, *, size: Optional[float] = None, **kwargs: Any) -> None:
         """
         :keyword size: The database size - the total size of compressed data and index in bytes.
         :paramtype size: float
         """
         super().__init__(**kwargs)
         self.size = size
 
@@ -1950,15 +2014,15 @@
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
     type = "Microsoft.Kusto/clusters/databases/dataConnections"
 
-    def __init__(self, *, name: str, **kwargs):
+    def __init__(self, *, name: str, **kwargs: Any) -> None:
         """
         :keyword name: Data Connection name. Required.
         :paramtype name: str
         """
         super().__init__(**kwargs)
         self.name = name
 
@@ -1970,15 +2034,15 @@
     :vartype value: list[~azure.mgmt.kusto.models.DataConnection]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DataConnection]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.DataConnection"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.DataConnection"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of Kusto data connections.
         :paramtype value: list[~azure.mgmt.kusto.models.DataConnection]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -1998,16 +2062,16 @@
     }
 
     def __init__(
         self,
         *,
         data_connection_name: Optional[str] = None,
         properties: Optional["_models.DataConnection"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword data_connection_name: The name of the data connection.
         :paramtype data_connection_name: str
         :keyword properties: The data connection properties to validate.
         :paramtype properties: ~azure.mgmt.kusto.models.DataConnection
         """
         super().__init__(**kwargs)
@@ -2022,15 +2086,17 @@
     :vartype value: list[~azure.mgmt.kusto.models.DataConnectionValidationResult]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[DataConnectionValidationResult]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.DataConnectionValidationResult"]] = None, **kwargs):
+    def __init__(
+        self, *, value: Optional[List["_models.DataConnectionValidationResult"]] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword value: The list of Kusto data connection validation errors.
         :paramtype value: list[~azure.mgmt.kusto.models.DataConnectionValidationResult]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -2042,15 +2108,15 @@
     :vartype error_message: str
     """
 
     _attribute_map = {
         "error_message": {"key": "errorMessage", "type": "str"},
     }
 
-    def __init__(self, *, error_message: Optional[str] = None, **kwargs):
+    def __init__(self, *, error_message: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword error_message: A message which indicates a problem in data connection validation.
         :paramtype error_message: str
         """
         super().__init__(**kwargs)
         self.error_message = error_message
 
@@ -2062,15 +2128,15 @@
     :vartype findings: list[str]
     """
 
     _attribute_map = {
         "findings": {"key": "findings", "type": "[str]"},
     }
 
-    def __init__(self, *, findings: Optional[List[str]] = None, **kwargs):
+    def __init__(self, *, findings: Optional[List[str]] = None, **kwargs: Any) -> None:
         """
         :keyword findings: The list of network connectivity diagnostic finding.
         :paramtype findings: list[str]
         """
         super().__init__(**kwargs)
         self.findings = findings
 
@@ -2090,16 +2156,16 @@
     }
 
     def __init__(
         self,
         *,
         domain_name: Optional[str] = None,
         endpoint_details: Optional[List["_models.EndpointDetail"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword domain_name: The domain name of the dependency.
         :paramtype domain_name: str
         :keyword endpoint_details: The ports used when connecting to DomainName.
         :paramtype endpoint_details: list[~azure.mgmt.kusto.models.EndpointDetail]
         """
         super().__init__(**kwargs)
@@ -2114,23 +2180,115 @@
     :vartype port: int
     """
 
     _attribute_map = {
         "port": {"key": "port", "type": "int"},
     }
 
-    def __init__(self, *, port: Optional[int] = None, **kwargs):
+    def __init__(self, *, port: Optional[int] = None, **kwargs: Any) -> None:
         """
         :keyword port: The port an endpoint is connected to.
         :paramtype port: int
         """
         super().__init__(**kwargs)
         self.port = port
 
 
+class ErrorAdditionalInfo(_serialization.Model):
+    """The resource management error additional info.
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar type: The additional info type.
+    :vartype type: str
+    :ivar info: The additional info.
+    :vartype info: JSON
+    """
+
+    _validation = {
+        "type": {"readonly": True},
+        "info": {"readonly": True},
+    }
+
+    _attribute_map = {
+        "type": {"key": "type", "type": "str"},
+        "info": {"key": "info", "type": "object"},
+    }
+
+    def __init__(self, **kwargs: Any) -> None:
+        """ """
+        super().__init__(**kwargs)
+        self.type = None
+        self.info = None
+
+
+class ErrorDetail(_serialization.Model):
+    """The error detail.
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar code: The error code.
+    :vartype code: str
+    :ivar message: The error message.
+    :vartype message: str
+    :ivar target: The error target.
+    :vartype target: str
+    :ivar details: The error details.
+    :vartype details: list[~azure.mgmt.kusto.models.ErrorDetail]
+    :ivar additional_info: The error additional info.
+    :vartype additional_info: list[~azure.mgmt.kusto.models.ErrorAdditionalInfo]
+    """
+
+    _validation = {
+        "code": {"readonly": True},
+        "message": {"readonly": True},
+        "target": {"readonly": True},
+        "details": {"readonly": True},
+        "additional_info": {"readonly": True},
+    }
+
+    _attribute_map = {
+        "code": {"key": "code", "type": "str"},
+        "message": {"key": "message", "type": "str"},
+        "target": {"key": "target", "type": "str"},
+        "details": {"key": "details", "type": "[ErrorDetail]"},
+        "additional_info": {"key": "additionalInfo", "type": "[ErrorAdditionalInfo]"},
+    }
+
+    def __init__(self, **kwargs: Any) -> None:
+        """ """
+        super().__init__(**kwargs)
+        self.code = None
+        self.message = None
+        self.target = None
+        self.details = None
+        self.additional_info = None
+
+
+class ErrorResponse(_serialization.Model):
+    """Common error response for all Azure Resource Manager APIs to return error details for failed
+    operations. (This also follows the OData error response format.).
+
+    :ivar error: The error object.
+    :vartype error: ~azure.mgmt.kusto.models.ErrorDetail
+    """
+
+    _attribute_map = {
+        "error": {"key": "error", "type": "ErrorDetail"},
+    }
+
+    def __init__(self, *, error: Optional["_models.ErrorDetail"] = None, **kwargs: Any) -> None:
+        """
+        :keyword error: The error object.
+        :paramtype error: ~azure.mgmt.kusto.models.ErrorDetail
+        """
+        super().__init__(**kwargs)
+        self.error = error
+
+
 class EventGridDataConnection(DataConnection):  # pylint: disable=too-many-instance-attributes
     """Class representing an Event Grid data connection.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
@@ -2228,16 +2386,16 @@
         table_name: Optional[str] = None,
         mapping_rule_name: Optional[str] = None,
         data_format: Optional[Union[str, "_models.EventGridDataFormat"]] = None,
         ignore_first_record: Optional[bool] = None,
         blob_storage_event_type: Optional[Union[str, "_models.BlobStorageEventType"]] = None,
         managed_identity_resource_id: Optional[str] = None,
         database_routing: Optional[Union[str, "_models.DatabaseRouting"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword location: Resource location.
         :paramtype location: str
         :keyword storage_account_resource_id: The resource ID of the storage account where the data
          resides.
         :paramtype storage_account_resource_id: str
         :keyword event_grid_resource_id: The resource ID of the event grid that is subscribed to the
@@ -2386,16 +2544,16 @@
         mapping_rule_name: Optional[str] = None,
         data_format: Optional[Union[str, "_models.EventHubDataFormat"]] = None,
         event_system_properties: Optional[List[str]] = None,
         compression: Union[str, "_models.Compression"] = "None",
         managed_identity_resource_id: Optional[str] = None,
         database_routing: Optional[Union[str, "_models.DatabaseRouting"]] = None,
         retrieval_start_date: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword location: Resource location.
         :paramtype location: str
         :keyword event_hub_resource_id: The resource ID of the event hub to be used to create a data
          connection.
         :paramtype event_hub_resource_id: str
         :keyword consumer_group: The event hub consumer group.
@@ -2478,15 +2636,15 @@
         "cluster_resource_id": {"key": "clusterResourceId", "type": "str"},
         "attached_database_configuration_name": {"key": "attachedDatabaseConfigurationName", "type": "str"},
         "database_name": {"key": "databaseName", "type": "str"},
         "table_level_sharing_properties": {"key": "tableLevelSharingProperties", "type": "TableLevelSharingProperties"},
         "database_share_origin": {"key": "databaseShareOrigin", "type": "str"},
     }
 
-    def __init__(self, *, cluster_resource_id: str, attached_database_configuration_name: str, **kwargs):
+    def __init__(self, *, cluster_resource_id: str, attached_database_configuration_name: str, **kwargs: Any) -> None:
         """
         :keyword cluster_resource_id: Resource id of the cluster that follows a database owned by this
          cluster. Required.
         :paramtype cluster_resource_id: str
         :keyword attached_database_configuration_name: Resource name of the attached database
          configuration in the follower cluster. Required.
         :paramtype attached_database_configuration_name: str
@@ -2506,15 +2664,15 @@
     :vartype value: list[~azure.mgmt.kusto.models.FollowerDatabaseDefinition]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[FollowerDatabaseDefinition]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.FollowerDatabaseDefinition"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.FollowerDatabaseDefinition"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of follower database result.
         :paramtype value: list[~azure.mgmt.kusto.models.FollowerDatabaseDefinition]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -2561,16 +2719,16 @@
     def __init__(
         self,
         *,
         type: Union[str, "_models.IdentityType"],
         user_assigned_identities: Optional[
             Dict[str, "_models.ComponentsSgqdofSchemasIdentityPropertiesUserassignedidentitiesAdditionalproperties"]
         ] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword type: The type of managed identity used. The type 'SystemAssigned, UserAssigned'
          includes both an implicitly created identity and a set of user-assigned identities. The type
          'None' will remove all identities. Required. Known values are: "None", "SystemAssigned",
          "UserAssigned", and "SystemAssigned, UserAssigned".
         :paramtype type: str or ~azure.mgmt.kusto.models.IdentityType
         :keyword user_assigned_identities: The list of user identities associated with the Kusto
@@ -2673,16 +2831,16 @@
         table_name: Optional[str] = None,
         mapping_rule_name: Optional[str] = None,
         data_format: Optional[Union[str, "_models.IotHubDataFormat"]] = None,
         event_system_properties: Optional[List[str]] = None,
         shared_access_policy_name: Optional[str] = None,
         database_routing: Optional[Union[str, "_models.DatabaseRouting"]] = None,
         retrieval_start_date: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword location: Resource location.
         :paramtype location: str
         :keyword iot_hub_resource_id: The resource ID of the Iot hub to be used to create a data
          connection.
         :paramtype iot_hub_resource_id: str
         :keyword consumer_group: The iot hub consumer group.
@@ -2747,16 +2905,16 @@
     def __init__(
         self,
         *,
         key_name: Optional[str] = None,
         key_version: Optional[str] = None,
         key_vault_uri: Optional[str] = None,
         user_identity: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword key_name: The name of the key vault key.
         :paramtype key_name: str
         :keyword key_version: The version of the key vault key.
         :paramtype key_version: str
         :keyword key_vault_uri: The Uri of the key vault.
         :paramtype key_vault_uri: str
@@ -2773,37 +2931,37 @@
 
 class LanguageExtension(_serialization.Model):
     """The language extension object.
 
     :ivar language_extension_name: The language extension name. Known values are: "PYTHON" and "R".
     :vartype language_extension_name: str or ~azure.mgmt.kusto.models.LanguageExtensionName
     :ivar language_extension_image_name: The language extension image name. Known values are: "R",
-     "Python3_6_5", "Python3_9_12", "Python3_9_12IncludeDeepLearning", and "Python3_10_8".
+     "Python3_6_5", and "Python3_10_8".
     :vartype language_extension_image_name: str or
      ~azure.mgmt.kusto.models.LanguageExtensionImageName
     """
 
     _attribute_map = {
         "language_extension_name": {"key": "languageExtensionName", "type": "str"},
         "language_extension_image_name": {"key": "languageExtensionImageName", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         language_extension_name: Optional[Union[str, "_models.LanguageExtensionName"]] = None,
         language_extension_image_name: Optional[Union[str, "_models.LanguageExtensionImageName"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword language_extension_name: The language extension name. Known values are: "PYTHON" and
          "R".
         :paramtype language_extension_name: str or ~azure.mgmt.kusto.models.LanguageExtensionName
         :keyword language_extension_image_name: The language extension image name. Known values are:
-         "R", "Python3_6_5", "Python3_9_12", "Python3_9_12IncludeDeepLearning", and "Python3_10_8".
+         "R", "Python3_6_5", and "Python3_10_8".
         :paramtype language_extension_image_name: str or
          ~azure.mgmt.kusto.models.LanguageExtensionImageName
         """
         super().__init__(**kwargs)
         self.language_extension_name = language_extension_name
         self.language_extension_image_name = language_extension_image_name
 
@@ -2815,15 +2973,15 @@
     :vartype value: list[~azure.mgmt.kusto.models.LanguageExtension]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[LanguageExtension]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.LanguageExtension"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.LanguageExtension"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of language extensions.
         :paramtype value: list[~azure.mgmt.kusto.models.LanguageExtension]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -2835,15 +2993,15 @@
     :vartype value: list[~azure.mgmt.kusto.models.AzureResourceSku]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[AzureResourceSku]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.AzureResourceSku"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.AzureResourceSku"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The collection of available SKUs for an existing resource.
         :paramtype value: list[~azure.mgmt.kusto.models.AzureResourceSku]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -2901,16 +3059,16 @@
     def __init__(
         self,
         *,
         private_link_resource_id: Optional[str] = None,
         private_link_resource_region: Optional[str] = None,
         group_id: Optional[str] = None,
         request_message: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword private_link_resource_id: The ARM resource ID of the resource for which the managed
          private endpoint is created.
         :paramtype private_link_resource_id: str
         :keyword private_link_resource_region: The region of the resource to which the managed private
          endpoint is created.
         :paramtype private_link_resource_region: str
@@ -2935,15 +3093,15 @@
     :vartype value: list[~azure.mgmt.kusto.models.ManagedPrivateEndpoint]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[ManagedPrivateEndpoint]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.ManagedPrivateEndpoint"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.ManagedPrivateEndpoint"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of managed private endpoints.
         :paramtype value: list[~azure.mgmt.kusto.models.ManagedPrivateEndpoint]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -2971,23 +3129,62 @@
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
     type = "Microsoft.Kusto/clusters/managedPrivateEndpoints"
 
-    def __init__(self, *, name: str, **kwargs):
+    def __init__(self, *, name: str, **kwargs: Any) -> None:
         """
         :keyword name: Managed private endpoint resource name. Required.
         :paramtype name: str
         """
         super().__init__(**kwargs)
         self.name = name
 
 
+class MigrationClusterProperties(_serialization.Model):
+    """Represents a properties of a cluster that is part of a migration.
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar id: The resource ID of the cluster.
+    :vartype id: str
+    :ivar uri: The public URL of the cluster.
+    :vartype uri: str
+    :ivar data_ingestion_uri: The public data ingestion URL of the cluster.
+    :vartype data_ingestion_uri: str
+    :ivar role: The role of the cluster in the migration process. Known values are: "Source" and
+     "Destination".
+    :vartype role: str or ~azure.mgmt.kusto.models.MigrationClusterRole
+    """
+
+    _validation = {
+        "id": {"readonly": True},
+        "uri": {"readonly": True},
+        "data_ingestion_uri": {"readonly": True},
+        "role": {"readonly": True},
+    }
+
+    _attribute_map = {
+        "id": {"key": "id", "type": "str"},
+        "uri": {"key": "uri", "type": "str"},
+        "data_ingestion_uri": {"key": "dataIngestionUri", "type": "str"},
+        "role": {"key": "role", "type": "str"},
+    }
+
+    def __init__(self, **kwargs: Any) -> None:
+        """ """
+        super().__init__(**kwargs)
+        self.id = None
+        self.uri = None
+        self.data_ingestion_uri = None
+        self.role = None
+
+
 class Operation(_serialization.Model):
     """A REST API operation.
 
     :ivar name: This is of the format {provider}/{resource}/{operation}.
     :vartype name: str
     :ivar display: The object that describes the operation.
     :vartype display: ~azure.mgmt.kusto.models.OperationDisplay
@@ -3007,16 +3204,16 @@
     def __init__(
         self,
         *,
         name: Optional[str] = None,
         display: Optional["_models.OperationDisplay"] = None,
         origin: Optional[str] = None,
         properties: Optional[JSON] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name: This is of the format {provider}/{resource}/{operation}.
         :paramtype name: str
         :keyword display: The object that describes the operation.
         :paramtype display: ~azure.mgmt.kusto.models.OperationDisplay
         :keyword origin: The intended executor of the operation.
         :paramtype origin: str
@@ -3053,16 +3250,16 @@
     def __init__(
         self,
         *,
         provider: Optional[str] = None,
         operation: Optional[str] = None,
         resource: Optional[str] = None,
         description: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword provider: Friendly name of the resource provider.
         :paramtype provider: str
         :keyword operation: For example: read, write, delete.
         :paramtype operation: str
         :keyword resource: The resource type on which the operation is performed.
         :paramtype resource: str
@@ -3073,28 +3270,31 @@
         self.provider = provider
         self.operation = operation
         self.resource = resource
         self.description = description
 
 
 class OperationListResult(_serialization.Model):
-    """Result of the request to list REST API operations. It contains a list of operations and a URL nextLink to get the next set of results.
+    """Result of the request to list REST API operations. It contains a list of operations and a URL
+    nextLink to get the next set of results.
 
     :ivar value: The list of operations supported by the resource provider.
     :vartype value: list[~azure.mgmt.kusto.models.Operation]
     :ivar next_link: The URL to get the next set of operation list results if there are any.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Operation]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.Operation"]] = None, next_link: Optional[str] = None, **kwargs):
+    def __init__(
+        self, *, value: Optional[List["_models.Operation"]] = None, next_link: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword value: The list of operations supported by the resource provider.
         :paramtype value: list[~azure.mgmt.kusto.models.Operation]
         :keyword next_link: The URL to get the next set of operation list results if there are any.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
@@ -3161,16 +3361,16 @@
         start_time: Optional[datetime.datetime] = None,
         end_time: Optional[datetime.datetime] = None,
         percent_complete: Optional[float] = None,
         code: Optional[str] = None,
         message: Optional[str] = None,
         operation_kind: Optional[str] = None,
         operation_state: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword start_time: The operation start time.
         :paramtype start_time: ~datetime.datetime
         :keyword end_time: The operation end time.
         :paramtype end_time: ~datetime.datetime
         :keyword percent_complete: Percentage completed.
         :paramtype percent_complete: float
@@ -3223,15 +3423,15 @@
     _attribute_map = {
         "version": {"key": "version", "type": "int"},
         "is_enabled": {"key": "isEnabled", "type": "bool"},
         "minimum": {"key": "minimum", "type": "int"},
         "maximum": {"key": "maximum", "type": "int"},
     }
 
-    def __init__(self, *, version: int, is_enabled: bool, minimum: int, maximum: int, **kwargs):
+    def __init__(self, *, version: int, is_enabled: bool, minimum: int, maximum: int, **kwargs: Any) -> None:
         """
         :keyword version: The version of the template defined, for instance 1. Required.
         :paramtype version: int
         :keyword is_enabled: A boolean value that indicate if the optimized autoscale feature is
          enabled or not. Required.
         :paramtype is_enabled: bool
         :keyword minimum: Minimum allowed instances count. Required.
@@ -3243,15 +3443,16 @@
         self.version = version
         self.is_enabled = is_enabled
         self.minimum = minimum
         self.maximum = maximum
 
 
 class OutboundNetworkDependenciesEndpoint(ProxyResource):
-    """Endpoints accessed for a common purpose that the Kusto Service Environment requires outbound network access to.
+    """Endpoints accessed for a common purpose that the Kusto Service Environment requires outbound
+    network access to.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: Fully qualified resource ID for the resource. Ex -
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
@@ -3290,16 +3491,16 @@
     }
 
     def __init__(
         self,
         *,
         category: Optional[str] = None,
         endpoints: Optional[List["_models.EndpointDependency"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword category: The type of service accessed by the Kusto Service Environment, e.g., Azure
          Storage, Azure SQL Database, and Azure Active Directory.
         :paramtype category: str
         :keyword endpoints: The endpoints that the Kusto Service Environment reaches the service at.
         :paramtype endpoints: list[~azure.mgmt.kusto.models.EndpointDependency]
         """
@@ -3329,15 +3530,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[OutboundNetworkDependenciesEndpoint]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, value: List["_models.OutboundNetworkDependenciesEndpoint"], **kwargs):
+    def __init__(self, *, value: List["_models.OutboundNetworkDependenciesEndpoint"], **kwargs: Any) -> None:
         """
         :keyword value: Collection of resources. Required.
         :paramtype value: list[~azure.mgmt.kusto.models.OutboundNetworkDependenciesEndpoint]
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = None
@@ -3394,16 +3595,16 @@
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         private_link_service_connection_state: Optional["_models.PrivateLinkServiceConnectionStateProperty"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword private_link_service_connection_state: Connection State of the Private Endpoint
          Connection.
         :paramtype private_link_service_connection_state:
          ~azure.mgmt.kusto.models.PrivateLinkServiceConnectionStateProperty
         """
         super().__init__(**kwargs)
@@ -3421,15 +3622,15 @@
     :vartype value: list[~azure.mgmt.kusto.models.PrivateEndpointConnection]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[PrivateEndpointConnection]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.PrivateEndpointConnection"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.PrivateEndpointConnection"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: Array of private endpoint connections.
         :paramtype value: list[~azure.mgmt.kusto.models.PrivateEndpointConnection]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -3447,15 +3648,15 @@
         "id": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
 
 
 class PrivateLinkResource(Resource):
     """A private link resource.
@@ -3496,15 +3697,15 @@
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "group_id": {"key": "properties.groupId", "type": "str"},
         "required_members": {"key": "properties.requiredMembers", "type": "[str]"},
         "required_zone_names": {"key": "properties.requiredZoneNames", "type": "[str]"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.system_data = None
         self.group_id = None
         self.required_members = None
         self.required_zone_names = None
 
@@ -3516,15 +3717,15 @@
     :vartype value: list[~azure.mgmt.kusto.models.PrivateLinkResource]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[PrivateLinkResource]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.PrivateLinkResource"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.PrivateLinkResource"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: Array of private link resources.
         :paramtype value: list[~azure.mgmt.kusto.models.PrivateLinkResource]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -3549,15 +3750,15 @@
 
     _attribute_map = {
         "status": {"key": "status", "type": "str"},
         "description": {"key": "description", "type": "str"},
         "actions_required": {"key": "actionsRequired", "type": "str"},
     }
 
-    def __init__(self, *, status: Optional[str] = None, description: Optional[str] = None, **kwargs):
+    def __init__(self, *, status: Optional[str] = None, description: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword status: The private link service connection status.
         :paramtype status: str
         :keyword description: The private link service connection description.
         :paramtype description: str
         """
         super().__init__(**kwargs)
@@ -3609,14 +3810,17 @@
     :vartype table_level_sharing_properties: ~azure.mgmt.kusto.models.TableLevelSharingProperties
     :ivar original_database_name: The original database name, before databaseNameOverride or
      databaseNamePrefix where applied.
     :vartype original_database_name: str
     :ivar database_share_origin: The origin of the following setup. Known values are: "Direct",
      "DataShare", and "Other".
     :vartype database_share_origin: str or ~azure.mgmt.kusto.models.DatabaseShareOrigin
+    :ivar suspension_details: The database suspension details. If the database is suspended, this
+     object contains information related to the database's suspension state.
+    :vartype suspension_details: ~azure.mgmt.kusto.models.SuspensionDetails
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "kind": {"required": True},
@@ -3625,14 +3829,15 @@
         "statistics": {"readonly": True},
         "leader_cluster_resource_id": {"readonly": True},
         "attached_database_configuration_name": {"readonly": True},
         "principals_modification_kind": {"readonly": True},
         "table_level_sharing_properties": {"readonly": True},
         "original_database_name": {"readonly": True},
         "database_share_origin": {"readonly": True},
+        "suspension_details": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "location": {"key": "location", "type": "str"},
@@ -3646,19 +3851,20 @@
         "principals_modification_kind": {"key": "properties.principalsModificationKind", "type": "str"},
         "table_level_sharing_properties": {
             "key": "properties.tableLevelSharingProperties",
             "type": "TableLevelSharingProperties",
         },
         "original_database_name": {"key": "properties.originalDatabaseName", "type": "str"},
         "database_share_origin": {"key": "properties.databaseShareOrigin", "type": "str"},
+        "suspension_details": {"key": "properties.suspensionDetails", "type": "SuspensionDetails"},
     }
 
     def __init__(
-        self, *, location: Optional[str] = None, hot_cache_period: Optional[datetime.timedelta] = None, **kwargs
-    ):
+        self, *, location: Optional[str] = None, hot_cache_period: Optional[datetime.timedelta] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword location: Resource location.
         :paramtype location: str
         :keyword hot_cache_period: The time the data should be kept in cache for fast queries in
          TimeSpan.
         :paramtype hot_cache_period: ~datetime.timedelta
         """
@@ -3670,17 +3876,18 @@
         self.statistics = None
         self.leader_cluster_resource_id = None
         self.attached_database_configuration_name = None
         self.principals_modification_kind = None
         self.table_level_sharing_properties = None
         self.original_database_name = None
         self.database_share_origin = None
+        self.suspension_details = None
 
 
-class ReadWriteDatabase(Database):
+class ReadWriteDatabase(Database):  # pylint: disable=too-many-instance-attributes
     """Class representing a read write database.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar id: Fully qualified resource ID for the resource. Ex -
@@ -3704,64 +3911,77 @@
     :vartype soft_delete_period: ~datetime.timedelta
     :ivar hot_cache_period: The time the data should be kept in cache for fast queries in TimeSpan.
     :vartype hot_cache_period: ~datetime.timedelta
     :ivar statistics: The statistics of the database.
     :vartype statistics: ~azure.mgmt.kusto.models.DatabaseStatistics
     :ivar is_followed: Indicates whether the database is followed.
     :vartype is_followed: bool
+    :ivar key_vault_properties: KeyVault properties for the database encryption.
+    :vartype key_vault_properties: ~azure.mgmt.kusto.models.KeyVaultProperties
+    :ivar suspension_details: The database suspension details. If the database is suspended, this
+     object contains information related to the database's suspension state.
+    :vartype suspension_details: ~azure.mgmt.kusto.models.SuspensionDetails
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "kind": {"required": True},
         "provisioning_state": {"readonly": True},
         "statistics": {"readonly": True},
         "is_followed": {"readonly": True},
+        "suspension_details": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "location": {"key": "location", "type": "str"},
         "kind": {"key": "kind", "type": "str"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
         "soft_delete_period": {"key": "properties.softDeletePeriod", "type": "duration"},
         "hot_cache_period": {"key": "properties.hotCachePeriod", "type": "duration"},
         "statistics": {"key": "properties.statistics", "type": "DatabaseStatistics"},
         "is_followed": {"key": "properties.isFollowed", "type": "bool"},
+        "key_vault_properties": {"key": "properties.keyVaultProperties", "type": "KeyVaultProperties"},
+        "suspension_details": {"key": "properties.suspensionDetails", "type": "SuspensionDetails"},
     }
 
     def __init__(
         self,
         *,
         location: Optional[str] = None,
         soft_delete_period: Optional[datetime.timedelta] = None,
         hot_cache_period: Optional[datetime.timedelta] = None,
-        **kwargs
-    ):
+        key_vault_properties: Optional["_models.KeyVaultProperties"] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword location: Resource location.
         :paramtype location: str
         :keyword soft_delete_period: The time the data should be kept before it stops being accessible
          to queries in TimeSpan.
         :paramtype soft_delete_period: ~datetime.timedelta
         :keyword hot_cache_period: The time the data should be kept in cache for fast queries in
          TimeSpan.
         :paramtype hot_cache_period: ~datetime.timedelta
+        :keyword key_vault_properties: KeyVault properties for the database encryption.
+        :paramtype key_vault_properties: ~azure.mgmt.kusto.models.KeyVaultProperties
         """
         super().__init__(location=location, **kwargs)
         self.kind: str = "ReadWrite"
         self.provisioning_state = None
         self.soft_delete_period = soft_delete_period
         self.hot_cache_period = hot_cache_period
         self.statistics = None
         self.is_followed = None
+        self.key_vault_properties = key_vault_properties
+        self.suspension_details = None
 
 
 class ResourceSkuCapabilities(_serialization.Model):
     """Describes The SKU capabilities object.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
@@ -3777,15 +3997,15 @@
     }
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "value": {"key": "value", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.name = None
         self.value = None
 
 
 class ResourceSkuZoneDetails(_serialization.Model):
@@ -3806,15 +4026,15 @@
     }
 
     _attribute_map = {
         "name": {"key": "name", "type": "[str]"},
         "capabilities": {"key": "capabilities", "type": "[ResourceSkuCapabilities]"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.name = None
         self.capabilities = None
 
 
 class Script(ProxyResource):
@@ -3876,16 +4096,16 @@
         self,
         *,
         script_url: Optional[str] = None,
         script_url_sas_token: Optional[str] = None,
         script_content: Optional[str] = None,
         force_update_tag: Optional[str] = None,
         continue_on_errors: bool = False,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword script_url: The url to the KQL script blob file. Must not be used together with
          scriptContent property.
         :paramtype script_url: str
         :keyword script_url_sas_token: The SaS token that provide read access to the file which contain
          the script. Must be provided when using scriptUrl property.
         :paramtype script_url_sas_token: str
@@ -3931,15 +4151,15 @@
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
     type = "Microsoft.Kusto/clusters/databases/scripts"
 
-    def __init__(self, *, name: str, **kwargs):
+    def __init__(self, *, name: str, **kwargs: Any) -> None:
         """
         :keyword name: Script name. Required.
         :paramtype name: str
         """
         super().__init__(**kwargs)
         self.name = name
 
@@ -3951,15 +4171,15 @@
     :vartype value: list[~azure.mgmt.kusto.models.Script]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Script]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.Script"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.Script"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of Kusto scripts.
         :paramtype value: list[~azure.mgmt.kusto.models.Script]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -3997,15 +4217,15 @@
         "name": {"key": "name", "type": "str"},
         "tier": {"key": "tier", "type": "str"},
         "locations": {"key": "locations", "type": "[str]"},
         "location_info": {"key": "locationInfo", "type": "[SkuLocationInfoItem]"},
         "restrictions": {"key": "restrictions", "type": "[object]"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.resource_type = None
         self.name = None
         self.tier = None
         self.locations = None
         self.location_info = None
@@ -4025,15 +4245,15 @@
         "value": {"readonly": True},
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[SkuDescription]"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
 
 
 class SkuLocationInfoItem(_serialization.Model):
     """The locations and zones info for SKU.
@@ -4060,30 +4280,51 @@
 
     def __init__(
         self,
         *,
         location: str,
         zones: Optional[List[str]] = None,
         zone_details: Optional[List["_models.ResourceSkuZoneDetails"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword location: The available location of the SKU. Required.
         :paramtype location: str
         :keyword zones: The available zone of the SKU.
         :paramtype zones: list[str]
         :keyword zone_details: Gets details of capabilities available to a SKU in specific zones.
         :paramtype zone_details: list[~azure.mgmt.kusto.models.ResourceSkuZoneDetails]
         """
         super().__init__(**kwargs)
         self.location = location
         self.zones = zones
         self.zone_details = zone_details
 
 
+class SuspensionDetails(_serialization.Model):
+    """The database suspension details. If the database is suspended, this object contains information
+    related to the database's suspension state.
+
+    :ivar suspension_start_date: The starting date and time of the suspension state.
+    :vartype suspension_start_date: ~datetime.datetime
+    """
+
+    _attribute_map = {
+        "suspension_start_date": {"key": "suspensionStartDate", "type": "iso-8601"},
+    }
+
+    def __init__(self, *, suspension_start_date: Optional[datetime.datetime] = None, **kwargs: Any) -> None:
+        """
+        :keyword suspension_start_date: The starting date and time of the suspension state.
+        :paramtype suspension_start_date: ~datetime.datetime
+        """
+        super().__init__(**kwargs)
+        self.suspension_start_date = suspension_start_date
+
+
 class SystemData(_serialization.Model):
     """Metadata pertaining to creation and last modification of the resource.
 
     :ivar created_by: The identity that created the resource.
     :vartype created_by: str
     :ivar created_by_type: The type of identity that created the resource. Known values are:
      "User", "Application", "ManagedIdentity", and "Key".
@@ -4113,16 +4354,16 @@
         *,
         created_by: Optional[str] = None,
         created_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
         created_at: Optional[datetime.datetime] = None,
         last_modified_by: Optional[str] = None,
         last_modified_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
         last_modified_at: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword created_by: The identity that created the resource.
         :paramtype created_by: str
         :keyword created_by_type: The type of identity that created the resource. Known values are:
          "User", "Application", "ManagedIdentity", and "Key".
         :paramtype created_by_type: str or ~azure.mgmt.kusto.models.CreatedByType
         :keyword created_at: The timestamp of resource creation (UTC).
@@ -4149,83 +4390,98 @@
 
     :ivar tables_to_include: List of tables to include in the follower database.
     :vartype tables_to_include: list[str]
     :ivar tables_to_exclude: List of tables to exclude from the follower database.
     :vartype tables_to_exclude: list[str]
     :ivar external_tables_to_include: List of external tables to include in the follower database.
     :vartype external_tables_to_include: list[str]
-    :ivar external_tables_to_exclude: List of external tables exclude from the follower database.
+    :ivar external_tables_to_exclude: List of external tables to exclude from the follower
+     database.
     :vartype external_tables_to_exclude: list[str]
     :ivar materialized_views_to_include: List of materialized views to include in the follower
      database.
     :vartype materialized_views_to_include: list[str]
-    :ivar materialized_views_to_exclude: List of materialized views exclude from the follower
+    :ivar materialized_views_to_exclude: List of materialized views to exclude from the follower
      database.
     :vartype materialized_views_to_exclude: list[str]
+    :ivar functions_to_include: List of functions to include in the follower database.
+    :vartype functions_to_include: list[str]
+    :ivar functions_to_exclude: List of functions to exclude from the follower database.
+    :vartype functions_to_exclude: list[str]
     """
 
     _attribute_map = {
         "tables_to_include": {"key": "tablesToInclude", "type": "[str]"},
         "tables_to_exclude": {"key": "tablesToExclude", "type": "[str]"},
         "external_tables_to_include": {"key": "externalTablesToInclude", "type": "[str]"},
         "external_tables_to_exclude": {"key": "externalTablesToExclude", "type": "[str]"},
         "materialized_views_to_include": {"key": "materializedViewsToInclude", "type": "[str]"},
         "materialized_views_to_exclude": {"key": "materializedViewsToExclude", "type": "[str]"},
+        "functions_to_include": {"key": "functionsToInclude", "type": "[str]"},
+        "functions_to_exclude": {"key": "functionsToExclude", "type": "[str]"},
     }
 
     def __init__(
         self,
         *,
         tables_to_include: Optional[List[str]] = None,
         tables_to_exclude: Optional[List[str]] = None,
         external_tables_to_include: Optional[List[str]] = None,
         external_tables_to_exclude: Optional[List[str]] = None,
         materialized_views_to_include: Optional[List[str]] = None,
         materialized_views_to_exclude: Optional[List[str]] = None,
-        **kwargs
-    ):
+        functions_to_include: Optional[List[str]] = None,
+        functions_to_exclude: Optional[List[str]] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword tables_to_include: List of tables to include in the follower database.
         :paramtype tables_to_include: list[str]
         :keyword tables_to_exclude: List of tables to exclude from the follower database.
         :paramtype tables_to_exclude: list[str]
         :keyword external_tables_to_include: List of external tables to include in the follower
          database.
         :paramtype external_tables_to_include: list[str]
-        :keyword external_tables_to_exclude: List of external tables exclude from the follower
+        :keyword external_tables_to_exclude: List of external tables to exclude from the follower
          database.
         :paramtype external_tables_to_exclude: list[str]
         :keyword materialized_views_to_include: List of materialized views to include in the follower
          database.
         :paramtype materialized_views_to_include: list[str]
-        :keyword materialized_views_to_exclude: List of materialized views exclude from the follower
+        :keyword materialized_views_to_exclude: List of materialized views to exclude from the follower
          database.
         :paramtype materialized_views_to_exclude: list[str]
+        :keyword functions_to_include: List of functions to include in the follower database.
+        :paramtype functions_to_include: list[str]
+        :keyword functions_to_exclude: List of functions to exclude from the follower database.
+        :paramtype functions_to_exclude: list[str]
         """
         super().__init__(**kwargs)
         self.tables_to_include = tables_to_include
         self.tables_to_exclude = tables_to_exclude
         self.external_tables_to_include = external_tables_to_include
         self.external_tables_to_exclude = external_tables_to_exclude
         self.materialized_views_to_include = materialized_views_to_include
         self.materialized_views_to_exclude = materialized_views_to_exclude
+        self.functions_to_include = functions_to_include
+        self.functions_to_exclude = functions_to_exclude
 
 
 class TrustedExternalTenant(_serialization.Model):
     """Represents a tenant ID that is trusted by the cluster.
 
     :ivar value: GUID representing an external tenant.
     :vartype value: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "str"},
     }
 
-    def __init__(self, *, value: Optional[str] = None, **kwargs):
+    def __init__(self, *, value: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword value: GUID representing an external tenant.
         :paramtype value: str
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -4252,15 +4508,17 @@
 
     _attribute_map = {
         "subnet_id": {"key": "subnetId", "type": "str"},
         "engine_public_ip_id": {"key": "enginePublicIpId", "type": "str"},
         "data_management_public_ip_id": {"key": "dataManagementPublicIpId", "type": "str"},
     }
 
-    def __init__(self, *, subnet_id: str, engine_public_ip_id: str, data_management_public_ip_id: str, **kwargs):
+    def __init__(
+        self, *, subnet_id: str, engine_public_ip_id: str, data_management_public_ip_id: str, **kwargs: Any
+    ) -> None:
         """
         :keyword subnet_id: The subnet resource id. Required.
         :paramtype subnet_id: str
         :keyword engine_public_ip_id: Engine service's public IP address resource id. Required.
         :paramtype engine_public_ip_id: str
         :keyword data_management_public_ip_id: Data management's service public IP address resource id.
          Required.
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/models/_patch.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/models/__init__.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/models/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -11,55 +11,61 @@
 from ._models_py3 import AttachedDatabaseConfigurationListResult
 from ._models_py3 import AttachedDatabaseConfigurationsCheckNameRequest
 from ._models_py3 import AzureCapacity
 from ._models_py3 import AzureResourceSku
 from ._models_py3 import AzureSku
 from ._models_py3 import CheckNameRequest
 from ._models_py3 import CheckNameResult
-from ._models_py3 import CloudErrorBody
 from ._models_py3 import Cluster
 from ._models_py3 import ClusterCheckNameRequest
 from ._models_py3 import ClusterListResult
+from ._models_py3 import ClusterMigrateRequest
 from ._models_py3 import ClusterPrincipalAssignment
 from ._models_py3 import ClusterPrincipalAssignmentCheckNameRequest
 from ._models_py3 import ClusterPrincipalAssignmentListResult
 from ._models_py3 import ClusterUpdate
 from ._models_py3 import ComponentsSgqdofSchemasIdentityPropertiesUserassignedidentitiesAdditionalproperties
 from ._models_py3 import CosmosDbDataConnection
 from ._models_py3 import DataConnection
 from ._models_py3 import DataConnectionCheckNameRequest
 from ._models_py3 import DataConnectionListResult
 from ._models_py3 import DataConnectionValidation
 from ._models_py3 import DataConnectionValidationListResult
 from ._models_py3 import DataConnectionValidationResult
 from ._models_py3 import Database
+from ._models_py3 import DatabaseInviteFollowerRequest
+from ._models_py3 import DatabaseInviteFollowerResult
 from ._models_py3 import DatabaseListResult
 from ._models_py3 import DatabasePrincipal
 from ._models_py3 import DatabasePrincipalAssignment
 from ._models_py3 import DatabasePrincipalAssignmentCheckNameRequest
 from ._models_py3 import DatabasePrincipalAssignmentListResult
 from ._models_py3 import DatabasePrincipalListRequest
 from ._models_py3 import DatabasePrincipalListResult
 from ._models_py3 import DatabaseStatistics
 from ._models_py3 import DiagnoseVirtualNetworkResult
 from ._models_py3 import EndpointDependency
 from ._models_py3 import EndpointDetail
+from ._models_py3 import ErrorAdditionalInfo
+from ._models_py3 import ErrorDetail
+from ._models_py3 import ErrorResponse
 from ._models_py3 import EventGridDataConnection
 from ._models_py3 import EventHubDataConnection
 from ._models_py3 import FollowerDatabaseDefinition
 from ._models_py3 import FollowerDatabaseListResult
 from ._models_py3 import Identity
 from ._models_py3 import IotHubDataConnection
 from ._models_py3 import KeyVaultProperties
 from ._models_py3 import LanguageExtension
 from ._models_py3 import LanguageExtensionsList
 from ._models_py3 import ListResourceSkusResult
 from ._models_py3 import ManagedPrivateEndpoint
 from ._models_py3 import ManagedPrivateEndpointListResult
 from ._models_py3 import ManagedPrivateEndpointsCheckNameRequest
+from ._models_py3 import MigrationClusterProperties
 from ._models_py3 import Operation
 from ._models_py3 import OperationDisplay
 from ._models_py3 import OperationListResult
 from ._models_py3 import OperationResult
 from ._models_py3 import OptimizedAutoscale
 from ._models_py3 import OutboundNetworkDependenciesEndpoint
 from ._models_py3 import OutboundNetworkDependenciesEndpointListResult
@@ -77,14 +83,15 @@
 from ._models_py3 import ResourceSkuZoneDetails
 from ._models_py3 import Script
 from ._models_py3 import ScriptCheckNameRequest
 from ._models_py3 import ScriptListResult
 from ._models_py3 import SkuDescription
 from ._models_py3 import SkuDescriptionList
 from ._models_py3 import SkuLocationInfoItem
+from ._models_py3 import SuspensionDetails
 from ._models_py3 import SystemData
 from ._models_py3 import TableLevelSharingProperties
 from ._models_py3 import TrackedResource
 from ._models_py3 import TrustedExternalTenant
 from ._models_py3 import VirtualNetworkConfiguration
 
 from ._kusto_management_client_enums import AzureScaleType
@@ -106,14 +113,15 @@
 from ._kusto_management_client_enums import EventGridDataFormat
 from ._kusto_management_client_enums import EventHubDataFormat
 from ._kusto_management_client_enums import IdentityType
 from ._kusto_management_client_enums import IotHubDataFormat
 from ._kusto_management_client_enums import Kind
 from ._kusto_management_client_enums import LanguageExtensionImageName
 from ._kusto_management_client_enums import LanguageExtensionName
+from ._kusto_management_client_enums import MigrationClusterRole
 from ._kusto_management_client_enums import PrincipalType
 from ._kusto_management_client_enums import PrincipalsModificationKind
 from ._kusto_management_client_enums import ProvisioningState
 from ._kusto_management_client_enums import PublicIPType
 from ._kusto_management_client_enums import PublicNetworkAccess
 from ._kusto_management_client_enums import Reason
 from ._kusto_management_client_enums import State
@@ -129,55 +137,61 @@
     "AttachedDatabaseConfigurationListResult",
     "AttachedDatabaseConfigurationsCheckNameRequest",
     "AzureCapacity",
     "AzureResourceSku",
     "AzureSku",
     "CheckNameRequest",
     "CheckNameResult",
-    "CloudErrorBody",
     "Cluster",
     "ClusterCheckNameRequest",
     "ClusterListResult",
+    "ClusterMigrateRequest",
     "ClusterPrincipalAssignment",
     "ClusterPrincipalAssignmentCheckNameRequest",
     "ClusterPrincipalAssignmentListResult",
     "ClusterUpdate",
     "ComponentsSgqdofSchemasIdentityPropertiesUserassignedidentitiesAdditionalproperties",
     "CosmosDbDataConnection",
     "DataConnection",
     "DataConnectionCheckNameRequest",
     "DataConnectionListResult",
     "DataConnectionValidation",
     "DataConnectionValidationListResult",
     "DataConnectionValidationResult",
     "Database",
+    "DatabaseInviteFollowerRequest",
+    "DatabaseInviteFollowerResult",
     "DatabaseListResult",
     "DatabasePrincipal",
     "DatabasePrincipalAssignment",
     "DatabasePrincipalAssignmentCheckNameRequest",
     "DatabasePrincipalAssignmentListResult",
     "DatabasePrincipalListRequest",
     "DatabasePrincipalListResult",
     "DatabaseStatistics",
     "DiagnoseVirtualNetworkResult",
     "EndpointDependency",
     "EndpointDetail",
+    "ErrorAdditionalInfo",
+    "ErrorDetail",
+    "ErrorResponse",
     "EventGridDataConnection",
     "EventHubDataConnection",
     "FollowerDatabaseDefinition",
     "FollowerDatabaseListResult",
     "Identity",
     "IotHubDataConnection",
     "KeyVaultProperties",
     "LanguageExtension",
     "LanguageExtensionsList",
     "ListResourceSkusResult",
     "ManagedPrivateEndpoint",
     "ManagedPrivateEndpointListResult",
     "ManagedPrivateEndpointsCheckNameRequest",
+    "MigrationClusterProperties",
     "Operation",
     "OperationDisplay",
     "OperationListResult",
     "OperationResult",
     "OptimizedAutoscale",
     "OutboundNetworkDependenciesEndpoint",
     "OutboundNetworkDependenciesEndpointListResult",
@@ -195,14 +209,15 @@
     "ResourceSkuZoneDetails",
     "Script",
     "ScriptCheckNameRequest",
     "ScriptListResult",
     "SkuDescription",
     "SkuDescriptionList",
     "SkuLocationInfoItem",
+    "SuspensionDetails",
     "SystemData",
     "TableLevelSharingProperties",
     "TrackedResource",
     "TrustedExternalTenant",
     "VirtualNetworkConfiguration",
     "AzureScaleType",
     "AzureSkuName",
@@ -223,14 +238,15 @@
     "EventGridDataFormat",
     "EventHubDataFormat",
     "IdentityType",
     "IotHubDataFormat",
     "Kind",
     "LanguageExtensionImageName",
     "LanguageExtensionName",
+    "MigrationClusterRole",
     "PrincipalType",
     "PrincipalsModificationKind",
     "ProvisioningState",
     "PublicIPType",
     "PublicNetworkAccess",
     "Reason",
     "State",
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_operations_results_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_operations_results_location_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,127 +23,120 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(location: str, operation_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
-    accept = _headers.pop("Accept", "application/json")
-
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/locations/{location}/operationResults/{operationId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "location": _SERIALIZER.url("location", location, "str"),
-        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "location": _SERIALIZER.url("location", location, "str", min_length=1),
+        "operationId": _SERIALIZER.url("operation_id", operation_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+    return HttpRequest(method="GET", url=_url, params=_params, **kwargs)
 
 
-class OperationsResultsOperations:
+class OperationsResultsLocationOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.kusto.KustoManagementClient`'s
-        :attr:`operations_results` attribute.
+        :attr:`operations_results_location` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def get(self, location: str, operation_id: str, **kwargs: Any) -> _models.OperationResult:
+    def get(  # pylint: disable=inconsistent-return-statements
+        self, location: str, operation_id: str, **kwargs: Any
+    ) -> None:
         """Returns operation results.
 
-        :param location: Azure location (region) name. Required.
+        :param location: The name of Azure region. Required.
         :type location: str
-        :param operation_id: The Guid of the operation ID. Required.
+        :param operation_id: The ID of an ongoing async operation. Required.
         :type operation_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: OperationResult or the result of cls(response)
-        :rtype: ~azure.mgmt.kusto.models.OperationResult
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
-        cls: ClsType[_models.OperationResult] = kwargs.pop("cls", None)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_get_request(
             location=location,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200]:
+        if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("OperationResult", pipeline_response)
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+            return cls(pipeline_response, None, response_headers)
 
     get.metadata = {
         "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/locations/{location}/operationResults/{operationId}"
     }
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_skus_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_skus_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,39 +25,35 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/locations/{location}/skus"
     )
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "location": _SERIALIZER.url("location", location, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "location": _SERIALIZER.url("location", location, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -87,27 +82,25 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def list(self, location: str, **kwargs: Any) -> Iterable["_models.SkuDescription"]:
         """Lists eligible region SKUs for Kusto resource provider by Azure region.
 
-        :param location: Azure location (region) name. Required.
+        :param location: The name of Azure region. Required.
         :type location: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either SkuDescription or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.SkuDescription]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SkuDescriptionList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -152,21 +145,23 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/locations/{location}/skus"}
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_managed_private_endpoints_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_managed_private_endpoints_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,44 +28,42 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_check_name_availability_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/managedPrivateEndpointsCheckNameAvailability",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -77,26 +75,28 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/managedPrivateEndpoints",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -108,28 +108,30 @@
 
 def build_get_request(
     resource_group_name: str, cluster_name: str, managed_private_endpoint_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/managedPrivateEndpoints/{managedPrivateEndpointName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
         "managedPrivateEndpointName": _SERIALIZER.url(
-            "managed_private_endpoint_name", managed_private_endpoint_name, "str"
+            "managed_private_endpoint_name", managed_private_endpoint_name, "str", pattern=r"^.*$"
         ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -142,29 +144,31 @@
 
 def build_create_or_update_request(
     resource_group_name: str, cluster_name: str, managed_private_endpoint_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/managedPrivateEndpoints/{managedPrivateEndpointName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
         "managedPrivateEndpointName": _SERIALIZER.url(
-            "managed_private_endpoint_name", managed_private_endpoint_name, "str"
+            "managed_private_endpoint_name", managed_private_endpoint_name, "str", pattern=r"^.*$"
         ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -179,29 +183,31 @@
 
 def build_update_request(
     resource_group_name: str, cluster_name: str, managed_private_endpoint_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/managedPrivateEndpoints/{managedPrivateEndpointName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
         "managedPrivateEndpointName": _SERIALIZER.url(
-            "managed_private_endpoint_name", managed_private_endpoint_name, "str"
+            "managed_private_endpoint_name", managed_private_endpoint_name, "str", pattern=r"^.*$"
         ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -216,28 +222,30 @@
 
 def build_delete_request(
     resource_group_name: str, cluster_name: str, managed_private_endpoint_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/managedPrivateEndpoints/{managedPrivateEndpointName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
         "managedPrivateEndpointName": _SERIALIZER.url(
-            "managed_private_endpoint_name", managed_private_endpoint_name, "str"
+            "managed_private_endpoint_name", managed_private_endpoint_name, "str", pattern=r"^.*$"
         ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -275,15 +283,15 @@
         resource_name: _models.ManagedPrivateEndpointsCheckNameRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the managed private endpoints resource name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param resource_name: The name of the resource. Required.
         :type resource_name: ~azure.mgmt.kusto.models.ManagedPrivateEndpointsCheckNameRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
@@ -303,15 +311,15 @@
         resource_name: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the managed private endpoints resource name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param resource_name: The name of the resource. Required.
         :type resource_name: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -329,20 +337,21 @@
         resource_group_name: str,
         cluster_name: str,
         resource_name: Union[_models.ManagedPrivateEndpointsCheckNameRequest, IO],
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the managed private endpoints resource name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param resource_name: The name of the resource. Is either a model type or a IO type. Required.
+        :param resource_name: The name of the resource. Is either a
+         ManagedPrivateEndpointsCheckNameRequest type or a IO type. Required.
         :type resource_name: ~azure.mgmt.kusto.models.ManagedPrivateEndpointsCheckNameRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.CheckNameResult
@@ -355,24 +364,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(resource_name, (IO, bytes)):
+        if isinstance(resource_name, (IOBase, bytes)):
             _content = resource_name
         else:
             _json = self._serialize.body(resource_name, "ManagedPrivateEndpointsCheckNameRequest")
 
         request = build_check_name_availability_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -384,23 +391,25 @@
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -411,31 +420,29 @@
 
     @distributed_trace
     def list(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> Iterable["_models.ManagedPrivateEndpoint"]:
         """Returns the list of managed private endpoints.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ManagedPrivateEndpoint or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.ManagedPrivateEndpoint]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ManagedPrivateEndpointListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -481,22 +488,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/managedPrivateEndpoints"
@@ -504,15 +513,15 @@
 
     @distributed_trace
     def get(
         self, resource_group_name: str, cluster_name: str, managed_private_endpoint_name: str, **kwargs: Any
     ) -> _models.ManagedPrivateEndpoint:
         """Gets a managed private endpoint.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param managed_private_endpoint_name: The name of the managed private endpoint. Required.
         :type managed_private_endpoint_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -527,17 +536,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ManagedPrivateEndpoint] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             managed_private_endpoint_name=managed_private_endpoint_name,
             subscription_id=self._config.subscription_id,
@@ -545,23 +552,25 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("ManagedPrivateEndpoint", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -585,24 +594,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ManagedPrivateEndpoint] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ManagedPrivateEndpoint")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -615,35 +622,42 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("ManagedPrivateEndpoint", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("ManagedPrivateEndpoint", pipeline_response)
 
         if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
             deserialized = self._deserialize("ManagedPrivateEndpoint", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_or_update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/managedPrivateEndpoints/{managedPrivateEndpointName}"
     }
 
@@ -656,15 +670,15 @@
         parameters: _models.ManagedPrivateEndpoint,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.ManagedPrivateEndpoint]:
         """Creates a managed private endpoint.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param managed_private_endpoint_name: The name of the managed private endpoint. Required.
         :type managed_private_endpoint_name: str
         :param parameters: The managed private endpoint parameters. Required.
@@ -695,15 +709,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.ManagedPrivateEndpoint]:
         """Creates a managed private endpoint.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param managed_private_endpoint_name: The name of the managed private endpoint. Required.
         :type managed_private_endpoint_name: str
         :param parameters: The managed private endpoint parameters. Required.
@@ -732,23 +746,23 @@
         cluster_name: str,
         managed_private_endpoint_name: str,
         parameters: Union[_models.ManagedPrivateEndpoint, IO],
         **kwargs: Any
     ) -> LROPoller[_models.ManagedPrivateEndpoint]:
         """Creates a managed private endpoint.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param managed_private_endpoint_name: The name of the managed private endpoint. Required.
         :type managed_private_endpoint_name: str
-        :param parameters: The managed private endpoint parameters. Is either a model type or a IO
-         type. Required.
+        :param parameters: The managed private endpoint parameters. Is either a ManagedPrivateEndpoint
+         type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.ManagedPrivateEndpoint or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -761,17 +775,15 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.ManagedPrivateEndpoint]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ManagedPrivateEndpoint] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -791,15 +803,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("ManagedPrivateEndpoint", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -828,24 +842,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ManagedPrivateEndpoint] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ManagedPrivateEndpoint")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -858,23 +870,25 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("ManagedPrivateEndpoint", pipeline_response)
 
         if response.status_code == 202:
             response_headers["Azure-AsyncOperation"] = self._deserialize(
@@ -901,15 +915,15 @@
         parameters: _models.ManagedPrivateEndpoint,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.ManagedPrivateEndpoint]:
         """Updates a managed private endpoint.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param managed_private_endpoint_name: The name of the managed private endpoint. Required.
         :type managed_private_endpoint_name: str
         :param parameters: The managed private endpoint parameters. Required.
@@ -940,15 +954,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.ManagedPrivateEndpoint]:
         """Updates a managed private endpoint.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param managed_private_endpoint_name: The name of the managed private endpoint. Required.
         :type managed_private_endpoint_name: str
         :param parameters: The managed private endpoint parameters. Required.
@@ -977,23 +991,23 @@
         cluster_name: str,
         managed_private_endpoint_name: str,
         parameters: Union[_models.ManagedPrivateEndpoint, IO],
         **kwargs: Any
     ) -> LROPoller[_models.ManagedPrivateEndpoint]:
         """Updates a managed private endpoint.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param managed_private_endpoint_name: The name of the managed private endpoint. Required.
         :type managed_private_endpoint_name: str
-        :param parameters: The managed private endpoint parameters. Is either a model type or a IO
-         type. Required.
+        :param parameters: The managed private endpoint parameters. Is either a ManagedPrivateEndpoint
+         type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.ManagedPrivateEndpoint or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -1006,17 +1020,15 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.ManagedPrivateEndpoint]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ManagedPrivateEndpoint] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1036,15 +1048,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("ManagedPrivateEndpoint", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -1068,17 +1082,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             managed_private_endpoint_name=managed_private_endpoint_name,
             subscription_id=self._config.subscription_id,
@@ -1086,38 +1098,46 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/managedPrivateEndpoints/{managedPrivateEndpointName}"
     }
 
     @distributed_trace
     def begin_delete(
         self, resource_group_name: str, cluster_name: str, managed_private_endpoint_name: str, **kwargs: Any
     ) -> LROPoller[None]:
         """Deletes a managed private endpoint.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param managed_private_endpoint_name: The name of the managed private endpoint. Required.
         :type managed_private_endpoint_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1131,17 +1151,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1156,15 +1174,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_scripts_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_scripts_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,44 +28,42 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_by_database_request(
     resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/scripts",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -82,28 +80,30 @@
     script_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/scripts/{scriptName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "scriptName": _SERIALIZER.url("script_name", script_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "scriptName": _SERIALIZER.url("script_name", script_name, "str", pattern=r"^.*$"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -120,29 +120,31 @@
     script_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/scripts/{scriptName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "scriptName": _SERIALIZER.url("script_name", script_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "scriptName": _SERIALIZER.url("script_name", script_name, "str", pattern=r"^.*$"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -161,29 +163,31 @@
     script_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/scripts/{scriptName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "scriptName": _SERIALIZER.url("script_name", script_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "scriptName": _SERIALIZER.url("script_name", script_name, "str", pattern=r"^.*$"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -202,28 +206,30 @@
     script_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/scripts/{scriptName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "scriptName": _SERIALIZER.url("script_name", script_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "scriptName": _SERIALIZER.url("script_name", script_name, "str", pattern=r"^.*$"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -235,28 +241,30 @@
 
 def build_check_name_availability_request(
     resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/scriptsCheckNameAvailability",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -289,32 +297,30 @@
 
     @distributed_trace
     def list_by_database(
         self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
     ) -> Iterable["_models.Script"]:
         """Returns the list of database scripts for given database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Script or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.Script]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ScriptListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -361,22 +367,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_by_database.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/scripts"
@@ -384,15 +392,15 @@
 
     @distributed_trace
     def get(
         self, resource_group_name: str, cluster_name: str, database_name: str, script_name: str, **kwargs: Any
     ) -> _models.Script:
         """Gets a Kusto cluster database script.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the Kusto database script. Required.
@@ -409,17 +417,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Script] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             database_name=database_name,
             script_name=script_name,
@@ -428,23 +434,25 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("Script", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -469,24 +477,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Script] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Script")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -500,35 +506,42 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("Script", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("Script", pipeline_response)
 
         if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
             deserialized = self._deserialize("Script", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_or_update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/scripts/{scriptName}"
     }
 
@@ -542,15 +555,15 @@
         parameters: _models.Script,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.Script]:
         """Creates a Kusto database script.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the Kusto database script. Required.
@@ -583,15 +596,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.Script]:
         """Creates a Kusto database script.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the Kusto database script. Required.
@@ -622,24 +635,24 @@
         database_name: str,
         script_name: str,
         parameters: Union[_models.Script, IO],
         **kwargs: Any
     ) -> LROPoller[_models.Script]:
         """Creates a Kusto database script.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the Kusto database script. Required.
         :type script_name: str
-        :param parameters: The Kusto Script parameters contains the KQL to run. Is either a model type
+        :param parameters: The Kusto Script parameters contains the KQL to run. Is either a Script type
          or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.Script or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -652,17 +665,15 @@
         :return: An instance of LROPoller that returns either Script or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.Script]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Script] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -683,15 +694,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Script", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -721,24 +734,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Script] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Script")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -752,23 +763,25 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("Script", pipeline_response)
 
         if response.status_code == 202:
             response_headers["Azure-AsyncOperation"] = self._deserialize(
@@ -796,15 +809,15 @@
         parameters: _models.Script,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.Script]:
         """Updates a database script.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the Kusto database script. Required.
@@ -837,15 +850,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.Script]:
         """Updates a database script.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the Kusto database script. Required.
@@ -876,24 +889,24 @@
         database_name: str,
         script_name: str,
         parameters: Union[_models.Script, IO],
         **kwargs: Any
     ) -> LROPoller[_models.Script]:
         """Updates a database script.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the Kusto database script. Required.
         :type script_name: str
-        :param parameters: The Kusto Script parameters contains to the KQL to run. Is either a model
+        :param parameters: The Kusto Script parameters contains to the KQL to run. Is either a Script
          type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.Script or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -906,17 +919,15 @@
         :return: An instance of LROPoller that returns either Script or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.Script]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Script] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -937,15 +948,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Script", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -969,17 +982,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             database_name=database_name,
             script_name=script_name,
@@ -988,38 +999,46 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/scripts/{scriptName}"
     }
 
     @distributed_trace
     def begin_delete(
         self, resource_group_name: str, cluster_name: str, database_name: str, script_name: str, **kwargs: Any
     ) -> LROPoller[None]:
-        """Deletes a Kusto principalAssignment.
+        """Deletes a Kusto database script.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the Kusto database script. Required.
@@ -1035,17 +1054,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1061,15 +1078,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -1092,15 +1111,15 @@
         script_name: _models.ScriptCheckNameRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the script name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the script. Required.
@@ -1123,15 +1142,15 @@
         script_name: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the script name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param script_name: The name of the script. Required.
@@ -1152,22 +1171,23 @@
         cluster_name: str,
         database_name: str,
         script_name: Union[_models.ScriptCheckNameRequest, IO],
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the script name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
-        :param script_name: The name of the script. Is either a model type or a IO type. Required.
+        :param script_name: The name of the script. Is either a ScriptCheckNameRequest type or a IO
+         type. Required.
         :type script_name: ~azure.mgmt.kusto.models.ScriptCheckNameRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.CheckNameResult
@@ -1180,24 +1200,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(script_name, (IO, bytes)):
+        if isinstance(script_name, (IOBase, bytes)):
             _content = script_name
         else:
             _json = self._serialize.body(script_name, "ScriptCheckNameRequest")
 
         request = build_check_name_availability_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1210,23 +1228,25 @@
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_database_principal_assignments_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_cluster_principal_assignments_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,45 +28,42 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_check_name_availability_request(
-    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/checkPrincipalAssignmentNameAvailability",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/checkPrincipalAssignmentNameAvailability",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -75,77 +72,73 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(
-    resource_group_name: str,
-    cluster_name: str,
-    database_name: str,
-    principal_assignment_name: str,
-    subscription_id: str,
-    **kwargs: Any
+    resource_group_name: str, cluster_name: str, principal_assignment_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "principalAssignmentName": _SERIALIZER.url("principal_assignment_name", principal_assignment_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "principalAssignmentName": _SERIALIZER.url(
+            "principal_assignment_name", principal_assignment_name, "str", pattern=r"^.*$"
+        ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_or_update_request(
-    resource_group_name: str,
-    cluster_name: str,
-    database_name: str,
-    principal_assignment_name: str,
-    subscription_id: str,
-    **kwargs: Any
+    resource_group_name: str, cluster_name: str, principal_assignment_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "principalAssignmentName": _SERIALIZER.url("principal_assignment_name", principal_assignment_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "principalAssignmentName": _SERIALIZER.url(
+            "principal_assignment_name", principal_assignment_name, "str", pattern=r"^.*$"
+        ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -154,91 +147,88 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(
-    resource_group_name: str,
-    cluster_name: str,
-    database_name: str,
-    principal_assignment_name: str,
-    subscription_id: str,
-    **kwargs: Any
+    resource_group_name: str, cluster_name: str, principal_assignment_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "principalAssignmentName": _SERIALIZER.url("principal_assignment_name", principal_assignment_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "principalAssignmentName": _SERIALIZER.url(
+            "principal_assignment_name", principal_assignment_name, "str", pattern=r"^.*$"
+        ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_request(
-    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
+def build_list_request(resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class DatabasePrincipalAssignmentsOperations:
+class ClusterPrincipalAssignmentsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.kusto.KustoManagementClient`'s
-        :attr:`database_principal_assignments` attribute.
+        :attr:`cluster_principal_assignments` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
@@ -247,62 +237,56 @@
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @overload
     def check_name_availability(
         self,
         resource_group_name: str,
         cluster_name: str,
-        database_name: str,
-        principal_assignment_name: _models.DatabasePrincipalAssignmentCheckNameRequest,
+        principal_assignment_name: _models.ClusterPrincipalAssignmentCheckNameRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
-        """Checks that the database principal assignment is valid and is not already in use.
+        """Checks that the principal assignment name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param database_name: The name of the database in the Kusto cluster. Required.
-        :type database_name: str
-        :param principal_assignment_name: The name of the resource. Required.
+        :param principal_assignment_name: The name of the principal assignment. Required.
         :type principal_assignment_name:
-         ~azure.mgmt.kusto.models.DatabasePrincipalAssignmentCheckNameRequest
+         ~azure.mgmt.kusto.models.ClusterPrincipalAssignmentCheckNameRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.CheckNameResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def check_name_availability(
         self,
         resource_group_name: str,
         cluster_name: str,
-        database_name: str,
         principal_assignment_name: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
-        """Checks that the database principal assignment is valid and is not already in use.
+        """Checks that the principal assignment name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param database_name: The name of the database in the Kusto cluster. Required.
-        :type database_name: str
-        :param principal_assignment_name: The name of the resource. Required.
+        :param principal_assignment_name: The name of the principal assignment. Required.
         :type principal_assignment_name: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.CheckNameResult
@@ -310,31 +294,28 @@
         """
 
     @distributed_trace
     def check_name_availability(
         self,
         resource_group_name: str,
         cluster_name: str,
-        database_name: str,
-        principal_assignment_name: Union[_models.DatabasePrincipalAssignmentCheckNameRequest, IO],
+        principal_assignment_name: Union[_models.ClusterPrincipalAssignmentCheckNameRequest, IO],
         **kwargs: Any
     ) -> _models.CheckNameResult:
-        """Checks that the database principal assignment is valid and is not already in use.
+        """Checks that the principal assignment name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param database_name: The name of the database in the Kusto cluster. Required.
-        :type database_name: str
-        :param principal_assignment_name: The name of the resource. Is either a model type or a IO
-         type. Required.
+        :param principal_assignment_name: The name of the principal assignment. Is either a
+         ClusterPrincipalAssignmentCheckNameRequest type or a IO type. Required.
         :type principal_assignment_name:
-         ~azure.mgmt.kusto.models.DatabasePrincipalAssignmentCheckNameRequest or IO
+         ~azure.mgmt.kusto.models.ClusterPrincipalAssignmentCheckNameRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.CheckNameResult
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -346,468 +327,440 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(principal_assignment_name, (IO, bytes)):
+        if isinstance(principal_assignment_name, (IOBase, bytes)):
             _content = principal_assignment_name
         else:
-            _json = self._serialize.body(principal_assignment_name, "DatabasePrincipalAssignmentCheckNameRequest")
+            _json = self._serialize.body(principal_assignment_name, "ClusterPrincipalAssignmentCheckNameRequest")
 
         request = build_check_name_availability_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
-            database_name=database_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     check_name_availability.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/checkPrincipalAssignmentNameAvailability"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/checkPrincipalAssignmentNameAvailability"
     }
 
     @distributed_trace
     def get(
-        self,
-        resource_group_name: str,
-        cluster_name: str,
-        database_name: str,
-        principal_assignment_name: str,
-        **kwargs: Any
-    ) -> _models.DatabasePrincipalAssignment:
-        """Gets a Kusto cluster database principalAssignment.
+        self, resource_group_name: str, cluster_name: str, principal_assignment_name: str, **kwargs: Any
+    ) -> _models.ClusterPrincipalAssignment:
+        """Gets a Kusto cluster principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param database_name: The name of the database in the Kusto cluster. Required.
-        :type database_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
         :type principal_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: DatabasePrincipalAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.kusto.models.DatabasePrincipalAssignment
+        :return: ClusterPrincipalAssignment or the result of cls(response)
+        :rtype: ~azure.mgmt.kusto.models.ClusterPrincipalAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
-        cls: ClsType[_models.DatabasePrincipalAssignment] = kwargs.pop("cls", None)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ClusterPrincipalAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
-            database_name=database_name,
             principal_assignment_name=principal_assignment_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("DatabasePrincipalAssignment", pipeline_response)
+        deserialized = self._deserialize("ClusterPrincipalAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}"
     }
 
     def _create_or_update_initial(
         self,
         resource_group_name: str,
         cluster_name: str,
-        database_name: str,
         principal_assignment_name: str,
-        parameters: Union[_models.DatabasePrincipalAssignment, IO],
+        parameters: Union[_models.ClusterPrincipalAssignment, IO],
         **kwargs: Any
-    ) -> _models.DatabasePrincipalAssignment:
+    ) -> _models.ClusterPrincipalAssignment:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.DatabasePrincipalAssignment] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ClusterPrincipalAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
-            _json = self._serialize.body(parameters, "DatabasePrincipalAssignment")
+            _json = self._serialize.body(parameters, "ClusterPrincipalAssignment")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
-            database_name=database_name,
             principal_assignment_name=principal_assignment_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
-            deserialized = self._deserialize("DatabasePrincipalAssignment", pipeline_response)
+            deserialized = self._deserialize("ClusterPrincipalAssignment", pipeline_response)
 
         if response.status_code == 201:
-            deserialized = self._deserialize("DatabasePrincipalAssignment", pipeline_response)
+            deserialized = self._deserialize("ClusterPrincipalAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_or_update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}"
     }
 
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         cluster_name: str,
-        database_name: str,
         principal_assignment_name: str,
-        parameters: _models.DatabasePrincipalAssignment,
+        parameters: _models.ClusterPrincipalAssignment,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.DatabasePrincipalAssignment]:
-        """Creates a Kusto cluster database principalAssignment.
+    ) -> LROPoller[_models.ClusterPrincipalAssignment]:
+        """Create a Kusto cluster principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param database_name: The name of the database in the Kusto cluster. Required.
-        :type database_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
         :type principal_assignment_name: str
-        :param parameters: The Kusto principalAssignments parameters supplied for the operation.
-         Required.
-        :type parameters: ~azure.mgmt.kusto.models.DatabasePrincipalAssignment
+        :param parameters: The Kusto cluster principalAssignment's parameters supplied for the
+         operation. Required.
+        :type parameters: ~azure.mgmt.kusto.models.ClusterPrincipalAssignment
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either DatabasePrincipalAssignment or the result
+        :return: An instance of LROPoller that returns either ClusterPrincipalAssignment or the result
          of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.DatabasePrincipalAssignment]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.ClusterPrincipalAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         cluster_name: str,
-        database_name: str,
         principal_assignment_name: str,
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.DatabasePrincipalAssignment]:
-        """Creates a Kusto cluster database principalAssignment.
+    ) -> LROPoller[_models.ClusterPrincipalAssignment]:
+        """Create a Kusto cluster principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param database_name: The name of the database in the Kusto cluster. Required.
-        :type database_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
         :type principal_assignment_name: str
-        :param parameters: The Kusto principalAssignments parameters supplied for the operation.
-         Required.
+        :param parameters: The Kusto cluster principalAssignment's parameters supplied for the
+         operation. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either DatabasePrincipalAssignment or the result
+        :return: An instance of LROPoller that returns either ClusterPrincipalAssignment or the result
          of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.DatabasePrincipalAssignment]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.ClusterPrincipalAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create_or_update(
         self,
         resource_group_name: str,
         cluster_name: str,
-        database_name: str,
         principal_assignment_name: str,
-        parameters: Union[_models.DatabasePrincipalAssignment, IO],
+        parameters: Union[_models.ClusterPrincipalAssignment, IO],
         **kwargs: Any
-    ) -> LROPoller[_models.DatabasePrincipalAssignment]:
-        """Creates a Kusto cluster database principalAssignment.
+    ) -> LROPoller[_models.ClusterPrincipalAssignment]:
+        """Create a Kusto cluster principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param database_name: The name of the database in the Kusto cluster. Required.
-        :type database_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
         :type principal_assignment_name: str
-        :param parameters: The Kusto principalAssignments parameters supplied for the operation. Is
-         either a model type or a IO type. Required.
-        :type parameters: ~azure.mgmt.kusto.models.DatabasePrincipalAssignment or IO
+        :param parameters: The Kusto cluster principalAssignment's parameters supplied for the
+         operation. Is either a ClusterPrincipalAssignment type or a IO type. Required.
+        :type parameters: ~azure.mgmt.kusto.models.ClusterPrincipalAssignment or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either DatabasePrincipalAssignment or the result
+        :return: An instance of LROPoller that returns either ClusterPrincipalAssignment or the result
          of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.DatabasePrincipalAssignment]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.ClusterPrincipalAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.DatabasePrincipalAssignment] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ClusterPrincipalAssignment] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
-                database_name=database_name,
                 principal_assignment_name=principal_assignment_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("DatabasePrincipalAssignment", pipeline_response)
+            deserialized = self._deserialize("ClusterPrincipalAssignment", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create_or_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}"
     }
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self,
-        resource_group_name: str,
-        cluster_name: str,
-        database_name: str,
-        principal_assignment_name: str,
-        **kwargs: Any
+        self, resource_group_name: str, cluster_name: str, principal_assignment_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
-            database_name=database_name,
             principal_assignment_name=principal_assignment_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}"
     }
 
     @distributed_trace
     def begin_delete(
-        self,
-        resource_group_name: str,
-        cluster_name: str,
-        database_name: str,
-        principal_assignment_name: str,
-        **kwargs: Any
+        self, resource_group_name: str, cluster_name: str, principal_assignment_name: str, **kwargs: Any
     ) -> LROPoller[None]:
-        """Deletes a Kusto principalAssignment.
+        """Deletes a Kusto cluster principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param database_name: The name of the database in the Kusto cluster. Required.
-        :type database_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
         :type principal_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
@@ -817,84 +770,79 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
-                database_name=database_name,
                 principal_assignment_name=principal_assignment_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}"
     }
 
     @distributed_trace
     def list(
-        self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
-    ) -> Iterable["_models.DatabasePrincipalAssignment"]:
-        """Lists all Kusto cluster database principalAssignments.
+        self, resource_group_name: str, cluster_name: str, **kwargs: Any
+    ) -> Iterable["_models.ClusterPrincipalAssignment"]:
+        """Lists all Kusto cluster principalAssignments.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param database_name: The name of the database in the Kusto cluster. Required.
-        :type database_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either DatabasePrincipalAssignment or the result of
+        :return: An iterator like instance of either ClusterPrincipalAssignment or the result of
          cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.DatabasePrincipalAssignment]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.ClusterPrincipalAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
-        cls: ClsType[_models.DatabasePrincipalAssignmentListResult] = kwargs.pop("cls", None)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.ClusterPrincipalAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -902,15 +850,14 @@
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
                     resource_group_name=resource_group_name,
                     cluster_name=cluster_name,
-                    database_name=database_name,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
@@ -931,32 +878,34 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("DatabasePrincipalAssignmentListResult", pipeline_response)
+            deserialized = self._deserialize("ClusterPrincipalAssignmentListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments"
     }
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_attached_database_configurations_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_attached_database_configurations_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,44 +28,42 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_check_name_availability_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/attachedDatabaseConfigurationCheckNameAvailability",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -79,26 +77,28 @@
 
 def build_list_by_cluster_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/attachedDatabaseConfigurations",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -114,29 +114,31 @@
     attached_database_configuration_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/attachedDatabaseConfigurations/{attachedDatabaseConfigurationName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
         "attachedDatabaseConfigurationName": _SERIALIZER.url(
-            "attached_database_configuration_name", attached_database_configuration_name, "str"
+            "attached_database_configuration_name", attached_database_configuration_name, "str", pattern=r"^.*$"
         ),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -152,30 +154,32 @@
     attached_database_configuration_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/attachedDatabaseConfigurations/{attachedDatabaseConfigurationName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
         "attachedDatabaseConfigurationName": _SERIALIZER.url(
-            "attached_database_configuration_name", attached_database_configuration_name, "str"
+            "attached_database_configuration_name", attached_database_configuration_name, "str", pattern=r"^.*$"
         ),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -193,29 +197,31 @@
     attached_database_configuration_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/attachedDatabaseConfigurations/{attachedDatabaseConfigurationName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
         "attachedDatabaseConfigurationName": _SERIALIZER.url(
-            "attached_database_configuration_name", attached_database_configuration_name, "str"
+            "attached_database_configuration_name", attached_database_configuration_name, "str", pattern=r"^.*$"
         ),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -253,15 +259,15 @@
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the attached database configuration resource name is valid and is not already in
         use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param resource_name: The name of the resource. Required.
         :type resource_name: ~azure.mgmt.kusto.models.AttachedDatabaseConfigurationsCheckNameRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
@@ -282,15 +288,15 @@
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the attached database configuration resource name is valid and is not already in
         use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param resource_name: The name of the resource. Required.
         :type resource_name: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -309,20 +315,21 @@
         cluster_name: str,
         resource_name: Union[_models.AttachedDatabaseConfigurationsCheckNameRequest, IO],
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the attached database configuration resource name is valid and is not already in
         use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param resource_name: The name of the resource. Is either a model type or a IO type. Required.
+        :param resource_name: The name of the resource. Is either a
+         AttachedDatabaseConfigurationsCheckNameRequest type or a IO type. Required.
         :type resource_name: ~azure.mgmt.kusto.models.AttachedDatabaseConfigurationsCheckNameRequest or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
@@ -336,24 +343,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(resource_name, (IO, bytes)):
+        if isinstance(resource_name, (IOBase, bytes)):
             _content = resource_name
         else:
             _json = self._serialize.body(resource_name, "AttachedDatabaseConfigurationsCheckNameRequest")
 
         request = build_check_name_availability_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -365,23 +370,25 @@
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -392,31 +399,29 @@
 
     @distributed_trace
     def list_by_cluster(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> Iterable["_models.AttachedDatabaseConfiguration"]:
         """Returns the list of attached database configurations of the given Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AttachedDatabaseConfiguration or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.AttachedDatabaseConfiguration]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AttachedDatabaseConfigurationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -462,22 +467,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_by_cluster.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/attachedDatabaseConfigurations"
@@ -485,15 +492,15 @@
 
     @distributed_trace
     def get(
         self, resource_group_name: str, cluster_name: str, attached_database_configuration_name: str, **kwargs: Any
     ) -> _models.AttachedDatabaseConfiguration:
         """Returns an attached database configuration.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param attached_database_configuration_name: The name of the attached database configuration.
          Required.
         :type attached_database_configuration_name: str
@@ -509,17 +516,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AttachedDatabaseConfiguration] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             attached_database_configuration_name=attached_database_configuration_name,
             subscription_id=self._config.subscription_id,
@@ -527,23 +532,25 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("AttachedDatabaseConfiguration", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -567,24 +574,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AttachedDatabaseConfiguration] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "AttachedDatabaseConfiguration")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -597,35 +602,42 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("AttachedDatabaseConfiguration", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("AttachedDatabaseConfiguration", pipeline_response)
 
         if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
             deserialized = self._deserialize("AttachedDatabaseConfiguration", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_or_update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/attachedDatabaseConfigurations/{attachedDatabaseConfigurationName}"
     }
 
@@ -638,15 +650,15 @@
         parameters: _models.AttachedDatabaseConfiguration,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.AttachedDatabaseConfiguration]:
         """Creates or updates an attached database configuration.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param attached_database_configuration_name: The name of the attached database configuration.
          Required.
         :type attached_database_configuration_name: str
@@ -678,15 +690,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.AttachedDatabaseConfiguration]:
         """Creates or updates an attached database configuration.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param attached_database_configuration_name: The name of the attached database configuration.
          Required.
         :type attached_database_configuration_name: str
@@ -716,24 +728,24 @@
         cluster_name: str,
         attached_database_configuration_name: str,
         parameters: Union[_models.AttachedDatabaseConfiguration, IO],
         **kwargs: Any
     ) -> LROPoller[_models.AttachedDatabaseConfiguration]:
         """Creates or updates an attached database configuration.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param attached_database_configuration_name: The name of the attached database configuration.
          Required.
         :type attached_database_configuration_name: str
         :param parameters: The database parameters supplied to the CreateOrUpdate operation. Is either
-         a model type or a IO type. Required.
+         a AttachedDatabaseConfiguration type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.AttachedDatabaseConfiguration or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -746,17 +758,15 @@
          result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.AttachedDatabaseConfiguration]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AttachedDatabaseConfiguration] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -776,15 +786,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("AttachedDatabaseConfiguration", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -808,17 +820,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             attached_database_configuration_name=attached_database_configuration_name,
             subscription_id=self._config.subscription_id,
@@ -826,38 +836,46 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/attachedDatabaseConfigurations/{attachedDatabaseConfigurationName}"
     }
 
     @distributed_trace
     def begin_delete(
         self, resource_group_name: str, cluster_name: str, attached_database_configuration_name: str, **kwargs: Any
     ) -> LROPoller[None]:
         """Deletes the attached database configuration with the given name.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param attached_database_configuration_name: The name of the attached database configuration.
          Required.
         :type attached_database_configuration_name: str
@@ -872,17 +890,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -897,15 +913,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/_skus_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,116 +2,91 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
-from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
+from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from .. import models as _models
-from .._serialization import Serializer
-from .._vendor import _convert_request
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
-
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
-
-
-def build_list_request(**kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
-    accept = _headers.pop("Accept", "application/json")
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._skus_operations import build_list_request
 
-    # Construct URL
-    _url = kwargs.pop("template_url", "/providers/Microsoft.Kusto/operations")
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+T = TypeVar("T")
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class Operations:
+class SkusOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.kusto.KustoManagementClient`'s
-        :attr:`operations` attribute.
+        :class:`~azure.mgmt.kusto.aio.KustoManagementClient`'s
+        :attr:`skus` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
-        """Lists available operations for the Microsoft.Kusto provider.
+    def list(self, location: str, **kwargs: Any) -> AsyncIterable["_models.SkuDescription"]:
+        """Lists eligible region SKUs for Kusto resource provider by Azure region.
 
+        :param location: The name of Azure region. Required.
+        :type location: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.Operation]
+        :return: An iterator like instance of either SkuDescription or the result of cls(response)
+        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.kusto.models.SkuDescription]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
-        cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.SkuDescriptionList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
+                    location=location,
+                    subscription_id=self._config.subscription_id,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
@@ -130,31 +105,33 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        def extract_data(pipeline_response):
-            deserialized = self._deserialize("OperationListResult", pipeline_response)
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("SkuDescriptionList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
+            return None, AsyncList(list_of_elem)
 
-        def get_next(next_link=None):
+        async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return ItemPaged(get_next, extract_data)
+        return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/providers/Microsoft.Kusto/operations"}
+    list.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/locations/{location}/skus"}
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_private_link_resources_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_private_link_resources_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,41 +25,39 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/privateLinkResources",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -72,27 +69,31 @@
 
 def build_get_request(
     resource_group_name: str, cluster_name: str, private_link_resource_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/privateLinkResources/{privateLinkResourceName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "privateLinkResourceName": _SERIALIZER.url("private_link_resource_name", private_link_resource_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "privateLinkResourceName": _SERIALIZER.url(
+            "private_link_resource_name", private_link_resource_name, "str", pattern=r"^.*$"
+        ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -123,30 +124,28 @@
 
     @distributed_trace
     def list(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> Iterable["_models.PrivateLinkResource"]:
         """Returns the list of private link resources.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either PrivateLinkResource or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.PrivateLinkResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateLinkResourceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -192,22 +191,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/privateLinkResources"
@@ -215,15 +216,15 @@
 
     @distributed_trace
     def get(
         self, resource_group_name: str, cluster_name: str, private_link_resource_name: str, **kwargs: Any
     ) -> _models.PrivateLinkResource:
         """Gets a private link resource.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param private_link_resource_name: The name of the private link resource. Required.
         :type private_link_resource_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -238,17 +239,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateLinkResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             private_link_resource_name=private_link_resource_name,
             subscription_id=self._config.subscription_id,
@@ -256,23 +255,25 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("PrivateLinkResource", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_operations_results_location_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_operations_results_operations.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,119 +23,123 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(location: str, operation_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
+    accept = _headers.pop("Accept", "application/json")
+
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/locations/{location}/operationResults/{operationId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "location": _SERIALIZER.url("location", location, "str"),
-        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "location": _SERIALIZER.url("location", location, "str", min_length=1),
+        "operationId": _SERIALIZER.url("operation_id", operation_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
-    return HttpRequest(method="GET", url=_url, params=_params, **kwargs)
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class OperationsResultsLocationOperations:
+class OperationsResultsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.kusto.KustoManagementClient`'s
-        :attr:`operations_results_location` attribute.
+        :attr:`operations_results` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
-    def get(  # pylint: disable=inconsistent-return-statements
-        self, location: str, operation_id: str, **kwargs: Any
-    ) -> None:
+    def get(self, location: str, operation_id: str, **kwargs: Any) -> _models.OperationResult:
         """Returns operation results.
 
-        :param location: Azure location (region) name. Required.
+        :param location: The name of Azure region. Required.
         :type location: str
-        :param operation_id: The Guid of the operation ID. Required.
+        :param operation_id: The ID of an ongoing async operation. Required.
         :type operation_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: None or the result of cls(response)
-        :rtype: None
+        :return: OperationResult or the result of cls(response)
+        :rtype: ~azure.mgmt.kusto.models.OperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.OperationResult] = kwargs.pop("cls", None)
 
         request = build_get_request(
             location=location,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        deserialized = self._deserialize("OperationResult", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
     get.metadata = {
         "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/locations/{location}/operationResults/{operationId}"
     }
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_private_endpoint_connections_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_private_endpoint_connections_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,41 +28,39 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/privateEndpointConnections",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -78,28 +76,30 @@
     private_endpoint_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/privateEndpointConnections/{privateEndpointConnectionName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
         "privateEndpointConnectionName": _SERIALIZER.url(
-            "private_endpoint_connection_name", private_endpoint_connection_name, "str"
+            "private_endpoint_connection_name", private_endpoint_connection_name, "str", pattern=r"^.*$"
         ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -116,29 +116,31 @@
     private_endpoint_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/privateEndpointConnections/{privateEndpointConnectionName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
         "privateEndpointConnectionName": _SERIALIZER.url(
-            "private_endpoint_connection_name", private_endpoint_connection_name, "str"
+            "private_endpoint_connection_name", private_endpoint_connection_name, "str", pattern=r"^.*$"
         ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -157,28 +159,30 @@
     private_endpoint_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/privateEndpointConnections/{privateEndpointConnectionName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
         "privateEndpointConnectionName": _SERIALIZER.url(
-            "private_endpoint_connection_name", private_endpoint_connection_name, "str"
+            "private_endpoint_connection_name", private_endpoint_connection_name, "str", pattern=r"^.*$"
         ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -210,31 +214,29 @@
 
     @distributed_trace
     def list(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> Iterable["_models.PrivateEndpointConnection"]:
         """Returns the list of private endpoint connections.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either PrivateEndpointConnection or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.PrivateEndpointConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateEndpointConnectionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -280,22 +282,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/privateEndpointConnections"
@@ -303,15 +307,15 @@
 
     @distributed_trace
     def get(
         self, resource_group_name: str, cluster_name: str, private_endpoint_connection_name: str, **kwargs: Any
     ) -> _models.PrivateEndpointConnection:
         """Gets a private endpoint connection.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -326,17 +330,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             private_endpoint_connection_name=private_endpoint_connection_name,
             subscription_id=self._config.subscription_id,
@@ -344,23 +346,25 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("PrivateEndpointConnection", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -384,24 +388,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "PrivateEndpointConnection")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -414,23 +416,25 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("PrivateEndpointConnection", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("PrivateEndpointConnection", pipeline_response)
 
@@ -452,15 +456,15 @@
         parameters: _models.PrivateEndpointConnection,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.PrivateEndpointConnection]:
         """Approve or reject a private endpoint connection with a given name.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
         :param parameters: Required.
@@ -491,15 +495,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.PrivateEndpointConnection]:
         """Approve or reject a private endpoint connection with a given name.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
         :param parameters: Required.
@@ -528,22 +532,22 @@
         cluster_name: str,
         private_endpoint_connection_name: str,
         parameters: Union[_models.PrivateEndpointConnection, IO],
         **kwargs: Any
     ) -> LROPoller[_models.PrivateEndpointConnection]:
         """Approve or reject a private endpoint connection with a given name.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
-        :param parameters: Is either a model type or a IO type. Required.
+        :param parameters: Is either a PrivateEndpointConnection type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.PrivateEndpointConnection or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -556,17 +560,15 @@
          of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.PrivateEndpointConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -586,15 +588,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("PrivateEndpointConnection", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -618,17 +622,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             private_endpoint_connection_name=private_endpoint_connection_name,
             subscription_id=self._config.subscription_id,
@@ -636,38 +638,46 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/privateEndpointConnections/{privateEndpointConnectionName}"
     }
 
     @distributed_trace
     def begin_delete(
         self, resource_group_name: str, cluster_name: str, private_endpoint_connection_name: str, **kwargs: Any
     ) -> LROPoller[None]:
         """Deletes a private endpoint connection with a given name.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -681,17 +691,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -706,15 +714,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_cluster_principal_assignments_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_database_principal_assignments_operations.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,44 +28,43 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_check_name_availability_request(
-    resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/checkPrincipalAssignmentNameAvailability",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/checkPrincipalAssignmentNameAvailability",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -74,65 +73,85 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(
-    resource_group_name: str, cluster_name: str, principal_assignment_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str,
+    cluster_name: str,
+    database_name: str,
+    principal_assignment_name: str,
+    subscription_id: str,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "principalAssignmentName": _SERIALIZER.url("principal_assignment_name", principal_assignment_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "principalAssignmentName": _SERIALIZER.url(
+            "principal_assignment_name", principal_assignment_name, "str", pattern=r"^.*$"
+        ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_or_update_request(
-    resource_group_name: str, cluster_name: str, principal_assignment_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str,
+    cluster_name: str,
+    database_name: str,
+    principal_assignment_name: str,
+    subscription_id: str,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "principalAssignmentName": _SERIALIZER.url("principal_assignment_name", principal_assignment_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "principalAssignmentName": _SERIALIZER.url(
+            "principal_assignment_name", principal_assignment_name, "str", pattern=r"^.*$"
+        ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -141,82 +160,97 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(
-    resource_group_name: str, cluster_name: str, principal_assignment_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str,
+    cluster_name: str,
+    database_name: str,
+    principal_assignment_name: str,
+    subscription_id: str,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "principalAssignmentName": _SERIALIZER.url("principal_assignment_name", principal_assignment_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "principalAssignmentName": _SERIALIZER.url(
+            "principal_assignment_name", principal_assignment_name, "str", pattern=r"^.*$"
+        ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_request(resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_list_request(
+    resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class ClusterPrincipalAssignmentsOperations:
+class DatabasePrincipalAssignmentsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.kusto.KustoManagementClient`'s
-        :attr:`cluster_principal_assignments` attribute.
+        :attr:`database_principal_assignments` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
@@ -225,56 +259,62 @@
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @overload
     def check_name_availability(
         self,
         resource_group_name: str,
         cluster_name: str,
-        principal_assignment_name: _models.ClusterPrincipalAssignmentCheckNameRequest,
+        database_name: str,
+        principal_assignment_name: _models.DatabasePrincipalAssignmentCheckNameRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
-        """Checks that the principal assignment name is valid and is not already in use.
+        """Checks that the database principal assignment is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param principal_assignment_name: The name of the principal assignment. Required.
+        :param database_name: The name of the database in the Kusto cluster. Required.
+        :type database_name: str
+        :param principal_assignment_name: The name of the resource. Required.
         :type principal_assignment_name:
-         ~azure.mgmt.kusto.models.ClusterPrincipalAssignmentCheckNameRequest
+         ~azure.mgmt.kusto.models.DatabasePrincipalAssignmentCheckNameRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.CheckNameResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def check_name_availability(
         self,
         resource_group_name: str,
         cluster_name: str,
+        database_name: str,
         principal_assignment_name: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
-        """Checks that the principal assignment name is valid and is not already in use.
+        """Checks that the database principal assignment is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param principal_assignment_name: The name of the principal assignment. Required.
+        :param database_name: The name of the database in the Kusto cluster. Required.
+        :type database_name: str
+        :param principal_assignment_name: The name of the resource. Required.
         :type principal_assignment_name: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.CheckNameResult
@@ -282,28 +322,31 @@
         """
 
     @distributed_trace
     def check_name_availability(
         self,
         resource_group_name: str,
         cluster_name: str,
-        principal_assignment_name: Union[_models.ClusterPrincipalAssignmentCheckNameRequest, IO],
+        database_name: str,
+        principal_assignment_name: Union[_models.DatabasePrincipalAssignmentCheckNameRequest, IO],
         **kwargs: Any
     ) -> _models.CheckNameResult:
-        """Checks that the principal assignment name is valid and is not already in use.
+        """Checks that the database principal assignment is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param principal_assignment_name: The name of the principal assignment. Is either a model type
-         or a IO type. Required.
+        :param database_name: The name of the database in the Kusto cluster. Required.
+        :type database_name: str
+        :param principal_assignment_name: The name of the resource. Is either a
+         DatabasePrincipalAssignmentCheckNameRequest type or a IO type. Required.
         :type principal_assignment_name:
-         ~azure.mgmt.kusto.models.ClusterPrincipalAssignmentCheckNameRequest or IO
+         ~azure.mgmt.kusto.models.DatabasePrincipalAssignmentCheckNameRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.CheckNameResult
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -315,434 +358,474 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(principal_assignment_name, (IO, bytes)):
+        if isinstance(principal_assignment_name, (IOBase, bytes)):
             _content = principal_assignment_name
         else:
-            _json = self._serialize.body(principal_assignment_name, "ClusterPrincipalAssignmentCheckNameRequest")
+            _json = self._serialize.body(principal_assignment_name, "DatabasePrincipalAssignmentCheckNameRequest")
 
         request = build_check_name_availability_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
+            database_name=database_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     check_name_availability.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/checkPrincipalAssignmentNameAvailability"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/checkPrincipalAssignmentNameAvailability"
     }
 
     @distributed_trace
     def get(
-        self, resource_group_name: str, cluster_name: str, principal_assignment_name: str, **kwargs: Any
-    ) -> _models.ClusterPrincipalAssignment:
-        """Gets a Kusto cluster principalAssignment.
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        database_name: str,
+        principal_assignment_name: str,
+        **kwargs: Any
+    ) -> _models.DatabasePrincipalAssignment:
+        """Gets a Kusto cluster database principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
+        :param database_name: The name of the database in the Kusto cluster. Required.
+        :type database_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
         :type principal_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: ClusterPrincipalAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.kusto.models.ClusterPrincipalAssignment
+        :return: DatabasePrincipalAssignment or the result of cls(response)
+        :rtype: ~azure.mgmt.kusto.models.DatabasePrincipalAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
-        cls: ClsType[_models.ClusterPrincipalAssignment] = kwargs.pop("cls", None)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.DatabasePrincipalAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
+            database_name=database_name,
             principal_assignment_name=principal_assignment_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("ClusterPrincipalAssignment", pipeline_response)
+        deserialized = self._deserialize("DatabasePrincipalAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}"
     }
 
     def _create_or_update_initial(
         self,
         resource_group_name: str,
         cluster_name: str,
+        database_name: str,
         principal_assignment_name: str,
-        parameters: Union[_models.ClusterPrincipalAssignment, IO],
+        parameters: Union[_models.DatabasePrincipalAssignment, IO],
         **kwargs: Any
-    ) -> _models.ClusterPrincipalAssignment:
+    ) -> _models.DatabasePrincipalAssignment:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.ClusterPrincipalAssignment] = kwargs.pop("cls", None)
+        cls: ClsType[_models.DatabasePrincipalAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
-            _json = self._serialize.body(parameters, "ClusterPrincipalAssignment")
+            _json = self._serialize.body(parameters, "DatabasePrincipalAssignment")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
+            database_name=database_name,
             principal_assignment_name=principal_assignment_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
-            deserialized = self._deserialize("ClusterPrincipalAssignment", pipeline_response)
+            deserialized = self._deserialize("DatabasePrincipalAssignment", pipeline_response)
 
         if response.status_code == 201:
-            deserialized = self._deserialize("ClusterPrincipalAssignment", pipeline_response)
+            deserialized = self._deserialize("DatabasePrincipalAssignment", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_or_update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}"
     }
 
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         cluster_name: str,
+        database_name: str,
         principal_assignment_name: str,
-        parameters: _models.ClusterPrincipalAssignment,
+        parameters: _models.DatabasePrincipalAssignment,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.ClusterPrincipalAssignment]:
-        """Create a Kusto cluster principalAssignment.
+    ) -> LROPoller[_models.DatabasePrincipalAssignment]:
+        """Creates a Kusto cluster database principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
+        :param database_name: The name of the database in the Kusto cluster. Required.
+        :type database_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
         :type principal_assignment_name: str
-        :param parameters: The Kusto cluster principalAssignment's parameters supplied for the
-         operation. Required.
-        :type parameters: ~azure.mgmt.kusto.models.ClusterPrincipalAssignment
+        :param parameters: The Kusto principalAssignments parameters supplied for the operation.
+         Required.
+        :type parameters: ~azure.mgmt.kusto.models.DatabasePrincipalAssignment
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either ClusterPrincipalAssignment or the result
+        :return: An instance of LROPoller that returns either DatabasePrincipalAssignment or the result
          of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.ClusterPrincipalAssignment]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.DatabasePrincipalAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create_or_update(
         self,
         resource_group_name: str,
         cluster_name: str,
+        database_name: str,
         principal_assignment_name: str,
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.ClusterPrincipalAssignment]:
-        """Create a Kusto cluster principalAssignment.
+    ) -> LROPoller[_models.DatabasePrincipalAssignment]:
+        """Creates a Kusto cluster database principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
+        :param database_name: The name of the database in the Kusto cluster. Required.
+        :type database_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
         :type principal_assignment_name: str
-        :param parameters: The Kusto cluster principalAssignment's parameters supplied for the
-         operation. Required.
+        :param parameters: The Kusto principalAssignments parameters supplied for the operation.
+         Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either ClusterPrincipalAssignment or the result
+        :return: An instance of LROPoller that returns either DatabasePrincipalAssignment or the result
          of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.ClusterPrincipalAssignment]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.DatabasePrincipalAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create_or_update(
         self,
         resource_group_name: str,
         cluster_name: str,
+        database_name: str,
         principal_assignment_name: str,
-        parameters: Union[_models.ClusterPrincipalAssignment, IO],
+        parameters: Union[_models.DatabasePrincipalAssignment, IO],
         **kwargs: Any
-    ) -> LROPoller[_models.ClusterPrincipalAssignment]:
-        """Create a Kusto cluster principalAssignment.
+    ) -> LROPoller[_models.DatabasePrincipalAssignment]:
+        """Creates a Kusto cluster database principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
+        :param database_name: The name of the database in the Kusto cluster. Required.
+        :type database_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
         :type principal_assignment_name: str
-        :param parameters: The Kusto cluster principalAssignment's parameters supplied for the
-         operation. Is either a model type or a IO type. Required.
-        :type parameters: ~azure.mgmt.kusto.models.ClusterPrincipalAssignment or IO
+        :param parameters: The Kusto principalAssignments parameters supplied for the operation. Is
+         either a DatabasePrincipalAssignment type or a IO type. Required.
+        :type parameters: ~azure.mgmt.kusto.models.DatabasePrincipalAssignment or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either ClusterPrincipalAssignment or the result
+        :return: An instance of LROPoller that returns either DatabasePrincipalAssignment or the result
          of cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.ClusterPrincipalAssignment]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.DatabasePrincipalAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.ClusterPrincipalAssignment] = kwargs.pop("cls", None)
+        cls: ClsType[_models.DatabasePrincipalAssignment] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
+                database_name=database_name,
                 principal_assignment_name=principal_assignment_name,
                 parameters=parameters,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("ClusterPrincipalAssignment", pipeline_response)
+            deserialized = self._deserialize("DatabasePrincipalAssignment", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create_or_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}"
     }
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, cluster_name: str, principal_assignment_name: str, **kwargs: Any
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        database_name: str,
+        principal_assignment_name: str,
+        **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
+            database_name=database_name,
             principal_assignment_name=principal_assignment_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}"
     }
 
     @distributed_trace
     def begin_delete(
-        self, resource_group_name: str, cluster_name: str, principal_assignment_name: str, **kwargs: Any
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        database_name: str,
+        principal_assignment_name: str,
+        **kwargs: Any
     ) -> LROPoller[None]:
-        """Deletes a Kusto cluster principalAssignment.
+        """Deletes a Kusto principalAssignment.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
+        :param database_name: The name of the database in the Kusto cluster. Required.
+        :type database_name: str
         :param principal_assignment_name: The name of the Kusto principalAssignment. Required.
         :type principal_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
@@ -752,81 +835,82 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 cluster_name=cluster_name,
+                database_name=database_name,
                 principal_assignment_name=principal_assignment_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments/{principalAssignmentName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments/{principalAssignmentName}"
     }
 
     @distributed_trace
     def list(
-        self, resource_group_name: str, cluster_name: str, **kwargs: Any
-    ) -> Iterable["_models.ClusterPrincipalAssignment"]:
-        """Lists all Kusto cluster principalAssignments.
+        self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
+    ) -> Iterable["_models.DatabasePrincipalAssignment"]:
+        """Lists all Kusto cluster database principalAssignments.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
+        :param database_name: The name of the database in the Kusto cluster. Required.
+        :type database_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either ClusterPrincipalAssignment or the result of
+        :return: An iterator like instance of either DatabasePrincipalAssignment or the result of
          cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.ClusterPrincipalAssignment]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.DatabasePrincipalAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
-        cls: ClsType[_models.ClusterPrincipalAssignmentListResult] = kwargs.pop("cls", None)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.DatabasePrincipalAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -834,14 +918,15 @@
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
                     resource_group_name=resource_group_name,
                     cluster_name=cluster_name,
+                    database_name=database_name,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
@@ -862,32 +947,34 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("ClusterPrincipalAssignmentListResult", pipeline_response)
+            deserialized = self._deserialize("DatabasePrincipalAssignmentListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/principalAssignments"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/principalAssignments"
     }
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_data_connections_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_data_connections_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,44 +28,42 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_by_database_request(
     resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/dataConnections",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -77,28 +75,30 @@
 
 def build_data_connection_validation_request(
     resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/dataConnectionValidation",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -112,28 +112,30 @@
 
 def build_check_name_availability_request(
     resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/checkNameAvailability",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -152,28 +154,30 @@
     data_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/dataConnections/{dataConnectionName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "dataConnectionName": _SERIALIZER.url("data_connection_name", data_connection_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "dataConnectionName": _SERIALIZER.url("data_connection_name", data_connection_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -190,29 +194,31 @@
     data_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/dataConnections/{dataConnectionName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "dataConnectionName": _SERIALIZER.url("data_connection_name", data_connection_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "dataConnectionName": _SERIALIZER.url("data_connection_name", data_connection_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -231,29 +237,31 @@
     data_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/dataConnections/{dataConnectionName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "dataConnectionName": _SERIALIZER.url("data_connection_name", data_connection_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "dataConnectionName": _SERIALIZER.url("data_connection_name", data_connection_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -272,28 +280,30 @@
     data_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/dataConnections/{dataConnectionName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "dataConnectionName": _SERIALIZER.url("data_connection_name", data_connection_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "dataConnectionName": _SERIALIZER.url("data_connection_name", data_connection_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -324,32 +334,30 @@
 
     @distributed_trace
     def list_by_database(
         self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
     ) -> Iterable["_models.DataConnection"]:
         """Returns the list of data connections of the given Kusto database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DataConnection or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.DataConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DataConnectionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -396,22 +404,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_by_database.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/dataConnections"
@@ -432,24 +442,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[Optional[_models.DataConnectionValidationListResult]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "DataConnectionValidation")
 
         request = build_data_connection_validation_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -462,30 +470,38 @@
             template_url=self._data_connection_validation_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
+        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("DataConnectionValidationListResult", pipeline_response)
 
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _data_connection_validation_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/dataConnectionValidation"
     }
 
@@ -498,15 +514,15 @@
         parameters: _models.DataConnectionValidation,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.DataConnectionValidationListResult]:
         """Checks that the data connection parameters are valid.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param parameters: The data connection parameters supplied to the CreateOrUpdate operation.
@@ -539,15 +555,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.DataConnectionValidationListResult]:
         """Checks that the data connection parameters are valid.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param parameters: The data connection parameters supplied to the CreateOrUpdate operation.
@@ -578,23 +594,23 @@
         cluster_name: str,
         database_name: str,
         parameters: Union[_models.DataConnectionValidation, IO],
         **kwargs: Any
     ) -> LROPoller[_models.DataConnectionValidationListResult]:
         """Checks that the data connection parameters are valid.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param parameters: The data connection parameters supplied to the CreateOrUpdate operation. Is
-         either a model type or a IO type. Required.
+         either a DataConnectionValidation type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.DataConnectionValidation or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -608,17 +624,15 @@
         :rtype:
          ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.DataConnectionValidationListResult]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.DataConnectionValidationListResult] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._data_connection_validation_initial(
@@ -671,15 +685,15 @@
         data_connection_name: _models.DataConnectionCheckNameRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the data connection name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
@@ -702,15 +716,15 @@
         data_connection_name: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the data connection name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
@@ -731,23 +745,23 @@
         cluster_name: str,
         database_name: str,
         data_connection_name: Union[_models.DataConnectionCheckNameRequest, IO],
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the data connection name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
-        :param data_connection_name: The name of the data connection. Is either a model type or a IO
-         type. Required.
+        :param data_connection_name: The name of the data connection. Is either a
+         DataConnectionCheckNameRequest type or a IO type. Required.
         :type data_connection_name: ~azure.mgmt.kusto.models.DataConnectionCheckNameRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.CheckNameResult
@@ -760,24 +774,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(data_connection_name, (IO, bytes)):
+        if isinstance(data_connection_name, (IOBase, bytes)):
             _content = data_connection_name
         else:
             _json = self._serialize.body(data_connection_name, "DataConnectionCheckNameRequest")
 
         request = build_check_name_availability_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -790,23 +802,25 @@
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -817,15 +831,15 @@
 
     @distributed_trace
     def get(
         self, resource_group_name: str, cluster_name: str, database_name: str, data_connection_name: str, **kwargs: Any
     ) -> _models.DataConnection:
         """Returns a data connection.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
@@ -842,17 +856,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DataConnection] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             database_name=database_name,
             data_connection_name=data_connection_name,
@@ -861,23 +873,25 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("DataConnection", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -902,24 +916,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.DataConnection] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "DataConnection")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -933,35 +945,42 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("DataConnection", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("DataConnection", pipeline_response)
 
         if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
             deserialized = self._deserialize("DataConnection", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_or_update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/dataConnections/{dataConnectionName}"
     }
 
@@ -975,15 +994,15 @@
         parameters: _models.DataConnection,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.DataConnection]:
         """Creates or updates a data connection.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
@@ -1018,15 +1037,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.DataConnection]:
         """Creates or updates a data connection.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
@@ -1059,25 +1078,25 @@
         database_name: str,
         data_connection_name: str,
         parameters: Union[_models.DataConnection, IO],
         **kwargs: Any
     ) -> LROPoller[_models.DataConnection]:
         """Creates or updates a data connection.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
         :type data_connection_name: str
         :param parameters: The data connection parameters supplied to the CreateOrUpdate operation. Is
-         either a model type or a IO type. Required.
+         either a DataConnection type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.DataConnection or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -1090,17 +1109,15 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.DataConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.DataConnection] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -1121,15 +1138,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("DataConnection", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -1159,24 +1178,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.DataConnection] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "DataConnection")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1190,23 +1207,25 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("DataConnection", pipeline_response)
 
         if response.status_code == 201:
             response_headers["Azure-AsyncOperation"] = self._deserialize(
@@ -1241,15 +1260,15 @@
         parameters: _models.DataConnection,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.DataConnection]:
         """Updates a data connection.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
@@ -1283,15 +1302,15 @@
         parameters: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.DataConnection]:
         """Updates a data connection.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
@@ -1323,25 +1342,25 @@
         database_name: str,
         data_connection_name: str,
         parameters: Union[_models.DataConnection, IO],
         **kwargs: Any
     ) -> LROPoller[_models.DataConnection]:
         """Updates a data connection.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
         :type data_connection_name: str
         :param parameters: The data connection parameters supplied to the Update operation. Is either a
-         model type or a IO type. Required.
+         DataConnection type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.DataConnection or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -1354,17 +1373,15 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.DataConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.DataConnection] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1385,15 +1402,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("DataConnection", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -1417,17 +1436,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             database_name=database_name,
             data_connection_name=data_connection_name,
@@ -1436,38 +1453,46 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/dataConnections/{dataConnectionName}"
     }
 
     @distributed_trace
     def begin_delete(
         self, resource_group_name: str, cluster_name: str, database_name: str, data_connection_name: str, **kwargs: Any
     ) -> LROPoller[None]:
         """Deletes the data connection with the given name.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param data_connection_name: The name of the data connection. Required.
@@ -1483,17 +1508,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1509,15 +1532,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_patch.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/__init__.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/aio/operations/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -8,14 +8,15 @@
 
 from ._clusters_operations import ClustersOperations
 from ._cluster_principal_assignments_operations import ClusterPrincipalAssignmentsOperations
 from ._skus_operations import SkusOperations
 from ._databases_operations import DatabasesOperations
 from ._attached_database_configurations_operations import AttachedDatabaseConfigurationsOperations
 from ._managed_private_endpoints_operations import ManagedPrivateEndpointsOperations
+from ._database_operations import DatabaseOperations
 from ._database_principal_assignments_operations import DatabasePrincipalAssignmentsOperations
 from ._scripts_operations import ScriptsOperations
 from ._private_endpoint_connections_operations import PrivateEndpointConnectionsOperations
 from ._private_link_resources_operations import PrivateLinkResourcesOperations
 from ._data_connections_operations import DataConnectionsOperations
 from ._operations import Operations
 from ._operations_results_operations import OperationsResultsOperations
@@ -28,14 +29,15 @@
 __all__ = [
     "ClustersOperations",
     "ClusterPrincipalAssignmentsOperations",
     "SkusOperations",
     "DatabasesOperations",
     "AttachedDatabaseConfigurationsOperations",
     "ManagedPrivateEndpointsOperations",
+    "DatabaseOperations",
     "DatabasePrincipalAssignmentsOperations",
     "ScriptsOperations",
     "PrivateEndpointConnectionsOperations",
     "PrivateLinkResourcesOperations",
     "DataConnectionsOperations",
     "Operations",
     "OperationsResultsOperations",
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_databases_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_databases_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,44 +28,42 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_check_name_availability_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/checkNameAvailability",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -74,63 +72,77 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_cluster_request(
-    resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str,
+    cluster_name: str,
+    subscription_id: str,
+    *,
+    top: Optional[int] = None,
+    skiptoken: Optional[str] = None,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if top is not None:
+        _params["$top"] = _SERIALIZER.query("top", top, "int", maximum=1000, minimum=5)
+    if skiptoken is not None:
+        _params["$skiptoken"] = _SERIALIZER.query("skiptoken", skiptoken, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(
     resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -148,28 +160,30 @@
     *,
     caller_role: Union[str, _models.CallerRole] = "Admin",
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
     if caller_role is not None:
@@ -191,28 +205,30 @@
     *,
     caller_role: Union[str, _models.CallerRole] = "Admin",
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
     if caller_role is not None:
@@ -228,27 +244,29 @@
 
 def build_delete_request(
     resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -260,27 +278,29 @@
 
 def build_list_principals_request(
     resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/listPrincipals",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -292,28 +312,30 @@
 
 def build_add_principals_request(
     resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/addPrincipals",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -327,28 +349,30 @@
 
 def build_remove_principals_request(
     resource_group_name: str, cluster_name: str, database_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/removePrincipals",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "databaseName": _SERIALIZER.url("database_name", database_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "databaseName": _SERIALIZER.url("database_name", database_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -387,15 +411,15 @@
         resource_name: _models.CheckNameRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the databases resource name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param resource_name: The name of the resource. Required.
         :type resource_name: ~azure.mgmt.kusto.models.CheckNameRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
@@ -415,15 +439,15 @@
         resource_name: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the databases resource name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param resource_name: The name of the resource. Required.
         :type resource_name: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -441,20 +465,21 @@
         resource_group_name: str,
         cluster_name: str,
         resource_name: Union[_models.CheckNameRequest, IO],
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the databases resource name is valid and is not already in use.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param resource_name: The name of the resource. Is either a model type or a IO type. Required.
+        :param resource_name: The name of the resource. Is either a CheckNameRequest type or a IO type.
+         Required.
         :type resource_name: ~azure.mgmt.kusto.models.CheckNameRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.CheckNameResult
@@ -467,24 +492,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(resource_name, (IO, bytes)):
+        if isinstance(resource_name, (IOBase, bytes)):
             _content = resource_name
         else:
             _json = self._serialize.body(resource_name, "CheckNameRequest")
 
         request = build_check_name_availability_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -496,57 +519,69 @@
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     check_name_availability.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/checkNameAvailability"
     }
 
     @distributed_trace
     def list_by_cluster(
-        self, resource_group_name: str, cluster_name: str, **kwargs: Any
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        top: Optional[int] = None,
+        skiptoken: Optional[str] = None,
+        **kwargs: Any
     ) -> Iterable["_models.Database"]:
         """Returns the list of databases of the given Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
+        :param top: limit the number of results. Default value is None.
+        :type top: int
+        :param skiptoken: Skiptoken is only used if a previous operation returned a partial result. If
+         a previous response contains a nextLink element, the value of the nextLink element will include
+         a skiptoken parameter that specifies a starting point to use for subsequent calls. Default
+         value is None.
+        :type skiptoken: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Database or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DatabaseListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -556,14 +591,16 @@
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_by_cluster_request(
                     resource_group_name=resource_group_name,
                     cluster_name=cluster_name,
                     subscription_id=self._config.subscription_id,
+                    top=top,
+                    skiptoken=skiptoken,
                     api_version=api_version,
                     template_url=self.list_by_cluster.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
@@ -587,41 +624,43 @@
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("DatabaseListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return None, iter(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_by_cluster.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases"
     }
 
     @distributed_trace
     def get(self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any) -> _models.Database:
         """Returns a database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -636,17 +675,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             database_name=database_name,
             subscription_id=self._config.subscription_id,
@@ -654,23 +691,25 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("Database", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -695,24 +734,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Database")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -726,35 +763,42 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("Database", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("Database", pipeline_response)
 
         if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
             deserialized = self._deserialize("Database", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_or_update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}"
     }
 
@@ -768,15 +812,15 @@
         caller_role: Union[str, _models.CallerRole] = "Admin",
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.Database]:
         """Creates or updates a database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param parameters: The database parameters supplied to the CreateOrUpdate operation. Required.
@@ -811,15 +855,15 @@
         caller_role: Union[str, _models.CallerRole] = "Admin",
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.Database]:
         """Creates or updates a database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param parameters: The database parameters supplied to the CreateOrUpdate operation. Required.
@@ -852,23 +896,23 @@
         database_name: str,
         parameters: Union[_models.Database, IO],
         caller_role: Union[str, _models.CallerRole] = "Admin",
         **kwargs: Any
     ) -> LROPoller[_models.Database]:
         """Creates or updates a database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param parameters: The database parameters supplied to the CreateOrUpdate operation. Is either
-         a model type or a IO type. Required.
+         a Database type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.Database or IO
         :param caller_role: By default, any user who run operation on a database become an Admin on it.
          This property allows the caller to exclude the caller from Admins list. Known values are:
          "Admin" and "None". Default value is "Admin".
         :type caller_role: str or ~azure.mgmt.kusto.models.CallerRole
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -884,17 +928,15 @@
         :return: An instance of LROPoller that returns either Database or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -915,15 +957,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Database", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -953,24 +997,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Database")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -984,23 +1026,25 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("Database", pipeline_response)
 
         if response.status_code == 201:
             response_headers["Azure-AsyncOperation"] = self._deserialize(
@@ -1035,15 +1079,15 @@
         caller_role: Union[str, _models.CallerRole] = "Admin",
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.Database]:
         """Updates a database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param parameters: The database parameters supplied to the Update operation. Required.
@@ -1078,15 +1122,15 @@
         caller_role: Union[str, _models.CallerRole] = "Admin",
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.Database]:
         """Updates a database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param parameters: The database parameters supplied to the Update operation. Required.
@@ -1119,23 +1163,23 @@
         database_name: str,
         parameters: Union[_models.Database, IO],
         caller_role: Union[str, _models.CallerRole] = "Admin",
         **kwargs: Any
     ) -> LROPoller[_models.Database]:
         """Updates a database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
-        :param parameters: The database parameters supplied to the Update operation. Is either a model
-         type or a IO type. Required.
+        :param parameters: The database parameters supplied to the Update operation. Is either a
+         Database type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.Database or IO
         :param caller_role: By default, any user who run operation on a database become an Admin on it.
          This property allows the caller to exclude the caller from Admins list. Known values are:
          "Admin" and "None". Default value is "Admin".
         :type caller_role: str or ~azure.mgmt.kusto.models.CallerRole
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -1151,17 +1195,15 @@
         :return: An instance of LROPoller that returns either Database or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.Database]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Database] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1182,15 +1224,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Database", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -1214,17 +1258,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             database_name=database_name,
             subscription_id=self._config.subscription_id,
@@ -1232,38 +1274,46 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}"
     }
 
     @distributed_trace
     def begin_delete(
         self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
     ) -> LROPoller[None]:
         """Deletes the database with the given name.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -1277,17 +1327,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1302,15 +1350,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -1326,32 +1376,30 @@
 
     @distributed_trace
     def list_principals(
         self, resource_group_name: str, cluster_name: str, database_name: str, **kwargs: Any
     ) -> Iterable["_models.DatabasePrincipal"]:
         """Returns a list of database principals of the given Kusto cluster and database.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either DatabasePrincipal or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.DatabasePrincipal]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DatabasePrincipalListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1398,22 +1446,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_principals.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/databases/{databaseName}/listPrincipals"
@@ -1428,15 +1478,15 @@
         database_principals_to_add: _models.DatabasePrincipalListRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.DatabasePrincipalListResult:
         """Add Database principals permissions.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param database_principals_to_add: List of database principals to add. Required.
@@ -1459,15 +1509,15 @@
         database_principals_to_add: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.DatabasePrincipalListResult:
         """Add Database principals permissions.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param database_principals_to_add: List of database principals to add. Required.
@@ -1488,23 +1538,23 @@
         cluster_name: str,
         database_name: str,
         database_principals_to_add: Union[_models.DatabasePrincipalListRequest, IO],
         **kwargs: Any
     ) -> _models.DatabasePrincipalListResult:
         """Add Database principals permissions.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
-        :param database_principals_to_add: List of database principals to add. Is either a model type
-         or a IO type. Required.
+        :param database_principals_to_add: List of database principals to add. Is either a
+         DatabasePrincipalListRequest type or a IO type. Required.
         :type database_principals_to_add: ~azure.mgmt.kusto.models.DatabasePrincipalListRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DatabasePrincipalListResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.DatabasePrincipalListResult
@@ -1517,24 +1567,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.DatabasePrincipalListResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(database_principals_to_add, (IO, bytes)):
+        if isinstance(database_principals_to_add, (IOBase, bytes)):
             _content = database_principals_to_add
         else:
             _json = self._serialize.body(database_principals_to_add, "DatabasePrincipalListRequest")
 
         request = build_add_principals_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1547,23 +1595,25 @@
             template_url=self.add_principals.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("DatabasePrincipalListResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -1581,15 +1631,15 @@
         database_principals_to_remove: _models.DatabasePrincipalListRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.DatabasePrincipalListResult:
         """Remove Database principals permissions.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param database_principals_to_remove: List of database principals to remove. Required.
@@ -1612,15 +1662,15 @@
         database_principals_to_remove: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.DatabasePrincipalListResult:
         """Remove Database principals permissions.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
         :param database_principals_to_remove: List of database principals to remove. Required.
@@ -1641,23 +1691,23 @@
         cluster_name: str,
         database_name: str,
         database_principals_to_remove: Union[_models.DatabasePrincipalListRequest, IO],
         **kwargs: Any
     ) -> _models.DatabasePrincipalListResult:
         """Remove Database principals permissions.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param database_name: The name of the database in the Kusto cluster. Required.
         :type database_name: str
-        :param database_principals_to_remove: List of database principals to remove. Is either a model
-         type or a IO type. Required.
+        :param database_principals_to_remove: List of database principals to remove. Is either a
+         DatabasePrincipalListRequest type or a IO type. Required.
         :type database_principals_to_remove: ~azure.mgmt.kusto.models.DatabasePrincipalListRequest or
          IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: DatabasePrincipalListResult or the result of cls(response)
@@ -1671,24 +1721,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.DatabasePrincipalListResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(database_principals_to_remove, (IO, bytes)):
+        if isinstance(database_principals_to_remove, (IOBase, bytes)):
             _content = database_principals_to_remove
         else:
             _json = self._serialize.body(database_principals_to_remove, "DatabasePrincipalListRequest")
 
         request = build_remove_principals_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1701,23 +1749,25 @@
             template_url=self.remove_principals.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("DatabasePrincipalListResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
```

## Comparing `azure-mgmt-kusto-3.1.0b1/azure/mgmt/kusto/operations/_clusters_operations.py` & `azure-mgmt-kusto-3.2.0/azure/mgmt/kusto/operations/_clusters_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,41 +28,39 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -80,27 +78,29 @@
     if_match: Optional[str] = None,
     if_none_match: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -118,27 +118,29 @@
 
 def build_update_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, *, if_match: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -154,26 +156,28 @@
 
 def build_delete_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -183,26 +187,28 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_stop_request(resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/stop",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -214,57 +220,97 @@
 
 def build_start_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/start",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
+def build_migrate_request(
+    resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/migrate",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
 def build_list_follower_databases_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/listFollowerDatabases",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -276,27 +322,29 @@
 
 def build_detach_follower_databases_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/detachFollowerDatabases",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -310,26 +358,28 @@
 
 def build_diagnose_virtual_network_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/diagnoseVirtualNetwork",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -339,25 +389,27 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -367,21 +419,21 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/clusters")
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -391,21 +443,21 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_skus_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/skus")
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -415,26 +467,26 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_check_name_availability_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/locations/{location}/checkNameAvailability",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "location": _SERIALIZER.url("location", location, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "location": _SERIALIZER.url("location", location, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -448,26 +500,28 @@
 
 def build_list_skus_by_resource_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/skus",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -479,26 +533,28 @@
 
 def build_list_outbound_network_dependencies_endpoints_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/outboundNetworkDependenciesEndpoints",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -510,26 +566,28 @@
 
 def build_list_language_extensions_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/listLanguageExtensions",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -541,27 +599,29 @@
 
 def build_add_language_extensions_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/addLanguageExtensions",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -575,27 +635,29 @@
 
 def build_remove_language_extensions_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-11-11"] = kwargs.pop("api_version", _params.pop("api-version", "2022-11-11"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-05-02"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/removeLanguageExtensions",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url("resource_group_name", resource_group_name, "str"),
-        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "clusterName": _SERIALIZER.url("cluster_name", cluster_name, "str", pattern=r"^.*$"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -626,15 +688,15 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def get(self, resource_group_name: str, cluster_name: str, **kwargs: Any) -> _models.Cluster:
         """Gets a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Cluster or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.Cluster
@@ -647,40 +709,40 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("Cluster", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -705,24 +767,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Cluster")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -736,23 +796,25 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
             deserialized = self._deserialize("Cluster", pipeline_response)
 
         if response.status_code == 201:
             deserialized = self._deserialize("Cluster", pipeline_response)
 
@@ -775,15 +837,15 @@
         if_none_match: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.Cluster]:
         """Create or update a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param parameters: The Kusto cluster parameters supplied to the CreateOrUpdate operation.
          Required.
         :type parameters: ~azure.mgmt.kusto.models.Cluster
@@ -821,15 +883,15 @@
         if_none_match: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.Cluster]:
         """Create or update a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param parameters: The Kusto cluster parameters supplied to the CreateOrUpdate operation.
          Required.
         :type parameters: IO
@@ -865,21 +927,21 @@
         parameters: Union[_models.Cluster, IO],
         if_match: Optional[str] = None,
         if_none_match: Optional[str] = None,
         **kwargs: Any
     ) -> LROPoller[_models.Cluster]:
         """Create or update a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param parameters: The Kusto cluster parameters supplied to the CreateOrUpdate operation. Is
-         either a model type or a IO type. Required.
+         either a Cluster type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.Cluster or IO
         :param if_match: The ETag of the cluster. Omit this value to always overwrite the current
          cluster. Specify the last-seen ETag value to prevent accidentally overwriting concurrent
          changes. Default value is None.
         :type if_match: str
         :param if_none_match: Set to '*' to allow a new cluster to be created, but to prevent updating
          an existing cluster. Other values will result in a 412 Pre-condition Failed response. Default
@@ -899,17 +961,15 @@
         :return: An instance of LROPoller that returns either Cluster or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -930,15 +990,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Cluster", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -967,24 +1029,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ClusterUpdate")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -997,23 +1057,25 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("Cluster", pipeline_response)
 
         if response.status_code == 201:
             response_headers["Azure-AsyncOperation"] = self._deserialize(
@@ -1047,15 +1109,15 @@
         if_match: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.Cluster]:
         """Update a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param parameters: The Kusto cluster parameters supplied to the Update operation. Required.
         :type parameters: ~azure.mgmt.kusto.models.ClusterUpdate
         :param if_match: The ETag of the cluster. Omit this value to always overwrite the current
@@ -1087,15 +1149,15 @@
         if_match: Optional[str] = None,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[_models.Cluster]:
         """Update a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param parameters: The Kusto cluster parameters supplied to the Update operation. Required.
         :type parameters: IO
         :param if_match: The ETag of the cluster. Omit this value to always overwrite the current
@@ -1125,21 +1187,21 @@
         cluster_name: str,
         parameters: Union[_models.ClusterUpdate, IO],
         if_match: Optional[str] = None,
         **kwargs: Any
     ) -> LROPoller[_models.Cluster]:
         """Update a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param parameters: The Kusto cluster parameters supplied to the Update operation. Is either a
-         model type or a IO type. Required.
+         ClusterUpdate type or a IO type. Required.
         :type parameters: ~azure.mgmt.kusto.models.ClusterUpdate or IO
         :param if_match: The ETag of the cluster. Omit this value to always overwrite the current
          cluster. Specify the last-seen ETag value to prevent accidentally overwriting concurrent
          changes. Default value is None.
         :type if_match: str
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
@@ -1155,17 +1217,15 @@
         :return: An instance of LROPoller that returns either Cluster or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
@@ -1185,15 +1245,17 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("Cluster", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -1217,53 +1279,59 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}"
     }
 
     @distributed_trace
     def begin_delete(self, resource_group_name: str, cluster_name: str, **kwargs: Any) -> LROPoller[None]:
         """Deletes a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -1275,17 +1343,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1299,15 +1365,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -1331,53 +1399,59 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._stop_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _stop_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/stop"
     }
 
     @distributed_trace
     def begin_stop(self, resource_group_name: str, cluster_name: str, **kwargs: Any) -> LROPoller[None]:
         """Stops a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -1389,17 +1463,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._stop_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1413,15 +1485,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -1445,53 +1519,59 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_start_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._start_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _start_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/start"
     }
 
     @distributed_trace
     def begin_start(self, resource_group_name: str, cluster_name: str, **kwargs: Any) -> LROPoller[None]:
         """Starts a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -1503,17 +1583,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._start_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1527,15 +1605,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -1545,38 +1625,257 @@
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_start.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/start"
     }
 
+    def _migrate_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        cluster_migrate_request: Union[_models.ClusterMigrateRequest, IO],
+        **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(cluster_migrate_request, (IOBase, bytes)):
+            _content = cluster_migrate_request
+        else:
+            _json = self._serialize.body(cluster_migrate_request, "ClusterMigrateRequest")
+
+        request = build_migrate_request(
+            resource_group_name=resource_group_name,
+            cluster_name=cluster_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._migrate_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200, 202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    _migrate_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/migrate"
+    }
+
+    @overload
+    def begin_migrate(
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        cluster_migrate_request: _models.ClusterMigrateRequest,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Migrate data from a Kusto cluster to another cluster.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param cluster_name: The name of the Kusto cluster. Required.
+        :type cluster_name: str
+        :param cluster_migrate_request: The cluster migrate request parameters. Required.
+        :type cluster_migrate_request: ~azure.mgmt.kusto.models.ClusterMigrateRequest
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    def begin_migrate(
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        cluster_migrate_request: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Migrate data from a Kusto cluster to another cluster.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param cluster_name: The name of the Kusto cluster. Required.
+        :type cluster_name: str
+        :param cluster_migrate_request: The cluster migrate request parameters. Required.
+        :type cluster_migrate_request: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @distributed_trace
+    def begin_migrate(
+        self,
+        resource_group_name: str,
+        cluster_name: str,
+        cluster_migrate_request: Union[_models.ClusterMigrateRequest, IO],
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Migrate data from a Kusto cluster to another cluster.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param cluster_name: The name of the Kusto cluster. Required.
+        :type cluster_name: str
+        :param cluster_migrate_request: The cluster migrate request parameters. Is either a
+         ClusterMigrateRequest type or a IO type. Required.
+        :type cluster_migrate_request: ~azure.mgmt.kusto.models.ClusterMigrateRequest or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = self._migrate_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                cluster_name=cluster_name,
+                cluster_migrate_request=cluster_migrate_request,
+                api_version=api_version,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
+
+        if polling is True:
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(PollingMethod, NoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return LROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_migrate.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/migrate"
+    }
+
     @distributed_trace
     def list_follower_databases(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> Iterable["_models.FollowerDatabaseDefinition"]:
         """Returns a list of databases that are owned by this cluster and were followed by another
         cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either FollowerDatabaseDefinition or the result of
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.FollowerDatabaseDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.FollowerDatabaseListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1622,22 +1921,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_follower_databases.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/listFollowerDatabases"
@@ -1657,24 +1958,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(follower_database_to_remove, (IO, bytes)):
+        if isinstance(follower_database_to_remove, (IOBase, bytes)):
             _content = follower_database_to_remove
         else:
             _json = self._serialize.body(follower_database_to_remove, "FollowerDatabaseDefinition")
 
         request = build_detach_follower_databases_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1686,26 +1985,34 @@
             template_url=self._detach_follower_databases_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _detach_follower_databases_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/detachFollowerDatabases"
     }
 
     @overload
     def begin_detach_follower_databases(
@@ -1715,15 +2022,15 @@
         follower_database_to_remove: _models.FollowerDatabaseDefinition,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[None]:
         """Detaches all followers of a database owned by this cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param follower_database_to_remove: The follower databases properties to remove. Required.
         :type follower_database_to_remove: ~azure.mgmt.kusto.models.FollowerDatabaseDefinition
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
@@ -1750,15 +2057,15 @@
         follower_database_to_remove: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[None]:
         """Detaches all followers of a database owned by this cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param follower_database_to_remove: The follower databases properties to remove. Required.
         :type follower_database_to_remove: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -1783,21 +2090,21 @@
         resource_group_name: str,
         cluster_name: str,
         follower_database_to_remove: Union[_models.FollowerDatabaseDefinition, IO],
         **kwargs: Any
     ) -> LROPoller[None]:
         """Detaches all followers of a database owned by this cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param follower_database_to_remove: The follower databases properties to remove. Is either a
-         model type or a IO type. Required.
+         FollowerDatabaseDefinition type or a IO type. Required.
         :type follower_database_to_remove: ~azure.mgmt.kusto.models.FollowerDatabaseDefinition or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -1809,17 +2116,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._detach_follower_databases_initial(  # type: ignore
@@ -1836,15 +2141,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -1868,62 +2175,68 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[Optional[_models.DiagnoseVirtualNetworkResult]] = kwargs.pop("cls", None)
 
         request = build_diagnose_virtual_network_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._diagnose_virtual_network_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
+        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("DiagnoseVirtualNetworkResult", pipeline_response)
 
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
         if cls:
-            return cls(pipeline_response, deserialized, {})
+            return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _diagnose_virtual_network_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/diagnoseVirtualNetwork"
     }
 
     @distributed_trace
     def begin_diagnose_virtual_network(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> LROPoller[_models.DiagnoseVirtualNetworkResult]:
         """Diagnoses network connectivity status for external resources on which the service is dependent
         on.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -1936,17 +2249,15 @@
          result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.kusto.models.DiagnoseVirtualNetworkResult]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.DiagnoseVirtualNetworkResult] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._diagnose_virtual_network_initial(
                 resource_group_name=resource_group_name,
@@ -1986,28 +2297,26 @@
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/diagnoseVirtualNetwork"
     }
 
     @distributed_trace
     def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.Cluster"]:
         """Lists all Kusto clusters within a resource group.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Cluster or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ClusterListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -2052,22 +2361,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_by_resource_group.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters"
@@ -2081,17 +2392,15 @@
         :return: An iterator like instance of either Cluster or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ClusterListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -2135,22 +2444,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/clusters"}
 
@@ -2162,17 +2473,15 @@
         :return: An iterator like instance of either SkuDescription or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.SkuDescription]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.SkuDescriptionList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -2216,22 +2525,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_skus.metadata = {"url": "/subscriptions/{subscriptionId}/providers/Microsoft.Kusto/skus"}
 
@@ -2242,15 +2553,15 @@
         cluster_name: _models.ClusterCheckNameRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the cluster name is valid and is not already in use.
 
-        :param location: Azure location (region) name. Required.
+        :param location: The name of Azure region. Required.
         :type location: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: ~azure.mgmt.kusto.models.ClusterCheckNameRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -2261,15 +2572,15 @@
 
     @overload
     def check_name_availability(
         self, location: str, cluster_name: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the cluster name is valid and is not already in use.
 
-        :param location: Azure location (region) name. Required.
+        :param location: The name of Azure region. Required.
         :type location: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -2280,17 +2591,18 @@
 
     @distributed_trace
     def check_name_availability(
         self, location: str, cluster_name: Union[_models.ClusterCheckNameRequest, IO], **kwargs: Any
     ) -> _models.CheckNameResult:
         """Checks that the cluster name is valid and is not already in use.
 
-        :param location: Azure location (region) name. Required.
+        :param location: The name of Azure region. Required.
         :type location: str
-        :param cluster_name: The name of the cluster. Is either a model type or a IO type. Required.
+        :param cluster_name: The name of the cluster. Is either a ClusterCheckNameRequest type or a IO
+         type. Required.
         :type cluster_name: ~azure.mgmt.kusto.models.ClusterCheckNameRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: CheckNameResult or the result of cls(response)
         :rtype: ~azure.mgmt.kusto.models.CheckNameResult
@@ -2303,24 +2615,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.CheckNameResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(cluster_name, (IO, bytes)):
+        if isinstance(cluster_name, (IOBase, bytes)):
             _content = cluster_name
         else:
             _json = self._serialize.body(cluster_name, "ClusterCheckNameRequest")
 
         request = build_check_name_availability_request(
             location=location,
             subscription_id=self._config.subscription_id,
@@ -2331,23 +2641,25 @@
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = self._deserialize("CheckNameResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
@@ -2358,30 +2670,28 @@
 
     @distributed_trace
     def list_skus_by_resource(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> Iterable["_models.AzureResourceSku"]:
         """Returns the SKUs available for the provided resource.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AzureResourceSku or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.AzureResourceSku]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ListResourceSkusResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -2427,22 +2737,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_skus_by_resource.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/skus"
@@ -2450,32 +2762,30 @@
 
     @distributed_trace
     def list_outbound_network_dependencies_endpoints(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> Iterable["_models.OutboundNetworkDependenciesEndpoint"]:
         """Gets the network endpoints of all outbound dependencies of a Kusto cluster.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either OutboundNetworkDependenciesEndpoint or the result
          of cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.OutboundNetworkDependenciesEndpoint]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OutboundNetworkDependenciesEndpointListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -2521,22 +2831,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_outbound_network_dependencies_endpoints.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/outboundNetworkDependenciesEndpoints"
@@ -2544,30 +2856,28 @@
 
     @distributed_trace
     def list_language_extensions(
         self, resource_group_name: str, cluster_name: str, **kwargs: Any
     ) -> Iterable["_models.LanguageExtension"]:
         """Returns a list of language extensions that can run within KQL queries.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either LanguageExtension or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.kusto.models.LanguageExtension]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.LanguageExtensionsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -2613,22 +2923,24 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_language_extensions.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/listLanguageExtensions"
@@ -2648,24 +2960,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(language_extensions_to_add, (IO, bytes)):
+        if isinstance(language_extensions_to_add, (IOBase, bytes)):
             _content = language_extensions_to_add
         else:
             _json = self._serialize.body(language_extensions_to_add, "LanguageExtensionsList")
 
         request = build_add_language_extensions_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -2677,26 +2987,34 @@
             template_url=self._add_language_extensions_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _add_language_extensions_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/addLanguageExtensions"
     }
 
     @overload
     def begin_add_language_extensions(
@@ -2706,15 +3024,15 @@
         language_extensions_to_add: _models.LanguageExtensionsList,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[None]:
         """Add a list of language extensions that can run within KQL queries.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param language_extensions_to_add: The language extensions to add. Required.
         :type language_extensions_to_add: ~azure.mgmt.kusto.models.LanguageExtensionsList
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
@@ -2741,15 +3059,15 @@
         language_extensions_to_add: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[None]:
         """Add a list of language extensions that can run within KQL queries.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param language_extensions_to_add: The language extensions to add. Required.
         :type language_extensions_to_add: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -2774,21 +3092,21 @@
         resource_group_name: str,
         cluster_name: str,
         language_extensions_to_add: Union[_models.LanguageExtensionsList, IO],
         **kwargs: Any
     ) -> LROPoller[None]:
         """Add a list of language extensions that can run within KQL queries.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param language_extensions_to_add: The language extensions to add. Is either a model type or a
-         IO type. Required.
+        :param language_extensions_to_add: The language extensions to add. Is either a
+         LanguageExtensionsList type or a IO type. Required.
         :type language_extensions_to_add: ~azure.mgmt.kusto.models.LanguageExtensionsList or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -2800,17 +3118,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._add_language_extensions_initial(  # type: ignore
@@ -2827,15 +3143,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
@@ -2863,24 +3181,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(language_extensions_to_remove, (IO, bytes)):
+        if isinstance(language_extensions_to_remove, (IOBase, bytes)):
             _content = language_extensions_to_remove
         else:
             _json = self._serialize.body(language_extensions_to_remove, "LanguageExtensionsList")
 
         request = build_remove_language_extensions_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -2892,26 +3208,34 @@
             template_url=self._remove_language_extensions_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _remove_language_extensions_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Kusto/clusters/{clusterName}/removeLanguageExtensions"
     }
 
     @overload
     def begin_remove_language_extensions(
@@ -2921,15 +3245,15 @@
         language_extensions_to_remove: _models.LanguageExtensionsList,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[None]:
         """Remove a list of language extensions that can run within KQL queries.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param language_extensions_to_remove: The language extensions to remove. Required.
         :type language_extensions_to_remove: ~azure.mgmt.kusto.models.LanguageExtensionsList
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
@@ -2956,15 +3280,15 @@
         language_extensions_to_remove: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> LROPoller[None]:
         """Remove a list of language extensions that can run within KQL queries.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
         :param language_extensions_to_remove: The language extensions to remove. Required.
         :type language_extensions_to_remove: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
@@ -2989,21 +3313,21 @@
         resource_group_name: str,
         cluster_name: str,
         language_extensions_to_remove: Union[_models.LanguageExtensionsList, IO],
         **kwargs: Any
     ) -> LROPoller[None]:
         """Remove a list of language extensions that can run within KQL queries.
 
-        :param resource_group_name: The name of the resource group containing the Kusto cluster.
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param cluster_name: The name of the Kusto cluster. Required.
         :type cluster_name: str
-        :param language_extensions_to_remove: The language extensions to remove. Is either a model type
-         or a IO type. Required.
+        :param language_extensions_to_remove: The language extensions to remove. Is either a
+         LanguageExtensionsList type or a IO type. Required.
         :type language_extensions_to_remove: ~azure.mgmt.kusto.models.LanguageExtensionsList or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -3015,17 +3339,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-11-11"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._remove_language_extensions_initial(  # type: ignore
@@ -3042,15 +3364,17 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: PollingMethod = cast(PollingMethod, ARMPolling(lro_delay, **kwargs))
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
                 polling_method=polling_method,
```

## Comparing `azure-mgmt-kusto-3.1.0b1/tests/disable_test_cli_mgmt_kusto.py` & `azure-mgmt-kusto-3.2.0/tests/disable_test_cli_mgmt_kusto.py`

 * *Files identical despite different names*

