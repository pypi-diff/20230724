# Comparing `tmp/azure-mgmt-managednetworkfabric-1.0.0.zip` & `tmp/azure-mgmt-managednetworkfabric-1.0.0b1.zip`

## zipinfo {}

```diff
@@ -1,95 +1,85 @@
-Zip file size: 338432 bytes, number of entries: 93
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/azure/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/azure_mgmt_managednetworkfabric.egg-info/
--rw-rw-r--  2.0 unx     1074 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/LICENSE
--rw-rw-r--  2.0 unx      226 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/MANIFEST.in
--rw-rw-r--  2.0 unx      648 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/_meta.json
--rw-rw-r--  2.0 unx     2879 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/setup.py
--rw-rw-r--  2.0 unx    25317 b- defN 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/PKG-INFO
--rw-rw-r--  2.0 unx     2223 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/README.md
--rw-rw-r--  2.0 unx    22168 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/CHANGELOG.md
--rw-rw-r--  2.0 unx       38 b- defN 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/setup.cfg
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/
--rw-rw-r--  2.0 unx       65 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/
--rw-rw-r--  2.0 unx       65 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/models/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/
--rw-rw-r--  2.0 unx     3550 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_configuration.py
--rw-rw-r--  2.0 unx      486 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_version.py
--rw-rw-r--  2.0 unx      932 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_patch.py
--rw-rw-r--  2.0 unx       26 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/py.typed
--rw-rw-r--  2.0 unx    78836 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_serialization.py
--rw-rw-r--  2.0 unx    12172 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_managed_network_fabric_mgmt_client.py
--rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_vendor.py
--rw-rw-r--  2.0 unx   578411 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/models/_models_py3.py
--rw-rw-r--  2.0 unx    23351 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/models/__init__.py
--rw-rw-r--  2.0 unx    10637 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/models/_managed_network_fabric_mgmt_client_enums.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/models/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/
--rw-rw-r--  2.0 unx     3598 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/_configuration.py
--rw-rw-r--  2.0 unx      879 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/_patch.py
--rw-rw-r--  2.0 unx    12415 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/_managed_network_fabric_mgmt_client.py
--rw-rw-r--  2.0 unx    67554 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_access_control_lists_operations.py
--rw-rw-r--  2.0 unx    67966 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_l3_isolation_domains_operations.py
--rw-rw-r--  2.0 unx    42683 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_ip_extended_communities_operations.py
--rw-rw-r--  2.0 unx   122860 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_fabrics_operations.py
--rw-rw-r--  2.0 unx     3210 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    41231 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_ip_communities_operations.py
--rw-rw-r--  2.0 unx    82887 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_devices_operations.py
--rw-rw-r--  2.0 unx    42660 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_internet_gateway_rules_operations.py
--rw-rw-r--  2.0 unx    40758 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_ip_prefixes_operations.py
--rw-rw-r--  2.0 unx    40654 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_racks_operations.py
--rw-rw-r--  2.0 unx    42177 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_packet_brokers_operations.py
--rw-rw-r--  2.0 unx    68005 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_to_network_interconnects_operations.py
--rw-rw-r--  2.0 unx    65710 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_route_policies_operations.py
--rw-rw-r--  2.0 unx    42101 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_internet_gateways_operations.py
--rw-rw-r--  2.0 unx    66853 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_tap_rules_operations.py
--rw-rw-r--  2.0 unx    58854 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_taps_operations.py
--rw-rw-r--  2.0 unx     8819 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_fabric_skus_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    66281 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_external_networks_operations.py
--rw-rw-r--  2.0 unx     5803 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_operations.py
--rw-rw-r--  2.0 unx    41303 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_neighbor_groups_operations.py
--rw-rw-r--  2.0 unx     8800 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_device_skus_operations.py
--rw-rw-r--  2.0 unx    67812 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_l2_isolation_domains_operations.py
--rw-rw-r--  2.0 unx    79205 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_internal_networks_operations.py
--rw-rw-r--  2.0 unx    52515 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_interfaces_operations.py
--rw-rw-r--  2.0 unx    42989 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_fabric_controllers_operations.py
--rw-rw-r--  2.0 unx    79580 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_access_control_lists_operations.py
--rw-rw-r--  2.0 unx    80022 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_l3_isolation_domains_operations.py
--rw-rw-r--  2.0 unx    50596 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_ip_extended_communities_operations.py
--rw-rw-r--  2.0 unx   143163 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_fabrics_operations.py
--rw-rw-r--  2.0 unx     3210 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/__init__.py
--rw-rw-r--  2.0 unx    48915 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_ip_communities_operations.py
--rw-rw-r--  2.0 unx    96349 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_devices_operations.py
--rw-rw-r--  2.0 unx    50568 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_internet_gateway_rules_operations.py
--rw-rw-r--  2.0 unx    48294 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_ip_prefixes_operations.py
--rw-rw-r--  2.0 unx    48333 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_racks_operations.py
--rw-rw-r--  2.0 unx    50085 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_packet_brokers_operations.py
--rw-rw-r--  2.0 unx    79696 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_to_network_interconnects_operations.py
--rw-rw-r--  2.0 unx    77524 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_route_policies_operations.py
--rw-rw-r--  2.0 unx    49812 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_internet_gateways_operations.py
--rw-rw-r--  2.0 unx    78727 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_tap_rules_operations.py
--rw-rw-r--  2.0 unx    69201 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_taps_operations.py
--rw-rw-r--  2.0 unx    10963 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_fabric_skus_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_patch.py
--rw-rw-r--  2.0 unx    77461 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_external_networks_operations.py
--rw-rw-r--  2.0 unx     6506 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_operations.py
--rw-rw-r--  2.0 unx    48978 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_neighbor_groups_operations.py
--rw-rw-r--  2.0 unx    10944 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_device_skus_operations.py
--rw-rw-r--  2.0 unx    79868 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_l2_isolation_domains_operations.py
--rw-rw-r--  2.0 unx    92098 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_internal_networks_operations.py
--rw-rw-r--  2.0 unx    61759 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_interfaces_operations.py
--rw-rw-r--  2.0 unx    51108 b- defN 23-Jul-24 02:19 azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_fabric_controllers_operations.py
--rw-rw-r--  2.0 unx        6 b- defN 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/azure_mgmt_managednetworkfabric.egg-info/top_level.txt
--rw-rw-r--  2.0 unx        1 b- defN 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/azure_mgmt_managednetworkfabric.egg-info/not-zip-safe
--rw-rw-r--  2.0 unx      124 b- defN 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/azure_mgmt_managednetworkfabric.egg-info/requires.txt
--rw-rw-r--  2.0 unx    25317 b- defN 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/azure_mgmt_managednetworkfabric.egg-info/PKG-INFO
--rw-rw-r--  2.0 unx        1 b- defN 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/azure_mgmt_managednetworkfabric.egg-info/dependency_links.txt
--rw-rw-r--  2.0 unx     5263 b- defN 23-Jul-24 02:20 azure-mgmt-managednetworkfabric-1.0.0/azure_mgmt_managednetworkfabric.egg-info/SOURCES.txt
-93 files, 3578830 bytes uncompressed, 313366 bytes compressed:  91.3%
+Zip file size: 258699 bytes, number of entries: 83
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/azure_mgmt_managednetworkfabric.egg-info/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/azure/
+-rw-rw-r--  2.0 unx     2866 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/setup.py
+-rw-rw-r--  2.0 unx     2223 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/README.md
+-rw-rw-r--  2.0 unx       38 b- defN 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/setup.cfg
+-rw-rw-r--  2.0 unx     1074 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/LICENSE
+-rw-rw-r--  2.0 unx     3200 b- defN 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/PKG-INFO
+-rw-rw-r--  2.0 unx      648 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/_meta.json
+-rw-rw-r--  2.0 unx      226 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/MANIFEST.in
+-rw-rw-r--  2.0 unx       62 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/CHANGELOG.md
+-rw-rw-r--  2.0 unx        1 b- defN 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/azure_mgmt_managednetworkfabric.egg-info/dependency_links.txt
+-rw-rw-r--  2.0 unx        6 b- defN 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/azure_mgmt_managednetworkfabric.egg-info/top_level.txt
+-rw-rw-r--  2.0 unx      124 b- defN 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/azure_mgmt_managednetworkfabric.egg-info/requires.txt
+-rw-rw-r--  2.0 unx     4477 b- defN 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/azure_mgmt_managednetworkfabric.egg-info/SOURCES.txt
+-rw-rw-r--  2.0 unx        1 b- defN 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/azure_mgmt_managednetworkfabric.egg-info/not-zip-safe
+-rw-rw-r--  2.0 unx     3200 b- defN 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/azure_mgmt_managednetworkfabric.egg-info/PKG-INFO
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/models/
+-rw-rw-r--  2.0 unx       26 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/py.typed
+-rw-rw-r--  2.0 unx      488 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_version.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_patch.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_vendor.py
+-rw-rw-r--  2.0 unx    10434 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_managed_network_fabric_mgmt_client.py
+-rw-rw-r--  2.0 unx    78836 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_serialization.py
+-rw-rw-r--  2.0 unx     3539 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_configuration.py
+-rw-rw-r--  2.0 unx      932 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/__init__.py
+-rw-rw-r--  2.0 unx    63752 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_fabrics_operations.py
+-rw-rw-r--  2.0 unx   129086 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_internal_networks_operations.py
+-rw-rw-r--  2.0 unx    10984 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_device_skus_operations.py
+-rw-rw-r--  2.0 unx    95727 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_l2_isolation_domains_operations.py
+-rw-rw-r--  2.0 unx   115226 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_external_networks_operations.py
+-rw-rw-r--  2.0 unx    66567 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_fabric_controllers_operations.py
+-rw-rw-r--  2.0 unx    48559 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_racks_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_patch.py
+-rw-rw-r--  2.0 unx    35543 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_to_network_interconnects_operations.py
+-rw-rw-r--  2.0 unx    37283 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_access_control_lists_operations.py
+-rw-rw-r--  2.0 unx    49102 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_ip_communities_operations.py
+-rw-rw-r--  2.0 unx    50787 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_ip_extended_communities_operations.py
+-rw-rw-r--  2.0 unx    68909 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_interfaces_operations.py
+-rw-rw-r--  2.0 unx     6514 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_operations.py
+-rw-rw-r--  2.0 unx    48485 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_ip_prefixes_operations.py
+-rw-rw-r--  2.0 unx    11003 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_fabric_skus_operations.py
+-rw-rw-r--  2.0 unx   119684 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_devices_operations.py
+-rw-rw-r--  2.0 unx    48634 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_route_policies_operations.py
+-rw-rw-r--  2.0 unx    10924 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_rack_skus_operations.py
+-rw-rw-r--  2.0 unx     2685 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/__init__.py
+-rw-rw-r--  2.0 unx   100980 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_l3_isolation_domains_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jun-29 02:10 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/_patch.py
+-rw-rw-r--  2.0 unx    10652 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/_managed_network_fabric_mgmt_client.py
+-rw-rw-r--  2.0 unx     3587 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/_configuration.py
+-rw-rw-r--  2.0 unx      879 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/__init__.py
+-rw-rw-r--  2.0 unx    53283 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_fabrics_operations.py
+-rw-rw-r--  2.0 unx   110843 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_internal_networks_operations.py
+-rw-rw-r--  2.0 unx     8796 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_device_skus_operations.py
+-rw-rw-r--  2.0 unx    81789 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_l2_isolation_domains_operations.py
+-rw-rw-r--  2.0 unx    98732 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_external_networks_operations.py
+-rw-rw-r--  2.0 unx    55413 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_fabric_controllers_operations.py
+-rw-rw-r--  2.0 unx    40748 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_racks_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    29123 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_to_network_interconnects_operations.py
+-rw-rw-r--  2.0 unx    28951 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_access_control_lists_operations.py
+-rw-rw-r--  2.0 unx    41286 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_ip_communities_operations.py
+-rw-rw-r--  2.0 unx    42742 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_ip_extended_communities_operations.py
+-rw-rw-r--  2.0 unx    58039 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_interfaces_operations.py
+-rw-rw-r--  2.0 unx     5803 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_operations.py
+-rw-rw-r--  2.0 unx    40817 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_ip_prefixes_operations.py
+-rw-rw-r--  2.0 unx     8815 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_fabric_skus_operations.py
+-rw-rw-r--  2.0 unx   100769 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_devices_operations.py
+-rw-rw-r--  2.0 unx    40818 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_route_policies_operations.py
+-rw-rw-r--  2.0 unx     8748 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_rack_skus_operations.py
+-rw-rw-r--  2.0 unx     2685 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    86864 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_l3_isolation_domains_operations.py
+-rw-rw-r--  2.0 unx     7668 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/models/_managed_network_fabric_mgmt_client_enums.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/models/_patch.py
+-rw-rw-r--  2.0 unx   376930 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/models/_models_py3.py
+-rw-rw-r--  2.0 unx    16241 b- defN 23-Jun-29 02:09 azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/models/__init__.py
+83 files, 2598658 bytes uncompressed, 236373 bytes compressed:  90.9%
```

## zipnote {}

```diff
@@ -1,280 +1,250 @@
-Filename: azure-mgmt-managednetworkfabric-1.0.0/
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure_mgmt_managednetworkfabric.egg-info/
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure_mgmt_managednetworkfabric.egg-info/
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/LICENSE
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/setup.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/MANIFEST.in
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/README.md
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/_meta.json
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/setup.cfg
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/setup.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/LICENSE
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/PKG-INFO
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/README.md
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/_meta.json
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/CHANGELOG.md
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/MANIFEST.in
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/setup.cfg
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/CHANGELOG.md
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure_mgmt_managednetworkfabric.egg-info/dependency_links.txt
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/__init__.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure_mgmt_managednetworkfabric.egg-info/top_level.txt
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure_mgmt_managednetworkfabric.egg-info/requires.txt
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/__init__.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure_mgmt_managednetworkfabric.egg-info/SOURCES.txt
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/models/
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure_mgmt_managednetworkfabric.egg-info/not-zip-safe
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure_mgmt_managednetworkfabric.egg-info/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_configuration.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/__init__.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_version.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/__init__.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/__init__.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_patch.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/py.typed
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_serialization.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/models/
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_managed_network_fabric_mgmt_client.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/py.typed
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_vendor.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_version.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/models/_models_py3.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_patch.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/models/__init__.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/models/_managed_network_fabric_mgmt_client_enums.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_managed_network_fabric_mgmt_client.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/models/_patch.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_serialization.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/_configuration.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/__init__.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/__init__.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_fabrics_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/_patch.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_internal_networks_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/_managed_network_fabric_mgmt_client.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_device_skus_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_access_control_lists_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_l2_isolation_domains_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_l3_isolation_domains_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_external_networks_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_ip_extended_communities_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_fabric_controllers_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_fabrics_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_racks_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/__init__.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_ip_communities_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_to_network_interconnects_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_devices_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_access_control_lists_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_internet_gateway_rules_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_ip_communities_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_ip_prefixes_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_ip_extended_communities_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_racks_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_interfaces_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_packet_brokers_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_to_network_interconnects_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_ip_prefixes_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_route_policies_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_fabric_skus_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_internet_gateways_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_devices_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_tap_rules_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_route_policies_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_taps_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_rack_skus_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_fabric_skus_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_patch.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_l3_isolation_domains_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_external_networks_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_neighbor_groups_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/_managed_network_fabric_mgmt_client.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_device_skus_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_l2_isolation_domains_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_internal_networks_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_fabrics_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_interfaces_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_internal_networks_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_fabric_controllers_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_device_skus_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_access_control_lists_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_l2_isolation_domains_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_l3_isolation_domains_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_external_networks_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_ip_extended_communities_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_fabric_controllers_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_fabrics_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_racks_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/__init__.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_ip_communities_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_to_network_interconnects_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_devices_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_access_control_lists_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_internet_gateway_rules_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_ip_communities_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_ip_prefixes_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_ip_extended_communities_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_racks_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_interfaces_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_packet_brokers_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_to_network_interconnects_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_ip_prefixes_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_route_policies_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_fabric_skus_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_internet_gateways_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_devices_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_tap_rules_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_route_policies_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_taps_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_rack_skus_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_fabric_skus_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_patch.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_l3_isolation_domains_operations.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_external_networks_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/models/_managed_network_fabric_mgmt_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_neighbor_groups_operations.py
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_device_skus_operations.py
-Comment: 
-
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_l2_isolation_domains_operations.py
-Comment: 
-
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_internal_networks_operations.py
-Comment: 
-
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_interfaces_operations.py
-Comment: 
-
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_fabric_controllers_operations.py
-Comment: 
-
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure_mgmt_managednetworkfabric.egg-info/top_level.txt
-Comment: 
-
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure_mgmt_managednetworkfabric.egg-info/not-zip-safe
-Comment: 
-
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure_mgmt_managednetworkfabric.egg-info/requires.txt
-Comment: 
-
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure_mgmt_managednetworkfabric.egg-info/PKG-INFO
-Comment: 
-
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure_mgmt_managednetworkfabric.egg-info/dependency_links.txt
-Comment: 
-
-Filename: azure-mgmt-managednetworkfabric-1.0.0/azure_mgmt_managednetworkfabric.egg-info/SOURCES.txt
+Filename: azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/models/__init__.py
 Comment: 
 
 Zip file comment:
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/LICENSE` & `azure-mgmt-managednetworkfabric-1.0.0b1/LICENSE`

 * *Files identical despite different names*

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/_meta.json` & `azure-mgmt-managednetworkfabric-1.0.0b1/_meta.json`

 * *Files 8% similar despite different names*

### Pretty-printed

 * *Similarity: 0.9166666666666666%*

 * *Differences: {"'commit'": "'de93ae3897babd397a59d3c9dcb894855d0db1c3'"}*

```diff
@@ -1,11 +1,11 @@
 {
     "autorest": "3.9.2",
     "autorest_command": "autorest specification/managednetworkfabric/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.6.0 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
-    "commit": "a89c3854f2d1cca8c996e00c97af3179ecb9dd72",
+    "commit": "de93ae3897babd397a59d3c9dcb894855d0db1c3",
     "readme": "specification/managednetworkfabric/resource-manager/readme.md",
     "repository_url": "https://github.com/Azure/azure-rest-api-specs",
     "use": [
         "@autorest/python@6.6.0",
         "@autorest/modelerfour@4.24.3"
     ]
 }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/setup.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/setup.py`

 * *Files 5% similar despite different names*

```diff
@@ -45,15 +45,15 @@
     long_description_content_type="text/markdown",
     license="MIT License",
     author="Microsoft Corporation",
     author_email="azpysdkhelp@microsoft.com",
     url="https://github.com/Azure/azure-sdk-for-python",
     keywords="azure, azure sdk",  # update with search keywords relevant to the azure service / product
     classifiers=[
-        "Development Status :: 5 - Production/Stable",
+        "Development Status :: 4 - Beta",
         "Programming Language :: Python",
         "Programming Language :: Python :: 3 :: Only",
         "Programming Language :: Python :: 3",
         "Programming Language :: Python :: 3.7",
         "Programming Language :: Python :: 3.8",
         "Programming Language :: Python :: 3.9",
         "Programming Language :: Python :: 3.10",
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/README.md` & `azure-mgmt-managednetworkfabric-1.0.0b1/README.md`

 * *Files identical despite different names*

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_configuration.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/_configuration.py`

 * *Files 4% similar despite different names*

```diff
@@ -6,41 +6,41 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
+from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
-from ._version import VERSION
+from .._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
 class ManagedNetworkFabricMgmtClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for ManagedNetworkFabricMgmtClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
-    :param subscription_id: The ID of the target subscription. The value must be an UUID. Required.
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
+    :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2023-06-15". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2023-02-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(ManagedNetworkFabricMgmtClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2023-06-15")
+        api_version: str = kwargs.pop("api_version", "2023-02-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -52,15 +52,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = ARMChallengeAuthenticationPolicy(
+            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/__init__.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_patch.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_serialization.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_serialization.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_managed_network_fabric_mgmt_client.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_managed_network_fabric_mgmt_client.py`

 * *Files 10% similar despite different names*

```diff
@@ -15,32 +15,27 @@
 from . import models as _models
 from ._configuration import ManagedNetworkFabricMgmtClientConfiguration
 from ._serialization import Deserializer, Serializer
 from .operations import (
     AccessControlListsOperations,
     ExternalNetworksOperations,
     InternalNetworksOperations,
-    InternetGatewayRulesOperations,
-    InternetGatewaysOperations,
     IpCommunitiesOperations,
     IpExtendedCommunitiesOperations,
     IpPrefixesOperations,
     L2IsolationDomainsOperations,
     L3IsolationDomainsOperations,
-    NeighborGroupsOperations,
     NetworkDeviceSkusOperations,
     NetworkDevicesOperations,
     NetworkFabricControllersOperations,
     NetworkFabricSkusOperations,
     NetworkFabricsOperations,
     NetworkInterfacesOperations,
-    NetworkPacketBrokersOperations,
+    NetworkRackSkusOperations,
     NetworkRacksOperations,
-    NetworkTapRulesOperations,
-    NetworkTapsOperations,
     NetworkToNetworkInterconnectsOperations,
     Operations,
     RoutePoliciesOperations,
 )
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
@@ -49,20 +44,14 @@
 
 class ManagedNetworkFabricMgmtClient:  # pylint: disable=client-accepts-api-version-keyword,too-many-instance-attributes
     """Self service experience for Azure Network Fabric API.
 
     :ivar access_control_lists: AccessControlListsOperations operations
     :vartype access_control_lists:
      azure.mgmt.managednetworkfabric.operations.AccessControlListsOperations
-    :ivar internet_gateways: InternetGatewaysOperations operations
-    :vartype internet_gateways:
-     azure.mgmt.managednetworkfabric.operations.InternetGatewaysOperations
-    :ivar internet_gateway_rules: InternetGatewayRulesOperations operations
-    :vartype internet_gateway_rules:
-     azure.mgmt.managednetworkfabric.operations.InternetGatewayRulesOperations
     :ivar ip_communities: IpCommunitiesOperations operations
     :vartype ip_communities: azure.mgmt.managednetworkfabric.operations.IpCommunitiesOperations
     :ivar ip_extended_communities: IpExtendedCommunitiesOperations operations
     :vartype ip_extended_communities:
      azure.mgmt.managednetworkfabric.operations.IpExtendedCommunitiesOperations
     :ivar ip_prefixes: IpPrefixesOperations operations
     :vartype ip_prefixes: azure.mgmt.managednetworkfabric.operations.IpPrefixesOperations
@@ -74,16 +63,14 @@
      azure.mgmt.managednetworkfabric.operations.L3IsolationDomainsOperations
     :ivar internal_networks: InternalNetworksOperations operations
     :vartype internal_networks:
      azure.mgmt.managednetworkfabric.operations.InternalNetworksOperations
     :ivar external_networks: ExternalNetworksOperations operations
     :vartype external_networks:
      azure.mgmt.managednetworkfabric.operations.ExternalNetworksOperations
-    :ivar neighbor_groups: NeighborGroupsOperations operations
-    :vartype neighbor_groups: azure.mgmt.managednetworkfabric.operations.NeighborGroupsOperations
     :ivar network_device_skus: NetworkDeviceSkusOperations operations
     :vartype network_device_skus:
      azure.mgmt.managednetworkfabric.operations.NetworkDeviceSkusOperations
     :ivar network_devices: NetworkDevicesOperations operations
     :vartype network_devices: azure.mgmt.managednetworkfabric.operations.NetworkDevicesOperations
     :ivar network_interfaces: NetworkInterfacesOperations operations
     :vartype network_interfaces:
@@ -95,36 +82,31 @@
     :vartype network_fabric_skus:
      azure.mgmt.managednetworkfabric.operations.NetworkFabricSkusOperations
     :ivar network_fabrics: NetworkFabricsOperations operations
     :vartype network_fabrics: azure.mgmt.managednetworkfabric.operations.NetworkFabricsOperations
     :ivar network_to_network_interconnects: NetworkToNetworkInterconnectsOperations operations
     :vartype network_to_network_interconnects:
      azure.mgmt.managednetworkfabric.operations.NetworkToNetworkInterconnectsOperations
-    :ivar network_packet_brokers: NetworkPacketBrokersOperations operations
-    :vartype network_packet_brokers:
-     azure.mgmt.managednetworkfabric.operations.NetworkPacketBrokersOperations
+    :ivar network_rack_skus: NetworkRackSkusOperations operations
+    :vartype network_rack_skus:
+     azure.mgmt.managednetworkfabric.operations.NetworkRackSkusOperations
     :ivar network_racks: NetworkRacksOperations operations
     :vartype network_racks: azure.mgmt.managednetworkfabric.operations.NetworkRacksOperations
-    :ivar network_tap_rules: NetworkTapRulesOperations operations
-    :vartype network_tap_rules:
-     azure.mgmt.managednetworkfabric.operations.NetworkTapRulesOperations
-    :ivar network_taps: NetworkTapsOperations operations
-    :vartype network_taps: azure.mgmt.managednetworkfabric.operations.NetworkTapsOperations
     :ivar operations: Operations operations
     :vartype operations: azure.mgmt.managednetworkfabric.operations.Operations
     :ivar route_policies: RoutePoliciesOperations operations
     :vartype route_policies: azure.mgmt.managednetworkfabric.operations.RoutePoliciesOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
-    :param subscription_id: The ID of the target subscription. The value must be an UUID. Required.
+    :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2023-06-15". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2023-02-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
         self,
@@ -141,20 +123,14 @@
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.access_control_lists = AccessControlListsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
-        self.internet_gateways = InternetGatewaysOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
-        self.internet_gateway_rules = InternetGatewayRulesOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
         self.ip_communities = IpCommunitiesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.ip_extended_communities = IpExtendedCommunitiesOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.ip_prefixes = IpPrefixesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.l2_isolation_domains = L2IsolationDomainsOperations(
             self._client, self._config, self._serialize, self._deserialize
@@ -164,15 +140,14 @@
         )
         self.internal_networks = InternalNetworksOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.external_networks = ExternalNetworksOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
-        self.neighbor_groups = NeighborGroupsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.network_device_skus = NetworkDeviceSkusOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.network_devices = NetworkDevicesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.network_interfaces = NetworkInterfacesOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
@@ -182,22 +157,18 @@
         self.network_fabric_skus = NetworkFabricSkusOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.network_fabrics = NetworkFabricsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.network_to_network_interconnects = NetworkToNetworkInterconnectsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
-        self.network_packet_brokers = NetworkPacketBrokersOperations(
+        self.network_rack_skus = NetworkRackSkusOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.network_racks = NetworkRacksOperations(self._client, self._config, self._serialize, self._deserialize)
-        self.network_tap_rules = NetworkTapRulesOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
-        self.network_taps = NetworkTapsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.route_policies = RoutePoliciesOperations(self._client, self._config, self._serialize, self._deserialize)
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/_vendor.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/models/_models_py3.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/models/_models_py3.py`

 * *Files 21% similar despite different names*

```diff
@@ -4,30 +4,37 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 import datetime
+import sys
 from typing import Any, Dict, List, Optional, TYPE_CHECKING, Union
 
 from .. import _serialization
 
+if sys.version_info >= (3, 9):
+    from collections.abc import MutableMapping
+else:
+    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
+
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from .. import models as _models
+JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
 
 
 class Resource(_serialization.Model):
     """Common fields that are returned in the response for all Azure Resource Manager resources.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -62,16 +69,16 @@
     """The resource model definition for an Azure Resource Manager tracked top level resource which
     has 'tags' and a 'location'.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -108,23 +115,23 @@
         :paramtype location: str
         """
         super().__init__(**kwargs)
         self.tags = tags
         self.location = location
 
 
-class AccessControlList(TrackedResource):  # pylint: disable=too-many-instance-attributes
-    """The Access Control List resource definition.
+class AccessControlList(TrackedResource):
+    """The AccessControlList resource definition.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -132,843 +139,341 @@
     :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar location: The geo-location where the resource lives. Required.
     :vartype location: str
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar configuration_type: Input method to configure Access Control List. Known values are:
-     "File" and "Inline".
-    :vartype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-    :ivar acls_url: Access Control List file URL.
-    :vartype acls_url: str
-    :ivar match_configurations: List of match configurations.
-    :vartype match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.AccessControlListMatchConfiguration]
-    :ivar dynamic_match_configurations: List of dynamic match configurations.
-    :vartype dynamic_match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
-    :ivar last_synced_time: The last synced timestamp.
-    :vartype last_synced_time: ~datetime.datetime
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
+    :ivar address_family: IP address family. Example: ipv4 | ipv6. Required. Known values are:
+     "ipv4" and "ipv6".
+    :vartype address_family: str or ~azure.mgmt.managednetworkfabric.models.AddressFamily
+    :ivar conditions: Access Control List conditions. Required.
+    :vartype conditions:
+     list[~azure.mgmt.managednetworkfabric.models.AccessControlListConditionProperties]
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
         "location": {"required": True},
-        "acls_url": {"min_length": 1},
-        "match_configurations": {"min_items": 1},
-        "dynamic_match_configurations": {"min_items": 1},
-        "last_synced_time": {"readonly": True},
-        "configuration_state": {"readonly": True},
+        "address_family": {"required": True},
+        "conditions": {"required": True},
         "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
         "annotation": {"key": "properties.annotation", "type": "str"},
-        "configuration_type": {"key": "properties.configurationType", "type": "str"},
-        "acls_url": {"key": "properties.aclsUrl", "type": "str"},
-        "match_configurations": {
-            "key": "properties.matchConfigurations",
-            "type": "[AccessControlListMatchConfiguration]",
-        },
-        "dynamic_match_configurations": {
-            "key": "properties.dynamicMatchConfigurations",
-            "type": "[CommonDynamicMatchConfiguration]",
-        },
-        "last_synced_time": {"key": "properties.lastSyncedTime", "type": "iso-8601"},
-        "configuration_state": {"key": "properties.configurationState", "type": "str"},
+        "address_family": {"key": "properties.addressFamily", "type": "str"},
+        "conditions": {"key": "properties.conditions", "type": "[AccessControlListConditionProperties]"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
-        "administrative_state": {"key": "properties.administrativeState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         location: str,
+        address_family: Union[str, "_models.AddressFamily"],
+        conditions: List["_models.AccessControlListConditionProperties"],
         tags: Optional[Dict[str, str]] = None,
         annotation: Optional[str] = None,
-        configuration_type: Optional[Union[str, "_models.ConfigurationType"]] = None,
-        acls_url: Optional[str] = None,
-        match_configurations: Optional[List["_models.AccessControlListMatchConfiguration"]] = None,
-        dynamic_match_configurations: Optional[List["_models.CommonDynamicMatchConfiguration"]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword configuration_type: Input method to configure Access Control List. Known values are:
-         "File" and "Inline".
-        :paramtype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-        :keyword acls_url: Access Control List file URL.
-        :paramtype acls_url: str
-        :keyword match_configurations: List of match configurations.
-        :paramtype match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.AccessControlListMatchConfiguration]
-        :keyword dynamic_match_configurations: List of dynamic match configurations.
-        :paramtype dynamic_match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
+        :keyword address_family: IP address family. Example: ipv4 | ipv6. Required. Known values are:
+         "ipv4" and "ipv6".
+        :paramtype address_family: str or ~azure.mgmt.managednetworkfabric.models.AddressFamily
+        :keyword conditions: Access Control List conditions. Required.
+        :paramtype conditions:
+         list[~azure.mgmt.managednetworkfabric.models.AccessControlListConditionProperties]
         """
         super().__init__(tags=tags, location=location, **kwargs)
         self.annotation = annotation
-        self.configuration_type = configuration_type
-        self.acls_url = acls_url
-        self.match_configurations = match_configurations
-        self.dynamic_match_configurations = dynamic_match_configurations
-        self.last_synced_time = None
-        self.configuration_state = None
+        self.address_family = address_family
+        self.conditions = conditions
         self.provisioning_state = None
-        self.administrative_state = None
-
-
-class AccessControlListAction(_serialization.Model):
-    """Action that need to performed.
 
-    :ivar type: Type of actions that can be performed. Known values are: "Drop", "Count", and
-     "Log".
-    :vartype type: str or ~azure.mgmt.managednetworkfabric.models.AclActionType
-    :ivar counter_name: Name of the counter block to get match count information.
-    :vartype counter_name: str
-    """
 
-    _validation = {
-        "counter_name": {"min_length": 1},
-    }
-
-    _attribute_map = {
-        "type": {"key": "type", "type": "str"},
-        "counter_name": {"key": "counterName", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        type: Optional[Union[str, "_models.AclActionType"]] = None,
-        counter_name: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword type: Type of actions that can be performed. Known values are: "Drop", "Count", and
-         "Log".
-        :paramtype type: str or ~azure.mgmt.managednetworkfabric.models.AclActionType
-        :keyword counter_name: Name of the counter block to get match count information.
-        :paramtype counter_name: str
-        """
-        super().__init__(**kwargs)
-        self.type = type
-        self.counter_name = counter_name
-
-
-class CommonMatchConditions(_serialization.Model):
-    """Defines the common match conditions of the ACL and Network Tap Rule.
+class AnnotationResource(_serialization.Model):
+    """Switch configuration entries require a description to discern between configuration groups.
 
-    :ivar protocol_types: List of the protocols that need to be matched.
-    :vartype protocol_types: list[str]
-    :ivar vlan_match_condition: Vlan match condition that needs to be matched.
-    :vartype vlan_match_condition: ~azure.mgmt.managednetworkfabric.models.VlanMatchCondition
-    :ivar ip_condition: IP condition that needs to be matched.
-    :vartype ip_condition: ~azure.mgmt.managednetworkfabric.models.IpMatchCondition
+    :ivar annotation: Switch configuration description.
+    :vartype annotation: str
     """
 
-    _validation = {
-        "protocol_types": {"min_items": 1},
-    }
-
     _attribute_map = {
-        "protocol_types": {"key": "protocolTypes", "type": "[str]"},
-        "vlan_match_condition": {"key": "vlanMatchCondition", "type": "VlanMatchCondition"},
-        "ip_condition": {"key": "ipCondition", "type": "IpMatchCondition"},
+        "annotation": {"key": "annotation", "type": "str"},
     }
 
-    def __init__(
-        self,
-        *,
-        protocol_types: Optional[List[str]] = None,
-        vlan_match_condition: Optional["_models.VlanMatchCondition"] = None,
-        ip_condition: Optional["_models.IpMatchCondition"] = None,
-        **kwargs: Any
-    ) -> None:
+    def __init__(self, *, annotation: Optional[str] = None, **kwargs: Any) -> None:
         """
-        :keyword protocol_types: List of the protocols that need to be matched.
-        :paramtype protocol_types: list[str]
-        :keyword vlan_match_condition: Vlan match condition that needs to be matched.
-        :paramtype vlan_match_condition: ~azure.mgmt.managednetworkfabric.models.VlanMatchCondition
-        :keyword ip_condition: IP condition that needs to be matched.
-        :paramtype ip_condition: ~azure.mgmt.managednetworkfabric.models.IpMatchCondition
+        :keyword annotation: Switch configuration description.
+        :paramtype annotation: str
         """
         super().__init__(**kwargs)
-        self.protocol_types = protocol_types
-        self.vlan_match_condition = vlan_match_condition
-        self.ip_condition = ip_condition
-
+        self.annotation = annotation
 
-class AccessControlListMatchCondition(CommonMatchConditions):
-    """Defines the match condition that is supported to filter the traffic.
 
-    :ivar protocol_types: List of the protocols that need to be matched.
-    :vartype protocol_types: list[str]
-    :ivar vlan_match_condition: Vlan match condition that needs to be matched.
-    :vartype vlan_match_condition: ~azure.mgmt.managednetworkfabric.models.VlanMatchCondition
-    :ivar ip_condition: IP condition that needs to be matched.
-    :vartype ip_condition: ~azure.mgmt.managednetworkfabric.models.IpMatchCondition
-    :ivar ether_types: List of ether type values that needs to be matched.
-    :vartype ether_types: list[str]
-    :ivar fragments: List of IP fragment packets that needs to be matched.
-    :vartype fragments: list[str]
-    :ivar ip_lengths: List of IP Lengths that needs to be matched.
-    :vartype ip_lengths: list[str]
-    :ivar ttl_values: List of TTL [Time To Live] values that needs to be matched.
-    :vartype ttl_values: list[str]
-    :ivar dscp_markings: List of DSCP Markings that needs to be matched.
-    :vartype dscp_markings: list[str]
-    :ivar port_condition: Defines the port condition that needs to be matched.
-    :vartype port_condition: ~azure.mgmt.managednetworkfabric.models.AccessControlListPortCondition
-    """
-
-    _validation = {
-        "protocol_types": {"min_items": 1},
-        "ether_types": {"min_items": 1},
-        "fragments": {"min_items": 1},
-        "ip_lengths": {"min_items": 1},
-        "ttl_values": {"min_items": 1},
-        "dscp_markings": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "protocol_types": {"key": "protocolTypes", "type": "[str]"},
-        "vlan_match_condition": {"key": "vlanMatchCondition", "type": "VlanMatchCondition"},
-        "ip_condition": {"key": "ipCondition", "type": "IpMatchCondition"},
-        "ether_types": {"key": "etherTypes", "type": "[str]"},
-        "fragments": {"key": "fragments", "type": "[str]"},
-        "ip_lengths": {"key": "ipLengths", "type": "[str]"},
-        "ttl_values": {"key": "ttlValues", "type": "[str]"},
-        "dscp_markings": {"key": "dscpMarkings", "type": "[str]"},
-        "port_condition": {"key": "portCondition", "type": "AccessControlListPortCondition"},
-    }
-
-    def __init__(
-        self,
-        *,
-        protocol_types: Optional[List[str]] = None,
-        vlan_match_condition: Optional["_models.VlanMatchCondition"] = None,
-        ip_condition: Optional["_models.IpMatchCondition"] = None,
-        ether_types: Optional[List[str]] = None,
-        fragments: Optional[List[str]] = None,
-        ip_lengths: Optional[List[str]] = None,
-        ttl_values: Optional[List[str]] = None,
-        dscp_markings: Optional[List[str]] = None,
-        port_condition: Optional["_models.AccessControlListPortCondition"] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword protocol_types: List of the protocols that need to be matched.
-        :paramtype protocol_types: list[str]
-        :keyword vlan_match_condition: Vlan match condition that needs to be matched.
-        :paramtype vlan_match_condition: ~azure.mgmt.managednetworkfabric.models.VlanMatchCondition
-        :keyword ip_condition: IP condition that needs to be matched.
-        :paramtype ip_condition: ~azure.mgmt.managednetworkfabric.models.IpMatchCondition
-        :keyword ether_types: List of ether type values that needs to be matched.
-        :paramtype ether_types: list[str]
-        :keyword fragments: List of IP fragment packets that needs to be matched.
-        :paramtype fragments: list[str]
-        :keyword ip_lengths: List of IP Lengths that needs to be matched.
-        :paramtype ip_lengths: list[str]
-        :keyword ttl_values: List of TTL [Time To Live] values that needs to be matched.
-        :paramtype ttl_values: list[str]
-        :keyword dscp_markings: List of DSCP Markings that needs to be matched.
-        :paramtype dscp_markings: list[str]
-        :keyword port_condition: Defines the port condition that needs to be matched.
-        :paramtype port_condition:
-         ~azure.mgmt.managednetworkfabric.models.AccessControlListPortCondition
-        """
-        super().__init__(
-            protocol_types=protocol_types,
-            vlan_match_condition=vlan_match_condition,
-            ip_condition=ip_condition,
-            **kwargs
-        )
-        self.ether_types = ether_types
-        self.fragments = fragments
-        self.ip_lengths = ip_lengths
-        self.ttl_values = ttl_values
-        self.dscp_markings = dscp_markings
-        self.port_condition = port_condition
+class AccessControlListConditionProperties(AnnotationResource):
+    """Access Control List condition model.
 
+    All required parameters must be populated in order to send to Azure.
 
-class AccessControlListMatchConfiguration(_serialization.Model):
-    """Defines the match configuration that are supported to filter the traffic.
-
-    :ivar match_configuration_name: The name of the match configuration.
-    :vartype match_configuration_name: str
-    :ivar sequence_number: Sequence Number of the match configuration.
+    :ivar annotation: Switch configuration description.
+    :vartype annotation: str
+    :ivar sequence_number: sequenceNumber of the Access Control List. Required.
     :vartype sequence_number: int
-    :ivar ip_address_type: Type of IP Address. IPv4 or IPv6. Known values are: "IPv4" and "IPv6".
-    :vartype ip_address_type: str or ~azure.mgmt.managednetworkfabric.models.IPAddressType
-    :ivar match_conditions: List of the match conditions.
-    :vartype match_conditions:
-     list[~azure.mgmt.managednetworkfabric.models.AccessControlListMatchCondition]
-    :ivar actions: List of actions that need to be performed for the matched conditions.
-    :vartype actions: list[~azure.mgmt.managednetworkfabric.models.AccessControlListAction]
+    :ivar action: action. Example: allow | deny. Required. Known values are: "allow" and "deny".
+    :vartype action: str or ~azure.mgmt.managednetworkfabric.models.ConditionActionType
+    :ivar destination_address: destinationAddress. Example: any | 1.1.1.0/24 | 1.1.10.10. Required.
+    :vartype destination_address: str
+    :ivar destination_port: destinationPort. Example: any | 1253. Required.
+    :vartype destination_port: str
+    :ivar source_address: sourceAddress. Example: any | 1.1.1.0/24 | 1.1.10.10. Required.
+    :vartype source_address: str
+    :ivar source_port: sourcePort. Example: any | 1253. Required.
+    :vartype source_port: str
+    :ivar protocol: TCP/IP protocol as defined in the list of IP protocol numbers. Example: 255
+     (any) | 0 | 1. Required.
+    :vartype protocol: int
     """
 
     _validation = {
-        "match_configuration_name": {"min_length": 1},
-        "sequence_number": {"maximum": 4294967295, "minimum": 1},
-        "match_conditions": {"min_items": 1},
-        "actions": {"min_items": 1},
+        "sequence_number": {"required": True},
+        "action": {"required": True},
+        "destination_address": {"required": True},
+        "destination_port": {"required": True},
+        "source_address": {"required": True},
+        "source_port": {"required": True},
+        "protocol": {"required": True},
     }
 
     _attribute_map = {
-        "match_configuration_name": {"key": "matchConfigurationName", "type": "str"},
+        "annotation": {"key": "annotation", "type": "str"},
         "sequence_number": {"key": "sequenceNumber", "type": "int"},
-        "ip_address_type": {"key": "ipAddressType", "type": "str"},
-        "match_conditions": {"key": "matchConditions", "type": "[AccessControlListMatchCondition]"},
-        "actions": {"key": "actions", "type": "[AccessControlListAction]"},
+        "action": {"key": "action", "type": "str"},
+        "destination_address": {"key": "destinationAddress", "type": "str"},
+        "destination_port": {"key": "destinationPort", "type": "str"},
+        "source_address": {"key": "sourceAddress", "type": "str"},
+        "source_port": {"key": "sourcePort", "type": "str"},
+        "protocol": {"key": "protocol", "type": "int"},
     }
 
     def __init__(
         self,
         *,
-        match_configuration_name: Optional[str] = None,
-        sequence_number: Optional[int] = None,
-        ip_address_type: Optional[Union[str, "_models.IPAddressType"]] = None,
-        match_conditions: Optional[List["_models.AccessControlListMatchCondition"]] = None,
-        actions: Optional[List["_models.AccessControlListAction"]] = None,
+        sequence_number: int,
+        action: Union[str, "_models.ConditionActionType"],
+        destination_address: str,
+        destination_port: str,
+        source_address: str,
+        source_port: str,
+        protocol: int,
+        annotation: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword match_configuration_name: The name of the match configuration.
-        :paramtype match_configuration_name: str
-        :keyword sequence_number: Sequence Number of the match configuration.
+        :keyword annotation: Switch configuration description.
+        :paramtype annotation: str
+        :keyword sequence_number: sequenceNumber of the Access Control List. Required.
         :paramtype sequence_number: int
-        :keyword ip_address_type: Type of IP Address. IPv4 or IPv6. Known values are: "IPv4" and
-         "IPv6".
-        :paramtype ip_address_type: str or ~azure.mgmt.managednetworkfabric.models.IPAddressType
-        :keyword match_conditions: List of the match conditions.
-        :paramtype match_conditions:
-         list[~azure.mgmt.managednetworkfabric.models.AccessControlListMatchCondition]
-        :keyword actions: List of actions that need to be performed for the matched conditions.
-        :paramtype actions: list[~azure.mgmt.managednetworkfabric.models.AccessControlListAction]
+        :keyword action: action. Example: allow | deny. Required. Known values are: "allow" and "deny".
+        :paramtype action: str or ~azure.mgmt.managednetworkfabric.models.ConditionActionType
+        :keyword destination_address: destinationAddress. Example: any | 1.1.1.0/24 | 1.1.10.10.
+         Required.
+        :paramtype destination_address: str
+        :keyword destination_port: destinationPort. Example: any | 1253. Required.
+        :paramtype destination_port: str
+        :keyword source_address: sourceAddress. Example: any | 1.1.1.0/24 | 1.1.10.10. Required.
+        :paramtype source_address: str
+        :keyword source_port: sourcePort. Example: any | 1253. Required.
+        :paramtype source_port: str
+        :keyword protocol: TCP/IP protocol as defined in the list of IP protocol numbers. Example: 255
+         (any) | 0 | 1. Required.
+        :paramtype protocol: int
         """
-        super().__init__(**kwargs)
-        self.match_configuration_name = match_configuration_name
+        super().__init__(annotation=annotation, **kwargs)
         self.sequence_number = sequence_number
-        self.ip_address_type = ip_address_type
-        self.match_conditions = match_conditions
-        self.actions = actions
-
-
-class TagsUpdate(_serialization.Model):
-    """Base tracked resource type for PATCH updates.
-
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
-    """
-
-    _attribute_map = {
-        "tags": {"key": "tags", "type": "{str}"},
-    }
-
-    def __init__(self, *, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
-        """
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
-        """
-        super().__init__(**kwargs)
-        self.tags = tags
+        self.action = action
+        self.destination_address = destination_address
+        self.destination_port = destination_port
+        self.source_address = source_address
+        self.source_port = source_port
+        self.protocol = protocol
 
 
-class AccessControlListPatch(TagsUpdate):
-    """The Access Control Lists patch resource definition.
+class AccessControlListPatch(_serialization.Model):
+    """The AccessControlList patch resource definition.
 
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
-    :ivar configuration_type: Input method to configure Access Control List. Known values are:
-     "File" and "Inline".
-    :vartype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-    :ivar acls_url: Access Control List file URL.
-    :vartype acls_url: str
-    :ivar match_configurations: List of match configurations.
-    :vartype match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.AccessControlListMatchConfiguration]
-    :ivar dynamic_match_configurations: List of dynamic match configurations.
-    :vartype dynamic_match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
+    :ivar address_family: IP address family. Example: ipv4 | ipv6. Known values are: "ipv4" and
+     "ipv6".
+    :vartype address_family: str or ~azure.mgmt.managednetworkfabric.models.AddressFamily
+    :ivar conditions: Access Control List conditions.
+    :vartype conditions:
+     list[~azure.mgmt.managednetworkfabric.models.AccessControlListConditionProperties]
     """
 
-    _validation = {
-        "acls_url": {"min_length": 1},
-        "match_configurations": {"min_items": 1},
-        "dynamic_match_configurations": {"min_items": 1},
-    }
-
     _attribute_map = {
         "tags": {"key": "tags", "type": "{str}"},
-        "configuration_type": {"key": "properties.configurationType", "type": "str"},
-        "acls_url": {"key": "properties.aclsUrl", "type": "str"},
-        "match_configurations": {
-            "key": "properties.matchConfigurations",
-            "type": "[AccessControlListMatchConfiguration]",
-        },
-        "dynamic_match_configurations": {
-            "key": "properties.dynamicMatchConfigurations",
-            "type": "[CommonDynamicMatchConfiguration]",
-        },
         "annotation": {"key": "properties.annotation", "type": "str"},
+        "address_family": {"key": "properties.addressFamily", "type": "str"},
+        "conditions": {"key": "properties.conditions", "type": "[AccessControlListConditionProperties]"},
     }
 
     def __init__(
         self,
         *,
         tags: Optional[Dict[str, str]] = None,
-        configuration_type: Optional[Union[str, "_models.ConfigurationType"]] = None,
-        acls_url: Optional[str] = None,
-        match_configurations: Optional[List["_models.AccessControlListMatchConfiguration"]] = None,
-        dynamic_match_configurations: Optional[List["_models.CommonDynamicMatchConfiguration"]] = None,
         annotation: Optional[str] = None,
+        address_family: Optional[Union[str, "_models.AddressFamily"]] = None,
+        conditions: Optional[List["_models.AccessControlListConditionProperties"]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
-        :keyword configuration_type: Input method to configure Access Control List. Known values are:
-         "File" and "Inline".
-        :paramtype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-        :keyword acls_url: Access Control List file URL.
-        :paramtype acls_url: str
-        :keyword match_configurations: List of match configurations.
-        :paramtype match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.AccessControlListMatchConfiguration]
-        :keyword dynamic_match_configurations: List of dynamic match configurations.
-        :paramtype dynamic_match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        """
-        super().__init__(tags=tags, **kwargs)
-        self.configuration_type = configuration_type
-        self.acls_url = acls_url
-        self.match_configurations = match_configurations
-        self.dynamic_match_configurations = dynamic_match_configurations
-        self.annotation = annotation
-
-
-class AccessControlListPatchableProperties(_serialization.Model):
-    """Access Control List Patch Properties defines the patchable resource properties.
-
-    :ivar configuration_type: Input method to configure Access Control List. Known values are:
-     "File" and "Inline".
-    :vartype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-    :ivar acls_url: Access Control List file URL.
-    :vartype acls_url: str
-    :ivar match_configurations: List of match configurations.
-    :vartype match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.AccessControlListMatchConfiguration]
-    :ivar dynamic_match_configurations: List of dynamic match configurations.
-    :vartype dynamic_match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
-    """
-
-    _validation = {
-        "acls_url": {"min_length": 1},
-        "match_configurations": {"min_items": 1},
-        "dynamic_match_configurations": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "configuration_type": {"key": "configurationType", "type": "str"},
-        "acls_url": {"key": "aclsUrl", "type": "str"},
-        "match_configurations": {"key": "matchConfigurations", "type": "[AccessControlListMatchConfiguration]"},
-        "dynamic_match_configurations": {
-            "key": "dynamicMatchConfigurations",
-            "type": "[CommonDynamicMatchConfiguration]",
-        },
-    }
-
-    def __init__(
-        self,
-        *,
-        configuration_type: Optional[Union[str, "_models.ConfigurationType"]] = None,
-        acls_url: Optional[str] = None,
-        match_configurations: Optional[List["_models.AccessControlListMatchConfiguration"]] = None,
-        dynamic_match_configurations: Optional[List["_models.CommonDynamicMatchConfiguration"]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword configuration_type: Input method to configure Access Control List. Known values are:
-         "File" and "Inline".
-        :paramtype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-        :keyword acls_url: Access Control List file URL.
-        :paramtype acls_url: str
-        :keyword match_configurations: List of match configurations.
-        :paramtype match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.AccessControlListMatchConfiguration]
-        :keyword dynamic_match_configurations: List of dynamic match configurations.
-        :paramtype dynamic_match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
-        """
-        super().__init__(**kwargs)
-        self.configuration_type = configuration_type
-        self.acls_url = acls_url
-        self.match_configurations = match_configurations
-        self.dynamic_match_configurations = dynamic_match_configurations
-
-
-class AnnotationResource(_serialization.Model):
-    """Switch configuration entries require a description to discern between configuration groups.
-
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    """
-
-    _attribute_map = {
-        "annotation": {"key": "annotation", "type": "str"},
-    }
-
-    def __init__(self, *, annotation: Optional[str] = None, **kwargs: Any) -> None:
-        """
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
+        :keyword address_family: IP address family. Example: ipv4 | ipv6. Known values are: "ipv4" and
+         "ipv6".
+        :paramtype address_family: str or ~azure.mgmt.managednetworkfabric.models.AddressFamily
+        :keyword conditions: Access Control List conditions.
+        :paramtype conditions:
+         list[~azure.mgmt.managednetworkfabric.models.AccessControlListConditionProperties]
         """
         super().__init__(**kwargs)
+        self.tags = tags
         self.annotation = annotation
+        self.address_family = address_family
+        self.conditions = conditions
 
 
-class AccessControlListPatchProperties(AccessControlListPatchableProperties, AnnotationResource):
-    """Access Control Lists patch properties.
+class AccessControlListPatchProperties(AnnotationResource):
+    """AccessControlListPatchProperties define the patchable resource properties.
 
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar configuration_type: Input method to configure Access Control List. Known values are:
-     "File" and "Inline".
-    :vartype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-    :ivar acls_url: Access Control List file URL.
-    :vartype acls_url: str
-    :ivar match_configurations: List of match configurations.
-    :vartype match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.AccessControlListMatchConfiguration]
-    :ivar dynamic_match_configurations: List of dynamic match configurations.
-    :vartype dynamic_match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
+    :ivar address_family: IP address family. Example: ipv4 | ipv6. Known values are: "ipv4" and
+     "ipv6".
+    :vartype address_family: str or ~azure.mgmt.managednetworkfabric.models.AddressFamily
+    :ivar conditions: Access Control List conditions.
+    :vartype conditions:
+     list[~azure.mgmt.managednetworkfabric.models.AccessControlListConditionProperties]
     """
 
-    _validation = {
-        "acls_url": {"min_length": 1},
-        "match_configurations": {"min_items": 1},
-        "dynamic_match_configurations": {"min_items": 1},
-    }
-
     _attribute_map = {
         "annotation": {"key": "annotation", "type": "str"},
-        "configuration_type": {"key": "configurationType", "type": "str"},
-        "acls_url": {"key": "aclsUrl", "type": "str"},
-        "match_configurations": {"key": "matchConfigurations", "type": "[AccessControlListMatchConfiguration]"},
-        "dynamic_match_configurations": {
-            "key": "dynamicMatchConfigurations",
-            "type": "[CommonDynamicMatchConfiguration]",
-        },
+        "address_family": {"key": "addressFamily", "type": "str"},
+        "conditions": {"key": "conditions", "type": "[AccessControlListConditionProperties]"},
     }
 
     def __init__(
         self,
         *,
         annotation: Optional[str] = None,
-        configuration_type: Optional[Union[str, "_models.ConfigurationType"]] = None,
-        acls_url: Optional[str] = None,
-        match_configurations: Optional[List["_models.AccessControlListMatchConfiguration"]] = None,
-        dynamic_match_configurations: Optional[List["_models.CommonDynamicMatchConfiguration"]] = None,
+        address_family: Optional[Union[str, "_models.AddressFamily"]] = None,
+        conditions: Optional[List["_models.AccessControlListConditionProperties"]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword configuration_type: Input method to configure Access Control List. Known values are:
-         "File" and "Inline".
-        :paramtype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-        :keyword acls_url: Access Control List file URL.
-        :paramtype acls_url: str
-        :keyword match_configurations: List of match configurations.
-        :paramtype match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.AccessControlListMatchConfiguration]
-        :keyword dynamic_match_configurations: List of dynamic match configurations.
-        :paramtype dynamic_match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
+        :keyword address_family: IP address family. Example: ipv4 | ipv6. Known values are: "ipv4" and
+         "ipv6".
+        :paramtype address_family: str or ~azure.mgmt.managednetworkfabric.models.AddressFamily
+        :keyword conditions: Access Control List conditions.
+        :paramtype conditions:
+         list[~azure.mgmt.managednetworkfabric.models.AccessControlListConditionProperties]
         """
-        super().__init__(
-            configuration_type=configuration_type,
-            acls_url=acls_url,
-            match_configurations=match_configurations,
-            dynamic_match_configurations=dynamic_match_configurations,
-            annotation=annotation,
-            **kwargs
-        )
-        self.annotation = annotation
-        self.configuration_type = configuration_type
-        self.acls_url = acls_url
-        self.match_configurations = match_configurations
-        self.dynamic_match_configurations = dynamic_match_configurations
-
-
-class PortCondition(_serialization.Model):
-    """Port condition that needs to be matched.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar port_type: Port type that needs to be matched. Known values are: "SourcePort" and
-     "DestinationPort".
-    :vartype port_type: str or ~azure.mgmt.managednetworkfabric.models.PortType
-    :ivar layer4_protocol: Layer4 protocol type that needs to be matched. Required. Known values
-     are: "TCP" and "UDP".
-    :vartype layer4_protocol: str or ~azure.mgmt.managednetworkfabric.models.Layer4Protocol
-    :ivar ports: List of the Ports that need to be matched.
-    :vartype ports: list[str]
-    :ivar port_group_names: List of the port Group Names that to be matched.
-    :vartype port_group_names: list[str]
-    """
-
-    _validation = {
-        "layer4_protocol": {"required": True},
-        "ports": {"min_items": 1},
-        "port_group_names": {"min_items": 1},
-    }
+        super().__init__(annotation=annotation, **kwargs)
+        self.address_family = address_family
+        self.conditions = conditions
 
-    _attribute_map = {
-        "port_type": {"key": "portType", "type": "str"},
-        "layer4_protocol": {"key": "layer4Protocol", "type": "str"},
-        "ports": {"key": "ports", "type": "[str]"},
-        "port_group_names": {"key": "portGroupNames", "type": "[str]"},
-    }
 
-    def __init__(
-        self,
-        *,
-        layer4_protocol: Union[str, "_models.Layer4Protocol"],
-        port_type: Optional[Union[str, "_models.PortType"]] = None,
-        ports: Optional[List[str]] = None,
-        port_group_names: Optional[List[str]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword port_type: Port type that needs to be matched. Known values are: "SourcePort" and
-         "DestinationPort".
-        :paramtype port_type: str or ~azure.mgmt.managednetworkfabric.models.PortType
-        :keyword layer4_protocol: Layer4 protocol type that needs to be matched. Required. Known values
-         are: "TCP" and "UDP".
-        :paramtype layer4_protocol: str or ~azure.mgmt.managednetworkfabric.models.Layer4Protocol
-        :keyword ports: List of the Ports that need to be matched.
-        :paramtype ports: list[str]
-        :keyword port_group_names: List of the port Group Names that to be matched.
-        :paramtype port_group_names: list[str]
-        """
-        super().__init__(**kwargs)
-        self.port_type = port_type
-        self.layer4_protocol = layer4_protocol
-        self.ports = ports
-        self.port_group_names = port_group_names
+class AccessControlListProperties(AnnotationResource):
+    """AccessControlListProperties define the resource properties.
 
-
-class AccessControlListPortCondition(PortCondition):
-    """Defines the port condition that needs to be matched.
+    Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar port_type: Port type that needs to be matched. Known values are: "SourcePort" and
-     "DestinationPort".
-    :vartype port_type: str or ~azure.mgmt.managednetworkfabric.models.PortType
-    :ivar layer4_protocol: Layer4 protocol type that needs to be matched. Required. Known values
-     are: "TCP" and "UDP".
-    :vartype layer4_protocol: str or ~azure.mgmt.managednetworkfabric.models.Layer4Protocol
-    :ivar ports: List of the Ports that need to be matched.
-    :vartype ports: list[str]
-    :ivar port_group_names: List of the port Group Names that to be matched.
-    :vartype port_group_names: list[str]
-    :ivar flags: List of protocol flags that needs to be matched.
-    :vartype flags: list[str]
-    """
-
-    _validation = {
-        "layer4_protocol": {"required": True},
-        "ports": {"min_items": 1},
-        "port_group_names": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "port_type": {"key": "portType", "type": "str"},
-        "layer4_protocol": {"key": "layer4Protocol", "type": "str"},
-        "ports": {"key": "ports", "type": "[str]"},
-        "port_group_names": {"key": "portGroupNames", "type": "[str]"},
-        "flags": {"key": "flags", "type": "[str]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        layer4_protocol: Union[str, "_models.Layer4Protocol"],
-        port_type: Optional[Union[str, "_models.PortType"]] = None,
-        ports: Optional[List[str]] = None,
-        port_group_names: Optional[List[str]] = None,
-        flags: Optional[List[str]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword port_type: Port type that needs to be matched. Known values are: "SourcePort" and
-         "DestinationPort".
-        :paramtype port_type: str or ~azure.mgmt.managednetworkfabric.models.PortType
-        :keyword layer4_protocol: Layer4 protocol type that needs to be matched. Required. Known values
-         are: "TCP" and "UDP".
-        :paramtype layer4_protocol: str or ~azure.mgmt.managednetworkfabric.models.Layer4Protocol
-        :keyword ports: List of the Ports that need to be matched.
-        :paramtype ports: list[str]
-        :keyword port_group_names: List of the port Group Names that to be matched.
-        :paramtype port_group_names: list[str]
-        :keyword flags: List of protocol flags that needs to be matched.
-        :paramtype flags: list[str]
-        """
-        super().__init__(
-            port_type=port_type,
-            layer4_protocol=layer4_protocol,
-            ports=ports,
-            port_group_names=port_group_names,
-            **kwargs
-        )
-        self.flags = flags
-
-
-class AccessControlListProperties(AnnotationResource, AccessControlListPatchableProperties):
-    """Access Control List Properties defines the resource properties.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar configuration_type: Input method to configure Access Control List. Known values are:
-     "File" and "Inline".
-    :vartype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-    :ivar acls_url: Access Control List file URL.
-    :vartype acls_url: str
-    :ivar match_configurations: List of match configurations.
-    :vartype match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.AccessControlListMatchConfiguration]
-    :ivar dynamic_match_configurations: List of dynamic match configurations.
-    :vartype dynamic_match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar last_synced_time: The last synced timestamp.
-    :vartype last_synced_time: ~datetime.datetime
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
+    :ivar annotation: Switch configuration description.
+    :vartype annotation: str
+    :ivar address_family: IP address family. Example: ipv4 | ipv6. Required. Known values are:
+     "ipv4" and "ipv6".
+    :vartype address_family: str or ~azure.mgmt.managednetworkfabric.models.AddressFamily
+    :ivar conditions: Access Control List conditions. Required.
+    :vartype conditions:
+     list[~azure.mgmt.managednetworkfabric.models.AccessControlListConditionProperties]
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
-        "acls_url": {"min_length": 1},
-        "match_configurations": {"min_items": 1},
-        "dynamic_match_configurations": {"min_items": 1},
-        "last_synced_time": {"readonly": True},
-        "configuration_state": {"readonly": True},
+        "address_family": {"required": True},
+        "conditions": {"required": True},
         "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
     }
 
     _attribute_map = {
-        "configuration_type": {"key": "configurationType", "type": "str"},
-        "acls_url": {"key": "aclsUrl", "type": "str"},
-        "match_configurations": {"key": "matchConfigurations", "type": "[AccessControlListMatchConfiguration]"},
-        "dynamic_match_configurations": {
-            "key": "dynamicMatchConfigurations",
-            "type": "[CommonDynamicMatchConfiguration]",
-        },
         "annotation": {"key": "annotation", "type": "str"},
-        "last_synced_time": {"key": "lastSyncedTime", "type": "iso-8601"},
-        "configuration_state": {"key": "configurationState", "type": "str"},
+        "address_family": {"key": "addressFamily", "type": "str"},
+        "conditions": {"key": "conditions", "type": "[AccessControlListConditionProperties]"},
         "provisioning_state": {"key": "provisioningState", "type": "str"},
-        "administrative_state": {"key": "administrativeState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
-        configuration_type: Optional[Union[str, "_models.ConfigurationType"]] = None,
-        acls_url: Optional[str] = None,
-        match_configurations: Optional[List["_models.AccessControlListMatchConfiguration"]] = None,
-        dynamic_match_configurations: Optional[List["_models.CommonDynamicMatchConfiguration"]] = None,
+        address_family: Union[str, "_models.AddressFamily"],
+        conditions: List["_models.AccessControlListConditionProperties"],
         annotation: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword configuration_type: Input method to configure Access Control List. Known values are:
-         "File" and "Inline".
-        :paramtype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-        :keyword acls_url: Access Control List file URL.
-        :paramtype acls_url: str
-        :keyword match_configurations: List of match configurations.
-        :paramtype match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.AccessControlListMatchConfiguration]
-        :keyword dynamic_match_configurations: List of dynamic match configurations.
-        :paramtype dynamic_match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
+        :keyword address_family: IP address family. Example: ipv4 | ipv6. Required. Known values are:
+         "ipv4" and "ipv6".
+        :paramtype address_family: str or ~azure.mgmt.managednetworkfabric.models.AddressFamily
+        :keyword conditions: Access Control List conditions. Required.
+        :paramtype conditions:
+         list[~azure.mgmt.managednetworkfabric.models.AccessControlListConditionProperties]
         """
-        super().__init__(
-            annotation=annotation,
-            configuration_type=configuration_type,
-            acls_url=acls_url,
-            match_configurations=match_configurations,
-            dynamic_match_configurations=dynamic_match_configurations,
-            **kwargs
-        )
-        self.configuration_type = configuration_type
-        self.acls_url = acls_url
-        self.match_configurations = match_configurations
-        self.dynamic_match_configurations = dynamic_match_configurations
-        self.last_synced_time = None
-        self.configuration_state = None
+        super().__init__(annotation=annotation, **kwargs)
+        self.address_family = address_family
+        self.conditions = conditions
         self.provisioning_state = None
-        self.administrative_state = None
-        self.annotation = annotation
 
 
 class AccessControlListsListResult(_serialization.Model):
-    """List of Access Control Lists.
+    """List of AccessControlLists.
 
-    :ivar value: List of Access Control List resources.
+    :ivar value: List of AccessControlList resources.
     :vartype value: list[~azure.mgmt.managednetworkfabric.models.AccessControlList]
     :ivar next_link: Url to follow for getting next page of resources.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[AccessControlList]"},
@@ -979,94 +484,94 @@
         self,
         *,
         value: Optional[List["_models.AccessControlList"]] = None,
         next_link: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword value: List of Access Control List resources.
+        :keyword value: List of AccessControlList resources.
         :paramtype value: list[~azure.mgmt.managednetworkfabric.models.AccessControlList]
         :keyword next_link: Url to follow for getting next page of resources.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
 class IpCommunitySetOperationProperties(_serialization.Model):
     """IP Community set operation properties.
 
-    :ivar set: List of IP Community IDs.
+    :ivar set: IP Community ID list properties.
     :vartype set: ~azure.mgmt.managednetworkfabric.models.IpCommunityIdList
     """
 
     _attribute_map = {
         "set": {"key": "set", "type": "IpCommunityIdList"},
     }
 
     def __init__(self, *, set: Optional["_models.IpCommunityIdList"] = None, **kwargs: Any) -> None:
         """
-        :keyword set: List of IP Community IDs.
+        :keyword set: IP Community ID list properties.
         :paramtype set: ~azure.mgmt.managednetworkfabric.models.IpCommunityIdList
         """
         super().__init__(**kwargs)
         self.set = set
 
 
 class IpCommunityDeleteOperationProperties(_serialization.Model):
     """IP Community delete operation properties.
 
-    :ivar delete: List of IP Community IDs.
+    :ivar delete: IP Community ID list properties.
     :vartype delete: ~azure.mgmt.managednetworkfabric.models.IpCommunityIdList
     """
 
     _attribute_map = {
         "delete": {"key": "delete", "type": "IpCommunityIdList"},
     }
 
     def __init__(self, *, delete: Optional["_models.IpCommunityIdList"] = None, **kwargs: Any) -> None:
         """
-        :keyword delete: List of IP Community IDs.
+        :keyword delete: IP Community ID list properties.
         :paramtype delete: ~azure.mgmt.managednetworkfabric.models.IpCommunityIdList
         """
         super().__init__(**kwargs)
         self.delete = delete
 
 
 class IpCommunityAddOperationProperties(_serialization.Model):
     """IP Community add operation properties.
 
-    :ivar add: List of IP Community IDs.
+    :ivar add: IP Community ID list properties.
     :vartype add: ~azure.mgmt.managednetworkfabric.models.IpCommunityIdList
     """
 
     _attribute_map = {
         "add": {"key": "add", "type": "IpCommunityIdList"},
     }
 
     def __init__(self, *, add: Optional["_models.IpCommunityIdList"] = None, **kwargs: Any) -> None:
         """
-        :keyword add: List of IP Community IDs.
+        :keyword add: IP Community ID list properties.
         :paramtype add: ~azure.mgmt.managednetworkfabric.models.IpCommunityIdList
         """
         super().__init__(**kwargs)
         self.add = add
 
 
 class ActionIpCommunityProperties(
     IpCommunityAddOperationProperties, IpCommunityDeleteOperationProperties, IpCommunitySetOperationProperties
 ):
     """IP Community Properties.
 
-    :ivar set: List of IP Community IDs.
+    :ivar set: IP Community ID list properties.
     :vartype set: ~azure.mgmt.managednetworkfabric.models.IpCommunityIdList
-    :ivar delete: List of IP Community IDs.
+    :ivar delete: IP Community ID list properties.
     :vartype delete: ~azure.mgmt.managednetworkfabric.models.IpCommunityIdList
-    :ivar add: List of IP Community IDs.
+    :ivar add: IP Community ID list properties.
     :vartype add: ~azure.mgmt.managednetworkfabric.models.IpCommunityIdList
     """
 
     _attribute_map = {
         "set": {"key": "set", "type": "IpCommunityIdList"},
         "delete": {"key": "delete", "type": "IpCommunityIdList"},
         "add": {"key": "add", "type": "IpCommunityIdList"},
@@ -1077,99 +582,99 @@
         *,
         set: Optional["_models.IpCommunityIdList"] = None,
         delete: Optional["_models.IpCommunityIdList"] = None,
         add: Optional["_models.IpCommunityIdList"] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword set: List of IP Community IDs.
+        :keyword set: IP Community ID list properties.
         :paramtype set: ~azure.mgmt.managednetworkfabric.models.IpCommunityIdList
-        :keyword delete: List of IP Community IDs.
+        :keyword delete: IP Community ID list properties.
         :paramtype delete: ~azure.mgmt.managednetworkfabric.models.IpCommunityIdList
-        :keyword add: List of IP Community IDs.
+        :keyword add: IP Community ID list properties.
         :paramtype add: ~azure.mgmt.managednetworkfabric.models.IpCommunityIdList
         """
         super().__init__(add=add, delete=delete, set=set, **kwargs)
         self.set = set
         self.delete = delete
         self.add = add
 
 
 class IpExtendedCommunitySetOperationProperties(_serialization.Model):
     """IP Extended Community set operation properties.
 
-    :ivar set: List of IP Extended Community IDs.
+    :ivar set: IP Extended Community Id list properties.
     :vartype set: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityIdList
     """
 
     _attribute_map = {
         "set": {"key": "set", "type": "IpExtendedCommunityIdList"},
     }
 
     def __init__(self, *, set: Optional["_models.IpExtendedCommunityIdList"] = None, **kwargs: Any) -> None:
         """
-        :keyword set: List of IP Extended Community IDs.
+        :keyword set: IP Extended Community Id list properties.
         :paramtype set: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityIdList
         """
         super().__init__(**kwargs)
         self.set = set
 
 
 class IpExtendedCommunityDeleteOperationProperties(_serialization.Model):
     """IP Extended Community delete operation properties.
 
-    :ivar delete: List of IP Extended Community IDs.
+    :ivar delete: IP Extended Community Id list properties.
     :vartype delete: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityIdList
     """
 
     _attribute_map = {
         "delete": {"key": "delete", "type": "IpExtendedCommunityIdList"},
     }
 
     def __init__(self, *, delete: Optional["_models.IpExtendedCommunityIdList"] = None, **kwargs: Any) -> None:
         """
-        :keyword delete: List of IP Extended Community IDs.
+        :keyword delete: IP Extended Community Id list properties.
         :paramtype delete: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityIdList
         """
         super().__init__(**kwargs)
         self.delete = delete
 
 
 class IpExtendedCommunityAddOperationProperties(_serialization.Model):
     """IP Extended Community add operation properties.
 
-    :ivar add: List of IP Extended Community IDs.
+    :ivar add: IP Extended Community Id list properties.
     :vartype add: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityIdList
     """
 
     _attribute_map = {
         "add": {"key": "add", "type": "IpExtendedCommunityIdList"},
     }
 
     def __init__(self, *, add: Optional["_models.IpExtendedCommunityIdList"] = None, **kwargs: Any) -> None:
         """
-        :keyword add: List of IP Extended Community IDs.
+        :keyword add: IP Extended Community Id list properties.
         :paramtype add: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityIdList
         """
         super().__init__(**kwargs)
         self.add = add
 
 
 class ActionIpExtendedCommunityProperties(
     IpExtendedCommunityAddOperationProperties,
     IpExtendedCommunityDeleteOperationProperties,
     IpExtendedCommunitySetOperationProperties,
 ):
     """IP Extended Community Properties.
 
-    :ivar set: List of IP Extended Community IDs.
+    :ivar set: IP Extended Community Id list properties.
     :vartype set: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityIdList
-    :ivar delete: List of IP Extended Community IDs.
+    :ivar delete: IP Extended Community Id list properties.
     :vartype delete: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityIdList
-    :ivar add: List of IP Extended Community IDs.
+    :ivar add: IP Extended Community Id list properties.
     :vartype add: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityIdList
     """
 
     _attribute_map = {
         "set": {"key": "set", "type": "IpExtendedCommunityIdList"},
         "delete": {"key": "delete", "type": "IpExtendedCommunityIdList"},
         "add": {"key": "add", "type": "IpExtendedCommunityIdList"},
@@ -1180,67 +685,56 @@
         *,
         set: Optional["_models.IpExtendedCommunityIdList"] = None,
         delete: Optional["_models.IpExtendedCommunityIdList"] = None,
         add: Optional["_models.IpExtendedCommunityIdList"] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword set: List of IP Extended Community IDs.
+        :keyword set: IP Extended Community Id list properties.
         :paramtype set: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityIdList
-        :keyword delete: List of IP Extended Community IDs.
+        :keyword delete: IP Extended Community Id list properties.
         :paramtype delete: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityIdList
-        :keyword add: List of IP Extended Community IDs.
+        :keyword add: IP Extended Community Id list properties.
         :paramtype add: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityIdList
         """
         super().__init__(add=add, delete=delete, set=set, **kwargs)
         self.set = set
         self.delete = delete
         self.add = add
 
 
 class AggregateRoute(_serialization.Model):
-    """aggregateIpv4Route model.
-
-    All required parameters must be populated in order to send to Azure.
+    """Aggregate Route properties.
 
-    :ivar prefix: IPv4 Prefix of the aggregate Ipv4Route. Required.
+    :ivar prefix: Prefix of the aggregate Route.
     :vartype prefix: str
     """
 
-    _validation = {
-        "prefix": {"required": True, "min_length": 1},
-    }
-
     _attribute_map = {
         "prefix": {"key": "prefix", "type": "str"},
     }
 
-    def __init__(self, *, prefix: str, **kwargs: Any) -> None:
+    def __init__(self, *, prefix: Optional[str] = None, **kwargs: Any) -> None:
         """
-        :keyword prefix: IPv4 Prefix of the aggregate Ipv4Route. Required.
+        :keyword prefix: Prefix of the aggregate Route.
         :paramtype prefix: str
         """
         super().__init__(**kwargs)
         self.prefix = prefix
 
 
 class AggregateRouteConfiguration(_serialization.Model):
-    """List of IPv4 and IPv6 aggregate routes.
+    """List of IPv4 and IPv6 route configurations.
 
     :ivar ipv4_routes: List of IPv4 Route prefixes.
     :vartype ipv4_routes: list[~azure.mgmt.managednetworkfabric.models.AggregateRoute]
-    :ivar ipv6_routes: List of Ipv6Routes prefixes.
+    :ivar ipv6_routes: List of IPv6 Routes prefixes.
     :vartype ipv6_routes: list[~azure.mgmt.managednetworkfabric.models.AggregateRoute]
     """
 
-    _validation = {
-        "ipv4_routes": {"min_items": 1},
-        "ipv6_routes": {"min_items": 1},
-    }
-
     _attribute_map = {
         "ipv4_routes": {"key": "ipv4Routes", "type": "[AggregateRoute]"},
         "ipv6_routes": {"key": "ipv6Routes", "type": "[AggregateRoute]"},
     }
 
     def __init__(
         self,
@@ -1248,65 +742,119 @@
         ipv4_routes: Optional[List["_models.AggregateRoute"]] = None,
         ipv6_routes: Optional[List["_models.AggregateRoute"]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword ipv4_routes: List of IPv4 Route prefixes.
         :paramtype ipv4_routes: list[~azure.mgmt.managednetworkfabric.models.AggregateRoute]
-        :keyword ipv6_routes: List of Ipv6Routes prefixes.
+        :keyword ipv6_routes: List of IPv6 Routes prefixes.
         :paramtype ipv6_routes: list[~azure.mgmt.managednetworkfabric.models.AggregateRoute]
         """
         super().__init__(**kwargs)
         self.ipv4_routes = ipv4_routes
         self.ipv6_routes = ipv6_routes
 
 
+class ARPProperties(_serialization.Model):
+    """Show ARP table entry properties.
+
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar address: Ipv4 or Ipv6 address. Required.
+    :vartype address: str
+    :ivar age: Duration in seconds. Required.
+    :vartype age: str
+    :ivar mac_address: Hardware address. Required.
+    :vartype mac_address: str
+    :ivar interface: Layer 2 interface name. Required.
+    :vartype interface: str
+    :ivar state: ARP status.
+    :vartype state: str
+    """
+
+    _validation = {
+        "address": {"required": True},
+        "age": {"required": True},
+        "mac_address": {"required": True},
+        "interface": {"required": True},
+    }
+
+    _attribute_map = {
+        "address": {"key": "address", "type": "str"},
+        "age": {"key": "age", "type": "str"},
+        "mac_address": {"key": "macAddress", "type": "str"},
+        "interface": {"key": "interface", "type": "str"},
+        "state": {"key": "state", "type": "str"},
+    }
+
+    def __init__(
+        self, *, address: str, age: str, mac_address: str, interface: str, state: Optional[str] = None, **kwargs: Any
+    ) -> None:
+        """
+        :keyword address: Ipv4 or Ipv6 address. Required.
+        :paramtype address: str
+        :keyword age: Duration in seconds. Required.
+        :paramtype age: str
+        :keyword mac_address: Hardware address. Required.
+        :paramtype mac_address: str
+        :keyword interface: Layer 2 interface name. Required.
+        :paramtype interface: str
+        :keyword state: ARP status.
+        :paramtype state: str
+        """
+        super().__init__(**kwargs)
+        self.address = address
+        self.age = age
+        self.mac_address = mac_address
+        self.interface = interface
+        self.state = state
+
+
 class BfdConfiguration(_serialization.Model):
     """BFD configuration properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar administrative_state: Administrative state of the BfdConfiguration. Example: Enabled |
-     Disabled. Known values are: "Enabled", "Disabled", "MAT", and "RMA".
+     Disabled. Known values are: "Enabled" and "Disabled".
     :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.BfdAdministrativeState
-    :ivar interval_in_milli_seconds: Interval in milliseconds. Example: 300.
-    :vartype interval_in_milli_seconds: int
-    :ivar multiplier: Multiplier for the Bfd Configuration. Example: 5.
+     ~azure.mgmt.managednetworkfabric.models.EnabledDisabledState
+    :ivar interval: interval in milliseconds. Example: 300.
+    :vartype interval: int
+    :ivar multiplier: Multiplier for the Bfd Configuration. Example: 3.
     :vartype multiplier: int
     """
 
     _validation = {
         "administrative_state": {"readonly": True},
+        "interval": {"readonly": True},
+        "multiplier": {"readonly": True},
     }
 
     _attribute_map = {
         "administrative_state": {"key": "administrativeState", "type": "str"},
-        "interval_in_milli_seconds": {"key": "intervalInMilliSeconds", "type": "int"},
+        "interval": {"key": "interval", "type": "int"},
         "multiplier": {"key": "multiplier", "type": "int"},
     }
 
-    def __init__(self, *, interval_in_milli_seconds: int = 300, multiplier: int = 5, **kwargs: Any) -> None:
-        """
-        :keyword interval_in_milli_seconds: Interval in milliseconds. Example: 300.
-        :paramtype interval_in_milli_seconds: int
-        :keyword multiplier: Multiplier for the Bfd Configuration. Example: 5.
-        :paramtype multiplier: int
-        """
+    def __init__(self, **kwargs: Any) -> None:
+        """ """
         super().__init__(**kwargs)
         self.administrative_state = None
-        self.interval_in_milli_seconds = interval_in_milli_seconds
-        self.multiplier = multiplier
+        self.interval = None
+        self.multiplier = None
 
 
 class BgpConfiguration(AnnotationResource):  # pylint: disable=too-many-instance-attributes
     """BGP configuration properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
+    All required parameters must be populated in order to send to Azure.
+
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
     :ivar bfd_configuration: BFD configuration properties.
     :vartype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
     :ivar default_route_originate: Originate a defaultRoute. Ex: "True" | "False". Known values
      are: "True" and "False".
     :vartype default_route_originate: str or
@@ -1314,34 +862,30 @@
     :ivar allow_as: Allows for routes to be received and processed even if the router detects its
      own ASN in the AS-Path. 0 is disable, Possible values are 1-10, default is 2.
     :vartype allow_as: int
     :ivar allow_as_override: Enable Or Disable state. Known values are: "Enable" and "Disable".
     :vartype allow_as_override: str or ~azure.mgmt.managednetworkfabric.models.AllowASOverride
     :ivar fabric_asn: ASN of Network Fabric. Example: 65048.
     :vartype fabric_asn: int
-    :ivar peer_asn: Peer ASN. Example: 65047.
+    :ivar peer_asn: Peer ASN. Example: 65047. Required.
     :vartype peer_asn: int
-    :ivar ipv4_listen_range_prefixes: List of BGP IPv4 Listen Range prefixes.
+    :ivar ipv4_listen_range_prefixes: BGP Ipv4 ListenRange.
     :vartype ipv4_listen_range_prefixes: list[str]
-    :ivar ipv6_listen_range_prefixes: List of BGP IPv6 Listen Ranges prefixes.
+    :ivar ipv6_listen_range_prefixes: BGP Ipv6 ListenRange.
     :vartype ipv6_listen_range_prefixes: list[str]
-    :ivar ipv4_neighbor_address: List with stringified IPv4 Neighbor Addresses.
+    :ivar ipv4_neighbor_address: List with stringified ipv4NeighborAddresses.
     :vartype ipv4_neighbor_address: list[~azure.mgmt.managednetworkfabric.models.NeighborAddress]
     :ivar ipv6_neighbor_address: List with stringified IPv6 Neighbor Address.
     :vartype ipv6_neighbor_address: list[~azure.mgmt.managednetworkfabric.models.NeighborAddress]
     """
 
     _validation = {
         "allow_as": {"maximum": 10, "minimum": 0},
         "fabric_asn": {"readonly": True},
-        "peer_asn": {"maximum": 4294967295, "minimum": 1},
-        "ipv4_listen_range_prefixes": {"min_items": 1},
-        "ipv6_listen_range_prefixes": {"min_items": 1},
-        "ipv4_neighbor_address": {"min_items": 1},
-        "ipv6_neighbor_address": {"min_items": 1},
+        "peer_asn": {"required": True, "maximum": 65535, "minimum": 1},
     }
 
     _attribute_map = {
         "annotation": {"key": "annotation", "type": "str"},
         "bfd_configuration": {"key": "bfdConfiguration", "type": "BfdConfiguration"},
         "default_route_originate": {"key": "defaultRouteOriginate", "type": "str"},
         "allow_as": {"key": "allowAS", "type": "int"},
@@ -1353,20 +897,20 @@
         "ipv4_neighbor_address": {"key": "ipv4NeighborAddress", "type": "[NeighborAddress]"},
         "ipv6_neighbor_address": {"key": "ipv6NeighborAddress", "type": "[NeighborAddress]"},
     }
 
     def __init__(
         self,
         *,
+        peer_asn: int,
         annotation: Optional[str] = None,
         bfd_configuration: Optional["_models.BfdConfiguration"] = None,
         default_route_originate: Optional[Union[str, "_models.BooleanEnumProperty"]] = None,
         allow_as: int = 2,
         allow_as_override: Optional[Union[str, "_models.AllowASOverride"]] = None,
-        peer_asn: Optional[int] = None,
         ipv4_listen_range_prefixes: Optional[List[str]] = None,
         ipv6_listen_range_prefixes: Optional[List[str]] = None,
         ipv4_neighbor_address: Optional[List["_models.NeighborAddress"]] = None,
         ipv6_neighbor_address: Optional[List["_models.NeighborAddress"]] = None,
         **kwargs: Any
     ) -> None:
         """
@@ -1379,21 +923,21 @@
         :paramtype default_route_originate: str or
          ~azure.mgmt.managednetworkfabric.models.BooleanEnumProperty
         :keyword allow_as: Allows for routes to be received and processed even if the router detects
          its own ASN in the AS-Path. 0 is disable, Possible values are 1-10, default is 2.
         :paramtype allow_as: int
         :keyword allow_as_override: Enable Or Disable state. Known values are: "Enable" and "Disable".
         :paramtype allow_as_override: str or ~azure.mgmt.managednetworkfabric.models.AllowASOverride
-        :keyword peer_asn: Peer ASN. Example: 65047.
+        :keyword peer_asn: Peer ASN. Example: 65047. Required.
         :paramtype peer_asn: int
-        :keyword ipv4_listen_range_prefixes: List of BGP IPv4 Listen Range prefixes.
+        :keyword ipv4_listen_range_prefixes: BGP Ipv4 ListenRange.
         :paramtype ipv4_listen_range_prefixes: list[str]
-        :keyword ipv6_listen_range_prefixes: List of BGP IPv6 Listen Ranges prefixes.
+        :keyword ipv6_listen_range_prefixes: BGP Ipv6 ListenRange.
         :paramtype ipv6_listen_range_prefixes: list[str]
-        :keyword ipv4_neighbor_address: List with stringified IPv4 Neighbor Addresses.
+        :keyword ipv4_neighbor_address: List with stringified ipv4NeighborAddresses.
         :paramtype ipv4_neighbor_address: list[~azure.mgmt.managednetworkfabric.models.NeighborAddress]
         :keyword ipv6_neighbor_address: List with stringified IPv6 Neighbor Address.
         :paramtype ipv6_neighbor_address: list[~azure.mgmt.managednetworkfabric.models.NeighborAddress]
         """
         super().__init__(annotation=annotation, **kwargs)
         self.bfd_configuration = bfd_configuration
         self.default_route_originate = default_route_originate
@@ -1403,328 +947,39 @@
         self.peer_asn = peer_asn
         self.ipv4_listen_range_prefixes = ipv4_listen_range_prefixes
         self.ipv6_listen_range_prefixes = ipv6_listen_range_prefixes
         self.ipv4_neighbor_address = ipv4_neighbor_address
         self.ipv6_neighbor_address = ipv6_neighbor_address
 
 
-class CommonDynamicMatchConfiguration(_serialization.Model):
-    """Dynamic match configuration object.
-
-    :ivar ip_groups: List of IP Groups.
-    :vartype ip_groups: list[~azure.mgmt.managednetworkfabric.models.IpGroupProperties]
-    :ivar vlan_groups: List of vlan groups.
-    :vartype vlan_groups: list[~azure.mgmt.managednetworkfabric.models.VlanGroupProperties]
-    :ivar port_groups: List of the port group.
-    :vartype port_groups: list[~azure.mgmt.managednetworkfabric.models.PortGroupProperties]
-    """
-
-    _validation = {
-        "ip_groups": {"min_items": 1},
-        "vlan_groups": {"min_items": 1},
-        "port_groups": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "ip_groups": {"key": "ipGroups", "type": "[IpGroupProperties]"},
-        "vlan_groups": {"key": "vlanGroups", "type": "[VlanGroupProperties]"},
-        "port_groups": {"key": "portGroups", "type": "[PortGroupProperties]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        ip_groups: Optional[List["_models.IpGroupProperties"]] = None,
-        vlan_groups: Optional[List["_models.VlanGroupProperties"]] = None,
-        port_groups: Optional[List["_models.PortGroupProperties"]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword ip_groups: List of IP Groups.
-        :paramtype ip_groups: list[~azure.mgmt.managednetworkfabric.models.IpGroupProperties]
-        :keyword vlan_groups: List of vlan groups.
-        :paramtype vlan_groups: list[~azure.mgmt.managednetworkfabric.models.VlanGroupProperties]
-        :keyword port_groups: List of the port group.
-        :paramtype port_groups: list[~azure.mgmt.managednetworkfabric.models.PortGroupProperties]
-        """
-        super().__init__(**kwargs)
-        self.ip_groups = ip_groups
-        self.vlan_groups = vlan_groups
-        self.port_groups = port_groups
-
-
-class ErrorResponse(_serialization.Model):
-    """Common error response for all Azure Resource Manager APIs to return error details for failed
-    operations. (This also follows the OData error response format.).
-
-    :ivar error: The error object.
-    :vartype error: ~azure.mgmt.managednetworkfabric.models.ErrorDetail
-    """
-
-    _attribute_map = {
-        "error": {"key": "error", "type": "ErrorDetail"},
-    }
-
-    def __init__(self, *, error: Optional["_models.ErrorDetail"] = None, **kwargs: Any) -> None:
-        """
-        :keyword error: The error object.
-        :paramtype error: ~azure.mgmt.managednetworkfabric.models.ErrorDetail
-        """
-        super().__init__(**kwargs)
-        self.error = error
-
-
-class CommonPostActionResponseForDeviceUpdate(ErrorResponse):
-    """Common response for device updates.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar error: The error object.
-    :vartype error: ~azure.mgmt.managednetworkfabric.models.ErrorDetail
-    :ivar configuration_state: Gets the configuration state. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar successful_devices: List of ARM Resource IDs for which the given action applied
-     successfully.
-    :vartype successful_devices: list[str]
-    :ivar failed_devices: List of ARM Resource IDs for which the given action failed to apply.
-    :vartype failed_devices: list[str]
-    """
-
-    _validation = {
-        "configuration_state": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "error": {"key": "error", "type": "ErrorDetail"},
-        "configuration_state": {"key": "configurationState", "type": "str"},
-        "successful_devices": {"key": "successfulDevices", "type": "[str]"},
-        "failed_devices": {"key": "failedDevices", "type": "[str]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        error: Optional["_models.ErrorDetail"] = None,
-        successful_devices: Optional[List[str]] = None,
-        failed_devices: Optional[List[str]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword error: The error object.
-        :paramtype error: ~azure.mgmt.managednetworkfabric.models.ErrorDetail
-        :keyword successful_devices: List of ARM Resource IDs for which the given action applied
-         successfully.
-        :paramtype successful_devices: list[str]
-        :keyword failed_devices: List of ARM Resource IDs for which the given action failed to apply.
-        :paramtype failed_devices: list[str]
-        """
-        super().__init__(error=error, **kwargs)
-        self.configuration_state = None
-        self.successful_devices = successful_devices
-        self.failed_devices = failed_devices
-
-
-class CommonPostActionResponseForStateUpdate(ErrorResponse):
-    """Common response for the state updates.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar error: The error object.
-    :vartype error: ~azure.mgmt.managednetworkfabric.models.ErrorDetail
-    :ivar configuration_state: Gets the configuration state. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    """
-
-    _validation = {
-        "configuration_state": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "error": {"key": "error", "type": "ErrorDetail"},
-        "configuration_state": {"key": "configurationState", "type": "str"},
-    }
-
-    def __init__(self, *, error: Optional["_models.ErrorDetail"] = None, **kwargs: Any) -> None:
-        """
-        :keyword error: The error object.
-        :paramtype error: ~azure.mgmt.managednetworkfabric.models.ErrorDetail
-        """
-        super().__init__(error=error, **kwargs)
-        self.configuration_state = None
-
-
 class ConnectedSubnet(AnnotationResource):
     """Connected Subnet properties.
 
-    All required parameters must be populated in order to send to Azure.
-
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar prefix: Prefix of the Connected Subnet. Required.
+    :ivar prefix: Prefix of the connected Subnet.
     :vartype prefix: str
     """
 
-    _validation = {
-        "prefix": {"required": True, "min_length": 1},
-    }
-
     _attribute_map = {
         "annotation": {"key": "annotation", "type": "str"},
         "prefix": {"key": "prefix", "type": "str"},
     }
 
-    def __init__(self, *, prefix: str, annotation: Optional[str] = None, **kwargs: Any) -> None:
+    def __init__(self, *, annotation: Optional[str] = None, prefix: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword prefix: Prefix of the Connected Subnet. Required.
+        :keyword prefix: Prefix of the connected Subnet.
         :paramtype prefix: str
         """
         super().__init__(annotation=annotation, **kwargs)
         self.prefix = prefix
 
 
-class ConnectedSubnetRoutePolicy(_serialization.Model):
-    """Connected Subnet Route Policy properties.
-
-    :ivar export_route_policy_id: ARM Resource ID of the Route Policy. This is used for the
-     backward compatibility.
-    :vartype export_route_policy_id: str
-    :ivar export_route_policy: Array of ARM Resource ID of the RoutePolicies.
-    :vartype export_route_policy: ~azure.mgmt.managednetworkfabric.models.L3ExportRoutePolicy
-    """
-
-    _attribute_map = {
-        "export_route_policy_id": {"key": "exportRoutePolicyId", "type": "str"},
-        "export_route_policy": {"key": "exportRoutePolicy", "type": "L3ExportRoutePolicy"},
-    }
-
-    def __init__(
-        self,
-        *,
-        export_route_policy_id: Optional[str] = None,
-        export_route_policy: Optional["_models.L3ExportRoutePolicy"] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword export_route_policy_id: ARM Resource ID of the Route Policy. This is used for the
-         backward compatibility.
-        :paramtype export_route_policy_id: str
-        :keyword export_route_policy: Array of ARM Resource ID of the RoutePolicies.
-        :paramtype export_route_policy: ~azure.mgmt.managednetworkfabric.models.L3ExportRoutePolicy
-        """
-        super().__init__(**kwargs)
-        self.export_route_policy_id = export_route_policy_id
-        self.export_route_policy = export_route_policy
-
-
-class ControllerServices(_serialization.Model):
-    """Network Fabric Controller services.
-
-    :ivar ipv4_address_spaces: The IPv4 Address space is optional, if the value is not defined at
-     the time of NFC creation, then the default value 10.0.0.0/19 is considered. The IPV4 address
-     subnet is an optional attribute.
-    :vartype ipv4_address_spaces: list[str]
-    :ivar ipv6_address_spaces: The IPv6 is not supported right now.
-    :vartype ipv6_address_spaces: list[str]
-    """
-
-    _attribute_map = {
-        "ipv4_address_spaces": {"key": "ipv4AddressSpaces", "type": "[str]"},
-        "ipv6_address_spaces": {"key": "ipv6AddressSpaces", "type": "[str]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        ipv4_address_spaces: Optional[List[str]] = None,
-        ipv6_address_spaces: Optional[List[str]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword ipv4_address_spaces: The IPv4 Address space is optional, if the value is not defined
-         at the time of NFC creation, then the default value 10.0.0.0/19 is considered. The IPV4 address
-         subnet is an optional attribute.
-        :paramtype ipv4_address_spaces: list[str]
-        :keyword ipv6_address_spaces: The IPv6 is not supported right now.
-        :paramtype ipv6_address_spaces: list[str]
-        """
-        super().__init__(**kwargs)
-        self.ipv4_address_spaces = ipv4_address_spaces
-        self.ipv6_address_spaces = ipv6_address_spaces
-
-
-class DestinationProperties(_serialization.Model):
-    """The network tap destination properties.
-
-    :ivar name: Destination name.
-    :vartype name: str
-    :ivar destination_type: Type of destination. Input can be IsolationDomain or Direct. Known
-     values are: "IsolationDomain" and "Direct".
-    :vartype destination_type: str or ~azure.mgmt.managednetworkfabric.models.DestinationType
-    :ivar destination_id: The destination Id. ARM Resource ID of either NNI or Internal Networks.
-    :vartype destination_id: str
-    :ivar isolation_domain_properties: Isolation Domain Properties.
-    :vartype isolation_domain_properties:
-     ~azure.mgmt.managednetworkfabric.models.IsolationDomainProperties
-    :ivar destination_tap_rule_id: ARM Resource ID of destination Tap Rule that contains match
-     configurations.
-    :vartype destination_tap_rule_id: str
-    """
-
-    _validation = {
-        "name": {"min_length": 1},
-    }
-
-    _attribute_map = {
-        "name": {"key": "name", "type": "str"},
-        "destination_type": {"key": "destinationType", "type": "str"},
-        "destination_id": {"key": "destinationId", "type": "str"},
-        "isolation_domain_properties": {"key": "isolationDomainProperties", "type": "IsolationDomainProperties"},
-        "destination_tap_rule_id": {"key": "destinationTapRuleId", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        name: Optional[str] = None,
-        destination_type: Optional[Union[str, "_models.DestinationType"]] = None,
-        destination_id: Optional[str] = None,
-        isolation_domain_properties: Optional["_models.IsolationDomainProperties"] = None,
-        destination_tap_rule_id: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword name: Destination name.
-        :paramtype name: str
-        :keyword destination_type: Type of destination. Input can be IsolationDomain or Direct. Known
-         values are: "IsolationDomain" and "Direct".
-        :paramtype destination_type: str or ~azure.mgmt.managednetworkfabric.models.DestinationType
-        :keyword destination_id: The destination Id. ARM Resource ID of either NNI or Internal
-         Networks.
-        :paramtype destination_id: str
-        :keyword isolation_domain_properties: Isolation Domain Properties.
-        :paramtype isolation_domain_properties:
-         ~azure.mgmt.managednetworkfabric.models.IsolationDomainProperties
-        :keyword destination_tap_rule_id: ARM Resource ID of destination Tap Rule that contains match
-         configurations.
-        :paramtype destination_tap_rule_id: str
-        """
-        super().__init__(**kwargs)
-        self.name = name
-        self.destination_type = destination_type
-        self.destination_id = destination_id
-        self.isolation_domain_properties = isolation_domain_properties
-        self.destination_tap_rule_id = destination_tap_rule_id
-
-
 class DeviceInterfaceProperties(_serialization.Model):
     """Network device interface properties.
 
     :ivar identifier: Interface identifier. Example: HundredGigE0/0.
     :vartype identifier: str
     :ivar interface_type: Interface type.
     :vartype interface_type: str
@@ -1758,14 +1013,80 @@
         """
         super().__init__(**kwargs)
         self.identifier = identifier
         self.interface_type = interface_type
         self.supported_connector_types = supported_connector_types
 
 
+class DeviceLimits(_serialization.Model):
+    """Network device limits.
+
+    :ivar physical_interface_count: Maximum number of physical interfaces.
+    :vartype physical_interface_count: int
+    :ivar max_sub_interfaces: Maximum number of sub-interfaces.
+    :vartype max_sub_interfaces: int
+    :ivar max_tunnel_interfaces: Maximum number of tunnel interfaces.
+    :vartype max_tunnel_interfaces: int
+    :ivar max_virtual_router_functions: Maximum number of virtual router functions.
+    :vartype max_virtual_router_functions: int
+    :ivar max_border_gateway_protocol_peers: Maximum number of Border Gateway Protocol (BGP) peers.
+    :vartype max_border_gateway_protocol_peers: int
+    :ivar max_bidirectional_forwarding_detection_peers: Maximum number of Bidirectional Forwarding
+     Detection (BFD) peers.
+    :vartype max_bidirectional_forwarding_detection_peers: int
+    """
+
+    _attribute_map = {
+        "physical_interface_count": {"key": "physicalInterfaceCount", "type": "int"},
+        "max_sub_interfaces": {"key": "maxSubInterfaces", "type": "int"},
+        "max_tunnel_interfaces": {"key": "maxTunnelInterfaces", "type": "int"},
+        "max_virtual_router_functions": {"key": "maxVirtualRouterFunctions", "type": "int"},
+        "max_border_gateway_protocol_peers": {"key": "maxBorderGatewayProtocolPeers", "type": "int"},
+        "max_bidirectional_forwarding_detection_peers": {
+            "key": "maxBidirectionalForwardingDetectionPeers",
+            "type": "int",
+        },
+    }
+
+    def __init__(
+        self,
+        *,
+        physical_interface_count: Optional[int] = None,
+        max_sub_interfaces: Optional[int] = None,
+        max_tunnel_interfaces: Optional[int] = None,
+        max_virtual_router_functions: Optional[int] = None,
+        max_border_gateway_protocol_peers: Optional[int] = None,
+        max_bidirectional_forwarding_detection_peers: Optional[int] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword physical_interface_count: Maximum number of physical interfaces.
+        :paramtype physical_interface_count: int
+        :keyword max_sub_interfaces: Maximum number of sub-interfaces.
+        :paramtype max_sub_interfaces: int
+        :keyword max_tunnel_interfaces: Maximum number of tunnel interfaces.
+        :paramtype max_tunnel_interfaces: int
+        :keyword max_virtual_router_functions: Maximum number of virtual router functions.
+        :paramtype max_virtual_router_functions: int
+        :keyword max_border_gateway_protocol_peers: Maximum number of Border Gateway Protocol (BGP)
+         peers.
+        :paramtype max_border_gateway_protocol_peers: int
+        :keyword max_bidirectional_forwarding_detection_peers: Maximum number of Bidirectional
+         Forwarding Detection (BFD) peers.
+        :paramtype max_bidirectional_forwarding_detection_peers: int
+        """
+        super().__init__(**kwargs)
+        self.physical_interface_count = physical_interface_count
+        self.max_sub_interfaces = max_sub_interfaces
+        self.max_tunnel_interfaces = max_tunnel_interfaces
+        self.max_virtual_router_functions = max_virtual_router_functions
+        self.max_border_gateway_protocol_peers = max_border_gateway_protocol_peers
+        self.max_bidirectional_forwarding_detection_peers = max_bidirectional_forwarding_detection_peers
+
+
 class EnableDisableOnResources(_serialization.Model):
     """Update administrative state on list of resources.
 
     :ivar resource_ids: Network Fabrics or Network Rack resource Id.
     :vartype resource_ids: list[str]
     """
 
@@ -1849,76 +1170,33 @@
         self.code = None
         self.message = None
         self.target = None
         self.details = None
         self.additional_info = None
 
 
-class ExportRoutePolicy(_serialization.Model):
-    """Export Route Policy either IPv4 or IPv6.
-
-    :ivar export_ipv4_route_policy_id: ARM resource ID of RoutePolicy.
-    :vartype export_ipv4_route_policy_id: str
-    :ivar export_ipv6_route_policy_id: ARM resource ID of RoutePolicy.
-    :vartype export_ipv6_route_policy_id: str
-    """
-
-    _attribute_map = {
-        "export_ipv4_route_policy_id": {"key": "exportIpv4RoutePolicyId", "type": "str"},
-        "export_ipv6_route_policy_id": {"key": "exportIpv6RoutePolicyId", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        export_ipv4_route_policy_id: Optional[str] = None,
-        export_ipv6_route_policy_id: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword export_ipv4_route_policy_id: ARM resource ID of RoutePolicy.
-        :paramtype export_ipv4_route_policy_id: str
-        :keyword export_ipv6_route_policy_id: ARM resource ID of RoutePolicy.
-        :paramtype export_ipv6_route_policy_id: str
-        """
-        super().__init__(**kwargs)
-        self.export_ipv4_route_policy_id = export_ipv4_route_policy_id
-        self.export_ipv6_route_policy_id = export_ipv6_route_policy_id
-
-
-class ExportRoutePolicyInformation(_serialization.Model):
-    """Export Route Policy Configuration.
+class ErrorResponse(_serialization.Model):
+    """Common error response for all Azure Resource Manager APIs to return error details for failed
+    operations. (This also follows the OData error response format.).
 
-    :ivar export_ipv4_route_policy_id: Export IPv4 Route Policy Id.
-    :vartype export_ipv4_route_policy_id: str
-    :ivar export_ipv6_route_policy_id: Export IPv6 Route Policy Id.
-    :vartype export_ipv6_route_policy_id: str
+    :ivar error: The error object.
+    :vartype error: ~azure.mgmt.managednetworkfabric.models.ErrorDetail
     """
 
     _attribute_map = {
-        "export_ipv4_route_policy_id": {"key": "exportIpv4RoutePolicyId", "type": "str"},
-        "export_ipv6_route_policy_id": {"key": "exportIpv6RoutePolicyId", "type": "str"},
+        "error": {"key": "error", "type": "ErrorDetail"},
     }
 
-    def __init__(
-        self,
-        *,
-        export_ipv4_route_policy_id: Optional[str] = None,
-        export_ipv6_route_policy_id: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
+    def __init__(self, *, error: Optional["_models.ErrorDetail"] = None, **kwargs: Any) -> None:
         """
-        :keyword export_ipv4_route_policy_id: Export IPv4 Route Policy Id.
-        :paramtype export_ipv4_route_policy_id: str
-        :keyword export_ipv6_route_policy_id: Export IPv6 Route Policy Id.
-        :paramtype export_ipv6_route_policy_id: str
+        :keyword error: The error object.
+        :paramtype error: ~azure.mgmt.managednetworkfabric.models.ErrorDetail
         """
         super().__init__(**kwargs)
-        self.export_ipv4_route_policy_id = export_ipv4_route_policy_id
-        self.export_ipv6_route_policy_id = export_ipv6_route_policy_id
+        self.error = error
 
 
 class ExpressRouteConnectionInformation(_serialization.Model):
     """The ExpressRoute circuit ID and the Auth Key are required for you to successfully deploy NFC
     service.
 
     All required parameters must be populated in order to send to Azure.
@@ -1955,14 +1233,52 @@
         :paramtype express_route_authorization_key: str
         """
         super().__init__(**kwargs)
         self.express_route_circuit_id = express_route_circuit_id
         self.express_route_authorization_key = express_route_authorization_key
 
 
+class ExpressRouteStatusDef(_serialization.Model):
+    """ExpressRouteStatus defines the resource properties.
+
+    :ivar express_route_circuit_id: The express route circuit Azure resource ID, must be of type
+     Microsoft.Network/expressRouteCircuits/circuitName.
+    :vartype express_route_circuit_id: str
+    :ivar express_route_status: Express route connection state for the resource. Known values are:
+     "Connecting", "Connected", and "Disconnected".
+    :vartype express_route_status: str or
+     ~azure.mgmt.managednetworkfabric.models.ExpressRouteConnectionState
+    """
+
+    _attribute_map = {
+        "express_route_circuit_id": {"key": "expressRouteCircuitId", "type": "str"},
+        "express_route_status": {"key": "expressRouteStatus", "type": "str"},
+    }
+
+    def __init__(
+        self,
+        *,
+        express_route_circuit_id: Optional[str] = None,
+        express_route_status: Optional[Union[str, "_models.ExpressRouteConnectionState"]] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword express_route_circuit_id: The express route circuit Azure resource ID, must be of type
+         Microsoft.Network/expressRouteCircuits/circuitName.
+        :paramtype express_route_circuit_id: str
+        :keyword express_route_status: Express route connection state for the resource. Known values
+         are: "Connecting", "Connected", and "Disconnected".
+        :paramtype express_route_status: str or
+         ~azure.mgmt.managednetworkfabric.models.ExpressRouteConnectionState
+        """
+        super().__init__(**kwargs)
+        self.express_route_circuit_id = express_route_circuit_id
+        self.express_route_status = express_route_status
+
+
 class ExtendedLocation(_serialization.Model):
     """The extended location.
 
     :ivar type: The extended location type.
     :vartype type: str
     :ivar name: The extended location name.
     :vartype name: str
@@ -1981,44 +1297,22 @@
         :paramtype name: str
         """
         super().__init__(**kwargs)
         self.type = type
         self.name = name
 
 
-class ExtensionEnumProperty(_serialization.Model):
-    """Extension property.
-
-    :ivar extension: Extension. Example: NoExtension | NPB. Known values are: "NoExtension" and
-     "NPB".
-    :vartype extension: str or ~azure.mgmt.managednetworkfabric.models.Extension
-    """
-
-    _attribute_map = {
-        "extension": {"key": "extension", "type": "str"},
-    }
-
-    def __init__(self, *, extension: Union[str, "_models.Extension"] = "NoExtension", **kwargs: Any) -> None:
-        """
-        :keyword extension: Extension. Example: NoExtension | NPB. Known values are: "NoExtension" and
-         "NPB".
-        :paramtype extension: str or ~azure.mgmt.managednetworkfabric.models.Extension
-        """
-        super().__init__(**kwargs)
-        self.extension = extension
-
-
 class ProxyResource(Resource):
     """The resource model definition for a Azure Resource Manager proxy resource. It will not have
     tags and a location.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -2042,453 +1336,433 @@
 
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
 
 
 class ExternalNetwork(ProxyResource):  # pylint: disable=too-many-instance-attributes
-    """Defines the External Network resource.
+    """Defines the ExternalNetwork item.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
      information.
     :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
-    :vartype import_route_policy_id: str
-    :ivar export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
-    :vartype export_route_policy_id: str
-    :ivar import_route_policy: Import Route Policy either IPv4 or IPv6.
-    :vartype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-    :ivar export_route_policy: Export Route Policy either IPv4 or IPv6.
-    :vartype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
     :ivar network_to_network_interconnect_id: Gets the networkToNetworkInterconnectId of the
      resource.
     :vartype network_to_network_interconnect_id: str
+    :ivar disabled_on_resources: List of resources the externalNetwork is disabled on. Can be
+     either entire NetworkFabric or NetworkRack.
+    :vartype disabled_on_resources: list[str]
+    :ivar administrative_state: AdministrativeState of the externalNetwork. Example: Enabled |
+     Disabled. Known values are: "Enabled" and "Disabled".
+    :vartype administrative_state: str or
+     ~azure.mgmt.managednetworkfabric.models.EnabledDisabledState
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
+    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
     :ivar peering_option: Peering option list. Required. Known values are: "OptionA" and "OptionB".
     :vartype peering_option: str or ~azure.mgmt.managednetworkfabric.models.PeeringOption
     :ivar option_b_properties: option B properties object.
-    :vartype option_b_properties: ~azure.mgmt.managednetworkfabric.models.L3OptionBProperties
+    :vartype option_b_properties: ~azure.mgmt.managednetworkfabric.models.OptionBProperties
     :ivar option_a_properties: option A properties object.
     :vartype option_a_properties:
      ~azure.mgmt.managednetworkfabric.models.ExternalNetworkPropertiesOptionAProperties
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
+    :ivar import_route_policy_id: ARM resource ID of importRoutePolicy.
+    :vartype import_route_policy_id: str
+    :ivar export_route_policy_id: ARM resource ID of exportRoutePolicy.
+    :vartype export_route_policy_id: str
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
         "network_to_network_interconnect_id": {"readonly": True},
-        "peering_option": {"required": True},
-        "configuration_state": {"readonly": True},
-        "provisioning_state": {"readonly": True},
+        "disabled_on_resources": {"readonly": True},
         "administrative_state": {"readonly": True},
+        "provisioning_state": {"readonly": True},
+        "peering_option": {"required": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "annotation": {"key": "properties.annotation", "type": "str"},
-        "import_route_policy_id": {"key": "properties.importRoutePolicyId", "type": "str"},
-        "export_route_policy_id": {"key": "properties.exportRoutePolicyId", "type": "str"},
-        "import_route_policy": {"key": "properties.importRoutePolicy", "type": "ImportRoutePolicy"},
-        "export_route_policy": {"key": "properties.exportRoutePolicy", "type": "ExportRoutePolicy"},
         "network_to_network_interconnect_id": {"key": "properties.networkToNetworkInterconnectId", "type": "str"},
+        "disabled_on_resources": {"key": "properties.disabledOnResources", "type": "[str]"},
+        "administrative_state": {"key": "properties.administrativeState", "type": "str"},
+        "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
         "peering_option": {"key": "properties.peeringOption", "type": "str"},
-        "option_b_properties": {"key": "properties.optionBProperties", "type": "L3OptionBProperties"},
+        "option_b_properties": {"key": "properties.optionBProperties", "type": "OptionBProperties"},
         "option_a_properties": {
             "key": "properties.optionAProperties",
             "type": "ExternalNetworkPropertiesOptionAProperties",
         },
-        "configuration_state": {"key": "properties.configurationState", "type": "str"},
-        "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
-        "administrative_state": {"key": "properties.administrativeState", "type": "str"},
+        "import_route_policy_id": {"key": "properties.importRoutePolicyId", "type": "str"},
+        "export_route_policy_id": {"key": "properties.exportRoutePolicyId", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         peering_option: Union[str, "_models.PeeringOption"],
         annotation: Optional[str] = None,
+        option_b_properties: Optional["_models.OptionBProperties"] = None,
+        option_a_properties: Optional["_models.ExternalNetworkPropertiesOptionAProperties"] = None,
         import_route_policy_id: Optional[str] = None,
         export_route_policy_id: Optional[str] = None,
-        import_route_policy: Optional["_models.ImportRoutePolicy"] = None,
-        export_route_policy: Optional["_models.ExportRoutePolicy"] = None,
-        option_b_properties: Optional["_models.L3OptionBProperties"] = None,
-        option_a_properties: Optional["_models.ExternalNetworkPropertiesOptionAProperties"] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
-        :paramtype import_route_policy_id: str
-        :keyword export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
-        :paramtype export_route_policy_id: str
-        :keyword import_route_policy: Import Route Policy either IPv4 or IPv6.
-        :paramtype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-        :keyword export_route_policy: Export Route Policy either IPv4 or IPv6.
-        :paramtype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
         :keyword peering_option: Peering option list. Required. Known values are: "OptionA" and
          "OptionB".
         :paramtype peering_option: str or ~azure.mgmt.managednetworkfabric.models.PeeringOption
         :keyword option_b_properties: option B properties object.
-        :paramtype option_b_properties: ~azure.mgmt.managednetworkfabric.models.L3OptionBProperties
+        :paramtype option_b_properties: ~azure.mgmt.managednetworkfabric.models.OptionBProperties
         :keyword option_a_properties: option A properties object.
         :paramtype option_a_properties:
          ~azure.mgmt.managednetworkfabric.models.ExternalNetworkPropertiesOptionAProperties
+        :keyword import_route_policy_id: ARM resource ID of importRoutePolicy.
+        :paramtype import_route_policy_id: str
+        :keyword export_route_policy_id: ARM resource ID of exportRoutePolicy.
+        :paramtype export_route_policy_id: str
         """
         super().__init__(**kwargs)
         self.annotation = annotation
-        self.import_route_policy_id = import_route_policy_id
-        self.export_route_policy_id = export_route_policy_id
-        self.import_route_policy = import_route_policy
-        self.export_route_policy = export_route_policy
         self.network_to_network_interconnect_id = None
+        self.disabled_on_resources = None
+        self.administrative_state = None
+        self.provisioning_state = None
         self.peering_option = peering_option
         self.option_b_properties = option_b_properties
         self.option_a_properties = option_a_properties
-        self.configuration_state = None
-        self.provisioning_state = None
-        self.administrative_state = None
+        self.import_route_policy_id = import_route_policy_id
+        self.export_route_policy_id = export_route_policy_id
 
 
 class ExternalNetworkPatch(_serialization.Model):
     """The ExternalNetwork patch resource definition.
 
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
-    :vartype import_route_policy_id: str
-    :ivar export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
-    :vartype export_route_policy_id: str
-    :ivar import_route_policy: Import Route Policy either IPv4 or IPv6.
-    :vartype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-    :ivar export_route_policy: Export Route Policy either IPv4 or IPv6.
-    :vartype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
     :ivar peering_option: Peering option list. Known values are: "OptionA" and "OptionB".
     :vartype peering_option: str or ~azure.mgmt.managednetworkfabric.models.PeeringOption
     :ivar option_b_properties: option B properties object.
-    :vartype option_b_properties: ~azure.mgmt.managednetworkfabric.models.L3OptionBProperties
+    :vartype option_b_properties: ~azure.mgmt.managednetworkfabric.models.OptionBProperties
     :ivar option_a_properties: option A properties object.
-    :vartype option_a_properties:
-     ~azure.mgmt.managednetworkfabric.models.ExternalNetworkPatchPropertiesOptionAProperties
+    :vartype option_a_properties: ~azure.mgmt.managednetworkfabric.models.Layer3OptionAProperties
+    :ivar import_route_policy_id: ARM resource ID of importRoutePolicy.
+    :vartype import_route_policy_id: str
+    :ivar export_route_policy_id: ARM resource ID of exportRoutePolicy.
+    :vartype export_route_policy_id: str
     """
 
     _attribute_map = {
         "annotation": {"key": "properties.annotation", "type": "str"},
+        "peering_option": {"key": "properties.peeringOption", "type": "str"},
+        "option_b_properties": {"key": "properties.optionBProperties", "type": "OptionBProperties"},
+        "option_a_properties": {"key": "properties.optionAProperties", "type": "Layer3OptionAProperties"},
         "import_route_policy_id": {"key": "properties.importRoutePolicyId", "type": "str"},
         "export_route_policy_id": {"key": "properties.exportRoutePolicyId", "type": "str"},
-        "import_route_policy": {"key": "properties.importRoutePolicy", "type": "ImportRoutePolicy"},
-        "export_route_policy": {"key": "properties.exportRoutePolicy", "type": "ExportRoutePolicy"},
-        "peering_option": {"key": "properties.peeringOption", "type": "str"},
-        "option_b_properties": {"key": "properties.optionBProperties", "type": "L3OptionBProperties"},
-        "option_a_properties": {
-            "key": "properties.optionAProperties",
-            "type": "ExternalNetworkPatchPropertiesOptionAProperties",
-        },
     }
 
     def __init__(
         self,
         *,
         annotation: Optional[str] = None,
+        peering_option: Optional[Union[str, "_models.PeeringOption"]] = None,
+        option_b_properties: Optional["_models.OptionBProperties"] = None,
+        option_a_properties: Optional["_models.Layer3OptionAProperties"] = None,
         import_route_policy_id: Optional[str] = None,
         export_route_policy_id: Optional[str] = None,
-        import_route_policy: Optional["_models.ImportRoutePolicy"] = None,
-        export_route_policy: Optional["_models.ExportRoutePolicy"] = None,
-        peering_option: Optional[Union[str, "_models.PeeringOption"]] = None,
-        option_b_properties: Optional["_models.L3OptionBProperties"] = None,
-        option_a_properties: Optional["_models.ExternalNetworkPatchPropertiesOptionAProperties"] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
-        :paramtype import_route_policy_id: str
-        :keyword export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
-        :paramtype export_route_policy_id: str
-        :keyword import_route_policy: Import Route Policy either IPv4 or IPv6.
-        :paramtype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-        :keyword export_route_policy: Export Route Policy either IPv4 or IPv6.
-        :paramtype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
         :keyword peering_option: Peering option list. Known values are: "OptionA" and "OptionB".
         :paramtype peering_option: str or ~azure.mgmt.managednetworkfabric.models.PeeringOption
         :keyword option_b_properties: option B properties object.
-        :paramtype option_b_properties: ~azure.mgmt.managednetworkfabric.models.L3OptionBProperties
+        :paramtype option_b_properties: ~azure.mgmt.managednetworkfabric.models.OptionBProperties
         :keyword option_a_properties: option A properties object.
-        :paramtype option_a_properties:
-         ~azure.mgmt.managednetworkfabric.models.ExternalNetworkPatchPropertiesOptionAProperties
+        :paramtype option_a_properties: ~azure.mgmt.managednetworkfabric.models.Layer3OptionAProperties
+        :keyword import_route_policy_id: ARM resource ID of importRoutePolicy.
+        :paramtype import_route_policy_id: str
+        :keyword export_route_policy_id: ARM resource ID of exportRoutePolicy.
+        :paramtype export_route_policy_id: str
         """
         super().__init__(**kwargs)
         self.annotation = annotation
-        self.import_route_policy_id = import_route_policy_id
-        self.export_route_policy_id = export_route_policy_id
-        self.import_route_policy = import_route_policy
-        self.export_route_policy = export_route_policy
         self.peering_option = peering_option
         self.option_b_properties = option_b_properties
         self.option_a_properties = option_a_properties
+        self.import_route_policy_id = import_route_policy_id
+        self.export_route_policy_id = export_route_policy_id
 
 
 class ExternalNetworkPatchableProperties(_serialization.Model):
     """The ExternalNetwork patchable properties.
 
-    :ivar import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
+    :ivar peering_option: Peering option list. Known values are: "OptionA" and "OptionB".
+    :vartype peering_option: str or ~azure.mgmt.managednetworkfabric.models.PeeringOption
+    :ivar option_b_properties: option B properties object.
+    :vartype option_b_properties: ~azure.mgmt.managednetworkfabric.models.OptionBProperties
+    :ivar option_a_properties: option A properties object.
+    :vartype option_a_properties: ~azure.mgmt.managednetworkfabric.models.Layer3OptionAProperties
+    :ivar import_route_policy_id: ARM resource ID of importRoutePolicy.
     :vartype import_route_policy_id: str
-    :ivar export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
+    :ivar export_route_policy_id: ARM resource ID of exportRoutePolicy.
     :vartype export_route_policy_id: str
-    :ivar import_route_policy: Import Route Policy either IPv4 or IPv6.
-    :vartype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-    :ivar export_route_policy: Export Route Policy either IPv4 or IPv6.
-    :vartype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
     """
 
     _attribute_map = {
+        "peering_option": {"key": "peeringOption", "type": "str"},
+        "option_b_properties": {"key": "optionBProperties", "type": "OptionBProperties"},
+        "option_a_properties": {"key": "optionAProperties", "type": "Layer3OptionAProperties"},
         "import_route_policy_id": {"key": "importRoutePolicyId", "type": "str"},
         "export_route_policy_id": {"key": "exportRoutePolicyId", "type": "str"},
-        "import_route_policy": {"key": "importRoutePolicy", "type": "ImportRoutePolicy"},
-        "export_route_policy": {"key": "exportRoutePolicy", "type": "ExportRoutePolicy"},
     }
 
     def __init__(
         self,
         *,
+        peering_option: Optional[Union[str, "_models.PeeringOption"]] = None,
+        option_b_properties: Optional["_models.OptionBProperties"] = None,
+        option_a_properties: Optional["_models.Layer3OptionAProperties"] = None,
         import_route_policy_id: Optional[str] = None,
         export_route_policy_id: Optional[str] = None,
-        import_route_policy: Optional["_models.ImportRoutePolicy"] = None,
-        export_route_policy: Optional["_models.ExportRoutePolicy"] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
+        :keyword peering_option: Peering option list. Known values are: "OptionA" and "OptionB".
+        :paramtype peering_option: str or ~azure.mgmt.managednetworkfabric.models.PeeringOption
+        :keyword option_b_properties: option B properties object.
+        :paramtype option_b_properties: ~azure.mgmt.managednetworkfabric.models.OptionBProperties
+        :keyword option_a_properties: option A properties object.
+        :paramtype option_a_properties: ~azure.mgmt.managednetworkfabric.models.Layer3OptionAProperties
+        :keyword import_route_policy_id: ARM resource ID of importRoutePolicy.
         :paramtype import_route_policy_id: str
-        :keyword export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
+        :keyword export_route_policy_id: ARM resource ID of exportRoutePolicy.
         :paramtype export_route_policy_id: str
-        :keyword import_route_policy: Import Route Policy either IPv4 or IPv6.
-        :paramtype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-        :keyword export_route_policy: Export Route Policy either IPv4 or IPv6.
-        :paramtype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
         """
         super().__init__(**kwargs)
+        self.peering_option = peering_option
+        self.option_b_properties = option_b_properties
+        self.option_a_properties = option_a_properties
         self.import_route_policy_id = import_route_policy_id
         self.export_route_policy_id = export_route_policy_id
-        self.import_route_policy = import_route_policy
-        self.export_route_policy = export_route_policy
 
 
 class ExternalNetworkPatchProperties(AnnotationResource, ExternalNetworkPatchableProperties):
     """External Network Patch properties.
 
-    :ivar import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
-    :vartype import_route_policy_id: str
-    :ivar export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
-    :vartype export_route_policy_id: str
-    :ivar import_route_policy: Import Route Policy either IPv4 or IPv6.
-    :vartype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-    :ivar export_route_policy: Export Route Policy either IPv4 or IPv6.
-    :vartype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
     :ivar peering_option: Peering option list. Known values are: "OptionA" and "OptionB".
     :vartype peering_option: str or ~azure.mgmt.managednetworkfabric.models.PeeringOption
     :ivar option_b_properties: option B properties object.
-    :vartype option_b_properties: ~azure.mgmt.managednetworkfabric.models.L3OptionBProperties
+    :vartype option_b_properties: ~azure.mgmt.managednetworkfabric.models.OptionBProperties
     :ivar option_a_properties: option A properties object.
-    :vartype option_a_properties:
-     ~azure.mgmt.managednetworkfabric.models.ExternalNetworkPatchPropertiesOptionAProperties
+    :vartype option_a_properties: ~azure.mgmt.managednetworkfabric.models.Layer3OptionAProperties
+    :ivar import_route_policy_id: ARM resource ID of importRoutePolicy.
+    :vartype import_route_policy_id: str
+    :ivar export_route_policy_id: ARM resource ID of exportRoutePolicy.
+    :vartype export_route_policy_id: str
+    :ivar annotation: Switch configuration description.
+    :vartype annotation: str
     """
 
     _attribute_map = {
+        "peering_option": {"key": "peeringOption", "type": "str"},
+        "option_b_properties": {"key": "optionBProperties", "type": "OptionBProperties"},
+        "option_a_properties": {"key": "optionAProperties", "type": "Layer3OptionAProperties"},
         "import_route_policy_id": {"key": "importRoutePolicyId", "type": "str"},
         "export_route_policy_id": {"key": "exportRoutePolicyId", "type": "str"},
-        "import_route_policy": {"key": "importRoutePolicy", "type": "ImportRoutePolicy"},
-        "export_route_policy": {"key": "exportRoutePolicy", "type": "ExportRoutePolicy"},
         "annotation": {"key": "annotation", "type": "str"},
-        "peering_option": {"key": "peeringOption", "type": "str"},
-        "option_b_properties": {"key": "optionBProperties", "type": "L3OptionBProperties"},
-        "option_a_properties": {"key": "optionAProperties", "type": "ExternalNetworkPatchPropertiesOptionAProperties"},
     }
 
     def __init__(
         self,
         *,
+        peering_option: Optional[Union[str, "_models.PeeringOption"]] = None,
+        option_b_properties: Optional["_models.OptionBProperties"] = None,
+        option_a_properties: Optional["_models.Layer3OptionAProperties"] = None,
         import_route_policy_id: Optional[str] = None,
         export_route_policy_id: Optional[str] = None,
-        import_route_policy: Optional["_models.ImportRoutePolicy"] = None,
-        export_route_policy: Optional["_models.ExportRoutePolicy"] = None,
         annotation: Optional[str] = None,
-        peering_option: Optional[Union[str, "_models.PeeringOption"]] = None,
-        option_b_properties: Optional["_models.L3OptionBProperties"] = None,
-        option_a_properties: Optional["_models.ExternalNetworkPatchPropertiesOptionAProperties"] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
-        :paramtype import_route_policy_id: str
-        :keyword export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
-        :paramtype export_route_policy_id: str
-        :keyword import_route_policy: Import Route Policy either IPv4 or IPv6.
-        :paramtype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-        :keyword export_route_policy: Export Route Policy either IPv4 or IPv6.
-        :paramtype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
         :keyword peering_option: Peering option list. Known values are: "OptionA" and "OptionB".
         :paramtype peering_option: str or ~azure.mgmt.managednetworkfabric.models.PeeringOption
         :keyword option_b_properties: option B properties object.
-        :paramtype option_b_properties: ~azure.mgmt.managednetworkfabric.models.L3OptionBProperties
+        :paramtype option_b_properties: ~azure.mgmt.managednetworkfabric.models.OptionBProperties
         :keyword option_a_properties: option A properties object.
-        :paramtype option_a_properties:
-         ~azure.mgmt.managednetworkfabric.models.ExternalNetworkPatchPropertiesOptionAProperties
+        :paramtype option_a_properties: ~azure.mgmt.managednetworkfabric.models.Layer3OptionAProperties
+        :keyword import_route_policy_id: ARM resource ID of importRoutePolicy.
+        :paramtype import_route_policy_id: str
+        :keyword export_route_policy_id: ARM resource ID of exportRoutePolicy.
+        :paramtype export_route_policy_id: str
+        :keyword annotation: Switch configuration description.
+        :paramtype annotation: str
         """
         super().__init__(
             annotation=annotation,
+            peering_option=peering_option,
+            option_b_properties=option_b_properties,
+            option_a_properties=option_a_properties,
             import_route_policy_id=import_route_policy_id,
             export_route_policy_id=export_route_policy_id,
-            import_route_policy=import_route_policy,
-            export_route_policy=export_route_policy,
             **kwargs
         )
-        self.import_route_policy_id = import_route_policy_id
-        self.export_route_policy_id = export_route_policy_id
-        self.import_route_policy = import_route_policy
-        self.export_route_policy = export_route_policy
         self.peering_option = peering_option
         self.option_b_properties = option_b_properties
         self.option_a_properties = option_a_properties
+        self.import_route_policy_id = import_route_policy_id
+        self.export_route_policy_id = export_route_policy_id
         self.annotation = annotation
 
 
-class L3OptionAProperties(_serialization.Model):
-    """Peering optionA properties.
+class ExternalNetworkProperties(AnnotationResource):
+    """External Network Properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar mtu: MTU to use for option A peering.
-    :vartype mtu: int
-    :ivar vlan_id: Vlan identifier. Example : 501.
-    :vartype vlan_id: int
-    :ivar fabric_asn: Fabric ASN number. Example 65001.
-    :vartype fabric_asn: int
-    :ivar peer_asn: Peer ASN number.Example : 28.
-    :vartype peer_asn: int
-    :ivar bfd_configuration: BFD configuration properties.
-    :vartype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
-    :ivar ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-    :vartype ingress_acl_id: str
-    :ivar egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-    :vartype egress_acl_id: str
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar annotation: Switch configuration description.
+    :vartype annotation: str
+    :ivar network_to_network_interconnect_id: Gets the networkToNetworkInterconnectId of the
+     resource.
+    :vartype network_to_network_interconnect_id: str
+    :ivar disabled_on_resources: List of resources the externalNetwork is disabled on. Can be
+     either entire NetworkFabric or NetworkRack.
+    :vartype disabled_on_resources: list[str]
+    :ivar administrative_state: AdministrativeState of the externalNetwork. Example: Enabled |
+     Disabled. Known values are: "Enabled" and "Disabled".
+    :vartype administrative_state: str or
+     ~azure.mgmt.managednetworkfabric.models.EnabledDisabledState
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
+    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
+    :ivar peering_option: Peering option list. Required. Known values are: "OptionA" and "OptionB".
+    :vartype peering_option: str or ~azure.mgmt.managednetworkfabric.models.PeeringOption
+    :ivar option_b_properties: option B properties object.
+    :vartype option_b_properties: ~azure.mgmt.managednetworkfabric.models.OptionBProperties
+    :ivar option_a_properties: option A properties object.
+    :vartype option_a_properties:
+     ~azure.mgmt.managednetworkfabric.models.ExternalNetworkPropertiesOptionAProperties
+    :ivar import_route_policy_id: ARM resource ID of importRoutePolicy.
+    :vartype import_route_policy_id: str
+    :ivar export_route_policy_id: ARM resource ID of exportRoutePolicy.
+    :vartype export_route_policy_id: str
     """
 
     _validation = {
-        "mtu": {"maximum": 9200, "minimum": 64},
-        "vlan_id": {"maximum": 4094, "minimum": 501},
-        "fabric_asn": {"readonly": True, "maximum": 4294967295, "minimum": 1},
-        "peer_asn": {"maximum": 4294967295, "minimum": 1},
+        "network_to_network_interconnect_id": {"readonly": True},
+        "disabled_on_resources": {"readonly": True},
+        "administrative_state": {"readonly": True},
+        "provisioning_state": {"readonly": True},
+        "peering_option": {"required": True},
     }
 
     _attribute_map = {
-        "mtu": {"key": "mtu", "type": "int"},
-        "vlan_id": {"key": "vlanId", "type": "int"},
-        "fabric_asn": {"key": "fabricASN", "type": "int"},
-        "peer_asn": {"key": "peerASN", "type": "int"},
-        "bfd_configuration": {"key": "bfdConfiguration", "type": "BfdConfiguration"},
-        "ingress_acl_id": {"key": "ingressAclId", "type": "str"},
-        "egress_acl_id": {"key": "egressAclId", "type": "str"},
+        "annotation": {"key": "annotation", "type": "str"},
+        "network_to_network_interconnect_id": {"key": "networkToNetworkInterconnectId", "type": "str"},
+        "disabled_on_resources": {"key": "disabledOnResources", "type": "[str]"},
+        "administrative_state": {"key": "administrativeState", "type": "str"},
+        "provisioning_state": {"key": "provisioningState", "type": "str"},
+        "peering_option": {"key": "peeringOption", "type": "str"},
+        "option_b_properties": {"key": "optionBProperties", "type": "OptionBProperties"},
+        "option_a_properties": {"key": "optionAProperties", "type": "ExternalNetworkPropertiesOptionAProperties"},
+        "import_route_policy_id": {"key": "importRoutePolicyId", "type": "str"},
+        "export_route_policy_id": {"key": "exportRoutePolicyId", "type": "str"},
     }
 
     def __init__(
         self,
         *,
-        mtu: int = 1500,
-        vlan_id: Optional[int] = None,
-        peer_asn: Optional[int] = None,
-        bfd_configuration: Optional["_models.BfdConfiguration"] = None,
-        ingress_acl_id: Optional[str] = None,
-        egress_acl_id: Optional[str] = None,
+        peering_option: Union[str, "_models.PeeringOption"],
+        annotation: Optional[str] = None,
+        option_b_properties: Optional["_models.OptionBProperties"] = None,
+        option_a_properties: Optional["_models.ExternalNetworkPropertiesOptionAProperties"] = None,
+        import_route_policy_id: Optional[str] = None,
+        export_route_policy_id: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword mtu: MTU to use for option A peering.
-        :paramtype mtu: int
-        :keyword vlan_id: Vlan identifier. Example : 501.
-        :paramtype vlan_id: int
-        :keyword peer_asn: Peer ASN number.Example : 28.
-        :paramtype peer_asn: int
-        :keyword bfd_configuration: BFD configuration properties.
-        :paramtype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
-        :keyword ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-        :paramtype ingress_acl_id: str
-        :keyword egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-        :paramtype egress_acl_id: str
+        :keyword annotation: Switch configuration description.
+        :paramtype annotation: str
+        :keyword peering_option: Peering option list. Required. Known values are: "OptionA" and
+         "OptionB".
+        :paramtype peering_option: str or ~azure.mgmt.managednetworkfabric.models.PeeringOption
+        :keyword option_b_properties: option B properties object.
+        :paramtype option_b_properties: ~azure.mgmt.managednetworkfabric.models.OptionBProperties
+        :keyword option_a_properties: option A properties object.
+        :paramtype option_a_properties:
+         ~azure.mgmt.managednetworkfabric.models.ExternalNetworkPropertiesOptionAProperties
+        :keyword import_route_policy_id: ARM resource ID of importRoutePolicy.
+        :paramtype import_route_policy_id: str
+        :keyword export_route_policy_id: ARM resource ID of exportRoutePolicy.
+        :paramtype export_route_policy_id: str
         """
-        super().__init__(**kwargs)
-        self.mtu = mtu
-        self.vlan_id = vlan_id
-        self.fabric_asn = None
-        self.peer_asn = peer_asn
-        self.bfd_configuration = bfd_configuration
-        self.ingress_acl_id = ingress_acl_id
-        self.egress_acl_id = egress_acl_id
+        super().__init__(annotation=annotation, **kwargs)
+        self.network_to_network_interconnect_id = None
+        self.disabled_on_resources = None
+        self.administrative_state = None
+        self.provisioning_state = None
+        self.peering_option = peering_option
+        self.option_b_properties = option_b_properties
+        self.option_a_properties = option_a_properties
+        self.import_route_policy_id = import_route_policy_id
+        self.export_route_policy_id = export_route_policy_id
 
 
 class Layer3IpPrefixProperties(_serialization.Model):
-    """Layer 3 primary and secondary IP Address prefixes.
+    """Layer 3 primary and secondary ip address prefixes.
 
-    :ivar primary_ipv4_prefix: IPv4 Address Prefix.
+    :ivar primary_ipv4_prefix: IPv4 Address Prefix of CE-PE interconnect links. Example:
+     172.31.0.0/31. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
     :vartype primary_ipv4_prefix: str
-    :ivar primary_ipv6_prefix: IPv6 Address Prefix.
+    :ivar primary_ipv6_prefix: IPv6 Address Prefix of CE-PE interconnect links. Example:
+     3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
     :vartype primary_ipv6_prefix: str
-    :ivar secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
+    :ivar secondary_ipv4_prefix: Secondary IPv4 Address Prefix of CE-PE interconnect links.
+     Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
     :vartype secondary_ipv4_prefix: str
-    :ivar secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
+    :ivar secondary_ipv6_prefix: Secondary IPv6 Address Prefix of CE-PE interconnect links.
+     Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can
+     be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st
+     and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs
+     are to be configured on PE1 and PE2 for Option B interfaces.
     :vartype secondary_ipv6_prefix: str
     """
 
     _attribute_map = {
         "primary_ipv4_prefix": {"key": "primaryIpv4Prefix", "type": "str"},
         "primary_ipv6_prefix": {"key": "primaryIpv6Prefix", "type": "str"},
         "secondary_ipv4_prefix": {"key": "secondaryIpv4Prefix", "type": "str"},
@@ -2501,1950 +1775,1247 @@
         primary_ipv4_prefix: Optional[str] = None,
         primary_ipv6_prefix: Optional[str] = None,
         secondary_ipv4_prefix: Optional[str] = None,
         secondary_ipv6_prefix: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword primary_ipv4_prefix: IPv4 Address Prefix.
+        :keyword primary_ipv4_prefix: IPv4 Address Prefix of CE-PE interconnect links. Example:
+         172.31.0.0/31. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
         :paramtype primary_ipv4_prefix: str
-        :keyword primary_ipv6_prefix: IPv6 Address Prefix.
+        :keyword primary_ipv6_prefix: IPv6 Address Prefix of CE-PE interconnect links. Example:
+         3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
         :paramtype primary_ipv6_prefix: str
-        :keyword secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
+        :keyword secondary_ipv4_prefix: Secondary IPv4 Address Prefix of CE-PE interconnect links.
+         Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
         :paramtype secondary_ipv4_prefix: str
-        :keyword secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
+        :keyword secondary_ipv6_prefix: Secondary IPv6 Address Prefix of CE-PE interconnect links.
+         Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can
+         be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st
+         and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs
+         are to be configured on PE1 and PE2 for Option B interfaces.
         :paramtype secondary_ipv6_prefix: str
         """
         super().__init__(**kwargs)
         self.primary_ipv4_prefix = primary_ipv4_prefix
         self.primary_ipv6_prefix = primary_ipv6_prefix
         self.secondary_ipv4_prefix = secondary_ipv4_prefix
         self.secondary_ipv6_prefix = secondary_ipv6_prefix
 
 
-class ExternalNetworkPatchPropertiesOptionAProperties(
-    Layer3IpPrefixProperties, L3OptionAProperties
-):  # pylint: disable=too-many-instance-attributes
-    """option A properties object.
+class Layer3OptionAProperties(Layer3IpPrefixProperties):
+    """Peering optionA properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
+    :ivar primary_ipv4_prefix: IPv4 Address Prefix of CE-PE interconnect links. Example:
+     172.31.0.0/31. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
+    :vartype primary_ipv4_prefix: str
+    :ivar primary_ipv6_prefix: IPv6 Address Prefix of CE-PE interconnect links. Example:
+     3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
+    :vartype primary_ipv6_prefix: str
+    :ivar secondary_ipv4_prefix: Secondary IPv4 Address Prefix of CE-PE interconnect links.
+     Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
+    :vartype secondary_ipv4_prefix: str
+    :ivar secondary_ipv6_prefix: Secondary IPv6 Address Prefix of CE-PE interconnect links.
+     Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can
+     be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st
+     and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs
+     are to be configured on PE1 and PE2 for Option B interfaces.
+    :vartype secondary_ipv6_prefix: str
     :ivar mtu: MTU to use for option A peering.
     :vartype mtu: int
     :ivar vlan_id: Vlan identifier. Example : 501.
     :vartype vlan_id: int
     :ivar fabric_asn: Fabric ASN number. Example 65001.
     :vartype fabric_asn: int
     :ivar peer_asn: Peer ASN number.Example : 28.
     :vartype peer_asn: int
     :ivar bfd_configuration: BFD configuration properties.
     :vartype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
-    :ivar ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-    :vartype ingress_acl_id: str
-    :ivar egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-    :vartype egress_acl_id: str
-    :ivar primary_ipv4_prefix: IPv4 Address Prefix.
-    :vartype primary_ipv4_prefix: str
-    :ivar primary_ipv6_prefix: IPv6 Address Prefix.
-    :vartype primary_ipv6_prefix: str
-    :ivar secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
-    :vartype secondary_ipv4_prefix: str
-    :ivar secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
-    :vartype secondary_ipv6_prefix: str
     """
 
     _validation = {
-        "mtu": {"maximum": 9200, "minimum": 64},
-        "vlan_id": {"maximum": 4094, "minimum": 501},
-        "fabric_asn": {"readonly": True, "maximum": 4294967295, "minimum": 1},
-        "peer_asn": {"maximum": 4294967295, "minimum": 1},
+        "mtu": {"maximum": 9000, "minimum": 1500},
+        "vlan_id": {"maximum": 4095, "minimum": 501},
+        "fabric_asn": {"readonly": True, "maximum": 65535, "minimum": 1},
+        "peer_asn": {"maximum": 65535, "minimum": 1},
     }
 
     _attribute_map = {
+        "primary_ipv4_prefix": {"key": "primaryIpv4Prefix", "type": "str"},
+        "primary_ipv6_prefix": {"key": "primaryIpv6Prefix", "type": "str"},
+        "secondary_ipv4_prefix": {"key": "secondaryIpv4Prefix", "type": "str"},
+        "secondary_ipv6_prefix": {"key": "secondaryIpv6Prefix", "type": "str"},
         "mtu": {"key": "mtu", "type": "int"},
         "vlan_id": {"key": "vlanId", "type": "int"},
         "fabric_asn": {"key": "fabricASN", "type": "int"},
         "peer_asn": {"key": "peerASN", "type": "int"},
         "bfd_configuration": {"key": "bfdConfiguration", "type": "BfdConfiguration"},
-        "ingress_acl_id": {"key": "ingressAclId", "type": "str"},
-        "egress_acl_id": {"key": "egressAclId", "type": "str"},
-        "primary_ipv4_prefix": {"key": "primaryIpv4Prefix", "type": "str"},
-        "primary_ipv6_prefix": {"key": "primaryIpv6Prefix", "type": "str"},
-        "secondary_ipv4_prefix": {"key": "secondaryIpv4Prefix", "type": "str"},
-        "secondary_ipv6_prefix": {"key": "secondaryIpv6Prefix", "type": "str"},
     }
 
     def __init__(
         self,
         *,
-        mtu: int = 1500,
-        vlan_id: Optional[int] = None,
-        peer_asn: Optional[int] = None,
-        bfd_configuration: Optional["_models.BfdConfiguration"] = None,
-        ingress_acl_id: Optional[str] = None,
-        egress_acl_id: Optional[str] = None,
         primary_ipv4_prefix: Optional[str] = None,
         primary_ipv6_prefix: Optional[str] = None,
         secondary_ipv4_prefix: Optional[str] = None,
         secondary_ipv6_prefix: Optional[str] = None,
+        mtu: int = 1500,
+        vlan_id: Optional[int] = None,
+        peer_asn: Optional[int] = None,
+        bfd_configuration: Optional["_models.BfdConfiguration"] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword primary_ipv4_prefix: IPv4 Address Prefix of CE-PE interconnect links. Example:
+         172.31.0.0/31. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
+        :paramtype primary_ipv4_prefix: str
+        :keyword primary_ipv6_prefix: IPv6 Address Prefix of CE-PE interconnect links. Example:
+         3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
+        :paramtype primary_ipv6_prefix: str
+        :keyword secondary_ipv4_prefix: Secondary IPv4 Address Prefix of CE-PE interconnect links.
+         Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
+        :paramtype secondary_ipv4_prefix: str
+        :keyword secondary_ipv6_prefix: Secondary IPv6 Address Prefix of CE-PE interconnect links.
+         Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can
+         be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st
+         and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs
+         are to be configured on PE1 and PE2 for Option B interfaces.
+        :paramtype secondary_ipv6_prefix: str
         :keyword mtu: MTU to use for option A peering.
         :paramtype mtu: int
         :keyword vlan_id: Vlan identifier. Example : 501.
         :paramtype vlan_id: int
         :keyword peer_asn: Peer ASN number.Example : 28.
         :paramtype peer_asn: int
         :keyword bfd_configuration: BFD configuration properties.
         :paramtype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
-        :keyword ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-        :paramtype ingress_acl_id: str
-        :keyword egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-        :paramtype egress_acl_id: str
-        :keyword primary_ipv4_prefix: IPv4 Address Prefix.
-        :paramtype primary_ipv4_prefix: str
-        :keyword primary_ipv6_prefix: IPv6 Address Prefix.
-        :paramtype primary_ipv6_prefix: str
-        :keyword secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
-        :paramtype secondary_ipv4_prefix: str
-        :keyword secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
-        :paramtype secondary_ipv6_prefix: str
         """
         super().__init__(
             primary_ipv4_prefix=primary_ipv4_prefix,
             primary_ipv6_prefix=primary_ipv6_prefix,
             secondary_ipv4_prefix=secondary_ipv4_prefix,
             secondary_ipv6_prefix=secondary_ipv6_prefix,
-            mtu=mtu,
-            vlan_id=vlan_id,
-            peer_asn=peer_asn,
-            bfd_configuration=bfd_configuration,
-            ingress_acl_id=ingress_acl_id,
-            egress_acl_id=egress_acl_id,
             **kwargs
         )
         self.mtu = mtu
         self.vlan_id = vlan_id
         self.fabric_asn = None
         self.peer_asn = peer_asn
         self.bfd_configuration = bfd_configuration
-        self.ingress_acl_id = ingress_acl_id
-        self.egress_acl_id = egress_acl_id
-        self.primary_ipv4_prefix = primary_ipv4_prefix
-        self.primary_ipv6_prefix = primary_ipv6_prefix
-        self.secondary_ipv4_prefix = secondary_ipv4_prefix
-        self.secondary_ipv6_prefix = secondary_ipv6_prefix
-
-
-class ExternalNetworkProperties(
-    AnnotationResource, ExternalNetworkPatchableProperties
-):  # pylint: disable=too-many-instance-attributes
-    """External Network Properties.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
-    :vartype import_route_policy_id: str
-    :ivar export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
-    :vartype export_route_policy_id: str
-    :ivar import_route_policy: Import Route Policy either IPv4 or IPv6.
-    :vartype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-    :ivar export_route_policy: Export Route Policy either IPv4 or IPv6.
-    :vartype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar network_to_network_interconnect_id: Gets the networkToNetworkInterconnectId of the
-     resource.
-    :vartype network_to_network_interconnect_id: str
-    :ivar peering_option: Peering option list. Required. Known values are: "OptionA" and "OptionB".
-    :vartype peering_option: str or ~azure.mgmt.managednetworkfabric.models.PeeringOption
-    :ivar option_b_properties: option B properties object.
-    :vartype option_b_properties: ~azure.mgmt.managednetworkfabric.models.L3OptionBProperties
-    :ivar option_a_properties: option A properties object.
-    :vartype option_a_properties:
-     ~azure.mgmt.managednetworkfabric.models.ExternalNetworkPropertiesOptionAProperties
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
-    """
-
-    _validation = {
-        "network_to_network_interconnect_id": {"readonly": True},
-        "peering_option": {"required": True},
-        "configuration_state": {"readonly": True},
-        "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
-    }
 
-    _attribute_map = {
-        "import_route_policy_id": {"key": "importRoutePolicyId", "type": "str"},
-        "export_route_policy_id": {"key": "exportRoutePolicyId", "type": "str"},
-        "import_route_policy": {"key": "importRoutePolicy", "type": "ImportRoutePolicy"},
-        "export_route_policy": {"key": "exportRoutePolicy", "type": "ExportRoutePolicy"},
-        "annotation": {"key": "annotation", "type": "str"},
-        "network_to_network_interconnect_id": {"key": "networkToNetworkInterconnectId", "type": "str"},
-        "peering_option": {"key": "peeringOption", "type": "str"},
-        "option_b_properties": {"key": "optionBProperties", "type": "L3OptionBProperties"},
-        "option_a_properties": {"key": "optionAProperties", "type": "ExternalNetworkPropertiesOptionAProperties"},
-        "configuration_state": {"key": "configurationState", "type": "str"},
-        "provisioning_state": {"key": "provisioningState", "type": "str"},
-        "administrative_state": {"key": "administrativeState", "type": "str"},
-    }
 
-    def __init__(
-        self,
-        *,
-        peering_option: Union[str, "_models.PeeringOption"],
-        import_route_policy_id: Optional[str] = None,
-        export_route_policy_id: Optional[str] = None,
-        import_route_policy: Optional["_models.ImportRoutePolicy"] = None,
-        export_route_policy: Optional["_models.ExportRoutePolicy"] = None,
-        annotation: Optional[str] = None,
-        option_b_properties: Optional["_models.L3OptionBProperties"] = None,
-        option_a_properties: Optional["_models.ExternalNetworkPropertiesOptionAProperties"] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
-        :paramtype import_route_policy_id: str
-        :keyword export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
-        :paramtype export_route_policy_id: str
-        :keyword import_route_policy: Import Route Policy either IPv4 or IPv6.
-        :paramtype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-        :keyword export_route_policy: Export Route Policy either IPv4 or IPv6.
-        :paramtype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword peering_option: Peering option list. Required. Known values are: "OptionA" and
-         "OptionB".
-        :paramtype peering_option: str or ~azure.mgmt.managednetworkfabric.models.PeeringOption
-        :keyword option_b_properties: option B properties object.
-        :paramtype option_b_properties: ~azure.mgmt.managednetworkfabric.models.L3OptionBProperties
-        :keyword option_a_properties: option A properties object.
-        :paramtype option_a_properties:
-         ~azure.mgmt.managednetworkfabric.models.ExternalNetworkPropertiesOptionAProperties
-        """
-        super().__init__(
-            annotation=annotation,
-            import_route_policy_id=import_route_policy_id,
-            export_route_policy_id=export_route_policy_id,
-            import_route_policy=import_route_policy,
-            export_route_policy=export_route_policy,
-            **kwargs
-        )
-        self.import_route_policy_id = import_route_policy_id
-        self.export_route_policy_id = export_route_policy_id
-        self.import_route_policy = import_route_policy
-        self.export_route_policy = export_route_policy
-        self.network_to_network_interconnect_id = None
-        self.peering_option = peering_option
-        self.option_b_properties = option_b_properties
-        self.option_a_properties = option_a_properties
-        self.configuration_state = None
-        self.provisioning_state = None
-        self.administrative_state = None
-        self.annotation = annotation
-
-
-class ExternalNetworkPropertiesOptionAProperties(
-    Layer3IpPrefixProperties, L3OptionAProperties
-):  # pylint: disable=too-many-instance-attributes
+class ExternalNetworkPropertiesOptionAProperties(Layer3OptionAProperties):
     """option A properties object.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
+    :ivar primary_ipv4_prefix: IPv4 Address Prefix of CE-PE interconnect links. Example:
+     172.31.0.0/31. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
+    :vartype primary_ipv4_prefix: str
+    :ivar primary_ipv6_prefix: IPv6 Address Prefix of CE-PE interconnect links. Example:
+     3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
+    :vartype primary_ipv6_prefix: str
+    :ivar secondary_ipv4_prefix: Secondary IPv4 Address Prefix of CE-PE interconnect links.
+     Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
+    :vartype secondary_ipv4_prefix: str
+    :ivar secondary_ipv6_prefix: Secondary IPv6 Address Prefix of CE-PE interconnect links.
+     Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can
+     be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st
+     and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs
+     are to be configured on PE1 and PE2 for Option B interfaces.
+    :vartype secondary_ipv6_prefix: str
     :ivar mtu: MTU to use for option A peering.
     :vartype mtu: int
     :ivar vlan_id: Vlan identifier. Example : 501.
     :vartype vlan_id: int
     :ivar fabric_asn: Fabric ASN number. Example 65001.
     :vartype fabric_asn: int
     :ivar peer_asn: Peer ASN number.Example : 28.
     :vartype peer_asn: int
     :ivar bfd_configuration: BFD configuration properties.
     :vartype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
-    :ivar ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-    :vartype ingress_acl_id: str
-    :ivar egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-    :vartype egress_acl_id: str
-    :ivar primary_ipv4_prefix: IPv4 Address Prefix.
-    :vartype primary_ipv4_prefix: str
-    :ivar primary_ipv6_prefix: IPv6 Address Prefix.
-    :vartype primary_ipv6_prefix: str
-    :ivar secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
-    :vartype secondary_ipv4_prefix: str
-    :ivar secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
-    :vartype secondary_ipv6_prefix: str
     """
 
     _validation = {
-        "mtu": {"maximum": 9200, "minimum": 64},
-        "vlan_id": {"maximum": 4094, "minimum": 501},
-        "fabric_asn": {"readonly": True, "maximum": 4294967295, "minimum": 1},
-        "peer_asn": {"maximum": 4294967295, "minimum": 1},
+        "mtu": {"maximum": 9000, "minimum": 1500},
+        "vlan_id": {"maximum": 4095, "minimum": 501},
+        "fabric_asn": {"readonly": True, "maximum": 65535, "minimum": 1},
+        "peer_asn": {"maximum": 65535, "minimum": 1},
     }
 
     _attribute_map = {
+        "primary_ipv4_prefix": {"key": "primaryIpv4Prefix", "type": "str"},
+        "primary_ipv6_prefix": {"key": "primaryIpv6Prefix", "type": "str"},
+        "secondary_ipv4_prefix": {"key": "secondaryIpv4Prefix", "type": "str"},
+        "secondary_ipv6_prefix": {"key": "secondaryIpv6Prefix", "type": "str"},
         "mtu": {"key": "mtu", "type": "int"},
         "vlan_id": {"key": "vlanId", "type": "int"},
         "fabric_asn": {"key": "fabricASN", "type": "int"},
         "peer_asn": {"key": "peerASN", "type": "int"},
         "bfd_configuration": {"key": "bfdConfiguration", "type": "BfdConfiguration"},
-        "ingress_acl_id": {"key": "ingressAclId", "type": "str"},
-        "egress_acl_id": {"key": "egressAclId", "type": "str"},
-        "primary_ipv4_prefix": {"key": "primaryIpv4Prefix", "type": "str"},
-        "primary_ipv6_prefix": {"key": "primaryIpv6Prefix", "type": "str"},
-        "secondary_ipv4_prefix": {"key": "secondaryIpv4Prefix", "type": "str"},
-        "secondary_ipv6_prefix": {"key": "secondaryIpv6Prefix", "type": "str"},
     }
 
     def __init__(
         self,
         *,
-        mtu: int = 1500,
-        vlan_id: Optional[int] = None,
-        peer_asn: Optional[int] = None,
-        bfd_configuration: Optional["_models.BfdConfiguration"] = None,
-        ingress_acl_id: Optional[str] = None,
-        egress_acl_id: Optional[str] = None,
         primary_ipv4_prefix: Optional[str] = None,
         primary_ipv6_prefix: Optional[str] = None,
         secondary_ipv4_prefix: Optional[str] = None,
         secondary_ipv6_prefix: Optional[str] = None,
+        mtu: int = 1500,
+        vlan_id: Optional[int] = None,
+        peer_asn: Optional[int] = None,
+        bfd_configuration: Optional["_models.BfdConfiguration"] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword primary_ipv4_prefix: IPv4 Address Prefix of CE-PE interconnect links. Example:
+         172.31.0.0/31. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
+        :paramtype primary_ipv4_prefix: str
+        :keyword primary_ipv6_prefix: IPv6 Address Prefix of CE-PE interconnect links. Example:
+         3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
+        :paramtype primary_ipv6_prefix: str
+        :keyword secondary_ipv4_prefix: Secondary IPv4 Address Prefix of CE-PE interconnect links.
+         Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
+        :paramtype secondary_ipv4_prefix: str
+        :keyword secondary_ipv6_prefix: Secondary IPv6 Address Prefix of CE-PE interconnect links.
+         Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can
+         be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st
+         and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs
+         are to be configured on PE1 and PE2 for Option B interfaces.
+        :paramtype secondary_ipv6_prefix: str
         :keyword mtu: MTU to use for option A peering.
         :paramtype mtu: int
         :keyword vlan_id: Vlan identifier. Example : 501.
         :paramtype vlan_id: int
         :keyword peer_asn: Peer ASN number.Example : 28.
         :paramtype peer_asn: int
         :keyword bfd_configuration: BFD configuration properties.
         :paramtype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
-        :keyword ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-        :paramtype ingress_acl_id: str
-        :keyword egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-        :paramtype egress_acl_id: str
-        :keyword primary_ipv4_prefix: IPv4 Address Prefix.
-        :paramtype primary_ipv4_prefix: str
-        :keyword primary_ipv6_prefix: IPv6 Address Prefix.
-        :paramtype primary_ipv6_prefix: str
-        :keyword secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
-        :paramtype secondary_ipv4_prefix: str
-        :keyword secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
-        :paramtype secondary_ipv6_prefix: str
         """
         super().__init__(
             primary_ipv4_prefix=primary_ipv4_prefix,
             primary_ipv6_prefix=primary_ipv6_prefix,
             secondary_ipv4_prefix=secondary_ipv4_prefix,
             secondary_ipv6_prefix=secondary_ipv6_prefix,
             mtu=mtu,
             vlan_id=vlan_id,
             peer_asn=peer_asn,
             bfd_configuration=bfd_configuration,
-            ingress_acl_id=ingress_acl_id,
-            egress_acl_id=egress_acl_id,
             **kwargs
         )
-        self.mtu = mtu
-        self.vlan_id = vlan_id
-        self.fabric_asn = None
-        self.peer_asn = peer_asn
-        self.bfd_configuration = bfd_configuration
-        self.ingress_acl_id = ingress_acl_id
-        self.egress_acl_id = egress_acl_id
-        self.primary_ipv4_prefix = primary_ipv4_prefix
-        self.primary_ipv6_prefix = primary_ipv6_prefix
-        self.secondary_ipv4_prefix = secondary_ipv4_prefix
-        self.secondary_ipv6_prefix = secondary_ipv6_prefix
 
 
 class ExternalNetworksList(_serialization.Model):
-    """List of External Networks.
+    """List of ExternalNetworks.
 
-    :ivar value: List of External Network resources.
+    :ivar value: List of ExternalNetworks resources.
     :vartype value: list[~azure.mgmt.managednetworkfabric.models.ExternalNetwork]
     :ivar next_link: Url to follow for getting next page of resources.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[ExternalNetwork]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
     def __init__(
         self, *, value: Optional[List["_models.ExternalNetwork"]] = None, next_link: Optional[str] = None, **kwargs: Any
     ) -> None:
         """
-        :keyword value: List of External Network resources.
+        :keyword value: List of ExternalNetworks resources.
         :paramtype value: list[~azure.mgmt.managednetworkfabric.models.ExternalNetwork]
         :keyword next_link: Url to follow for getting next page of resources.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
-class ImportRoutePolicy(_serialization.Model):
-    """Import Route Policy either IPv4 or IPv6.
+class FabricBfdConfiguration(_serialization.Model):
+    """BFD Configuration properties.
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar interval: interval in seconds. Example: 300.
+    :vartype interval: int
+    :ivar multiplier: multiplier. Example: 3.
+    :vartype multiplier: int
+    """
+
+    _validation = {
+        "interval": {"readonly": True},
+        "multiplier": {"readonly": True},
+    }
+
+    _attribute_map = {
+        "interval": {"key": "interval", "type": "int"},
+        "multiplier": {"key": "multiplier", "type": "int"},
+    }
+
+    def __init__(self, **kwargs: Any) -> None:
+        """ """
+        super().__init__(**kwargs)
+        self.interval = None
+        self.multiplier = None
+
+
+class GetDeviceStatusProperties(_serialization.Model):
+    """Get Device status response properties.
+
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar operational_status: Primary or Secondary power end. Required. Known values are: "Booted",
+     "BootPrompt", and "Ztp".
+    :vartype operational_status: str or ~azure.mgmt.managednetworkfabric.models.OperationalStatus
+    :ivar power_cycle_state: On or Off power cycle state. Required. Known values are: "On" and
+     "Off".
+    :vartype power_cycle_state: str or ~azure.mgmt.managednetworkfabric.models.PowerCycleState
+    :ivar serial_number: The serial number of the device. Required.
+    :vartype serial_number: str
+    """
+
+    _validation = {
+        "operational_status": {"required": True},
+        "power_cycle_state": {"required": True},
+        "serial_number": {"required": True},
+    }
+
+    _attribute_map = {
+        "operational_status": {"key": "operationalStatus", "type": "str"},
+        "power_cycle_state": {"key": "powerCycleState", "type": "str"},
+        "serial_number": {"key": "serialNumber", "type": "str"},
+    }
+
+    def __init__(
+        self,
+        *,
+        operational_status: Union[str, "_models.OperationalStatus"],
+        power_cycle_state: Union[str, "_models.PowerCycleState"],
+        serial_number: str,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword operational_status: Primary or Secondary power end. Required. Known values are:
+         "Booted", "BootPrompt", and "Ztp".
+        :paramtype operational_status: str or ~azure.mgmt.managednetworkfabric.models.OperationalStatus
+        :keyword power_cycle_state: On or Off power cycle state. Required. Known values are: "On" and
+         "Off".
+        :paramtype power_cycle_state: str or ~azure.mgmt.managednetworkfabric.models.PowerCycleState
+        :keyword serial_number: The serial number of the device. Required.
+        :paramtype serial_number: str
+        """
+        super().__init__(**kwargs)
+        self.operational_status = operational_status
+        self.power_cycle_state = power_cycle_state
+        self.serial_number = serial_number
+
+
+class InterfaceStatus(_serialization.Model):
+    """Interface running status properties.
 
-    :ivar import_ipv4_route_policy_id: ARM resource ID of RoutePolicy.
-    :vartype import_ipv4_route_policy_id: str
-    :ivar import_ipv6_route_policy_id: ARM resource ID of RoutePolicy.
-    :vartype import_ipv6_route_policy_id: str
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar administrative_state: The interface administrative state. Known values are: "Enabled" and
+     "Disabled".
+    :vartype administrative_state: str or
+     ~azure.mgmt.managednetworkfabric.models.EnabledDisabledState
+    :ivar operational_status: The interface operational status.
+    :vartype operational_status: str
+    :ivar phy_status: The physical status.
+    :vartype phy_status: str
+    :ivar transceiver_status: The interface transceiver type. Example: up or down.
+    :vartype transceiver_status: str
+    :ivar connected_to: Connected to ARM resource or external interface.
+    :vartype connected_to: str
     """
 
+    _validation = {
+        "administrative_state": {"readonly": True},
+    }
+
     _attribute_map = {
-        "import_ipv4_route_policy_id": {"key": "importIpv4RoutePolicyId", "type": "str"},
-        "import_ipv6_route_policy_id": {"key": "importIpv6RoutePolicyId", "type": "str"},
+        "administrative_state": {"key": "administrativeState", "type": "str"},
+        "operational_status": {"key": "operationalStatus", "type": "str"},
+        "phy_status": {"key": "phyStatus", "type": "str"},
+        "transceiver_status": {"key": "transceiverStatus", "type": "str"},
+        "connected_to": {"key": "connectedTo", "type": "str"},
+    }
+
+    def __init__(
+        self,
+        *,
+        operational_status: Optional[str] = None,
+        phy_status: Optional[str] = None,
+        transceiver_status: Optional[str] = None,
+        connected_to: Optional[str] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword operational_status: The interface operational status.
+        :paramtype operational_status: str
+        :keyword phy_status: The physical status.
+        :paramtype phy_status: str
+        :keyword transceiver_status: The interface transceiver type. Example: up or down.
+        :paramtype transceiver_status: str
+        :keyword connected_to: Connected to ARM resource or external interface.
+        :paramtype connected_to: str
+        """
+        super().__init__(**kwargs)
+        self.administrative_state = None
+        self.operational_status = operational_status
+        self.phy_status = phy_status
+        self.transceiver_status = transceiver_status
+        self.connected_to = connected_to
+
+
+class GetDynamicInterfaceMapsPropertiesItem(InterfaceStatus):
+    """Get Device static interface maps as per topology.
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar administrative_state: The interface administrative state. Known values are: "Enabled" and
+     "Disabled".
+    :vartype administrative_state: str or
+     ~azure.mgmt.managednetworkfabric.models.EnabledDisabledState
+    :ivar operational_status: The interface operational status.
+    :vartype operational_status: str
+    :ivar phy_status: The physical status.
+    :vartype phy_status: str
+    :ivar transceiver_status: The interface transceiver type. Example: up or down.
+    :vartype transceiver_status: str
+    :ivar connected_to: Connected to ARM resource or external interface.
+    :vartype connected_to: str
+    :ivar name: The interface name.
+    :vartype name: str
+    """
+
+    _validation = {
+        "administrative_state": {"readonly": True},
+    }
+
+    _attribute_map = {
+        "administrative_state": {"key": "administrativeState", "type": "str"},
+        "operational_status": {"key": "operationalStatus", "type": "str"},
+        "phy_status": {"key": "phyStatus", "type": "str"},
+        "transceiver_status": {"key": "transceiverStatus", "type": "str"},
+        "connected_to": {"key": "connectedTo", "type": "str"},
+        "name": {"key": "name", "type": "str"},
+    }
+
+    def __init__(
+        self,
+        *,
+        operational_status: Optional[str] = None,
+        phy_status: Optional[str] = None,
+        transceiver_status: Optional[str] = None,
+        connected_to: Optional[str] = None,
+        name: Optional[str] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword operational_status: The interface operational status.
+        :paramtype operational_status: str
+        :keyword phy_status: The physical status.
+        :paramtype phy_status: str
+        :keyword transceiver_status: The interface transceiver type. Example: up or down.
+        :paramtype transceiver_status: str
+        :keyword connected_to: Connected to ARM resource or external interface.
+        :paramtype connected_to: str
+        :keyword name: The interface name.
+        :paramtype name: str
+        """
+        super().__init__(
+            operational_status=operational_status,
+            phy_status=phy_status,
+            transceiver_status=transceiver_status,
+            connected_to=connected_to,
+            **kwargs
+        )
+        self.name = name
+
+
+class GetStaticInterfaceMapsPropertiesItem(_serialization.Model):
+    """Get Device static interface maps as per topology.
+
+    :ivar name: The interface name.
+    :vartype name: str
+    :ivar description: The interface description.
+    :vartype description: str
+    :ivar identifier: The interface identifier.
+    :vartype identifier: str
+    :ivar interface_type: The interface type. Example: Ethernet.
+    :vartype interface_type: str
+    :ivar connector_type: The physical cable connector type. Example: Optical.
+    :vartype connector_type: str
+    :ivar connected_to: Connected to ARM resource or external interface.
+    :vartype connected_to: str
+    :ivar speed: The interface speed. Example: 100.
+    :vartype speed: float
+    :ivar channel_group_id: The port channel group id.
+    :vartype channel_group_id: float
+    """
+
+    _attribute_map = {
+        "name": {"key": "name", "type": "str"},
+        "description": {"key": "description", "type": "str"},
+        "identifier": {"key": "identifier", "type": "str"},
+        "interface_type": {"key": "interfaceType", "type": "str"},
+        "connector_type": {"key": "connectorType", "type": "str"},
+        "connected_to": {"key": "connectedTo", "type": "str"},
+        "speed": {"key": "speed", "type": "float"},
+        "channel_group_id": {"key": "channelGroupId", "type": "float"},
     }
 
     def __init__(
         self,
         *,
-        import_ipv4_route_policy_id: Optional[str] = None,
-        import_ipv6_route_policy_id: Optional[str] = None,
+        name: Optional[str] = None,
+        description: Optional[str] = None,
+        identifier: Optional[str] = None,
+        interface_type: Optional[str] = None,
+        connector_type: Optional[str] = None,
+        connected_to: Optional[str] = None,
+        speed: Optional[float] = None,
+        channel_group_id: Optional[float] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword import_ipv4_route_policy_id: ARM resource ID of RoutePolicy.
-        :paramtype import_ipv4_route_policy_id: str
-        :keyword import_ipv6_route_policy_id: ARM resource ID of RoutePolicy.
-        :paramtype import_ipv6_route_policy_id: str
+        :keyword name: The interface name.
+        :paramtype name: str
+        :keyword description: The interface description.
+        :paramtype description: str
+        :keyword identifier: The interface identifier.
+        :paramtype identifier: str
+        :keyword interface_type: The interface type. Example: Ethernet.
+        :paramtype interface_type: str
+        :keyword connector_type: The physical cable connector type. Example: Optical.
+        :paramtype connector_type: str
+        :keyword connected_to: Connected to ARM resource or external interface.
+        :paramtype connected_to: str
+        :keyword speed: The interface speed. Example: 100.
+        :paramtype speed: float
+        :keyword channel_group_id: The port channel group id.
+        :paramtype channel_group_id: float
         """
         super().__init__(**kwargs)
-        self.import_ipv4_route_policy_id = import_ipv4_route_policy_id
-        self.import_ipv6_route_policy_id = import_ipv6_route_policy_id
+        self.name = name
+        self.description = description
+        self.identifier = identifier
+        self.interface_type = interface_type
+        self.connector_type = connector_type
+        self.connected_to = connected_to
+        self.speed = speed
+        self.channel_group_id = channel_group_id
 
 
-class ImportRoutePolicyInformation(_serialization.Model):
-    """Import Route Policy Configuration.
+class InfrastructureServices(_serialization.Model):
+    """InfrastructureServices IP ranges.
 
-    :ivar import_ipv4_route_policy_id: Import IPv4 Route Policy Id.
-    :vartype import_ipv4_route_policy_id: str
-    :ivar import_ipv6_route_policy_id: Import IPv6 Route Policy Id.
-    :vartype import_ipv6_route_policy_id: str
+    :ivar ipv4_address_spaces: The IPv4 Address space is optional, if the value is not defined at
+     the time of NFC creation, then the default value 10.0.0.0/19 is considered. The IPV4 address
+     subnet is an optional attribute.
+    :vartype ipv4_address_spaces: list[str]
+    :ivar ipv6_address_spaces: The IPv6 is not supported right now.
+    :vartype ipv6_address_spaces: list[str]
     """
 
     _attribute_map = {
-        "import_ipv4_route_policy_id": {"key": "importIpv4RoutePolicyId", "type": "str"},
-        "import_ipv6_route_policy_id": {"key": "importIpv6RoutePolicyId", "type": "str"},
+        "ipv4_address_spaces": {"key": "ipv4AddressSpaces", "type": "[str]"},
+        "ipv6_address_spaces": {"key": "ipv6AddressSpaces", "type": "[str]"},
     }
 
     def __init__(
         self,
         *,
-        import_ipv4_route_policy_id: Optional[str] = None,
-        import_ipv6_route_policy_id: Optional[str] = None,
+        ipv4_address_spaces: Optional[List[str]] = None,
+        ipv6_address_spaces: Optional[List[str]] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword import_ipv4_route_policy_id: Import IPv4 Route Policy Id.
-        :paramtype import_ipv4_route_policy_id: str
-        :keyword import_ipv6_route_policy_id: Import IPv6 Route Policy Id.
-        :paramtype import_ipv6_route_policy_id: str
+        :keyword ipv4_address_spaces: The IPv4 Address space is optional, if the value is not defined
+         at the time of NFC creation, then the default value 10.0.0.0/19 is considered. The IPV4 address
+         subnet is an optional attribute.
+        :paramtype ipv4_address_spaces: list[str]
+        :keyword ipv6_address_spaces: The IPv6 is not supported right now.
+        :paramtype ipv6_address_spaces: list[str]
         """
         super().__init__(**kwargs)
-        self.import_ipv4_route_policy_id = import_ipv4_route_policy_id
-        self.import_ipv6_route_policy_id = import_ipv6_route_policy_id
+        self.ipv4_address_spaces = ipv4_address_spaces
+        self.ipv6_address_spaces = ipv6_address_spaces
 
 
 class InternalNetwork(ProxyResource):  # pylint: disable=too-many-instance-attributes
-    """Defines the Internal Network resource.
+    """Defines the InternalNetwork item.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
      information.
     :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
     :ivar mtu: Maximum transmission unit. Default value is 1500.
     :vartype mtu: int
-    :ivar connected_i_pv4_subnets: List of Connected IPv4 Subnets.
+    :ivar connected_i_pv4_subnets: List with object connected IPv4 Subnets.
     :vartype connected_i_pv4_subnets: list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-    :ivar connected_i_pv6_subnets: List of connected IPv6 Subnets.
+    :ivar connected_i_pv6_subnets: List with object connected IPv6 Subnets.
     :vartype connected_i_pv6_subnets: list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-    :ivar import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
+    :ivar static_route_configuration: Static Route Configuration properties.
+    :vartype static_route_configuration:
+     ~azure.mgmt.managednetworkfabric.models.StaticRouteConfiguration
+    :ivar bgp_configuration: BGP configuration properties.
+    :vartype bgp_configuration: ~azure.mgmt.managednetworkfabric.models.BgpConfiguration
+    :ivar import_route_policy_id: ARM resource ID of importRoutePolicy.
     :vartype import_route_policy_id: str
-    :ivar export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
+    :ivar export_route_policy_id: ARM resource ID of importRoutePolicy.
     :vartype export_route_policy_id: str
-    :ivar import_route_policy: Import Route Policy either IPv4 or IPv6.
-    :vartype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-    :ivar export_route_policy: Export Route Policy either IPv4 or IPv6.
-    :vartype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
-    :ivar ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-    :vartype ingress_acl_id: str
-    :ivar egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-    :vartype egress_acl_id: str
-    :ivar is_monitoring_enabled: To check whether monitoring of internal network is enabled or not.
-     Known values are: "True" and "False".
-    :vartype is_monitoring_enabled: str or
-     ~azure.mgmt.managednetworkfabric.models.IsMonitoringEnabled
-    :ivar extension: Extension. Example: NoExtension | NPB. Known values are: "NoExtension" and
-     "NPB".
-    :vartype extension: str or ~azure.mgmt.managednetworkfabric.models.Extension
+    :ivar disabled_on_resources: List of resources the InternalNetwork is disabled on. Can be
+     either entire NetworkFabric or NetworkRack.
+    :vartype disabled_on_resources: list[str]
+    :ivar administrative_state: Administrative state of the InternalNetwork. Example: Enabled |
+     Disabled. Known values are: "Enabled" and "Disabled".
+    :vartype administrative_state: str or
+     ~azure.mgmt.managednetworkfabric.models.EnabledDisabledState
+    :ivar bgp_disabled_on_resources: List of resources the BGP is disabled on. Can be either entire
+     NetworkFabric or NetworkRack.
+    :vartype bgp_disabled_on_resources: list[str]
+    :ivar bfd_disabled_on_resources: List of resources the BFD for BGP is disabled on. Can be
+     either entire NetworkFabric or NetworkRack.
+    :vartype bfd_disabled_on_resources: list[str]
+    :ivar bfd_for_static_routes_disabled_on_resources: List of resources the BFD of StaticRoutes is
+     disabled on. Can be either entire NetworkFabric or NetworkRack.
+    :vartype bfd_for_static_routes_disabled_on_resources: list[str]
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
+    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
     :ivar vlan_id: Vlan identifier. Example: 1001. Required.
     :vartype vlan_id: int
-    :ivar bgp_configuration: BGP configuration properties.
-    :vartype bgp_configuration:
-     ~azure.mgmt.managednetworkfabric.models.InternalNetworkPropertiesBgpConfiguration
-    :ivar static_route_configuration: Static Route Configuration properties.
-    :vartype static_route_configuration:
-     ~azure.mgmt.managednetworkfabric.models.InternalNetworkPropertiesStaticRouteConfiguration
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
-        "mtu": {"maximum": 9200, "minimum": 64},
-        "connected_i_pv4_subnets": {"min_items": 1},
-        "connected_i_pv6_subnets": {"min_items": 1},
-        "vlan_id": {"required": True, "maximum": 4094, "minimum": 100},
-        "configuration_state": {"readonly": True},
-        "provisioning_state": {"readonly": True},
+        "mtu": {"maximum": 9000, "minimum": 1500},
+        "disabled_on_resources": {"readonly": True},
         "administrative_state": {"readonly": True},
+        "bgp_disabled_on_resources": {"readonly": True},
+        "bfd_disabled_on_resources": {"readonly": True},
+        "bfd_for_static_routes_disabled_on_resources": {"readonly": True},
+        "provisioning_state": {"readonly": True},
+        "vlan_id": {"required": True, "maximum": 4095, "minimum": 100},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "annotation": {"key": "properties.annotation", "type": "str"},
         "mtu": {"key": "properties.mtu", "type": "int"},
         "connected_i_pv4_subnets": {"key": "properties.connectedIPv4Subnets", "type": "[ConnectedSubnet]"},
         "connected_i_pv6_subnets": {"key": "properties.connectedIPv6Subnets", "type": "[ConnectedSubnet]"},
-        "import_route_policy_id": {"key": "properties.importRoutePolicyId", "type": "str"},
-        "export_route_policy_id": {"key": "properties.exportRoutePolicyId", "type": "str"},
-        "import_route_policy": {"key": "properties.importRoutePolicy", "type": "ImportRoutePolicy"},
-        "export_route_policy": {"key": "properties.exportRoutePolicy", "type": "ExportRoutePolicy"},
-        "ingress_acl_id": {"key": "properties.ingressAclId", "type": "str"},
-        "egress_acl_id": {"key": "properties.egressAclId", "type": "str"},
-        "is_monitoring_enabled": {"key": "properties.isMonitoringEnabled", "type": "str"},
-        "extension": {"key": "properties.extension", "type": "str"},
-        "vlan_id": {"key": "properties.vlanId", "type": "int"},
-        "bgp_configuration": {
-            "key": "properties.bgpConfiguration",
-            "type": "InternalNetworkPropertiesBgpConfiguration",
-        },
         "static_route_configuration": {
             "key": "properties.staticRouteConfiguration",
-            "type": "InternalNetworkPropertiesStaticRouteConfiguration",
+            "type": "StaticRouteConfiguration",
         },
-        "configuration_state": {"key": "properties.configurationState", "type": "str"},
-        "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
+        "bgp_configuration": {"key": "properties.bgpConfiguration", "type": "BgpConfiguration"},
+        "import_route_policy_id": {"key": "properties.importRoutePolicyId", "type": "str"},
+        "export_route_policy_id": {"key": "properties.exportRoutePolicyId", "type": "str"},
+        "disabled_on_resources": {"key": "properties.disabledOnResources", "type": "[str]"},
         "administrative_state": {"key": "properties.administrativeState", "type": "str"},
+        "bgp_disabled_on_resources": {"key": "properties.bgpDisabledOnResources", "type": "[str]"},
+        "bfd_disabled_on_resources": {"key": "properties.bfdDisabledOnResources", "type": "[str]"},
+        "bfd_for_static_routes_disabled_on_resources": {
+            "key": "properties.bfdForStaticRoutesDisabledOnResources",
+            "type": "[str]",
+        },
+        "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
+        "vlan_id": {"key": "properties.vlanId", "type": "int"},
     }
 
     def __init__(
         self,
         *,
         vlan_id: int,
         annotation: Optional[str] = None,
         mtu: int = 1500,
         connected_i_pv4_subnets: Optional[List["_models.ConnectedSubnet"]] = None,
         connected_i_pv6_subnets: Optional[List["_models.ConnectedSubnet"]] = None,
+        static_route_configuration: Optional["_models.StaticRouteConfiguration"] = None,
+        bgp_configuration: Optional["_models.BgpConfiguration"] = None,
         import_route_policy_id: Optional[str] = None,
         export_route_policy_id: Optional[str] = None,
-        import_route_policy: Optional["_models.ImportRoutePolicy"] = None,
-        export_route_policy: Optional["_models.ExportRoutePolicy"] = None,
-        ingress_acl_id: Optional[str] = None,
-        egress_acl_id: Optional[str] = None,
-        is_monitoring_enabled: Union[str, "_models.IsMonitoringEnabled"] = "False",
-        extension: Union[str, "_models.Extension"] = "NoExtension",
-        bgp_configuration: Optional["_models.InternalNetworkPropertiesBgpConfiguration"] = None,
-        static_route_configuration: Optional["_models.InternalNetworkPropertiesStaticRouteConfiguration"] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
         :keyword mtu: Maximum transmission unit. Default value is 1500.
         :paramtype mtu: int
-        :keyword connected_i_pv4_subnets: List of Connected IPv4 Subnets.
+        :keyword connected_i_pv4_subnets: List with object connected IPv4 Subnets.
         :paramtype connected_i_pv4_subnets:
          list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-        :keyword connected_i_pv6_subnets: List of connected IPv6 Subnets.
+        :keyword connected_i_pv6_subnets: List with object connected IPv6 Subnets.
         :paramtype connected_i_pv6_subnets:
          list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-        :keyword import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
+        :keyword static_route_configuration: Static Route Configuration properties.
+        :paramtype static_route_configuration:
+         ~azure.mgmt.managednetworkfabric.models.StaticRouteConfiguration
+        :keyword bgp_configuration: BGP configuration properties.
+        :paramtype bgp_configuration: ~azure.mgmt.managednetworkfabric.models.BgpConfiguration
+        :keyword import_route_policy_id: ARM resource ID of importRoutePolicy.
         :paramtype import_route_policy_id: str
-        :keyword export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
+        :keyword export_route_policy_id: ARM resource ID of importRoutePolicy.
         :paramtype export_route_policy_id: str
-        :keyword import_route_policy: Import Route Policy either IPv4 or IPv6.
-        :paramtype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-        :keyword export_route_policy: Export Route Policy either IPv4 or IPv6.
-        :paramtype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
-        :keyword ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-        :paramtype ingress_acl_id: str
-        :keyword egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-        :paramtype egress_acl_id: str
-        :keyword is_monitoring_enabled: To check whether monitoring of internal network is enabled or
-         not. Known values are: "True" and "False".
-        :paramtype is_monitoring_enabled: str or
-         ~azure.mgmt.managednetworkfabric.models.IsMonitoringEnabled
-        :keyword extension: Extension. Example: NoExtension | NPB. Known values are: "NoExtension" and
-         "NPB".
-        :paramtype extension: str or ~azure.mgmt.managednetworkfabric.models.Extension
         :keyword vlan_id: Vlan identifier. Example: 1001. Required.
         :paramtype vlan_id: int
-        :keyword bgp_configuration: BGP configuration properties.
-        :paramtype bgp_configuration:
-         ~azure.mgmt.managednetworkfabric.models.InternalNetworkPropertiesBgpConfiguration
-        :keyword static_route_configuration: Static Route Configuration properties.
-        :paramtype static_route_configuration:
-         ~azure.mgmt.managednetworkfabric.models.InternalNetworkPropertiesStaticRouteConfiguration
         """
         super().__init__(**kwargs)
         self.annotation = annotation
         self.mtu = mtu
         self.connected_i_pv4_subnets = connected_i_pv4_subnets
         self.connected_i_pv6_subnets = connected_i_pv6_subnets
+        self.static_route_configuration = static_route_configuration
+        self.bgp_configuration = bgp_configuration
         self.import_route_policy_id = import_route_policy_id
         self.export_route_policy_id = export_route_policy_id
-        self.import_route_policy = import_route_policy
-        self.export_route_policy = export_route_policy
-        self.ingress_acl_id = ingress_acl_id
-        self.egress_acl_id = egress_acl_id
-        self.is_monitoring_enabled = is_monitoring_enabled
-        self.extension = extension
-        self.vlan_id = vlan_id
-        self.bgp_configuration = bgp_configuration
-        self.static_route_configuration = static_route_configuration
-        self.configuration_state = None
-        self.provisioning_state = None
+        self.disabled_on_resources = None
         self.administrative_state = None
+        self.bgp_disabled_on_resources = None
+        self.bfd_disabled_on_resources = None
+        self.bfd_for_static_routes_disabled_on_resources = None
+        self.provisioning_state = None
+        self.vlan_id = vlan_id
 
 
-class InternalNetworkPatch(_serialization.Model):  # pylint: disable=too-many-instance-attributes
+class InternalNetworkPatch(_serialization.Model):
     """The InternalNetwork patch resource definition.
 
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
     :ivar mtu: Maximum transmission unit. Default value is 1500.
     :vartype mtu: int
-    :ivar connected_i_pv4_subnets: List of Connected IPv4 Subnets.
+    :ivar connected_i_pv4_subnets: List with object connected IPv4 Subnets.
     :vartype connected_i_pv4_subnets: list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-    :ivar connected_i_pv6_subnets: List of connected IPv6 Subnets.
+    :ivar connected_i_pv6_subnets: List with object connected IPv6 Subnets.
     :vartype connected_i_pv6_subnets: list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-    :ivar import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
-    :vartype import_route_policy_id: str
-    :ivar export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
-    :vartype export_route_policy_id: str
-    :ivar import_route_policy: Import Route Policy either IPv4 or IPv6.
-    :vartype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-    :ivar export_route_policy: Export Route Policy either IPv4 or IPv6.
-    :vartype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
-    :ivar ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-    :vartype ingress_acl_id: str
-    :ivar egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-    :vartype egress_acl_id: str
-    :ivar is_monitoring_enabled: To check whether monitoring of internal network is enabled or not.
-     Known values are: "True" and "False".
-    :vartype is_monitoring_enabled: str or
-     ~azure.mgmt.managednetworkfabric.models.IsMonitoringEnabled
-    :ivar bgp_configuration: BGP configuration properties.
-    :vartype bgp_configuration: ~azure.mgmt.managednetworkfabric.models.BgpConfiguration
     :ivar static_route_configuration: Static Route Configuration properties.
     :vartype static_route_configuration:
      ~azure.mgmt.managednetworkfabric.models.StaticRouteConfiguration
+    :ivar bgp_configuration: BGP configuration properties.
+    :vartype bgp_configuration: ~azure.mgmt.managednetworkfabric.models.BgpConfiguration
+    :ivar import_route_policy_id: ARM resource ID of importRoutePolicy.
+    :vartype import_route_policy_id: str
+    :ivar export_route_policy_id: ARM resource ID of importRoutePolicy.
+    :vartype export_route_policy_id: str
     """
 
     _validation = {
-        "mtu": {"maximum": 9200, "minimum": 64},
-        "connected_i_pv4_subnets": {"min_items": 1},
-        "connected_i_pv6_subnets": {"min_items": 1},
+        "mtu": {"maximum": 9000, "minimum": 1500},
     }
 
     _attribute_map = {
         "annotation": {"key": "properties.annotation", "type": "str"},
         "mtu": {"key": "properties.mtu", "type": "int"},
         "connected_i_pv4_subnets": {"key": "properties.connectedIPv4Subnets", "type": "[ConnectedSubnet]"},
         "connected_i_pv6_subnets": {"key": "properties.connectedIPv6Subnets", "type": "[ConnectedSubnet]"},
-        "import_route_policy_id": {"key": "properties.importRoutePolicyId", "type": "str"},
-        "export_route_policy_id": {"key": "properties.exportRoutePolicyId", "type": "str"},
-        "import_route_policy": {"key": "properties.importRoutePolicy", "type": "ImportRoutePolicy"},
-        "export_route_policy": {"key": "properties.exportRoutePolicy", "type": "ExportRoutePolicy"},
-        "ingress_acl_id": {"key": "properties.ingressAclId", "type": "str"},
-        "egress_acl_id": {"key": "properties.egressAclId", "type": "str"},
-        "is_monitoring_enabled": {"key": "properties.isMonitoringEnabled", "type": "str"},
-        "bgp_configuration": {"key": "properties.bgpConfiguration", "type": "BgpConfiguration"},
         "static_route_configuration": {
             "key": "properties.staticRouteConfiguration",
             "type": "StaticRouteConfiguration",
         },
+        "bgp_configuration": {"key": "properties.bgpConfiguration", "type": "BgpConfiguration"},
+        "import_route_policy_id": {"key": "properties.importRoutePolicyId", "type": "str"},
+        "export_route_policy_id": {"key": "properties.exportRoutePolicyId", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         annotation: Optional[str] = None,
         mtu: int = 1500,
         connected_i_pv4_subnets: Optional[List["_models.ConnectedSubnet"]] = None,
         connected_i_pv6_subnets: Optional[List["_models.ConnectedSubnet"]] = None,
+        static_route_configuration: Optional["_models.StaticRouteConfiguration"] = None,
+        bgp_configuration: Optional["_models.BgpConfiguration"] = None,
         import_route_policy_id: Optional[str] = None,
         export_route_policy_id: Optional[str] = None,
-        import_route_policy: Optional["_models.ImportRoutePolicy"] = None,
-        export_route_policy: Optional["_models.ExportRoutePolicy"] = None,
-        ingress_acl_id: Optional[str] = None,
-        egress_acl_id: Optional[str] = None,
-        is_monitoring_enabled: Union[str, "_models.IsMonitoringEnabled"] = "False",
-        bgp_configuration: Optional["_models.BgpConfiguration"] = None,
-        static_route_configuration: Optional["_models.StaticRouteConfiguration"] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
         :keyword mtu: Maximum transmission unit. Default value is 1500.
         :paramtype mtu: int
-        :keyword connected_i_pv4_subnets: List of Connected IPv4 Subnets.
+        :keyword connected_i_pv4_subnets: List with object connected IPv4 Subnets.
         :paramtype connected_i_pv4_subnets:
          list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-        :keyword connected_i_pv6_subnets: List of connected IPv6 Subnets.
+        :keyword connected_i_pv6_subnets: List with object connected IPv6 Subnets.
         :paramtype connected_i_pv6_subnets:
          list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-        :keyword import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
-        :paramtype import_route_policy_id: str
-        :keyword export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
-        :paramtype export_route_policy_id: str
-        :keyword import_route_policy: Import Route Policy either IPv4 or IPv6.
-        :paramtype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-        :keyword export_route_policy: Export Route Policy either IPv4 or IPv6.
-        :paramtype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
-        :keyword ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-        :paramtype ingress_acl_id: str
-        :keyword egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-        :paramtype egress_acl_id: str
-        :keyword is_monitoring_enabled: To check whether monitoring of internal network is enabled or
-         not. Known values are: "True" and "False".
-        :paramtype is_monitoring_enabled: str or
-         ~azure.mgmt.managednetworkfabric.models.IsMonitoringEnabled
-        :keyword bgp_configuration: BGP configuration properties.
-        :paramtype bgp_configuration: ~azure.mgmt.managednetworkfabric.models.BgpConfiguration
         :keyword static_route_configuration: Static Route Configuration properties.
         :paramtype static_route_configuration:
          ~azure.mgmt.managednetworkfabric.models.StaticRouteConfiguration
+        :keyword bgp_configuration: BGP configuration properties.
+        :paramtype bgp_configuration: ~azure.mgmt.managednetworkfabric.models.BgpConfiguration
+        :keyword import_route_policy_id: ARM resource ID of importRoutePolicy.
+        :paramtype import_route_policy_id: str
+        :keyword export_route_policy_id: ARM resource ID of importRoutePolicy.
+        :paramtype export_route_policy_id: str
         """
         super().__init__(**kwargs)
         self.annotation = annotation
         self.mtu = mtu
         self.connected_i_pv4_subnets = connected_i_pv4_subnets
         self.connected_i_pv6_subnets = connected_i_pv6_subnets
+        self.static_route_configuration = static_route_configuration
+        self.bgp_configuration = bgp_configuration
         self.import_route_policy_id = import_route_policy_id
         self.export_route_policy_id = export_route_policy_id
-        self.import_route_policy = import_route_policy
-        self.export_route_policy = export_route_policy
-        self.ingress_acl_id = ingress_acl_id
-        self.egress_acl_id = egress_acl_id
-        self.is_monitoring_enabled = is_monitoring_enabled
-        self.bgp_configuration = bgp_configuration
-        self.static_route_configuration = static_route_configuration
 
 
 class InternalNetworkPatchableProperties(_serialization.Model):
-    """The InternalNetwork patchable properties.
+    """The ExternalNetwork patchable properties.
 
     :ivar mtu: Maximum transmission unit. Default value is 1500.
     :vartype mtu: int
-    :ivar connected_i_pv4_subnets: List of Connected IPv4 Subnets.
+    :ivar connected_i_pv4_subnets: List with object connected IPv4 Subnets.
     :vartype connected_i_pv4_subnets: list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-    :ivar connected_i_pv6_subnets: List of connected IPv6 Subnets.
+    :ivar connected_i_pv6_subnets: List with object connected IPv6 Subnets.
     :vartype connected_i_pv6_subnets: list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-    :ivar import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
+    :ivar static_route_configuration: Static Route Configuration properties.
+    :vartype static_route_configuration:
+     ~azure.mgmt.managednetworkfabric.models.StaticRouteConfiguration
+    :ivar bgp_configuration: BGP configuration properties.
+    :vartype bgp_configuration: ~azure.mgmt.managednetworkfabric.models.BgpConfiguration
+    :ivar import_route_policy_id: ARM resource ID of importRoutePolicy.
     :vartype import_route_policy_id: str
-    :ivar export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
+    :ivar export_route_policy_id: ARM resource ID of importRoutePolicy.
     :vartype export_route_policy_id: str
-    :ivar import_route_policy: Import Route Policy either IPv4 or IPv6.
-    :vartype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-    :ivar export_route_policy: Export Route Policy either IPv4 or IPv6.
-    :vartype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
-    :ivar ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-    :vartype ingress_acl_id: str
-    :ivar egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-    :vartype egress_acl_id: str
-    :ivar is_monitoring_enabled: To check whether monitoring of internal network is enabled or not.
-     Known values are: "True" and "False".
-    :vartype is_monitoring_enabled: str or
-     ~azure.mgmt.managednetworkfabric.models.IsMonitoringEnabled
     """
 
     _validation = {
-        "mtu": {"maximum": 9200, "minimum": 64},
-        "connected_i_pv4_subnets": {"min_items": 1},
-        "connected_i_pv6_subnets": {"min_items": 1},
+        "mtu": {"maximum": 9000, "minimum": 1500},
     }
 
     _attribute_map = {
         "mtu": {"key": "mtu", "type": "int"},
         "connected_i_pv4_subnets": {"key": "connectedIPv4Subnets", "type": "[ConnectedSubnet]"},
         "connected_i_pv6_subnets": {"key": "connectedIPv6Subnets", "type": "[ConnectedSubnet]"},
+        "static_route_configuration": {"key": "staticRouteConfiguration", "type": "StaticRouteConfiguration"},
+        "bgp_configuration": {"key": "bgpConfiguration", "type": "BgpConfiguration"},
         "import_route_policy_id": {"key": "importRoutePolicyId", "type": "str"},
         "export_route_policy_id": {"key": "exportRoutePolicyId", "type": "str"},
-        "import_route_policy": {"key": "importRoutePolicy", "type": "ImportRoutePolicy"},
-        "export_route_policy": {"key": "exportRoutePolicy", "type": "ExportRoutePolicy"},
-        "ingress_acl_id": {"key": "ingressAclId", "type": "str"},
-        "egress_acl_id": {"key": "egressAclId", "type": "str"},
-        "is_monitoring_enabled": {"key": "isMonitoringEnabled", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         mtu: int = 1500,
         connected_i_pv4_subnets: Optional[List["_models.ConnectedSubnet"]] = None,
         connected_i_pv6_subnets: Optional[List["_models.ConnectedSubnet"]] = None,
+        static_route_configuration: Optional["_models.StaticRouteConfiguration"] = None,
+        bgp_configuration: Optional["_models.BgpConfiguration"] = None,
         import_route_policy_id: Optional[str] = None,
         export_route_policy_id: Optional[str] = None,
-        import_route_policy: Optional["_models.ImportRoutePolicy"] = None,
-        export_route_policy: Optional["_models.ExportRoutePolicy"] = None,
-        ingress_acl_id: Optional[str] = None,
-        egress_acl_id: Optional[str] = None,
-        is_monitoring_enabled: Union[str, "_models.IsMonitoringEnabled"] = "False",
         **kwargs: Any
     ) -> None:
         """
         :keyword mtu: Maximum transmission unit. Default value is 1500.
         :paramtype mtu: int
-        :keyword connected_i_pv4_subnets: List of Connected IPv4 Subnets.
+        :keyword connected_i_pv4_subnets: List with object connected IPv4 Subnets.
         :paramtype connected_i_pv4_subnets:
          list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-        :keyword connected_i_pv6_subnets: List of connected IPv6 Subnets.
+        :keyword connected_i_pv6_subnets: List with object connected IPv6 Subnets.
         :paramtype connected_i_pv6_subnets:
          list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-        :keyword import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
+        :keyword static_route_configuration: Static Route Configuration properties.
+        :paramtype static_route_configuration:
+         ~azure.mgmt.managednetworkfabric.models.StaticRouteConfiguration
+        :keyword bgp_configuration: BGP configuration properties.
+        :paramtype bgp_configuration: ~azure.mgmt.managednetworkfabric.models.BgpConfiguration
+        :keyword import_route_policy_id: ARM resource ID of importRoutePolicy.
         :paramtype import_route_policy_id: str
-        :keyword export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
+        :keyword export_route_policy_id: ARM resource ID of importRoutePolicy.
         :paramtype export_route_policy_id: str
-        :keyword import_route_policy: Import Route Policy either IPv4 or IPv6.
-        :paramtype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-        :keyword export_route_policy: Export Route Policy either IPv4 or IPv6.
-        :paramtype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
-        :keyword ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-        :paramtype ingress_acl_id: str
-        :keyword egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-        :paramtype egress_acl_id: str
-        :keyword is_monitoring_enabled: To check whether monitoring of internal network is enabled or
-         not. Known values are: "True" and "False".
-        :paramtype is_monitoring_enabled: str or
-         ~azure.mgmt.managednetworkfabric.models.IsMonitoringEnabled
         """
         super().__init__(**kwargs)
         self.mtu = mtu
         self.connected_i_pv4_subnets = connected_i_pv4_subnets
         self.connected_i_pv6_subnets = connected_i_pv6_subnets
+        self.static_route_configuration = static_route_configuration
+        self.bgp_configuration = bgp_configuration
         self.import_route_policy_id = import_route_policy_id
         self.export_route_policy_id = export_route_policy_id
-        self.import_route_policy = import_route_policy
-        self.export_route_policy = export_route_policy
-        self.ingress_acl_id = ingress_acl_id
-        self.egress_acl_id = egress_acl_id
-        self.is_monitoring_enabled = is_monitoring_enabled
 
 
-class InternalNetworkPatchProperties(
-    AnnotationResource, InternalNetworkPatchableProperties
-):  # pylint: disable=too-many-instance-attributes
+class InternalNetworkPatchProperties(AnnotationResource, InternalNetworkPatchableProperties):
     """InternalNetwork Patch properties.
 
     :ivar mtu: Maximum transmission unit. Default value is 1500.
     :vartype mtu: int
-    :ivar connected_i_pv4_subnets: List of Connected IPv4 Subnets.
+    :ivar connected_i_pv4_subnets: List with object connected IPv4 Subnets.
     :vartype connected_i_pv4_subnets: list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-    :ivar connected_i_pv6_subnets: List of connected IPv6 Subnets.
+    :ivar connected_i_pv6_subnets: List with object connected IPv6 Subnets.
     :vartype connected_i_pv6_subnets: list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-    :ivar import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
+    :ivar static_route_configuration: Static Route Configuration properties.
+    :vartype static_route_configuration:
+     ~azure.mgmt.managednetworkfabric.models.StaticRouteConfiguration
+    :ivar bgp_configuration: BGP configuration properties.
+    :vartype bgp_configuration: ~azure.mgmt.managednetworkfabric.models.BgpConfiguration
+    :ivar import_route_policy_id: ARM resource ID of importRoutePolicy.
     :vartype import_route_policy_id: str
-    :ivar export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
+    :ivar export_route_policy_id: ARM resource ID of importRoutePolicy.
     :vartype export_route_policy_id: str
-    :ivar import_route_policy: Import Route Policy either IPv4 or IPv6.
-    :vartype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-    :ivar export_route_policy: Export Route Policy either IPv4 or IPv6.
-    :vartype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
-    :ivar ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-    :vartype ingress_acl_id: str
-    :ivar egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-    :vartype egress_acl_id: str
-    :ivar is_monitoring_enabled: To check whether monitoring of internal network is enabled or not.
-     Known values are: "True" and "False".
-    :vartype is_monitoring_enabled: str or
-     ~azure.mgmt.managednetworkfabric.models.IsMonitoringEnabled
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar bgp_configuration: BGP configuration properties.
-    :vartype bgp_configuration: ~azure.mgmt.managednetworkfabric.models.BgpConfiguration
-    :ivar static_route_configuration: Static Route Configuration properties.
-    :vartype static_route_configuration:
-     ~azure.mgmt.managednetworkfabric.models.StaticRouteConfiguration
     """
 
     _validation = {
-        "mtu": {"maximum": 9200, "minimum": 64},
-        "connected_i_pv4_subnets": {"min_items": 1},
-        "connected_i_pv6_subnets": {"min_items": 1},
+        "mtu": {"maximum": 9000, "minimum": 1500},
     }
 
     _attribute_map = {
         "mtu": {"key": "mtu", "type": "int"},
         "connected_i_pv4_subnets": {"key": "connectedIPv4Subnets", "type": "[ConnectedSubnet]"},
         "connected_i_pv6_subnets": {"key": "connectedIPv6Subnets", "type": "[ConnectedSubnet]"},
+        "static_route_configuration": {"key": "staticRouteConfiguration", "type": "StaticRouteConfiguration"},
+        "bgp_configuration": {"key": "bgpConfiguration", "type": "BgpConfiguration"},
         "import_route_policy_id": {"key": "importRoutePolicyId", "type": "str"},
         "export_route_policy_id": {"key": "exportRoutePolicyId", "type": "str"},
-        "import_route_policy": {"key": "importRoutePolicy", "type": "ImportRoutePolicy"},
-        "export_route_policy": {"key": "exportRoutePolicy", "type": "ExportRoutePolicy"},
-        "ingress_acl_id": {"key": "ingressAclId", "type": "str"},
-        "egress_acl_id": {"key": "egressAclId", "type": "str"},
-        "is_monitoring_enabled": {"key": "isMonitoringEnabled", "type": "str"},
         "annotation": {"key": "annotation", "type": "str"},
-        "bgp_configuration": {"key": "bgpConfiguration", "type": "BgpConfiguration"},
-        "static_route_configuration": {"key": "staticRouteConfiguration", "type": "StaticRouteConfiguration"},
     }
 
     def __init__(
         self,
         *,
         mtu: int = 1500,
         connected_i_pv4_subnets: Optional[List["_models.ConnectedSubnet"]] = None,
         connected_i_pv6_subnets: Optional[List["_models.ConnectedSubnet"]] = None,
+        static_route_configuration: Optional["_models.StaticRouteConfiguration"] = None,
+        bgp_configuration: Optional["_models.BgpConfiguration"] = None,
         import_route_policy_id: Optional[str] = None,
         export_route_policy_id: Optional[str] = None,
-        import_route_policy: Optional["_models.ImportRoutePolicy"] = None,
-        export_route_policy: Optional["_models.ExportRoutePolicy"] = None,
-        ingress_acl_id: Optional[str] = None,
-        egress_acl_id: Optional[str] = None,
-        is_monitoring_enabled: Union[str, "_models.IsMonitoringEnabled"] = "False",
         annotation: Optional[str] = None,
-        bgp_configuration: Optional["_models.BgpConfiguration"] = None,
-        static_route_configuration: Optional["_models.StaticRouteConfiguration"] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword mtu: Maximum transmission unit. Default value is 1500.
         :paramtype mtu: int
-        :keyword connected_i_pv4_subnets: List of Connected IPv4 Subnets.
+        :keyword connected_i_pv4_subnets: List with object connected IPv4 Subnets.
         :paramtype connected_i_pv4_subnets:
          list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-        :keyword connected_i_pv6_subnets: List of connected IPv6 Subnets.
+        :keyword connected_i_pv6_subnets: List with object connected IPv6 Subnets.
         :paramtype connected_i_pv6_subnets:
          list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-        :keyword import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
+        :keyword static_route_configuration: Static Route Configuration properties.
+        :paramtype static_route_configuration:
+         ~azure.mgmt.managednetworkfabric.models.StaticRouteConfiguration
+        :keyword bgp_configuration: BGP configuration properties.
+        :paramtype bgp_configuration: ~azure.mgmt.managednetworkfabric.models.BgpConfiguration
+        :keyword import_route_policy_id: ARM resource ID of importRoutePolicy.
         :paramtype import_route_policy_id: str
-        :keyword export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
+        :keyword export_route_policy_id: ARM resource ID of importRoutePolicy.
         :paramtype export_route_policy_id: str
-        :keyword import_route_policy: Import Route Policy either IPv4 or IPv6.
-        :paramtype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-        :keyword export_route_policy: Export Route Policy either IPv4 or IPv6.
-        :paramtype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
-        :keyword ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-        :paramtype ingress_acl_id: str
-        :keyword egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-        :paramtype egress_acl_id: str
-        :keyword is_monitoring_enabled: To check whether monitoring of internal network is enabled or
-         not. Known values are: "True" and "False".
-        :paramtype is_monitoring_enabled: str or
-         ~azure.mgmt.managednetworkfabric.models.IsMonitoringEnabled
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword bgp_configuration: BGP configuration properties.
-        :paramtype bgp_configuration: ~azure.mgmt.managednetworkfabric.models.BgpConfiguration
-        :keyword static_route_configuration: Static Route Configuration properties.
-        :paramtype static_route_configuration:
-         ~azure.mgmt.managednetworkfabric.models.StaticRouteConfiguration
         """
         super().__init__(
             annotation=annotation,
             mtu=mtu,
             connected_i_pv4_subnets=connected_i_pv4_subnets,
             connected_i_pv6_subnets=connected_i_pv6_subnets,
+            static_route_configuration=static_route_configuration,
+            bgp_configuration=bgp_configuration,
             import_route_policy_id=import_route_policy_id,
             export_route_policy_id=export_route_policy_id,
-            import_route_policy=import_route_policy,
-            export_route_policy=export_route_policy,
-            ingress_acl_id=ingress_acl_id,
-            egress_acl_id=egress_acl_id,
-            is_monitoring_enabled=is_monitoring_enabled,
             **kwargs
         )
         self.mtu = mtu
         self.connected_i_pv4_subnets = connected_i_pv4_subnets
         self.connected_i_pv6_subnets = connected_i_pv6_subnets
+        self.static_route_configuration = static_route_configuration
+        self.bgp_configuration = bgp_configuration
         self.import_route_policy_id = import_route_policy_id
         self.export_route_policy_id = export_route_policy_id
-        self.import_route_policy = import_route_policy
-        self.export_route_policy = export_route_policy
-        self.ingress_acl_id = ingress_acl_id
-        self.egress_acl_id = egress_acl_id
-        self.is_monitoring_enabled = is_monitoring_enabled
-        self.bgp_configuration = bgp_configuration
-        self.static_route_configuration = static_route_configuration
         self.annotation = annotation
 
 
 class InternalNetworkProperties(
-    AnnotationResource, InternalNetworkPatchableProperties, ExtensionEnumProperty
+    AnnotationResource, InternalNetworkPatchableProperties
 ):  # pylint: disable=too-many-instance-attributes
-    """Internal Network Properties defines the properties of the resource.
+    """Internal Network Properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar extension: Extension. Example: NoExtension | NPB. Known values are: "NoExtension" and
-     "NPB".
-    :vartype extension: str or ~azure.mgmt.managednetworkfabric.models.Extension
     :ivar mtu: Maximum transmission unit. Default value is 1500.
     :vartype mtu: int
-    :ivar connected_i_pv4_subnets: List of Connected IPv4 Subnets.
+    :ivar connected_i_pv4_subnets: List with object connected IPv4 Subnets.
     :vartype connected_i_pv4_subnets: list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-    :ivar connected_i_pv6_subnets: List of connected IPv6 Subnets.
+    :ivar connected_i_pv6_subnets: List with object connected IPv6 Subnets.
     :vartype connected_i_pv6_subnets: list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-    :ivar import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
+    :ivar static_route_configuration: Static Route Configuration properties.
+    :vartype static_route_configuration:
+     ~azure.mgmt.managednetworkfabric.models.StaticRouteConfiguration
+    :ivar bgp_configuration: BGP configuration properties.
+    :vartype bgp_configuration: ~azure.mgmt.managednetworkfabric.models.BgpConfiguration
+    :ivar import_route_policy_id: ARM resource ID of importRoutePolicy.
     :vartype import_route_policy_id: str
-    :ivar export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the backward
-     compatibility.
+    :ivar export_route_policy_id: ARM resource ID of importRoutePolicy.
     :vartype export_route_policy_id: str
-    :ivar import_route_policy: Import Route Policy either IPv4 or IPv6.
-    :vartype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-    :ivar export_route_policy: Export Route Policy either IPv4 or IPv6.
-    :vartype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
-    :ivar ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-    :vartype ingress_acl_id: str
-    :ivar egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-    :vartype egress_acl_id: str
-    :ivar is_monitoring_enabled: To check whether monitoring of internal network is enabled or not.
-     Known values are: "True" and "False".
-    :vartype is_monitoring_enabled: str or
-     ~azure.mgmt.managednetworkfabric.models.IsMonitoringEnabled
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
+    :ivar disabled_on_resources: List of resources the InternalNetwork is disabled on. Can be
+     either entire NetworkFabric or NetworkRack.
+    :vartype disabled_on_resources: list[str]
+    :ivar administrative_state: Administrative state of the InternalNetwork. Example: Enabled |
+     Disabled. Known values are: "Enabled" and "Disabled".
+    :vartype administrative_state: str or
+     ~azure.mgmt.managednetworkfabric.models.EnabledDisabledState
+    :ivar bgp_disabled_on_resources: List of resources the BGP is disabled on. Can be either entire
+     NetworkFabric or NetworkRack.
+    :vartype bgp_disabled_on_resources: list[str]
+    :ivar bfd_disabled_on_resources: List of resources the BFD for BGP is disabled on. Can be
+     either entire NetworkFabric or NetworkRack.
+    :vartype bfd_disabled_on_resources: list[str]
+    :ivar bfd_for_static_routes_disabled_on_resources: List of resources the BFD of StaticRoutes is
+     disabled on. Can be either entire NetworkFabric or NetworkRack.
+    :vartype bfd_for_static_routes_disabled_on_resources: list[str]
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
+    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
     :ivar vlan_id: Vlan identifier. Example: 1001. Required.
     :vartype vlan_id: int
-    :ivar bgp_configuration: BGP configuration properties.
-    :vartype bgp_configuration:
-     ~azure.mgmt.managednetworkfabric.models.InternalNetworkPropertiesBgpConfiguration
-    :ivar static_route_configuration: Static Route Configuration properties.
-    :vartype static_route_configuration:
-     ~azure.mgmt.managednetworkfabric.models.InternalNetworkPropertiesStaticRouteConfiguration
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
-        "mtu": {"maximum": 9200, "minimum": 64},
-        "connected_i_pv4_subnets": {"min_items": 1},
-        "connected_i_pv6_subnets": {"min_items": 1},
-        "vlan_id": {"required": True, "maximum": 4094, "minimum": 100},
-        "configuration_state": {"readonly": True},
-        "provisioning_state": {"readonly": True},
+        "mtu": {"maximum": 9000, "minimum": 1500},
+        "disabled_on_resources": {"readonly": True},
         "administrative_state": {"readonly": True},
+        "bgp_disabled_on_resources": {"readonly": True},
+        "bfd_disabled_on_resources": {"readonly": True},
+        "bfd_for_static_routes_disabled_on_resources": {"readonly": True},
+        "provisioning_state": {"readonly": True},
+        "vlan_id": {"required": True, "maximum": 4095, "minimum": 100},
     }
 
     _attribute_map = {
-        "extension": {"key": "extension", "type": "str"},
         "mtu": {"key": "mtu", "type": "int"},
         "connected_i_pv4_subnets": {"key": "connectedIPv4Subnets", "type": "[ConnectedSubnet]"},
         "connected_i_pv6_subnets": {"key": "connectedIPv6Subnets", "type": "[ConnectedSubnet]"},
+        "static_route_configuration": {"key": "staticRouteConfiguration", "type": "StaticRouteConfiguration"},
+        "bgp_configuration": {"key": "bgpConfiguration", "type": "BgpConfiguration"},
         "import_route_policy_id": {"key": "importRoutePolicyId", "type": "str"},
         "export_route_policy_id": {"key": "exportRoutePolicyId", "type": "str"},
-        "import_route_policy": {"key": "importRoutePolicy", "type": "ImportRoutePolicy"},
-        "export_route_policy": {"key": "exportRoutePolicy", "type": "ExportRoutePolicy"},
-        "ingress_acl_id": {"key": "ingressAclId", "type": "str"},
-        "egress_acl_id": {"key": "egressAclId", "type": "str"},
-        "is_monitoring_enabled": {"key": "isMonitoringEnabled", "type": "str"},
         "annotation": {"key": "annotation", "type": "str"},
-        "vlan_id": {"key": "vlanId", "type": "int"},
-        "bgp_configuration": {"key": "bgpConfiguration", "type": "InternalNetworkPropertiesBgpConfiguration"},
-        "static_route_configuration": {
-            "key": "staticRouteConfiguration",
-            "type": "InternalNetworkPropertiesStaticRouteConfiguration",
+        "disabled_on_resources": {"key": "disabledOnResources", "type": "[str]"},
+        "administrative_state": {"key": "administrativeState", "type": "str"},
+        "bgp_disabled_on_resources": {"key": "bgpDisabledOnResources", "type": "[str]"},
+        "bfd_disabled_on_resources": {"key": "bfdDisabledOnResources", "type": "[str]"},
+        "bfd_for_static_routes_disabled_on_resources": {
+            "key": "bfdForStaticRoutesDisabledOnResources",
+            "type": "[str]",
         },
-        "configuration_state": {"key": "configurationState", "type": "str"},
         "provisioning_state": {"key": "provisioningState", "type": "str"},
-        "administrative_state": {"key": "administrativeState", "type": "str"},
+        "vlan_id": {"key": "vlanId", "type": "int"},
     }
 
     def __init__(
         self,
         *,
         vlan_id: int,
-        extension: Union[str, "_models.Extension"] = "NoExtension",
         mtu: int = 1500,
         connected_i_pv4_subnets: Optional[List["_models.ConnectedSubnet"]] = None,
         connected_i_pv6_subnets: Optional[List["_models.ConnectedSubnet"]] = None,
+        static_route_configuration: Optional["_models.StaticRouteConfiguration"] = None,
+        bgp_configuration: Optional["_models.BgpConfiguration"] = None,
         import_route_policy_id: Optional[str] = None,
         export_route_policy_id: Optional[str] = None,
-        import_route_policy: Optional["_models.ImportRoutePolicy"] = None,
-        export_route_policy: Optional["_models.ExportRoutePolicy"] = None,
-        ingress_acl_id: Optional[str] = None,
-        egress_acl_id: Optional[str] = None,
-        is_monitoring_enabled: Union[str, "_models.IsMonitoringEnabled"] = "False",
         annotation: Optional[str] = None,
-        bgp_configuration: Optional["_models.InternalNetworkPropertiesBgpConfiguration"] = None,
-        static_route_configuration: Optional["_models.InternalNetworkPropertiesStaticRouteConfiguration"] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword extension: Extension. Example: NoExtension | NPB. Known values are: "NoExtension" and
-         "NPB".
-        :paramtype extension: str or ~azure.mgmt.managednetworkfabric.models.Extension
         :keyword mtu: Maximum transmission unit. Default value is 1500.
         :paramtype mtu: int
-        :keyword connected_i_pv4_subnets: List of Connected IPv4 Subnets.
+        :keyword connected_i_pv4_subnets: List with object connected IPv4 Subnets.
         :paramtype connected_i_pv4_subnets:
          list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-        :keyword connected_i_pv6_subnets: List of connected IPv6 Subnets.
+        :keyword connected_i_pv6_subnets: List with object connected IPv6 Subnets.
         :paramtype connected_i_pv6_subnets:
          list[~azure.mgmt.managednetworkfabric.models.ConnectedSubnet]
-        :keyword import_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
+        :keyword static_route_configuration: Static Route Configuration properties.
+        :paramtype static_route_configuration:
+         ~azure.mgmt.managednetworkfabric.models.StaticRouteConfiguration
+        :keyword bgp_configuration: BGP configuration properties.
+        :paramtype bgp_configuration: ~azure.mgmt.managednetworkfabric.models.BgpConfiguration
+        :keyword import_route_policy_id: ARM resource ID of importRoutePolicy.
         :paramtype import_route_policy_id: str
-        :keyword export_route_policy_id: ARM Resource ID of the RoutePolicy. This is used for the
-         backward compatibility.
+        :keyword export_route_policy_id: ARM resource ID of importRoutePolicy.
         :paramtype export_route_policy_id: str
-        :keyword import_route_policy: Import Route Policy either IPv4 or IPv6.
-        :paramtype import_route_policy: ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicy
-        :keyword export_route_policy: Export Route Policy either IPv4 or IPv6.
-        :paramtype export_route_policy: ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicy
-        :keyword ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-        :paramtype ingress_acl_id: str
-        :keyword egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-        :paramtype egress_acl_id: str
-        :keyword is_monitoring_enabled: To check whether monitoring of internal network is enabled or
-         not. Known values are: "True" and "False".
-        :paramtype is_monitoring_enabled: str or
-         ~azure.mgmt.managednetworkfabric.models.IsMonitoringEnabled
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
         :keyword vlan_id: Vlan identifier. Example: 1001. Required.
         :paramtype vlan_id: int
-        :keyword bgp_configuration: BGP configuration properties.
-        :paramtype bgp_configuration:
-         ~azure.mgmt.managednetworkfabric.models.InternalNetworkPropertiesBgpConfiguration
-        :keyword static_route_configuration: Static Route Configuration properties.
-        :paramtype static_route_configuration:
-         ~azure.mgmt.managednetworkfabric.models.InternalNetworkPropertiesStaticRouteConfiguration
         """
         super().__init__(
             annotation=annotation,
             mtu=mtu,
             connected_i_pv4_subnets=connected_i_pv4_subnets,
             connected_i_pv6_subnets=connected_i_pv6_subnets,
+            static_route_configuration=static_route_configuration,
+            bgp_configuration=bgp_configuration,
             import_route_policy_id=import_route_policy_id,
             export_route_policy_id=export_route_policy_id,
-            import_route_policy=import_route_policy,
-            export_route_policy=export_route_policy,
-            ingress_acl_id=ingress_acl_id,
-            egress_acl_id=egress_acl_id,
-            is_monitoring_enabled=is_monitoring_enabled,
-            extension=extension,
             **kwargs
         )
-        self.extension = extension
         self.mtu = mtu
         self.connected_i_pv4_subnets = connected_i_pv4_subnets
         self.connected_i_pv6_subnets = connected_i_pv6_subnets
+        self.static_route_configuration = static_route_configuration
+        self.bgp_configuration = bgp_configuration
         self.import_route_policy_id = import_route_policy_id
         self.export_route_policy_id = export_route_policy_id
-        self.import_route_policy = import_route_policy
-        self.export_route_policy = export_route_policy
-        self.ingress_acl_id = ingress_acl_id
-        self.egress_acl_id = egress_acl_id
-        self.is_monitoring_enabled = is_monitoring_enabled
-        self.vlan_id = vlan_id
-        self.bgp_configuration = bgp_configuration
-        self.static_route_configuration = static_route_configuration
-        self.configuration_state = None
-        self.provisioning_state = None
+        self.disabled_on_resources = None
         self.administrative_state = None
+        self.bgp_disabled_on_resources = None
+        self.bfd_disabled_on_resources = None
+        self.bfd_for_static_routes_disabled_on_resources = None
+        self.provisioning_state = None
+        self.vlan_id = vlan_id
         self.annotation = annotation
 
 
-class InternalNetworkPropertiesBgpConfiguration(BgpConfiguration):  # pylint: disable=too-many-instance-attributes
-    """BGP configuration properties.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar bfd_configuration: BFD configuration properties.
-    :vartype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
-    :ivar default_route_originate: Originate a defaultRoute. Ex: "True" | "False". Known values
-     are: "True" and "False".
-    :vartype default_route_originate: str or
-     ~azure.mgmt.managednetworkfabric.models.BooleanEnumProperty
-    :ivar allow_as: Allows for routes to be received and processed even if the router detects its
-     own ASN in the AS-Path. 0 is disable, Possible values are 1-10, default is 2.
-    :vartype allow_as: int
-    :ivar allow_as_override: Enable Or Disable state. Known values are: "Enable" and "Disable".
-    :vartype allow_as_override: str or ~azure.mgmt.managednetworkfabric.models.AllowASOverride
-    :ivar fabric_asn: ASN of Network Fabric. Example: 65048.
-    :vartype fabric_asn: int
-    :ivar peer_asn: Peer ASN. Example: 65047.
-    :vartype peer_asn: int
-    :ivar ipv4_listen_range_prefixes: List of BGP IPv4 Listen Range prefixes.
-    :vartype ipv4_listen_range_prefixes: list[str]
-    :ivar ipv6_listen_range_prefixes: List of BGP IPv6 Listen Ranges prefixes.
-    :vartype ipv6_listen_range_prefixes: list[str]
-    :ivar ipv4_neighbor_address: List with stringified IPv4 Neighbor Addresses.
-    :vartype ipv4_neighbor_address: list[~azure.mgmt.managednetworkfabric.models.NeighborAddress]
-    :ivar ipv6_neighbor_address: List with stringified IPv6 Neighbor Address.
-    :vartype ipv6_neighbor_address: list[~azure.mgmt.managednetworkfabric.models.NeighborAddress]
-    """
-
-    _validation = {
-        "allow_as": {"maximum": 10, "minimum": 0},
-        "fabric_asn": {"readonly": True},
-        "peer_asn": {"maximum": 4294967295, "minimum": 1},
-        "ipv4_listen_range_prefixes": {"min_items": 1},
-        "ipv6_listen_range_prefixes": {"min_items": 1},
-        "ipv4_neighbor_address": {"min_items": 1},
-        "ipv6_neighbor_address": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "annotation": {"key": "annotation", "type": "str"},
-        "bfd_configuration": {"key": "bfdConfiguration", "type": "BfdConfiguration"},
-        "default_route_originate": {"key": "defaultRouteOriginate", "type": "str"},
-        "allow_as": {"key": "allowAS", "type": "int"},
-        "allow_as_override": {"key": "allowASOverride", "type": "str"},
-        "fabric_asn": {"key": "fabricASN", "type": "int"},
-        "peer_asn": {"key": "peerASN", "type": "int"},
-        "ipv4_listen_range_prefixes": {"key": "ipv4ListenRangePrefixes", "type": "[str]"},
-        "ipv6_listen_range_prefixes": {"key": "ipv6ListenRangePrefixes", "type": "[str]"},
-        "ipv4_neighbor_address": {"key": "ipv4NeighborAddress", "type": "[NeighborAddress]"},
-        "ipv6_neighbor_address": {"key": "ipv6NeighborAddress", "type": "[NeighborAddress]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        annotation: Optional[str] = None,
-        bfd_configuration: Optional["_models.BfdConfiguration"] = None,
-        default_route_originate: Optional[Union[str, "_models.BooleanEnumProperty"]] = None,
-        allow_as: int = 2,
-        allow_as_override: Optional[Union[str, "_models.AllowASOverride"]] = None,
-        peer_asn: Optional[int] = None,
-        ipv4_listen_range_prefixes: Optional[List[str]] = None,
-        ipv6_listen_range_prefixes: Optional[List[str]] = None,
-        ipv4_neighbor_address: Optional[List["_models.NeighborAddress"]] = None,
-        ipv6_neighbor_address: Optional[List["_models.NeighborAddress"]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword bfd_configuration: BFD configuration properties.
-        :paramtype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
-        :keyword default_route_originate: Originate a defaultRoute. Ex: "True" | "False". Known values
-         are: "True" and "False".
-        :paramtype default_route_originate: str or
-         ~azure.mgmt.managednetworkfabric.models.BooleanEnumProperty
-        :keyword allow_as: Allows for routes to be received and processed even if the router detects
-         its own ASN in the AS-Path. 0 is disable, Possible values are 1-10, default is 2.
-        :paramtype allow_as: int
-        :keyword allow_as_override: Enable Or Disable state. Known values are: "Enable" and "Disable".
-        :paramtype allow_as_override: str or ~azure.mgmt.managednetworkfabric.models.AllowASOverride
-        :keyword peer_asn: Peer ASN. Example: 65047.
-        :paramtype peer_asn: int
-        :keyword ipv4_listen_range_prefixes: List of BGP IPv4 Listen Range prefixes.
-        :paramtype ipv4_listen_range_prefixes: list[str]
-        :keyword ipv6_listen_range_prefixes: List of BGP IPv6 Listen Ranges prefixes.
-        :paramtype ipv6_listen_range_prefixes: list[str]
-        :keyword ipv4_neighbor_address: List with stringified IPv4 Neighbor Addresses.
-        :paramtype ipv4_neighbor_address: list[~azure.mgmt.managednetworkfabric.models.NeighborAddress]
-        :keyword ipv6_neighbor_address: List with stringified IPv6 Neighbor Address.
-        :paramtype ipv6_neighbor_address: list[~azure.mgmt.managednetworkfabric.models.NeighborAddress]
-        """
-        super().__init__(
-            annotation=annotation,
-            bfd_configuration=bfd_configuration,
-            default_route_originate=default_route_originate,
-            allow_as=allow_as,
-            allow_as_override=allow_as_override,
-            peer_asn=peer_asn,
-            ipv4_listen_range_prefixes=ipv4_listen_range_prefixes,
-            ipv6_listen_range_prefixes=ipv6_listen_range_prefixes,
-            ipv4_neighbor_address=ipv4_neighbor_address,
-            ipv6_neighbor_address=ipv6_neighbor_address,
-            **kwargs
-        )
-
-
-class StaticRouteConfiguration(_serialization.Model):
-    """Static Route Configuration properties.
-
-    :ivar bfd_configuration: BFD configuration properties.
-    :vartype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
-    :ivar ipv4_routes: List of IPv4 Routes.
-    :vartype ipv4_routes: list[~azure.mgmt.managednetworkfabric.models.StaticRouteProperties]
-    :ivar ipv6_routes: List of IPv6 Routes.
-    :vartype ipv6_routes: list[~azure.mgmt.managednetworkfabric.models.StaticRouteProperties]
-    """
-
-    _validation = {
-        "ipv4_routes": {"min_items": 1},
-        "ipv6_routes": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "bfd_configuration": {"key": "bfdConfiguration", "type": "BfdConfiguration"},
-        "ipv4_routes": {"key": "ipv4Routes", "type": "[StaticRouteProperties]"},
-        "ipv6_routes": {"key": "ipv6Routes", "type": "[StaticRouteProperties]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        bfd_configuration: Optional["_models.BfdConfiguration"] = None,
-        ipv4_routes: Optional[List["_models.StaticRouteProperties"]] = None,
-        ipv6_routes: Optional[List["_models.StaticRouteProperties"]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword bfd_configuration: BFD configuration properties.
-        :paramtype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
-        :keyword ipv4_routes: List of IPv4 Routes.
-        :paramtype ipv4_routes: list[~azure.mgmt.managednetworkfabric.models.StaticRouteProperties]
-        :keyword ipv6_routes: List of IPv6 Routes.
-        :paramtype ipv6_routes: list[~azure.mgmt.managednetworkfabric.models.StaticRouteProperties]
-        """
-        super().__init__(**kwargs)
-        self.bfd_configuration = bfd_configuration
-        self.ipv4_routes = ipv4_routes
-        self.ipv6_routes = ipv6_routes
-
-
-class InternalNetworkPropertiesStaticRouteConfiguration(StaticRouteConfiguration, ExtensionEnumProperty):
-    """Static Route Configuration properties.
-
-    :ivar extension: Extension. Example: NoExtension | NPB. Known values are: "NoExtension" and
-     "NPB".
-    :vartype extension: str or ~azure.mgmt.managednetworkfabric.models.Extension
-    :ivar bfd_configuration: BFD configuration properties.
-    :vartype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
-    :ivar ipv4_routes: List of IPv4 Routes.
-    :vartype ipv4_routes: list[~azure.mgmt.managednetworkfabric.models.StaticRouteProperties]
-    :ivar ipv6_routes: List of IPv6 Routes.
-    :vartype ipv6_routes: list[~azure.mgmt.managednetworkfabric.models.StaticRouteProperties]
-    """
-
-    _validation = {
-        "ipv4_routes": {"min_items": 1},
-        "ipv6_routes": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "extension": {"key": "extension", "type": "str"},
-        "bfd_configuration": {"key": "bfdConfiguration", "type": "BfdConfiguration"},
-        "ipv4_routes": {"key": "ipv4Routes", "type": "[StaticRouteProperties]"},
-        "ipv6_routes": {"key": "ipv6Routes", "type": "[StaticRouteProperties]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        extension: Union[str, "_models.Extension"] = "NoExtension",
-        bfd_configuration: Optional["_models.BfdConfiguration"] = None,
-        ipv4_routes: Optional[List["_models.StaticRouteProperties"]] = None,
-        ipv6_routes: Optional[List["_models.StaticRouteProperties"]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword extension: Extension. Example: NoExtension | NPB. Known values are: "NoExtension" and
-         "NPB".
-        :paramtype extension: str or ~azure.mgmt.managednetworkfabric.models.Extension
-        :keyword bfd_configuration: BFD configuration properties.
-        :paramtype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
-        :keyword ipv4_routes: List of IPv4 Routes.
-        :paramtype ipv4_routes: list[~azure.mgmt.managednetworkfabric.models.StaticRouteProperties]
-        :keyword ipv6_routes: List of IPv6 Routes.
-        :paramtype ipv6_routes: list[~azure.mgmt.managednetworkfabric.models.StaticRouteProperties]
-        """
-        super().__init__(
-            bfd_configuration=bfd_configuration,
-            ipv4_routes=ipv4_routes,
-            ipv6_routes=ipv6_routes,
-            extension=extension,
-            **kwargs
-        )
-        self.extension = extension
-        self.bfd_configuration = bfd_configuration
-        self.ipv4_routes = ipv4_routes
-        self.ipv6_routes = ipv6_routes
-
-
 class InternalNetworksList(_serialization.Model):
-    """List of Internal Networks.
+    """List of InternalNetworks.
 
-    :ivar value: List of Internal Network resources.
+    :ivar value: List of InternalNetworks resources.
     :vartype value: list[~azure.mgmt.managednetworkfabric.models.InternalNetwork]
     :ivar next_link: Url to follow for getting next page of resources.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[InternalNetwork]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
     def __init__(
         self, *, value: Optional[List["_models.InternalNetwork"]] = None, next_link: Optional[str] = None, **kwargs: Any
     ) -> None:
         """
-        :keyword value: List of Internal Network resources.
+        :keyword value: List of InternalNetworks resources.
         :paramtype value: list[~azure.mgmt.managednetworkfabric.models.InternalNetwork]
         :keyword next_link: Url to follow for getting next page of resources.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
-class InternetGateway(TrackedResource):  # pylint: disable=too-many-instance-attributes
-    """The Internet Gateway resource definition.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
-    :vartype id: str
-    :ivar name: The name of the resource.
-    :vartype name: str
-    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
-     "Microsoft.Storage/storageAccounts".
-    :vartype type: str
-    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
-     information.
-    :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
-    :ivar location: The geo-location where the resource lives. Required.
-    :vartype location: str
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar internet_gateway_rule_id: ARM Resource ID of the Internet Gateway Rule.
-    :vartype internet_gateway_rule_id: str
-    :ivar ipv4_address: IPv4 Address of Internet Gateway.
-    :vartype ipv4_address: str
-    :ivar port: Port number of Internet Gateway.
-    :vartype port: int
-    :ivar type_properties_type: Gateway Type of the resource. Required. Known values are:
-     "Infrastructure" and "Workload".
-    :vartype type_properties_type: str or ~azure.mgmt.managednetworkfabric.models.GatewayType
-    :ivar network_fabric_controller_id: ARM Resource ID of the Network Fabric Controller. Required.
-    :vartype network_fabric_controller_id: str
-    :ivar provisioning_state: Provisioning state of resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    """
-
-    _validation = {
-        "id": {"readonly": True},
-        "name": {"readonly": True},
-        "type": {"readonly": True},
-        "system_data": {"readonly": True},
-        "location": {"required": True},
-        "ipv4_address": {"readonly": True},
-        "port": {"readonly": True},
-        "type_properties_type": {"required": True},
-        "network_fabric_controller_id": {"required": True},
-        "provisioning_state": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "id": {"key": "id", "type": "str"},
-        "name": {"key": "name", "type": "str"},
-        "type": {"key": "type", "type": "str"},
-        "system_data": {"key": "systemData", "type": "SystemData"},
-        "tags": {"key": "tags", "type": "{str}"},
-        "location": {"key": "location", "type": "str"},
-        "annotation": {"key": "properties.annotation", "type": "str"},
-        "internet_gateway_rule_id": {"key": "properties.internetGatewayRuleId", "type": "str"},
-        "ipv4_address": {"key": "properties.ipv4Address", "type": "str"},
-        "port": {"key": "properties.port", "type": "int"},
-        "type_properties_type": {"key": "properties.type", "type": "str"},
-        "network_fabric_controller_id": {"key": "properties.networkFabricControllerId", "type": "str"},
-        "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        location: str,
-        type_properties_type: Union[str, "_models.GatewayType"],
-        network_fabric_controller_id: str,
-        tags: Optional[Dict[str, str]] = None,
-        annotation: Optional[str] = None,
-        internet_gateway_rule_id: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
-        :keyword location: The geo-location where the resource lives. Required.
-        :paramtype location: str
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword internet_gateway_rule_id: ARM Resource ID of the Internet Gateway Rule.
-        :paramtype internet_gateway_rule_id: str
-        :keyword type_properties_type: Gateway Type of the resource. Required. Known values are:
-         "Infrastructure" and "Workload".
-        :paramtype type_properties_type: str or ~azure.mgmt.managednetworkfabric.models.GatewayType
-        :keyword network_fabric_controller_id: ARM Resource ID of the Network Fabric Controller.
-         Required.
-        :paramtype network_fabric_controller_id: str
-        """
-        super().__init__(tags=tags, location=location, **kwargs)
-        self.annotation = annotation
-        self.internet_gateway_rule_id = internet_gateway_rule_id
-        self.ipv4_address = None
-        self.port = None
-        self.type_properties_type = type_properties_type
-        self.network_fabric_controller_id = network_fabric_controller_id
-        self.provisioning_state = None
-
-
-class InternetGatewayPatch(TagsUpdate):
-    """The Internet Gateway patch resource definition.
-
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
-    :ivar internet_gateway_rule_id: ARM Resource ID of the Internet Gateway Rule.
-    :vartype internet_gateway_rule_id: str
-    """
-
-    _attribute_map = {
-        "tags": {"key": "tags", "type": "{str}"},
-        "internet_gateway_rule_id": {"key": "properties.internetGatewayRuleId", "type": "str"},
-    }
-
-    def __init__(
-        self, *, tags: Optional[Dict[str, str]] = None, internet_gateway_rule_id: Optional[str] = None, **kwargs: Any
-    ) -> None:
-        """
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
-        :keyword internet_gateway_rule_id: ARM Resource ID of the Internet Gateway Rule.
-        :paramtype internet_gateway_rule_id: str
-        """
-        super().__init__(tags=tags, **kwargs)
-        self.internet_gateway_rule_id = internet_gateway_rule_id
-
-
-class InternetGatewayPatchableProperties(_serialization.Model):
-    """Internet Gateway Patchable Properties defines the patchable properties of the resource.
-
-    :ivar internet_gateway_rule_id: ARM Resource ID of the Internet Gateway Rule.
-    :vartype internet_gateway_rule_id: str
-    """
-
-    _attribute_map = {
-        "internet_gateway_rule_id": {"key": "internetGatewayRuleId", "type": "str"},
-    }
-
-    def __init__(self, *, internet_gateway_rule_id: Optional[str] = None, **kwargs: Any) -> None:
-        """
-        :keyword internet_gateway_rule_id: ARM Resource ID of the Internet Gateway Rule.
-        :paramtype internet_gateway_rule_id: str
-        """
-        super().__init__(**kwargs)
-        self.internet_gateway_rule_id = internet_gateway_rule_id
-
-
-class InternetGatewayProperties(AnnotationResource, InternetGatewayPatchableProperties):
-    """Internet Gateway Properties defines the properties of the resource.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar internet_gateway_rule_id: ARM Resource ID of the Internet Gateway Rule.
-    :vartype internet_gateway_rule_id: str
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar ipv4_address: IPv4 Address of Internet Gateway.
-    :vartype ipv4_address: str
-    :ivar port: Port number of Internet Gateway.
-    :vartype port: int
-    :ivar type: Gateway Type of the resource. Required. Known values are: "Infrastructure" and
-     "Workload".
-    :vartype type: str or ~azure.mgmt.managednetworkfabric.models.GatewayType
-    :ivar network_fabric_controller_id: ARM Resource ID of the Network Fabric Controller. Required.
-    :vartype network_fabric_controller_id: str
-    :ivar provisioning_state: Provisioning state of resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    """
-
-    _validation = {
-        "ipv4_address": {"readonly": True},
-        "port": {"readonly": True},
-        "type": {"required": True},
-        "network_fabric_controller_id": {"required": True},
-        "provisioning_state": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "internet_gateway_rule_id": {"key": "internetGatewayRuleId", "type": "str"},
-        "annotation": {"key": "annotation", "type": "str"},
-        "ipv4_address": {"key": "ipv4Address", "type": "str"},
-        "port": {"key": "port", "type": "int"},
-        "type": {"key": "type", "type": "str"},
-        "network_fabric_controller_id": {"key": "networkFabricControllerId", "type": "str"},
-        "provisioning_state": {"key": "provisioningState", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        type: Union[str, "_models.GatewayType"],
-        network_fabric_controller_id: str,
-        internet_gateway_rule_id: Optional[str] = None,
-        annotation: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword internet_gateway_rule_id: ARM Resource ID of the Internet Gateway Rule.
-        :paramtype internet_gateway_rule_id: str
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword type: Gateway Type of the resource. Required. Known values are: "Infrastructure" and
-         "Workload".
-        :paramtype type: str or ~azure.mgmt.managednetworkfabric.models.GatewayType
-        :keyword network_fabric_controller_id: ARM Resource ID of the Network Fabric Controller.
-         Required.
-        :paramtype network_fabric_controller_id: str
-        """
-        super().__init__(annotation=annotation, internet_gateway_rule_id=internet_gateway_rule_id, **kwargs)
-        self.internet_gateway_rule_id = internet_gateway_rule_id
-        self.ipv4_address = None
-        self.port = None
-        self.type = type
-        self.network_fabric_controller_id = network_fabric_controller_id
-        self.provisioning_state = None
-        self.annotation = annotation
-
-
-class InternetGatewayRule(TrackedResource):
-    """The Internet Gateway Rule resource definition.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
-    :vartype id: str
-    :ivar name: The name of the resource.
-    :vartype name: str
-    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
-     "Microsoft.Storage/storageAccounts".
-    :vartype type: str
-    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
-     information.
-    :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
-    :ivar location: The geo-location where the resource lives. Required.
-    :vartype location: str
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar rule_properties: Rules for the InternetGateways. Required.
-    :vartype rule_properties: ~azure.mgmt.managednetworkfabric.models.RuleProperties
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar internet_gateway_ids: List of Internet Gateway resource Id.
-    :vartype internet_gateway_ids: list[str]
-    """
-
-    _validation = {
-        "id": {"readonly": True},
-        "name": {"readonly": True},
-        "type": {"readonly": True},
-        "system_data": {"readonly": True},
-        "location": {"required": True},
-        "rule_properties": {"required": True},
-        "provisioning_state": {"readonly": True},
-        "internet_gateway_ids": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "id": {"key": "id", "type": "str"},
-        "name": {"key": "name", "type": "str"},
-        "type": {"key": "type", "type": "str"},
-        "system_data": {"key": "systemData", "type": "SystemData"},
-        "tags": {"key": "tags", "type": "{str}"},
-        "location": {"key": "location", "type": "str"},
-        "annotation": {"key": "properties.annotation", "type": "str"},
-        "rule_properties": {"key": "properties.ruleProperties", "type": "RuleProperties"},
-        "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
-        "internet_gateway_ids": {"key": "properties.internetGatewayIds", "type": "[str]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        location: str,
-        rule_properties: "_models.RuleProperties",
-        tags: Optional[Dict[str, str]] = None,
-        annotation: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
-        :keyword location: The geo-location where the resource lives. Required.
-        :paramtype location: str
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword rule_properties: Rules for the InternetGateways. Required.
-        :paramtype rule_properties: ~azure.mgmt.managednetworkfabric.models.RuleProperties
-        """
-        super().__init__(tags=tags, location=location, **kwargs)
-        self.annotation = annotation
-        self.rule_properties = rule_properties
-        self.provisioning_state = None
-        self.internet_gateway_ids = None
-
-
-class InternetGatewayRulePatch(TagsUpdate):
-    """The Internet Gateway Rules patch resource definition.
-
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
-    """
-
-    _attribute_map = {
-        "tags": {"key": "tags", "type": "{str}"},
-    }
-
-    def __init__(self, *, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
-        """
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
-        """
-        super().__init__(tags=tags, **kwargs)
-
-
-class InternetGatewayRuleProperties(AnnotationResource):
-    """Internet Gateway Rule Properties defines the resource properties.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar rule_properties: Rules for the InternetGateways. Required.
-    :vartype rule_properties: ~azure.mgmt.managednetworkfabric.models.RuleProperties
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar internet_gateway_ids: List of Internet Gateway resource Id.
-    :vartype internet_gateway_ids: list[str]
-    """
-
-    _validation = {
-        "rule_properties": {"required": True},
-        "provisioning_state": {"readonly": True},
-        "internet_gateway_ids": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "annotation": {"key": "annotation", "type": "str"},
-        "rule_properties": {"key": "ruleProperties", "type": "RuleProperties"},
-        "provisioning_state": {"key": "provisioningState", "type": "str"},
-        "internet_gateway_ids": {"key": "internetGatewayIds", "type": "[str]"},
-    }
-
-    def __init__(
-        self, *, rule_properties: "_models.RuleProperties", annotation: Optional[str] = None, **kwargs: Any
-    ) -> None:
-        """
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword rule_properties: Rules for the InternetGateways. Required.
-        :paramtype rule_properties: ~azure.mgmt.managednetworkfabric.models.RuleProperties
-        """
-        super().__init__(annotation=annotation, **kwargs)
-        self.rule_properties = rule_properties
-        self.provisioning_state = None
-        self.internet_gateway_ids = None
-
-
-class InternetGatewayRulesListResult(_serialization.Model):
-    """List of Internet Gateway Rules.
-
-    :ivar value: List of Internet Gateway Rule resources.
-    :vartype value: list[~azure.mgmt.managednetworkfabric.models.InternetGatewayRule]
-    :ivar next_link: Url to follow for getting next page of resources.
-    :vartype next_link: str
-    """
-
-    _attribute_map = {
-        "value": {"key": "value", "type": "[InternetGatewayRule]"},
-        "next_link": {"key": "nextLink", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        value: Optional[List["_models.InternetGatewayRule"]] = None,
-        next_link: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword value: List of Internet Gateway Rule resources.
-        :paramtype value: list[~azure.mgmt.managednetworkfabric.models.InternetGatewayRule]
-        :keyword next_link: Url to follow for getting next page of resources.
-        :paramtype next_link: str
-        """
-        super().__init__(**kwargs)
-        self.value = value
-        self.next_link = next_link
-
-
-class InternetGatewaysListResult(_serialization.Model):
-    """List of InternetGateways.
-
-    :ivar value: Displays list of Internet Gateway resources.
-    :vartype value: list[~azure.mgmt.managednetworkfabric.models.InternetGateway]
-    :ivar next_link: Url to follow for getting next page of resources.
-    :vartype next_link: str
-    """
-
-    _attribute_map = {
-        "value": {"key": "value", "type": "[InternetGateway]"},
-        "next_link": {"key": "nextLink", "type": "str"},
-    }
-
-    def __init__(
-        self, *, value: Optional[List["_models.InternetGateway"]] = None, next_link: Optional[str] = None, **kwargs: Any
-    ) -> None:
-        """
-        :keyword value: Displays list of Internet Gateway resources.
-        :paramtype value: list[~azure.mgmt.managednetworkfabric.models.InternetGateway]
-        :keyword next_link: Url to follow for getting next page of resources.
-        :paramtype next_link: str
-        """
-        super().__init__(**kwargs)
-        self.value = value
-        self.next_link = next_link
-
-
 class IpCommunitiesListResult(_serialization.Model):
-    """List of IP Communities.
+    """List of IPCommunities.
 
-    :ivar value: List of IP Community resources.
+    :ivar value: List of IpCommunity resources.
     :vartype value: list[~azure.mgmt.managednetworkfabric.models.IpCommunity]
     :ivar next_link: Url to follow for getting next page of resources.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[IpCommunity]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
     def __init__(
         self, *, value: Optional[List["_models.IpCommunity"]] = None, next_link: Optional[str] = None, **kwargs: Any
     ) -> None:
         """
-        :keyword value: List of IP Community resources.
+        :keyword value: List of IpCommunity resources.
         :paramtype value: list[~azure.mgmt.managednetworkfabric.models.IpCommunity]
         :keyword next_link: Url to follow for getting next page of resources.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
 class IpCommunity(TrackedResource):  # pylint: disable=too-many-instance-attributes
-    """The IP Community resource definition.
+    """The IpCommunity resource definition.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -4452,79 +3023,84 @@
     :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar location: The geo-location where the resource lives. Required.
     :vartype location: str
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar ip_community_rules: List of IP Community Rules.
-    :vartype ip_community_rules: list[~azure.mgmt.managednetworkfabric.models.IpCommunityRule]
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
+    :ivar action: Action to be taken on the configuration. Example: Permit | Deny. Known values
+     are: "Permit" and "Deny".
+    :vartype action: str or ~azure.mgmt.managednetworkfabric.models.CommunityActionTypes
+    :ivar well_known_communities: Supported well known Community List.
+    :vartype well_known_communities: list[str or
+     ~azure.mgmt.managednetworkfabric.models.WellKnownCommunities]
+    :ivar community_members: List the communityMembers of IP Community .
+    :vartype community_members: list[str]
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
         "location": {"required": True},
-        "configuration_state": {"readonly": True},
+        "well_known_communities": {"unique": True},
         "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
         "annotation": {"key": "properties.annotation", "type": "str"},
-        "ip_community_rules": {"key": "properties.ipCommunityRules", "type": "[IpCommunityRule]"},
-        "configuration_state": {"key": "properties.configurationState", "type": "str"},
+        "action": {"key": "properties.action", "type": "str"},
+        "well_known_communities": {"key": "properties.wellKnownCommunities", "type": "[str]"},
+        "community_members": {"key": "properties.communityMembers", "type": "[str]"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
-        "administrative_state": {"key": "properties.administrativeState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         location: str,
         tags: Optional[Dict[str, str]] = None,
         annotation: Optional[str] = None,
-        ip_community_rules: Optional[List["_models.IpCommunityRule"]] = None,
+        action: Optional[Union[str, "_models.CommunityActionTypes"]] = None,
+        well_known_communities: Optional[List[Union[str, "_models.WellKnownCommunities"]]] = None,
+        community_members: Optional[List[str]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword ip_community_rules: List of IP Community Rules.
-        :paramtype ip_community_rules: list[~azure.mgmt.managednetworkfabric.models.IpCommunityRule]
+        :keyword action: Action to be taken on the configuration. Example: Permit | Deny. Known values
+         are: "Permit" and "Deny".
+        :paramtype action: str or ~azure.mgmt.managednetworkfabric.models.CommunityActionTypes
+        :keyword well_known_communities: Supported well known Community List.
+        :paramtype well_known_communities: list[str or
+         ~azure.mgmt.managednetworkfabric.models.WellKnownCommunities]
+        :keyword community_members: List the communityMembers of IP Community .
+        :paramtype community_members: list[str]
         """
         super().__init__(tags=tags, location=location, **kwargs)
         self.annotation = annotation
-        self.ip_community_rules = ip_community_rules
-        self.configuration_state = None
+        self.action = action
+        self.well_known_communities = well_known_communities
+        self.community_members = community_members
         self.provisioning_state = None
-        self.administrative_state = None
 
 
 class IpCommunityIdList(_serialization.Model):
     """IP Community ID list properties.
 
     :ivar ip_community_ids: List of IP Community resource IDs.
     :vartype ip_community_ids: list[str]
@@ -4539,196 +3115,108 @@
         :keyword ip_community_ids: List of IP Community resource IDs.
         :paramtype ip_community_ids: list[str]
         """
         super().__init__(**kwargs)
         self.ip_community_ids = ip_community_ids
 
 
-class IpCommunityPatch(TagsUpdate):
-    """The IP Community patch resource definition.
+class IpCommunityPatch(_serialization.Model):
+    """The IPCommunity patch resource definition.
 
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
-    :ivar ip_community_rules: List of IP Community Rules.
-    :vartype ip_community_rules: list[~azure.mgmt.managednetworkfabric.models.IpCommunityRule]
     """
 
     _attribute_map = {
         "tags": {"key": "tags", "type": "{str}"},
-        "ip_community_rules": {"key": "properties.ipCommunityRules", "type": "[IpCommunityRule]"},
     }
 
-    def __init__(
-        self,
-        *,
-        tags: Optional[Dict[str, str]] = None,
-        ip_community_rules: Optional[List["_models.IpCommunityRule"]] = None,
-        **kwargs: Any
-    ) -> None:
+    def __init__(self, *, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
-        :keyword ip_community_rules: List of IP Community Rules.
-        :paramtype ip_community_rules: list[~azure.mgmt.managednetworkfabric.models.IpCommunityRule]
-        """
-        super().__init__(tags=tags, **kwargs)
-        self.ip_community_rules = ip_community_rules
-
-
-class IpCommunityPatchableProperties(_serialization.Model):
-    """IP Community patchable properties.
-
-    :ivar ip_community_rules: List of IP Community Rules.
-    :vartype ip_community_rules: list[~azure.mgmt.managednetworkfabric.models.IpCommunityRule]
-    """
-
-    _attribute_map = {
-        "ip_community_rules": {"key": "ipCommunityRules", "type": "[IpCommunityRule]"},
-    }
-
-    def __init__(self, *, ip_community_rules: Optional[List["_models.IpCommunityRule"]] = None, **kwargs: Any) -> None:
-        """
-        :keyword ip_community_rules: List of IP Community Rules.
-        :paramtype ip_community_rules: list[~azure.mgmt.managednetworkfabric.models.IpCommunityRule]
         """
         super().__init__(**kwargs)
-        self.ip_community_rules = ip_community_rules
+        self.tags = tags
 
 
-class IpCommunityProperties(AnnotationResource, IpCommunityPatchableProperties):
-    """IP Community Properties defines the resource properties.
+class IpCommunityProperties(AnnotationResource):
+    """IpCommunityProperties define the resource properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar ip_community_rules: List of IP Community Rules.
-    :vartype ip_community_rules: list[~azure.mgmt.managednetworkfabric.models.IpCommunityRule]
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
-    """
-
-    _validation = {
-        "configuration_state": {"readonly": True},
-        "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "ip_community_rules": {"key": "ipCommunityRules", "type": "[IpCommunityRule]"},
-        "annotation": {"key": "annotation", "type": "str"},
-        "configuration_state": {"key": "configurationState", "type": "str"},
-        "provisioning_state": {"key": "provisioningState", "type": "str"},
-        "administrative_state": {"key": "administrativeState", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        ip_community_rules: Optional[List["_models.IpCommunityRule"]] = None,
-        annotation: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword ip_community_rules: List of IP Community Rules.
-        :paramtype ip_community_rules: list[~azure.mgmt.managednetworkfabric.models.IpCommunityRule]
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        """
-        super().__init__(annotation=annotation, ip_community_rules=ip_community_rules, **kwargs)
-        self.ip_community_rules = ip_community_rules
-        self.configuration_state = None
-        self.provisioning_state = None
-        self.administrative_state = None
-        self.annotation = annotation
-
-
-class IpCommunityRule(_serialization.Model):
-    """IP Community patchable properties.
-
     All required parameters must be populated in order to send to Azure.
 
+    :ivar annotation: Switch configuration description.
+    :vartype annotation: str
     :ivar action: Action to be taken on the configuration. Example: Permit | Deny. Required. Known
      values are: "Permit" and "Deny".
     :vartype action: str or ~azure.mgmt.managednetworkfabric.models.CommunityActionTypes
-    :ivar sequence_number: Sequence to insert to/delete from existing route. Prefix lists are
-     evaluated starting with the lowest sequence number and continue down the list until a match is
-     made. Once a match is made, the permit or deny statement is applied to that network and the
-     rest of the list is ignored. Required.
-    :vartype sequence_number: int
     :ivar well_known_communities: Supported well known Community List.
     :vartype well_known_communities: list[str or
      ~azure.mgmt.managednetworkfabric.models.WellKnownCommunities]
-    :ivar community_members: List the community members of IP Community. Required.
+    :ivar community_members: List the communityMembers of IP Community . Required.
     :vartype community_members: list[str]
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
+    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
     """
 
     _validation = {
         "action": {"required": True},
-        "sequence_number": {"required": True, "maximum": 4294967295, "minimum": 1},
         "well_known_communities": {"unique": True},
-        "community_members": {"required": True, "min_items": 1},
+        "community_members": {"required": True},
+        "provisioning_state": {"readonly": True},
     }
 
     _attribute_map = {
+        "annotation": {"key": "annotation", "type": "str"},
         "action": {"key": "action", "type": "str"},
-        "sequence_number": {"key": "sequenceNumber", "type": "int"},
         "well_known_communities": {"key": "wellKnownCommunities", "type": "[str]"},
         "community_members": {"key": "communityMembers", "type": "[str]"},
+        "provisioning_state": {"key": "provisioningState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         action: Union[str, "_models.CommunityActionTypes"],
-        sequence_number: int,
         community_members: List[str],
+        annotation: Optional[str] = None,
         well_known_communities: Optional[List[Union[str, "_models.WellKnownCommunities"]]] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword annotation: Switch configuration description.
+        :paramtype annotation: str
         :keyword action: Action to be taken on the configuration. Example: Permit | Deny. Required.
          Known values are: "Permit" and "Deny".
         :paramtype action: str or ~azure.mgmt.managednetworkfabric.models.CommunityActionTypes
-        :keyword sequence_number: Sequence to insert to/delete from existing route. Prefix lists are
-         evaluated starting with the lowest sequence number and continue down the list until a match is
-         made. Once a match is made, the permit or deny statement is applied to that network and the
-         rest of the list is ignored. Required.
-        :paramtype sequence_number: int
         :keyword well_known_communities: Supported well known Community List.
         :paramtype well_known_communities: list[str or
          ~azure.mgmt.managednetworkfabric.models.WellKnownCommunities]
-        :keyword community_members: List the community members of IP Community. Required.
+        :keyword community_members: List the communityMembers of IP Community . Required.
         :paramtype community_members: list[str]
         """
-        super().__init__(**kwargs)
+        super().__init__(annotation=annotation, **kwargs)
         self.action = action
-        self.sequence_number = sequence_number
         self.well_known_communities = well_known_communities
         self.community_members = community_members
+        self.provisioning_state = None
 
 
-class IpExtendedCommunity(TrackedResource):  # pylint: disable=too-many-instance-attributes
-    """The IP Extended Community resource definition.
+class IpExtendedCommunity(TrackedResource):
+    """The IpExtendedCommunity resource definition.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -4736,85 +3224,80 @@
     :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar location: The geo-location where the resource lives. Required.
     :vartype location: str
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar ip_extended_community_rules: List of IP Extended Community Rules. Required.
-    :vartype ip_extended_community_rules:
-     list[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityRule]
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
+    :ivar action: Action to be taken on the configuration. Example: Permit | Deny. Known values
+     are: "Permit" and "Deny".
+    :vartype action: str or ~azure.mgmt.managednetworkfabric.models.CommunityActionTypes
+    :ivar route_targets: Route Target List.The expected formats are ASN(plain):NN >> example
+     4294967294:50, ASN.ASN:NN >> example 65533.65333:40, IP-address:NN >> example
+     10.10.10.10:65535. The possible values of ASN,NN are in range of 0-65535, ASN(plain) is in
+     range of 0-4294967295.
+    :vartype route_targets: list[str]
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
         "location": {"required": True},
-        "ip_extended_community_rules": {"required": True},
-        "configuration_state": {"readonly": True},
         "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
         "annotation": {"key": "properties.annotation", "type": "str"},
-        "ip_extended_community_rules": {
-            "key": "properties.ipExtendedCommunityRules",
-            "type": "[IpExtendedCommunityRule]",
-        },
-        "configuration_state": {"key": "properties.configurationState", "type": "str"},
+        "action": {"key": "properties.action", "type": "str"},
+        "route_targets": {"key": "properties.routeTargets", "type": "[str]"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
-        "administrative_state": {"key": "properties.administrativeState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         location: str,
-        ip_extended_community_rules: List["_models.IpExtendedCommunityRule"],
         tags: Optional[Dict[str, str]] = None,
         annotation: Optional[str] = None,
+        action: Optional[Union[str, "_models.CommunityActionTypes"]] = None,
+        route_targets: Optional[List[str]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword ip_extended_community_rules: List of IP Extended Community Rules. Required.
-        :paramtype ip_extended_community_rules:
-         list[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityRule]
+        :keyword action: Action to be taken on the configuration. Example: Permit | Deny. Known values
+         are: "Permit" and "Deny".
+        :paramtype action: str or ~azure.mgmt.managednetworkfabric.models.CommunityActionTypes
+        :keyword route_targets: Route Target List.The expected formats are ASN(plain):NN >> example
+         4294967294:50, ASN.ASN:NN >> example 65533.65333:40, IP-address:NN >> example
+         10.10.10.10:65535. The possible values of ASN,NN are in range of 0-65535, ASN(plain) is in
+         range of 0-4294967295.
+        :paramtype route_targets: list[str]
         """
         super().__init__(tags=tags, location=location, **kwargs)
         self.annotation = annotation
-        self.ip_extended_community_rules = ip_extended_community_rules
-        self.configuration_state = None
+        self.action = action
+        self.route_targets = route_targets
         self.provisioning_state = None
-        self.administrative_state = None
 
 
 class IpExtendedCommunityIdList(_serialization.Model):
     """IP Extended Community Id list properties.
 
     :ivar ip_extended_community_ids: List of IP Extended Community resource IDs.
     :vartype ip_extended_community_ids: list[str]
@@ -4830,17 +3313,17 @@
         :paramtype ip_extended_community_ids: list[str]
         """
         super().__init__(**kwargs)
         self.ip_extended_community_ids = ip_extended_community_ids
 
 
 class IpExtendedCommunityListResult(_serialization.Model):
-    """List of IP Extended Communities.
+    """List of IpExtendedCommunities.
 
-    :ivar value: List of IP Extended Communities resources.
+    :ivar value: List of IpExtendedCommunities resources.
     :vartype value: list[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
     :ivar next_link: Url to follow for getting next page of resources.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[IpExtendedCommunity]"},
@@ -4851,362 +3334,114 @@
         self,
         *,
         value: Optional[List["_models.IpExtendedCommunity"]] = None,
         next_link: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword value: List of IP Extended Communities resources.
+        :keyword value: List of IpExtendedCommunities resources.
         :paramtype value: list[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
         :keyword next_link: Url to follow for getting next page of resources.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
-class IpExtendedCommunityPatch(TagsUpdate):
-    """The IP Extended Communities patch resource definition.
+class IpExtendedCommunityPatch(_serialization.Model):
+    """The IpExtendedCommunities patch resource definition.
 
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
-    :ivar ip_extended_community_rules: List of IP Extended Community Rules.
-    :vartype ip_extended_community_rules:
-     list[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityRule]
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
     """
 
     _attribute_map = {
         "tags": {"key": "tags", "type": "{str}"},
-        "ip_extended_community_rules": {
-            "key": "properties.ipExtendedCommunityRules",
-            "type": "[IpExtendedCommunityRule]",
-        },
-        "annotation": {"key": "properties.annotation", "type": "str"},
     }
 
-    def __init__(
-        self,
-        *,
-        tags: Optional[Dict[str, str]] = None,
-        ip_extended_community_rules: Optional[List["_models.IpExtendedCommunityRule"]] = None,
-        annotation: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
+    def __init__(self, *, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
-        :keyword ip_extended_community_rules: List of IP Extended Community Rules.
-        :paramtype ip_extended_community_rules:
-         list[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityRule]
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        """
-        super().__init__(tags=tags, **kwargs)
-        self.ip_extended_community_rules = ip_extended_community_rules
-        self.annotation = annotation
-
-
-class IpExtendedCommunityPatchableProperties(_serialization.Model):
-    """IP Extended Community patchable properties.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar ip_extended_community_rules: List of IP Extended Community Rules. Required.
-    :vartype ip_extended_community_rules:
-     list[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityRule]
-    """
-
-    _validation = {
-        "ip_extended_community_rules": {"required": True},
-    }
-
-    _attribute_map = {
-        "ip_extended_community_rules": {"key": "ipExtendedCommunityRules", "type": "[IpExtendedCommunityRule]"},
-    }
-
-    def __init__(self, *, ip_extended_community_rules: List["_models.IpExtendedCommunityRule"], **kwargs: Any) -> None:
-        """
-        :keyword ip_extended_community_rules: List of IP Extended Community Rules. Required.
-        :paramtype ip_extended_community_rules:
-         list[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityRule]
         """
         super().__init__(**kwargs)
-        self.ip_extended_community_rules = ip_extended_community_rules
-
-
-class IpExtendedCommunityPatchProperties(IpExtendedCommunityPatchableProperties, AnnotationResource):
-    """IP Extended Community patchable properties.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar ip_extended_community_rules: List of IP Extended Community Rules. Required.
-    :vartype ip_extended_community_rules:
-     list[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityRule]
-    """
-
-    _validation = {
-        "ip_extended_community_rules": {"required": True},
-    }
-
-    _attribute_map = {
-        "annotation": {"key": "annotation", "type": "str"},
-        "ip_extended_community_rules": {"key": "ipExtendedCommunityRules", "type": "[IpExtendedCommunityRule]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        ip_extended_community_rules: List["_models.IpExtendedCommunityRule"],
-        annotation: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword ip_extended_community_rules: List of IP Extended Community Rules. Required.
-        :paramtype ip_extended_community_rules:
-         list[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityRule]
-        """
-        super().__init__(ip_extended_community_rules=ip_extended_community_rules, annotation=annotation, **kwargs)
-        self.annotation = annotation
-        self.ip_extended_community_rules = ip_extended_community_rules
+        self.tags = tags
 
 
-class IpExtendedCommunityProperties(AnnotationResource, IpExtendedCommunityPatchableProperties):
-    """IP Extended Community Properties defines the resource properties.
+class IpExtendedCommunityProperties(AnnotationResource):
+    """IpExtendedCommunityProperties define the resource properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar ip_extended_community_rules: List of IP Extended Community Rules. Required.
-    :vartype ip_extended_community_rules:
-     list[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityRule]
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
-    """
-
-    _validation = {
-        "ip_extended_community_rules": {"required": True},
-        "configuration_state": {"readonly": True},
-        "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "ip_extended_community_rules": {"key": "ipExtendedCommunityRules", "type": "[IpExtendedCommunityRule]"},
-        "annotation": {"key": "annotation", "type": "str"},
-        "configuration_state": {"key": "configurationState", "type": "str"},
-        "provisioning_state": {"key": "provisioningState", "type": "str"},
-        "administrative_state": {"key": "administrativeState", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        ip_extended_community_rules: List["_models.IpExtendedCommunityRule"],
-        annotation: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword ip_extended_community_rules: List of IP Extended Community Rules. Required.
-        :paramtype ip_extended_community_rules:
-         list[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityRule]
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        """
-        super().__init__(annotation=annotation, ip_extended_community_rules=ip_extended_community_rules, **kwargs)
-        self.ip_extended_community_rules = ip_extended_community_rules
-        self.configuration_state = None
-        self.provisioning_state = None
-        self.administrative_state = None
-        self.annotation = annotation
-
-
-class IpExtendedCommunityRule(_serialization.Model):
-    """List of IP Extended Community Rules.
-
-    All required parameters must be populated in order to send to Azure.
-
     :ivar action: Action to be taken on the configuration. Example: Permit | Deny. Required. Known
      values are: "Permit" and "Deny".
     :vartype action: str or ~azure.mgmt.managednetworkfabric.models.CommunityActionTypes
-    :ivar sequence_number: Sequence to insert to/delete from existing route. Prefix lists are
-     evaluated starting with the lowest sequence number and continue down the list until a match is
-     made. Once a match is made, the permit or deny statement is applied to that network and the
-     rest of the list is ignored. Required.
-    :vartype sequence_number: int
     :ivar route_targets: Route Target List.The expected formats are ASN(plain):NN >> example
      4294967294:50, ASN.ASN:NN >> example 65533.65333:40, IP-address:NN >> example
      10.10.10.10:65535. The possible values of ASN,NN are in range of 0-65535, ASN(plain) is in
      range of 0-4294967295. Required.
     :vartype route_targets: list[str]
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
+    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
     """
 
     _validation = {
         "action": {"required": True},
-        "sequence_number": {"required": True, "maximum": 4294967295, "minimum": 1},
-        "route_targets": {"required": True, "min_items": 1},
+        "route_targets": {"required": True},
+        "provisioning_state": {"readonly": True},
     }
 
     _attribute_map = {
+        "annotation": {"key": "annotation", "type": "str"},
         "action": {"key": "action", "type": "str"},
-        "sequence_number": {"key": "sequenceNumber", "type": "int"},
         "route_targets": {"key": "routeTargets", "type": "[str]"},
+        "provisioning_state": {"key": "provisioningState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         action: Union[str, "_models.CommunityActionTypes"],
-        sequence_number: int,
         route_targets: List[str],
+        annotation: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword annotation: Switch configuration description.
+        :paramtype annotation: str
         :keyword action: Action to be taken on the configuration. Example: Permit | Deny. Required.
          Known values are: "Permit" and "Deny".
         :paramtype action: str or ~azure.mgmt.managednetworkfabric.models.CommunityActionTypes
-        :keyword sequence_number: Sequence to insert to/delete from existing route. Prefix lists are
-         evaluated starting with the lowest sequence number and continue down the list until a match is
-         made. Once a match is made, the permit or deny statement is applied to that network and the
-         rest of the list is ignored. Required.
-        :paramtype sequence_number: int
         :keyword route_targets: Route Target List.The expected formats are ASN(plain):NN >> example
          4294967294:50, ASN.ASN:NN >> example 65533.65333:40, IP-address:NN >> example
          10.10.10.10:65535. The possible values of ASN,NN are in range of 0-65535, ASN(plain) is in
          range of 0-4294967295. Required.
         :paramtype route_targets: list[str]
         """
-        super().__init__(**kwargs)
+        super().__init__(annotation=annotation, **kwargs)
         self.action = action
-        self.sequence_number = sequence_number
         self.route_targets = route_targets
+        self.provisioning_state = None
 
 
-class IpGroupProperties(_serialization.Model):
-    """IP Group properties.
-
-    :ivar name: IP Group name.
-    :vartype name: str
-    :ivar ip_address_type: IP Address type. Known values are: "IPv4" and "IPv6".
-    :vartype ip_address_type: str or ~azure.mgmt.managednetworkfabric.models.IPAddressType
-    :ivar ip_prefixes: List of IP Prefixes.
-    :vartype ip_prefixes: list[str]
-    """
-
-    _validation = {
-        "name": {"min_length": 1},
-        "ip_prefixes": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "name": {"key": "name", "type": "str"},
-        "ip_address_type": {"key": "ipAddressType", "type": "str"},
-        "ip_prefixes": {"key": "ipPrefixes", "type": "[str]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        name: Optional[str] = None,
-        ip_address_type: Optional[Union[str, "_models.IPAddressType"]] = None,
-        ip_prefixes: Optional[List[str]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword name: IP Group name.
-        :paramtype name: str
-        :keyword ip_address_type: IP Address type. Known values are: "IPv4" and "IPv6".
-        :paramtype ip_address_type: str or ~azure.mgmt.managednetworkfabric.models.IPAddressType
-        :keyword ip_prefixes: List of IP Prefixes.
-        :paramtype ip_prefixes: list[str]
-        """
-        super().__init__(**kwargs)
-        self.name = name
-        self.ip_address_type = ip_address_type
-        self.ip_prefixes = ip_prefixes
-
-
-class IpMatchCondition(_serialization.Model):
-    """Defines the condition that can be filtered using the selected IPs.
-
-    :ivar type: IP Address type. Known values are: "SourceIP" and "DestinationIP".
-    :vartype type: str or ~azure.mgmt.managednetworkfabric.models.SourceDestinationType
-    :ivar prefix_type: IP Prefix Type. Known values are: "Prefix" and "LongestPrefix".
-    :vartype prefix_type: str or ~azure.mgmt.managednetworkfabric.models.PrefixType
-    :ivar ip_prefix_values: The list of IP Prefixes.
-    :vartype ip_prefix_values: list[str]
-    :ivar ip_group_names: The List of IP Group Names that need to be matched.
-    :vartype ip_group_names: list[str]
-    """
-
-    _validation = {
-        "ip_prefix_values": {"min_items": 1},
-        "ip_group_names": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "type": {"key": "type", "type": "str"},
-        "prefix_type": {"key": "prefixType", "type": "str"},
-        "ip_prefix_values": {"key": "ipPrefixValues", "type": "[str]"},
-        "ip_group_names": {"key": "ipGroupNames", "type": "[str]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        type: Optional[Union[str, "_models.SourceDestinationType"]] = None,
-        prefix_type: Optional[Union[str, "_models.PrefixType"]] = None,
-        ip_prefix_values: Optional[List[str]] = None,
-        ip_group_names: Optional[List[str]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword type: IP Address type. Known values are: "SourceIP" and "DestinationIP".
-        :paramtype type: str or ~azure.mgmt.managednetworkfabric.models.SourceDestinationType
-        :keyword prefix_type: IP Prefix Type. Known values are: "Prefix" and "LongestPrefix".
-        :paramtype prefix_type: str or ~azure.mgmt.managednetworkfabric.models.PrefixType
-        :keyword ip_prefix_values: The list of IP Prefixes.
-        :paramtype ip_prefix_values: list[str]
-        :keyword ip_group_names: The List of IP Group Names that need to be matched.
-        :paramtype ip_group_names: list[str]
-        """
-        super().__init__(**kwargs)
-        self.type = type
-        self.prefix_type = prefix_type
-        self.ip_prefix_values = ip_prefix_values
-        self.ip_group_names = ip_group_names
-
-
-class IpPrefix(TrackedResource):  # pylint: disable=too-many-instance-attributes
-    """The IP Prefix resource definition.
+class IpPrefix(TrackedResource):
+    """The IPPrefix resource definition.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -5214,258 +3449,167 @@
     :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar location: The geo-location where the resource lives. Required.
     :vartype location: str
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar ip_prefix_rules: The list of IP Prefix Rules.
-    :vartype ip_prefix_rules: list[~azure.mgmt.managednetworkfabric.models.IpPrefixRule]
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
+    :ivar ip_prefix_rules: IpPrefix contains the list of IP PrefixRules objects. Required.
+    :vartype ip_prefix_rules:
+     list[~azure.mgmt.managednetworkfabric.models.IpPrefixPropertiesIpPrefixRulesItem]
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
         "location": {"required": True},
-        "configuration_state": {"readonly": True},
+        "ip_prefix_rules": {"required": True},
         "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
         "annotation": {"key": "properties.annotation", "type": "str"},
-        "ip_prefix_rules": {"key": "properties.ipPrefixRules", "type": "[IpPrefixRule]"},
-        "configuration_state": {"key": "properties.configurationState", "type": "str"},
+        "ip_prefix_rules": {"key": "properties.ipPrefixRules", "type": "[IpPrefixPropertiesIpPrefixRulesItem]"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
-        "administrative_state": {"key": "properties.administrativeState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         location: str,
+        ip_prefix_rules: List["_models.IpPrefixPropertiesIpPrefixRulesItem"],
         tags: Optional[Dict[str, str]] = None,
         annotation: Optional[str] = None,
-        ip_prefix_rules: Optional[List["_models.IpPrefixRule"]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword ip_prefix_rules: The list of IP Prefix Rules.
-        :paramtype ip_prefix_rules: list[~azure.mgmt.managednetworkfabric.models.IpPrefixRule]
+        :keyword ip_prefix_rules: IpPrefix contains the list of IP PrefixRules objects. Required.
+        :paramtype ip_prefix_rules:
+         list[~azure.mgmt.managednetworkfabric.models.IpPrefixPropertiesIpPrefixRulesItem]
         """
         super().__init__(tags=tags, location=location, **kwargs)
         self.annotation = annotation
         self.ip_prefix_rules = ip_prefix_rules
-        self.configuration_state = None
         self.provisioning_state = None
-        self.administrative_state = None
 
 
 class IpPrefixesListResult(_serialization.Model):
-    """List of IP Prefixes.
+    """List of IpPrefixes.
 
-    :ivar value: List of IP Prefix resources.
+    :ivar value: List of IPPrefix resources.
     :vartype value: list[~azure.mgmt.managednetworkfabric.models.IpPrefix]
     :ivar next_link: Url to follow for getting next page of resources.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[IpPrefix]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
     def __init__(
         self, *, value: Optional[List["_models.IpPrefix"]] = None, next_link: Optional[str] = None, **kwargs: Any
     ) -> None:
         """
-        :keyword value: List of IP Prefix resources.
+        :keyword value: List of IPPrefix resources.
         :paramtype value: list[~azure.mgmt.managednetworkfabric.models.IpPrefix]
         :keyword next_link: Url to follow for getting next page of resources.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
-class IpPrefixPatch(TagsUpdate):
-    """The IP Prefix patch resource definition.
+class IpPrefixPatch(_serialization.Model):
+    """The IPPrefix patch resource definition.
 
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar ip_prefix_rules: The list of IP Prefix Rules.
-    :vartype ip_prefix_rules: list[~azure.mgmt.managednetworkfabric.models.IpPrefixRule]
     """
 
     _attribute_map = {
         "tags": {"key": "tags", "type": "{str}"},
-        "annotation": {"key": "properties.annotation", "type": "str"},
-        "ip_prefix_rules": {"key": "properties.ipPrefixRules", "type": "[IpPrefixRule]"},
     }
 
-    def __init__(
-        self,
-        *,
-        tags: Optional[Dict[str, str]] = None,
-        annotation: Optional[str] = None,
-        ip_prefix_rules: Optional[List["_models.IpPrefixRule"]] = None,
-        **kwargs: Any
-    ) -> None:
+    def __init__(self, *, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword ip_prefix_rules: The list of IP Prefix Rules.
-        :paramtype ip_prefix_rules: list[~azure.mgmt.managednetworkfabric.models.IpPrefixRule]
-        """
-        super().__init__(tags=tags, **kwargs)
-        self.annotation = annotation
-        self.ip_prefix_rules = ip_prefix_rules
-
-
-class IpPrefixPatchableProperties(_serialization.Model):
-    """IP Prefix patchable properties.
-
-    :ivar ip_prefix_rules: The list of IP Prefix Rules.
-    :vartype ip_prefix_rules: list[~azure.mgmt.managednetworkfabric.models.IpPrefixRule]
-    """
-
-    _attribute_map = {
-        "ip_prefix_rules": {"key": "ipPrefixRules", "type": "[IpPrefixRule]"},
-    }
-
-    def __init__(self, *, ip_prefix_rules: Optional[List["_models.IpPrefixRule"]] = None, **kwargs: Any) -> None:
-        """
-        :keyword ip_prefix_rules: The list of IP Prefix Rules.
-        :paramtype ip_prefix_rules: list[~azure.mgmt.managednetworkfabric.models.IpPrefixRule]
         """
         super().__init__(**kwargs)
-        self.ip_prefix_rules = ip_prefix_rules
-
-
-class IpPrefixPatchProperties(AnnotationResource, IpPrefixPatchableProperties):
-    """IP Prefix patchable properties.
-
-    :ivar ip_prefix_rules: The list of IP Prefix Rules.
-    :vartype ip_prefix_rules: list[~azure.mgmt.managednetworkfabric.models.IpPrefixRule]
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    """
-
-    _attribute_map = {
-        "ip_prefix_rules": {"key": "ipPrefixRules", "type": "[IpPrefixRule]"},
-        "annotation": {"key": "annotation", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        ip_prefix_rules: Optional[List["_models.IpPrefixRule"]] = None,
-        annotation: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword ip_prefix_rules: The list of IP Prefix Rules.
-        :paramtype ip_prefix_rules: list[~azure.mgmt.managednetworkfabric.models.IpPrefixRule]
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        """
-        super().__init__(annotation=annotation, ip_prefix_rules=ip_prefix_rules, **kwargs)
-        self.ip_prefix_rules = ip_prefix_rules
-        self.annotation = annotation
+        self.tags = tags
 
 
-class IpPrefixProperties(AnnotationResource, IpPrefixPatchableProperties):
-    """IP Prefix Properties defines the properties of the resource.
+class IpPrefixProperties(AnnotationResource):
+    """IpPrefixProperties define the resource properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar ip_prefix_rules: The list of IP Prefix Rules.
-    :vartype ip_prefix_rules: list[~azure.mgmt.managednetworkfabric.models.IpPrefixRule]
+    All required parameters must be populated in order to send to Azure.
+
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
+    :ivar ip_prefix_rules: IpPrefix contains the list of IP PrefixRules objects. Required.
+    :vartype ip_prefix_rules:
+     list[~azure.mgmt.managednetworkfabric.models.IpPrefixPropertiesIpPrefixRulesItem]
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
-        "configuration_state": {"readonly": True},
+        "ip_prefix_rules": {"required": True},
         "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
     }
 
     _attribute_map = {
-        "ip_prefix_rules": {"key": "ipPrefixRules", "type": "[IpPrefixRule]"},
         "annotation": {"key": "annotation", "type": "str"},
-        "configuration_state": {"key": "configurationState", "type": "str"},
+        "ip_prefix_rules": {"key": "ipPrefixRules", "type": "[IpPrefixPropertiesIpPrefixRulesItem]"},
         "provisioning_state": {"key": "provisioningState", "type": "str"},
-        "administrative_state": {"key": "administrativeState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
-        ip_prefix_rules: Optional[List["_models.IpPrefixRule"]] = None,
+        ip_prefix_rules: List["_models.IpPrefixPropertiesIpPrefixRulesItem"],
         annotation: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword ip_prefix_rules: The list of IP Prefix Rules.
-        :paramtype ip_prefix_rules: list[~azure.mgmt.managednetworkfabric.models.IpPrefixRule]
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
+        :keyword ip_prefix_rules: IpPrefix contains the list of IP PrefixRules objects. Required.
+        :paramtype ip_prefix_rules:
+         list[~azure.mgmt.managednetworkfabric.models.IpPrefixPropertiesIpPrefixRulesItem]
         """
-        super().__init__(annotation=annotation, ip_prefix_rules=ip_prefix_rules, **kwargs)
+        super().__init__(annotation=annotation, **kwargs)
         self.ip_prefix_rules = ip_prefix_rules
-        self.configuration_state = None
         self.provisioning_state = None
-        self.administrative_state = None
-        self.annotation = annotation
 
 
-class IpPrefixRule(_serialization.Model):
-    """IP Prefix Rule properties.
+class IpPrefixPropertiesIpPrefixRulesItem(_serialization.Model):
+    """IpPrefixPropertiesIpPrefixRulesItem.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar action: Action to be taken on the configuration. Example: Permit | Deny. Required. Known
      values are: "Permit" and "Deny".
     :vartype action: str or ~azure.mgmt.managednetworkfabric.models.CommunityActionTypes
     :ivar sequence_number: Sequence to insert to/delete from existing route. Prefix lists are
@@ -5473,43 +3617,44 @@
      made. Once a match is made, the permit or deny statement is applied to that network and the
      rest of the list is ignored. Required.
     :vartype sequence_number: int
     :ivar network_prefix: Network Prefix specifying IPv4/IPv6 packets to be permitted or denied.
      Example: 1.1.1.0/24 | 3FFE:FFFF:0:CD30::/126. Required.
     :vartype network_prefix: str
     :ivar condition: Specify prefix-list bounds. Known values are: "EqualTo",
-     "GreaterThanOrEqualTo", "LesserThanOrEqualTo", and "Range".
+     "GreaterThanOrEqualTo", and "LesserThanOrEqualTo".
     :vartype condition: str or ~azure.mgmt.managednetworkfabric.models.Condition
     :ivar subnet_mask_length: SubnetMaskLength gives the minimum NetworkPrefix length to be
-     matched. Possible values for IPv4 are 1 - 32 . Possible values of IPv6 are 1 - 128.
-    :vartype subnet_mask_length: str
+     matched.Possible values for IPv4 are 1 - 32. Possible values of IPv6 are 1 - 128.
+    :vartype subnet_mask_length: int
     """
 
     _validation = {
         "action": {"required": True},
         "sequence_number": {"required": True, "maximum": 4294967295, "minimum": 1},
         "network_prefix": {"required": True},
+        "subnet_mask_length": {"maximum": 128, "minimum": 1},
     }
 
     _attribute_map = {
         "action": {"key": "action", "type": "str"},
         "sequence_number": {"key": "sequenceNumber", "type": "int"},
         "network_prefix": {"key": "networkPrefix", "type": "str"},
         "condition": {"key": "condition", "type": "str"},
-        "subnet_mask_length": {"key": "subnetMaskLength", "type": "str"},
+        "subnet_mask_length": {"key": "subnetMaskLength", "type": "int"},
     }
 
     def __init__(
         self,
         *,
         action: Union[str, "_models.CommunityActionTypes"],
         sequence_number: int,
         network_prefix: str,
         condition: Optional[Union[str, "_models.Condition"]] = None,
-        subnet_mask_length: Optional[str] = None,
+        subnet_mask_length: Optional[int] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword action: Action to be taken on the configuration. Example: Permit | Deny. Required.
          Known values are: "Permit" and "Deny".
         :paramtype action: str or ~azure.mgmt.managednetworkfabric.models.CommunityActionTypes
         :keyword sequence_number: Sequence to insert to/delete from existing route. Prefix lists are
@@ -5517,69 +3662,37 @@
          made. Once a match is made, the permit or deny statement is applied to that network and the
          rest of the list is ignored. Required.
         :paramtype sequence_number: int
         :keyword network_prefix: Network Prefix specifying IPv4/IPv6 packets to be permitted or denied.
          Example: 1.1.1.0/24 | 3FFE:FFFF:0:CD30::/126. Required.
         :paramtype network_prefix: str
         :keyword condition: Specify prefix-list bounds. Known values are: "EqualTo",
-         "GreaterThanOrEqualTo", "LesserThanOrEqualTo", and "Range".
+         "GreaterThanOrEqualTo", and "LesserThanOrEqualTo".
         :paramtype condition: str or ~azure.mgmt.managednetworkfabric.models.Condition
         :keyword subnet_mask_length: SubnetMaskLength gives the minimum NetworkPrefix length to be
-         matched. Possible values for IPv4 are 1 - 32 . Possible values of IPv6 are 1 - 128.
-        :paramtype subnet_mask_length: str
+         matched.Possible values for IPv4 are 1 - 32. Possible values of IPv6 are 1 - 128.
+        :paramtype subnet_mask_length: int
         """
         super().__init__(**kwargs)
         self.action = action
         self.sequence_number = sequence_number
         self.network_prefix = network_prefix
         self.condition = condition
         self.subnet_mask_length = subnet_mask_length
 
 
-class IsolationDomainProperties(_serialization.Model):
-    """Isolation Domain Properties.
-
-    :ivar encapsulation: Type of encapsulation. Known values are: "None" and "GRE".
-    :vartype encapsulation: str or ~azure.mgmt.managednetworkfabric.models.Encapsulation
-    :ivar neighbor_group_ids: List of Neighbor Group IDs.
-    :vartype neighbor_group_ids: list[str]
-    """
-
-    _attribute_map = {
-        "encapsulation": {"key": "encapsulation", "type": "str"},
-        "neighbor_group_ids": {"key": "neighborGroupIds", "type": "[str]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        encapsulation: Optional[Union[str, "_models.Encapsulation"]] = None,
-        neighbor_group_ids: Optional[List[str]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword encapsulation: Type of encapsulation. Known values are: "None" and "GRE".
-        :paramtype encapsulation: str or ~azure.mgmt.managednetworkfabric.models.Encapsulation
-        :keyword neighbor_group_ids: List of Neighbor Group IDs.
-        :paramtype neighbor_group_ids: list[str]
-        """
-        super().__init__(**kwargs)
-        self.encapsulation = encapsulation
-        self.neighbor_group_ids = neighbor_group_ids
-
-
 class L2IsolationDomain(TrackedResource):  # pylint: disable=too-many-instance-attributes
-    """The L2 Isolation Domain resource definition.
+    """The L2IsolationDomain resource definition.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -5587,237 +3700,239 @@
     :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar location: The geo-location where the resource lives. Required.
     :vartype location: str
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar network_fabric_id: ARM Resource ID of the Network Fabric. Required.
+    :ivar network_fabric_id: Network Fabric ARM resource id.
     :vartype network_fabric_id: str
-    :ivar vlan_id: Vlan Identifier of the Network Fabric. Example: 501. Required.
+    :ivar vlan_id: vlanId. Example: 501.
     :vartype vlan_id: int
-    :ivar mtu: Maximum transmission unit. Default value is 1500.
+    :ivar mtu: maximum transmission unit. Default value is 1500.
     :vartype mtu: int
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
+    :ivar disabled_on_resources: List of resources the L2 Isolation Domain is disabled on. Can be
+     either entire NetworkFabric or NetworkRack.
+    :vartype disabled_on_resources: list[str]
+    :ivar administrative_state: state. Example: Enabled | Disabled. It indicates administrative
+     state of the isolationDomain, whether it is enabled or disabled. If enabled, the configuration
+     is applied on the devices. If disabled, the configuration is removed from the devices. Known
+     values are: "Enabled" and "Disabled".
     :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
+     ~azure.mgmt.managednetworkfabric.models.EnabledDisabledState
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
+    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
         "location": {"required": True},
-        "network_fabric_id": {"required": True},
-        "vlan_id": {"required": True, "maximum": 4094, "minimum": 100},
-        "mtu": {"maximum": 9200, "minimum": 64},
-        "configuration_state": {"readonly": True},
-        "provisioning_state": {"readonly": True},
+        "disabled_on_resources": {"readonly": True},
         "administrative_state": {"readonly": True},
+        "provisioning_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
         "annotation": {"key": "properties.annotation", "type": "str"},
         "network_fabric_id": {"key": "properties.networkFabricId", "type": "str"},
         "vlan_id": {"key": "properties.vlanId", "type": "int"},
         "mtu": {"key": "properties.mtu", "type": "int"},
-        "configuration_state": {"key": "properties.configurationState", "type": "str"},
-        "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
+        "disabled_on_resources": {"key": "properties.disabledOnResources", "type": "[str]"},
         "administrative_state": {"key": "properties.administrativeState", "type": "str"},
+        "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         location: str,
-        network_fabric_id: str,
-        vlan_id: int,
         tags: Optional[Dict[str, str]] = None,
         annotation: Optional[str] = None,
-        mtu: int = 1500,
+        network_fabric_id: Optional[str] = None,
+        vlan_id: Optional[int] = None,
+        mtu: Optional[int] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword network_fabric_id: ARM Resource ID of the Network Fabric. Required.
+        :keyword network_fabric_id: Network Fabric ARM resource id.
         :paramtype network_fabric_id: str
-        :keyword vlan_id: Vlan Identifier of the Network Fabric. Example: 501. Required.
+        :keyword vlan_id: vlanId. Example: 501.
         :paramtype vlan_id: int
-        :keyword mtu: Maximum transmission unit. Default value is 1500.
+        :keyword mtu: maximum transmission unit. Default value is 1500.
         :paramtype mtu: int
         """
         super().__init__(tags=tags, location=location, **kwargs)
         self.annotation = annotation
         self.network_fabric_id = network_fabric_id
         self.vlan_id = vlan_id
         self.mtu = mtu
-        self.configuration_state = None
-        self.provisioning_state = None
+        self.disabled_on_resources = None
         self.administrative_state = None
+        self.provisioning_state = None
 
 
-class L2IsolationDomainPatch(TagsUpdate):
-    """The L2 Isolation Domain patch resource definition.
+class L2IsolationDomainPatch(_serialization.Model):
+    """The L2IsolationDomain patch resource definition.
 
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar mtu: Maximum transmission unit. Default value is 1500.
+    :ivar mtu: maximum transmission unit. Default value is 1500.
     :vartype mtu: int
     """
 
-    _validation = {
-        "mtu": {"maximum": 9200, "minimum": 64},
-    }
-
     _attribute_map = {
         "tags": {"key": "tags", "type": "{str}"},
         "annotation": {"key": "properties.annotation", "type": "str"},
         "mtu": {"key": "properties.mtu", "type": "int"},
     }
 
     def __init__(
-        self, *, tags: Optional[Dict[str, str]] = None, annotation: Optional[str] = None, mtu: int = 1500, **kwargs: Any
+        self,
+        *,
+        tags: Optional[Dict[str, str]] = None,
+        annotation: Optional[str] = None,
+        mtu: Optional[int] = None,
+        **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword mtu: Maximum transmission unit. Default value is 1500.
+        :keyword mtu: maximum transmission unit. Default value is 1500.
         :paramtype mtu: int
         """
-        super().__init__(tags=tags, **kwargs)
+        super().__init__(**kwargs)
+        self.tags = tags
         self.annotation = annotation
         self.mtu = mtu
 
 
 class L2IsolationDomainPatchProperties(AnnotationResource):
-    """L2 Isolation Domain Patch Properties defines the patchable properties of the resource.
+    """L2IsolationDomainPatchProperties define the patchable resource properties.
 
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar mtu: Maximum transmission unit. Default value is 1500.
+    :ivar mtu: maximum transmission unit. Default value is 1500.
     :vartype mtu: int
     """
 
-    _validation = {
-        "mtu": {"maximum": 9200, "minimum": 64},
-    }
-
     _attribute_map = {
         "annotation": {"key": "annotation", "type": "str"},
         "mtu": {"key": "mtu", "type": "int"},
     }
 
-    def __init__(self, *, annotation: Optional[str] = None, mtu: int = 1500, **kwargs: Any) -> None:
+    def __init__(self, *, annotation: Optional[str] = None, mtu: Optional[int] = None, **kwargs: Any) -> None:
         """
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword mtu: Maximum transmission unit. Default value is 1500.
+        :keyword mtu: maximum transmission unit. Default value is 1500.
         :paramtype mtu: int
         """
         super().__init__(annotation=annotation, **kwargs)
         self.mtu = mtu
 
 
 class L2IsolationDomainProperties(AnnotationResource):
-    """L2Isolation Domain Properties defines the properties of the resource.
+    """L2IsolationDomainProperties define the resource properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar network_fabric_id: ARM Resource ID of the Network Fabric. Required.
+    :ivar network_fabric_id: Network Fabric ARM resource id. Required.
     :vartype network_fabric_id: str
-    :ivar vlan_id: Vlan Identifier of the Network Fabric. Example: 501. Required.
+    :ivar vlan_id: vlanId. Example: 501. Required.
     :vartype vlan_id: int
-    :ivar mtu: Maximum transmission unit. Default value is 1500.
+    :ivar mtu: maximum transmission unit. Default value is 1500.
     :vartype mtu: int
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
+    :ivar disabled_on_resources: List of resources the L2 Isolation Domain is disabled on. Can be
+     either entire NetworkFabric or NetworkRack.
+    :vartype disabled_on_resources: list[str]
+    :ivar administrative_state: state. Example: Enabled | Disabled. It indicates administrative
+     state of the isolationDomain, whether it is enabled or disabled. If enabled, the configuration
+     is applied on the devices. If disabled, the configuration is removed from the devices. Known
+     values are: "Enabled" and "Disabled".
     :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
+     ~azure.mgmt.managednetworkfabric.models.EnabledDisabledState
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
+    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
     """
 
     _validation = {
         "network_fabric_id": {"required": True},
-        "vlan_id": {"required": True, "maximum": 4094, "minimum": 100},
-        "mtu": {"maximum": 9200, "minimum": 64},
-        "configuration_state": {"readonly": True},
-        "provisioning_state": {"readonly": True},
+        "vlan_id": {"required": True},
+        "disabled_on_resources": {"readonly": True},
         "administrative_state": {"readonly": True},
+        "provisioning_state": {"readonly": True},
     }
 
     _attribute_map = {
         "annotation": {"key": "annotation", "type": "str"},
         "network_fabric_id": {"key": "networkFabricId", "type": "str"},
         "vlan_id": {"key": "vlanId", "type": "int"},
         "mtu": {"key": "mtu", "type": "int"},
-        "configuration_state": {"key": "configurationState", "type": "str"},
-        "provisioning_state": {"key": "provisioningState", "type": "str"},
+        "disabled_on_resources": {"key": "disabledOnResources", "type": "[str]"},
         "administrative_state": {"key": "administrativeState", "type": "str"},
+        "provisioning_state": {"key": "provisioningState", "type": "str"},
     }
 
     def __init__(
-        self, *, network_fabric_id: str, vlan_id: int, annotation: Optional[str] = None, mtu: int = 1500, **kwargs: Any
+        self,
+        *,
+        network_fabric_id: str,
+        vlan_id: int,
+        annotation: Optional[str] = None,
+        mtu: Optional[int] = None,
+        **kwargs: Any
     ) -> None:
         """
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword network_fabric_id: ARM Resource ID of the Network Fabric. Required.
+        :keyword network_fabric_id: Network Fabric ARM resource id. Required.
         :paramtype network_fabric_id: str
-        :keyword vlan_id: Vlan Identifier of the Network Fabric. Example: 501. Required.
+        :keyword vlan_id: vlanId. Example: 501. Required.
         :paramtype vlan_id: int
-        :keyword mtu: Maximum transmission unit. Default value is 1500.
+        :keyword mtu: maximum transmission unit. Default value is 1500.
         :paramtype mtu: int
         """
         super().__init__(annotation=annotation, **kwargs)
         self.network_fabric_id = network_fabric_id
         self.vlan_id = vlan_id
         self.mtu = mtu
-        self.configuration_state = None
-        self.provisioning_state = None
+        self.disabled_on_resources = None
         self.administrative_state = None
+        self.provisioning_state = None
 
 
 class L2IsolationDomainsListResult(_serialization.Model):
-    """List of L2 Isolation Domains.
+    """List of L2IsolationDomains.
 
-    :ivar value: Displays list of L2 Isolation Domain resources.
+    :ivar value: Displays list of L2IsolationDomain resources.
     :vartype value: list[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
     :ivar next_link: Url to follow for getting next page of resources.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[L2IsolationDomain]"},
@@ -5828,65 +3943,33 @@
         self,
         *,
         value: Optional[List["_models.L2IsolationDomain"]] = None,
         next_link: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword value: Displays list of L2 Isolation Domain resources.
+        :keyword value: Displays list of L2IsolationDomain resources.
         :paramtype value: list[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
         :keyword next_link: Url to follow for getting next page of resources.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
-class L3ExportRoutePolicy(_serialization.Model):
-    """Array of ARM Resource ID of the RoutePolicies.
-
-    :ivar export_ipv4_route_policy_id: ARM Resource ID of the RoutePolicy.
-    :vartype export_ipv4_route_policy_id: str
-    :ivar export_ipv6_route_policy_id: ARM Resource ID of the RoutePolicy.
-    :vartype export_ipv6_route_policy_id: str
-    """
-
-    _attribute_map = {
-        "export_ipv4_route_policy_id": {"key": "exportIpv4RoutePolicyId", "type": "str"},
-        "export_ipv6_route_policy_id": {"key": "exportIpv6RoutePolicyId", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        export_ipv4_route_policy_id: Optional[str] = None,
-        export_ipv6_route_policy_id: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword export_ipv4_route_policy_id: ARM Resource ID of the RoutePolicy.
-        :paramtype export_ipv4_route_policy_id: str
-        :keyword export_ipv6_route_policy_id: ARM Resource ID of the RoutePolicy.
-        :paramtype export_ipv6_route_policy_id: str
-        """
-        super().__init__(**kwargs)
-        self.export_ipv4_route_policy_id = export_ipv4_route_policy_id
-        self.export_ipv6_route_policy_id = export_ipv6_route_policy_id
-
-
 class L3IsolationDomain(TrackedResource):  # pylint: disable=too-many-instance-attributes
-    """The L3 Isolation Domain resource definition.
+    """The L3IsolationDomain resource definition.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -5902,45 +3985,49 @@
      values are: "True" and "False".
     :vartype redistribute_connected_subnets: str or
      ~azure.mgmt.managednetworkfabric.models.RedistributeConnectedSubnets
     :ivar redistribute_static_routes: Advertise Static Routes. Ex: "True" | "False". Known values
      are: "True" and "False".
     :vartype redistribute_static_routes: str or
      ~azure.mgmt.managednetworkfabric.models.RedistributeStaticRoutes
-    :ivar aggregate_route_configuration: Aggregate route configurations.
+    :ivar aggregate_route_configuration: List of Ipv4 and Ipv6 route configurations.
     :vartype aggregate_route_configuration:
      ~azure.mgmt.managednetworkfabric.models.AggregateRouteConfiguration
+    :ivar description: L3 Isolation Domain description.
+    :vartype description: str
     :ivar connected_subnet_route_policy: Connected Subnet RoutePolicy.
     :vartype connected_subnet_route_policy:
-     ~azure.mgmt.managednetworkfabric.models.ConnectedSubnetRoutePolicy
-    :ivar network_fabric_id: ARM Resource ID of the Network Fabric. Required.
+     ~azure.mgmt.managednetworkfabric.models.L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy
+    :ivar network_fabric_id: Network Fabric ARM resource id.
     :vartype network_fabric_id: str
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
+    :ivar disabled_on_resources: List of resources the L3 Isolation Domain is disabled on. Can be
+     either entire NetworkFabric or NetworkRack.
+    :vartype disabled_on_resources: list[str]
+    :ivar administrative_state: Administrative state of the IsolationDomain. Example: Enabled |
+     Disabled. Known values are: "Enabled" and "Disabled".
     :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
+     ~azure.mgmt.managednetworkfabric.models.EnabledDisabledState
+    :ivar option_b_disabled_on_resources: List of resources the OptionB is disabled on. Can be
+     either entire NetworkFabric or NetworkRack.
+    :vartype option_b_disabled_on_resources: list[str]
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
+    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
         "location": {"required": True},
-        "network_fabric_id": {"required": True},
-        "configuration_state": {"readonly": True},
-        "provisioning_state": {"readonly": True},
+        "disabled_on_resources": {"readonly": True},
         "administrative_state": {"readonly": True},
+        "option_b_disabled_on_resources": {"readonly": True},
+        "provisioning_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
@@ -5949,35 +4036,40 @@
         "annotation": {"key": "properties.annotation", "type": "str"},
         "redistribute_connected_subnets": {"key": "properties.redistributeConnectedSubnets", "type": "str"},
         "redistribute_static_routes": {"key": "properties.redistributeStaticRoutes", "type": "str"},
         "aggregate_route_configuration": {
             "key": "properties.aggregateRouteConfiguration",
             "type": "AggregateRouteConfiguration",
         },
+        "description": {"key": "properties.description", "type": "str"},
         "connected_subnet_route_policy": {
             "key": "properties.connectedSubnetRoutePolicy",
-            "type": "ConnectedSubnetRoutePolicy",
+            "type": "L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy",
         },
         "network_fabric_id": {"key": "properties.networkFabricId", "type": "str"},
-        "configuration_state": {"key": "properties.configurationState", "type": "str"},
-        "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
+        "disabled_on_resources": {"key": "properties.disabledOnResources", "type": "[str]"},
         "administrative_state": {"key": "properties.administrativeState", "type": "str"},
+        "option_b_disabled_on_resources": {"key": "properties.optionBDisabledOnResources", "type": "[str]"},
+        "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         location: str,
-        network_fabric_id: str,
         tags: Optional[Dict[str, str]] = None,
         annotation: Optional[str] = None,
         redistribute_connected_subnets: Union[str, "_models.RedistributeConnectedSubnets"] = "True",
         redistribute_static_routes: Union[str, "_models.RedistributeStaticRoutes"] = "False",
         aggregate_route_configuration: Optional["_models.AggregateRouteConfiguration"] = None,
-        connected_subnet_route_policy: Optional["_models.ConnectedSubnetRoutePolicy"] = None,
+        description: Optional[str] = None,
+        connected_subnet_route_policy: Optional[
+            "_models.L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy"
+        ] = None,
+        network_fabric_id: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
@@ -5987,353 +4079,352 @@
          Known values are: "True" and "False".
         :paramtype redistribute_connected_subnets: str or
          ~azure.mgmt.managednetworkfabric.models.RedistributeConnectedSubnets
         :keyword redistribute_static_routes: Advertise Static Routes. Ex: "True" | "False". Known
          values are: "True" and "False".
         :paramtype redistribute_static_routes: str or
          ~azure.mgmt.managednetworkfabric.models.RedistributeStaticRoutes
-        :keyword aggregate_route_configuration: Aggregate route configurations.
+        :keyword aggregate_route_configuration: List of Ipv4 and Ipv6 route configurations.
         :paramtype aggregate_route_configuration:
          ~azure.mgmt.managednetworkfabric.models.AggregateRouteConfiguration
+        :keyword description: L3 Isolation Domain description.
+        :paramtype description: str
         :keyword connected_subnet_route_policy: Connected Subnet RoutePolicy.
         :paramtype connected_subnet_route_policy:
-         ~azure.mgmt.managednetworkfabric.models.ConnectedSubnetRoutePolicy
-        :keyword network_fabric_id: ARM Resource ID of the Network Fabric. Required.
+         ~azure.mgmt.managednetworkfabric.models.L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy
+        :keyword network_fabric_id: Network Fabric ARM resource id.
         :paramtype network_fabric_id: str
         """
         super().__init__(tags=tags, location=location, **kwargs)
         self.annotation = annotation
         self.redistribute_connected_subnets = redistribute_connected_subnets
         self.redistribute_static_routes = redistribute_static_routes
         self.aggregate_route_configuration = aggregate_route_configuration
+        self.description = description
         self.connected_subnet_route_policy = connected_subnet_route_policy
         self.network_fabric_id = network_fabric_id
-        self.configuration_state = None
-        self.provisioning_state = None
+        self.disabled_on_resources = None
         self.administrative_state = None
+        self.option_b_disabled_on_resources = None
+        self.provisioning_state = None
 
 
-class L3IsolationDomainPatch(TagsUpdate):
-    """The L3 Isolation Domain patch resource definition.
+class L3IsolationDomainPatch(_serialization.Model):
+    """The L3IsolationDomain patch resource definition.
 
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
     :ivar redistribute_connected_subnets: Advertise Connected Subnets. Ex: "True" | "False". Known
      values are: "True" and "False".
     :vartype redistribute_connected_subnets: str or
      ~azure.mgmt.managednetworkfabric.models.RedistributeConnectedSubnets
     :ivar redistribute_static_routes: Advertise Static Routes. Ex: "True" | "False". Known values
      are: "True" and "False".
     :vartype redistribute_static_routes: str or
      ~azure.mgmt.managednetworkfabric.models.RedistributeStaticRoutes
-    :ivar aggregate_route_configuration: Aggregate route configurations.
+    :ivar aggregate_route_configuration: List of Ipv4 and Ipv6 route configurations.
     :vartype aggregate_route_configuration:
      ~azure.mgmt.managednetworkfabric.models.AggregateRouteConfiguration
+    :ivar description: L3 Isolation Domain description.
+    :vartype description: str
     :ivar connected_subnet_route_policy: Connected Subnet RoutePolicy.
     :vartype connected_subnet_route_policy:
-     ~azure.mgmt.managednetworkfabric.models.ConnectedSubnetRoutePolicy
+     ~azure.mgmt.managednetworkfabric.models.L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy
     """
 
     _attribute_map = {
         "tags": {"key": "tags", "type": "{str}"},
-        "annotation": {"key": "properties.annotation", "type": "str"},
         "redistribute_connected_subnets": {"key": "properties.redistributeConnectedSubnets", "type": "str"},
         "redistribute_static_routes": {"key": "properties.redistributeStaticRoutes", "type": "str"},
         "aggregate_route_configuration": {
             "key": "properties.aggregateRouteConfiguration",
             "type": "AggregateRouteConfiguration",
         },
+        "description": {"key": "properties.description", "type": "str"},
         "connected_subnet_route_policy": {
             "key": "properties.connectedSubnetRoutePolicy",
-            "type": "ConnectedSubnetRoutePolicy",
+            "type": "L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy",
         },
     }
 
     def __init__(
         self,
         *,
         tags: Optional[Dict[str, str]] = None,
-        annotation: Optional[str] = None,
         redistribute_connected_subnets: Union[str, "_models.RedistributeConnectedSubnets"] = "True",
         redistribute_static_routes: Union[str, "_models.RedistributeStaticRoutes"] = "False",
         aggregate_route_configuration: Optional["_models.AggregateRouteConfiguration"] = None,
-        connected_subnet_route_policy: Optional["_models.ConnectedSubnetRoutePolicy"] = None,
+        description: Optional[str] = None,
+        connected_subnet_route_policy: Optional[
+            "_models.L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy"
+        ] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
         :keyword redistribute_connected_subnets: Advertise Connected Subnets. Ex: "True" | "False".
          Known values are: "True" and "False".
         :paramtype redistribute_connected_subnets: str or
          ~azure.mgmt.managednetworkfabric.models.RedistributeConnectedSubnets
         :keyword redistribute_static_routes: Advertise Static Routes. Ex: "True" | "False". Known
          values are: "True" and "False".
         :paramtype redistribute_static_routes: str or
          ~azure.mgmt.managednetworkfabric.models.RedistributeStaticRoutes
-        :keyword aggregate_route_configuration: Aggregate route configurations.
+        :keyword aggregate_route_configuration: List of Ipv4 and Ipv6 route configurations.
         :paramtype aggregate_route_configuration:
          ~azure.mgmt.managednetworkfabric.models.AggregateRouteConfiguration
+        :keyword description: L3 Isolation Domain description.
+        :paramtype description: str
         :keyword connected_subnet_route_policy: Connected Subnet RoutePolicy.
         :paramtype connected_subnet_route_policy:
-         ~azure.mgmt.managednetworkfabric.models.ConnectedSubnetRoutePolicy
+         ~azure.mgmt.managednetworkfabric.models.L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy
         """
-        super().__init__(tags=tags, **kwargs)
-        self.annotation = annotation
+        super().__init__(**kwargs)
+        self.tags = tags
         self.redistribute_connected_subnets = redistribute_connected_subnets
         self.redistribute_static_routes = redistribute_static_routes
         self.aggregate_route_configuration = aggregate_route_configuration
+        self.description = description
         self.connected_subnet_route_policy = connected_subnet_route_policy
 
 
-class L3IsolationDomainPatchableProperties(_serialization.Model):
-    """L3 Isolation Domain Patch Properties defines the patchable properties of the resource.
+class L3IsolationDomainPatchProperties(_serialization.Model):
+    """L3IsolationDomainPatchProperties define the patch resource properties.
 
     :ivar redistribute_connected_subnets: Advertise Connected Subnets. Ex: "True" | "False". Known
      values are: "True" and "False".
     :vartype redistribute_connected_subnets: str or
      ~azure.mgmt.managednetworkfabric.models.RedistributeConnectedSubnets
     :ivar redistribute_static_routes: Advertise Static Routes. Ex: "True" | "False". Known values
      are: "True" and "False".
     :vartype redistribute_static_routes: str or
      ~azure.mgmt.managednetworkfabric.models.RedistributeStaticRoutes
-    :ivar aggregate_route_configuration: Aggregate route configurations.
+    :ivar aggregate_route_configuration: List of Ipv4 and Ipv6 route configurations.
     :vartype aggregate_route_configuration:
      ~azure.mgmt.managednetworkfabric.models.AggregateRouteConfiguration
+    :ivar description: L3 Isolation Domain description.
+    :vartype description: str
     :ivar connected_subnet_route_policy: Connected Subnet RoutePolicy.
     :vartype connected_subnet_route_policy:
-     ~azure.mgmt.managednetworkfabric.models.ConnectedSubnetRoutePolicy
+     ~azure.mgmt.managednetworkfabric.models.L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy
     """
 
     _attribute_map = {
         "redistribute_connected_subnets": {"key": "redistributeConnectedSubnets", "type": "str"},
         "redistribute_static_routes": {"key": "redistributeStaticRoutes", "type": "str"},
         "aggregate_route_configuration": {"key": "aggregateRouteConfiguration", "type": "AggregateRouteConfiguration"},
-        "connected_subnet_route_policy": {"key": "connectedSubnetRoutePolicy", "type": "ConnectedSubnetRoutePolicy"},
+        "description": {"key": "description", "type": "str"},
+        "connected_subnet_route_policy": {
+            "key": "connectedSubnetRoutePolicy",
+            "type": "L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy",
+        },
     }
 
     def __init__(
         self,
         *,
         redistribute_connected_subnets: Union[str, "_models.RedistributeConnectedSubnets"] = "True",
         redistribute_static_routes: Union[str, "_models.RedistributeStaticRoutes"] = "False",
         aggregate_route_configuration: Optional["_models.AggregateRouteConfiguration"] = None,
-        connected_subnet_route_policy: Optional["_models.ConnectedSubnetRoutePolicy"] = None,
+        description: Optional[str] = None,
+        connected_subnet_route_policy: Optional[
+            "_models.L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy"
+        ] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword redistribute_connected_subnets: Advertise Connected Subnets. Ex: "True" | "False".
          Known values are: "True" and "False".
         :paramtype redistribute_connected_subnets: str or
          ~azure.mgmt.managednetworkfabric.models.RedistributeConnectedSubnets
         :keyword redistribute_static_routes: Advertise Static Routes. Ex: "True" | "False". Known
          values are: "True" and "False".
         :paramtype redistribute_static_routes: str or
          ~azure.mgmt.managednetworkfabric.models.RedistributeStaticRoutes
-        :keyword aggregate_route_configuration: Aggregate route configurations.
+        :keyword aggregate_route_configuration: List of Ipv4 and Ipv6 route configurations.
         :paramtype aggregate_route_configuration:
          ~azure.mgmt.managednetworkfabric.models.AggregateRouteConfiguration
+        :keyword description: L3 Isolation Domain description.
+        :paramtype description: str
         :keyword connected_subnet_route_policy: Connected Subnet RoutePolicy.
         :paramtype connected_subnet_route_policy:
-         ~azure.mgmt.managednetworkfabric.models.ConnectedSubnetRoutePolicy
+         ~azure.mgmt.managednetworkfabric.models.L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy
         """
         super().__init__(**kwargs)
         self.redistribute_connected_subnets = redistribute_connected_subnets
         self.redistribute_static_routes = redistribute_static_routes
         self.aggregate_route_configuration = aggregate_route_configuration
+        self.description = description
         self.connected_subnet_route_policy = connected_subnet_route_policy
 
 
-class L3IsolationDomainPatchProperties(AnnotationResource, L3IsolationDomainPatchableProperties):
-    """Resource properties.
+class L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy(_serialization.Model):
+    """Connected Subnet RoutePolicy.
 
-    :ivar redistribute_connected_subnets: Advertise Connected Subnets. Ex: "True" | "False". Known
-     values are: "True" and "False".
-    :vartype redistribute_connected_subnets: str or
-     ~azure.mgmt.managednetworkfabric.models.RedistributeConnectedSubnets
-    :ivar redistribute_static_routes: Advertise Static Routes. Ex: "True" | "False". Known values
-     are: "True" and "False".
-    :vartype redistribute_static_routes: str or
-     ~azure.mgmt.managednetworkfabric.models.RedistributeStaticRoutes
-    :ivar aggregate_route_configuration: Aggregate route configurations.
-    :vartype aggregate_route_configuration:
-     ~azure.mgmt.managednetworkfabric.models.AggregateRouteConfiguration
-    :ivar connected_subnet_route_policy: Connected Subnet RoutePolicy.
-    :vartype connected_subnet_route_policy:
-     ~azure.mgmt.managednetworkfabric.models.ConnectedSubnetRoutePolicy
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar export_route_policy_id: exportRoutePolicyId value.
+    :vartype export_route_policy_id: str
+    :ivar administrative_state: Enabled/Disabled connected subnet route policy. Ex: Enabled |
+     Disabled. Known values are: "Enabled" and "Disabled".
+    :vartype administrative_state: str or
+     ~azure.mgmt.managednetworkfabric.models.EnabledDisabledState
     """
 
+    _validation = {
+        "administrative_state": {"readonly": True},
+    }
+
     _attribute_map = {
-        "redistribute_connected_subnets": {"key": "redistributeConnectedSubnets", "type": "str"},
-        "redistribute_static_routes": {"key": "redistributeStaticRoutes", "type": "str"},
-        "aggregate_route_configuration": {"key": "aggregateRouteConfiguration", "type": "AggregateRouteConfiguration"},
-        "connected_subnet_route_policy": {"key": "connectedSubnetRoutePolicy", "type": "ConnectedSubnetRoutePolicy"},
-        "annotation": {"key": "annotation", "type": "str"},
+        "export_route_policy_id": {"key": "exportRoutePolicyId", "type": "str"},
+        "administrative_state": {"key": "administrativeState", "type": "str"},
     }
 
-    def __init__(
-        self,
-        *,
-        redistribute_connected_subnets: Union[str, "_models.RedistributeConnectedSubnets"] = "True",
-        redistribute_static_routes: Union[str, "_models.RedistributeStaticRoutes"] = "False",
-        aggregate_route_configuration: Optional["_models.AggregateRouteConfiguration"] = None,
-        connected_subnet_route_policy: Optional["_models.ConnectedSubnetRoutePolicy"] = None,
-        annotation: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
+    def __init__(self, *, export_route_policy_id: Optional[str] = None, **kwargs: Any) -> None:
         """
-        :keyword redistribute_connected_subnets: Advertise Connected Subnets. Ex: "True" | "False".
-         Known values are: "True" and "False".
-        :paramtype redistribute_connected_subnets: str or
-         ~azure.mgmt.managednetworkfabric.models.RedistributeConnectedSubnets
-        :keyword redistribute_static_routes: Advertise Static Routes. Ex: "True" | "False". Known
-         values are: "True" and "False".
-        :paramtype redistribute_static_routes: str or
-         ~azure.mgmt.managednetworkfabric.models.RedistributeStaticRoutes
-        :keyword aggregate_route_configuration: Aggregate route configurations.
-        :paramtype aggregate_route_configuration:
-         ~azure.mgmt.managednetworkfabric.models.AggregateRouteConfiguration
-        :keyword connected_subnet_route_policy: Connected Subnet RoutePolicy.
-        :paramtype connected_subnet_route_policy:
-         ~azure.mgmt.managednetworkfabric.models.ConnectedSubnetRoutePolicy
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
+        :keyword export_route_policy_id: exportRoutePolicyId value.
+        :paramtype export_route_policy_id: str
         """
-        super().__init__(
-            annotation=annotation,
-            redistribute_connected_subnets=redistribute_connected_subnets,
-            redistribute_static_routes=redistribute_static_routes,
-            aggregate_route_configuration=aggregate_route_configuration,
-            connected_subnet_route_policy=connected_subnet_route_policy,
-            **kwargs
-        )
-        self.redistribute_connected_subnets = redistribute_connected_subnets
-        self.redistribute_static_routes = redistribute_static_routes
-        self.aggregate_route_configuration = aggregate_route_configuration
-        self.connected_subnet_route_policy = connected_subnet_route_policy
-        self.annotation = annotation
+        super().__init__(**kwargs)
+        self.export_route_policy_id = export_route_policy_id
+        self.administrative_state = None
 
 
-class L3IsolationDomainProperties(AnnotationResource, L3IsolationDomainPatchableProperties):
-    """L3 Isolation Domain Properties defines the properties of the resource.
+class L3IsolationDomainProperties(
+    AnnotationResource, L3IsolationDomainPatchProperties
+):  # pylint: disable=too-many-instance-attributes
+    """L3IsolationDomainProperties define the resource properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar redistribute_connected_subnets: Advertise Connected Subnets. Ex: "True" | "False". Known
      values are: "True" and "False".
     :vartype redistribute_connected_subnets: str or
      ~azure.mgmt.managednetworkfabric.models.RedistributeConnectedSubnets
     :ivar redistribute_static_routes: Advertise Static Routes. Ex: "True" | "False". Known values
      are: "True" and "False".
     :vartype redistribute_static_routes: str or
      ~azure.mgmt.managednetworkfabric.models.RedistributeStaticRoutes
-    :ivar aggregate_route_configuration: Aggregate route configurations.
+    :ivar aggregate_route_configuration: List of Ipv4 and Ipv6 route configurations.
     :vartype aggregate_route_configuration:
      ~azure.mgmt.managednetworkfabric.models.AggregateRouteConfiguration
+    :ivar description: L3 Isolation Domain description.
+    :vartype description: str
     :ivar connected_subnet_route_policy: Connected Subnet RoutePolicy.
     :vartype connected_subnet_route_policy:
-     ~azure.mgmt.managednetworkfabric.models.ConnectedSubnetRoutePolicy
+     ~azure.mgmt.managednetworkfabric.models.L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar network_fabric_id: ARM Resource ID of the Network Fabric. Required.
+    :ivar network_fabric_id: Network Fabric ARM resource id. Required.
     :vartype network_fabric_id: str
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
+    :ivar disabled_on_resources: List of resources the L3 Isolation Domain is disabled on. Can be
+     either entire NetworkFabric or NetworkRack.
+    :vartype disabled_on_resources: list[str]
+    :ivar administrative_state: Administrative state of the IsolationDomain. Example: Enabled |
+     Disabled. Known values are: "Enabled" and "Disabled".
     :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
+     ~azure.mgmt.managednetworkfabric.models.EnabledDisabledState
+    :ivar option_b_disabled_on_resources: List of resources the OptionB is disabled on. Can be
+     either entire NetworkFabric or NetworkRack.
+    :vartype option_b_disabled_on_resources: list[str]
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
+    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
     """
 
     _validation = {
         "network_fabric_id": {"required": True},
-        "configuration_state": {"readonly": True},
-        "provisioning_state": {"readonly": True},
+        "disabled_on_resources": {"readonly": True},
         "administrative_state": {"readonly": True},
+        "option_b_disabled_on_resources": {"readonly": True},
+        "provisioning_state": {"readonly": True},
     }
 
     _attribute_map = {
         "redistribute_connected_subnets": {"key": "redistributeConnectedSubnets", "type": "str"},
         "redistribute_static_routes": {"key": "redistributeStaticRoutes", "type": "str"},
         "aggregate_route_configuration": {"key": "aggregateRouteConfiguration", "type": "AggregateRouteConfiguration"},
-        "connected_subnet_route_policy": {"key": "connectedSubnetRoutePolicy", "type": "ConnectedSubnetRoutePolicy"},
+        "description": {"key": "description", "type": "str"},
+        "connected_subnet_route_policy": {
+            "key": "connectedSubnetRoutePolicy",
+            "type": "L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy",
+        },
         "annotation": {"key": "annotation", "type": "str"},
         "network_fabric_id": {"key": "networkFabricId", "type": "str"},
-        "configuration_state": {"key": "configurationState", "type": "str"},
-        "provisioning_state": {"key": "provisioningState", "type": "str"},
+        "disabled_on_resources": {"key": "disabledOnResources", "type": "[str]"},
         "administrative_state": {"key": "administrativeState", "type": "str"},
+        "option_b_disabled_on_resources": {"key": "optionBDisabledOnResources", "type": "[str]"},
+        "provisioning_state": {"key": "provisioningState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         network_fabric_id: str,
         redistribute_connected_subnets: Union[str, "_models.RedistributeConnectedSubnets"] = "True",
         redistribute_static_routes: Union[str, "_models.RedistributeStaticRoutes"] = "False",
         aggregate_route_configuration: Optional["_models.AggregateRouteConfiguration"] = None,
-        connected_subnet_route_policy: Optional["_models.ConnectedSubnetRoutePolicy"] = None,
+        description: Optional[str] = None,
+        connected_subnet_route_policy: Optional[
+            "_models.L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy"
+        ] = None,
         annotation: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword redistribute_connected_subnets: Advertise Connected Subnets. Ex: "True" | "False".
          Known values are: "True" and "False".
         :paramtype redistribute_connected_subnets: str or
          ~azure.mgmt.managednetworkfabric.models.RedistributeConnectedSubnets
         :keyword redistribute_static_routes: Advertise Static Routes. Ex: "True" | "False". Known
          values are: "True" and "False".
         :paramtype redistribute_static_routes: str or
          ~azure.mgmt.managednetworkfabric.models.RedistributeStaticRoutes
-        :keyword aggregate_route_configuration: Aggregate route configurations.
+        :keyword aggregate_route_configuration: List of Ipv4 and Ipv6 route configurations.
         :paramtype aggregate_route_configuration:
          ~azure.mgmt.managednetworkfabric.models.AggregateRouteConfiguration
+        :keyword description: L3 Isolation Domain description.
+        :paramtype description: str
         :keyword connected_subnet_route_policy: Connected Subnet RoutePolicy.
         :paramtype connected_subnet_route_policy:
-         ~azure.mgmt.managednetworkfabric.models.ConnectedSubnetRoutePolicy
+         ~azure.mgmt.managednetworkfabric.models.L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword network_fabric_id: ARM Resource ID of the Network Fabric. Required.
+        :keyword network_fabric_id: Network Fabric ARM resource id. Required.
         :paramtype network_fabric_id: str
         """
         super().__init__(
             annotation=annotation,
             redistribute_connected_subnets=redistribute_connected_subnets,
             redistribute_static_routes=redistribute_static_routes,
             aggregate_route_configuration=aggregate_route_configuration,
+            description=description,
             connected_subnet_route_policy=connected_subnet_route_policy,
             **kwargs
         )
         self.redistribute_connected_subnets = redistribute_connected_subnets
         self.redistribute_static_routes = redistribute_static_routes
         self.aggregate_route_configuration = aggregate_route_configuration
+        self.description = description
         self.connected_subnet_route_policy = connected_subnet_route_policy
         self.network_fabric_id = network_fabric_id
-        self.configuration_state = None
-        self.provisioning_state = None
+        self.disabled_on_resources = None
         self.administrative_state = None
+        self.option_b_disabled_on_resources = None
+        self.provisioning_state = None
         self.annotation = annotation
 
 
 class L3IsolationDomainsListResult(_serialization.Model):
-    """List of L3 Isolation Domains.
+    """List of L3IsolationDomains.
 
-    :ivar value: List of L3 Isolation Domain resources.
+    :ivar value: List of L3IsolationDomain resources.
     :vartype value: list[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
     :ivar next_link: Url to follow for getting next page of resources.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[L3IsolationDomain]"},
@@ -6344,96 +4435,182 @@
         self,
         *,
         value: Optional[List["_models.L3IsolationDomain"]] = None,
         next_link: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword value: List of L3 Isolation Domain resources.
+        :keyword value: List of L3IsolationDomain resources.
         :paramtype value: list[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
         :keyword next_link: Url to follow for getting next page of resources.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
-class L3OptionBProperties(_serialization.Model):
-    """Option B configuration.
-
-    :ivar import_route_targets: RouteTargets to be applied. This is used for the backward
-     compatibility.
-    :vartype import_route_targets: list[str]
-    :ivar export_route_targets: RouteTargets to be applied. This is used for the backward
-     compatibility.
-    :vartype export_route_targets: list[str]
-    :ivar route_targets: RouteTargets to be applied.
-    :vartype route_targets: ~azure.mgmt.managednetworkfabric.models.RouteTargetInformation
-    """
-
-    _attribute_map = {
-        "import_route_targets": {"key": "importRouteTargets", "type": "[str]"},
-        "export_route_targets": {"key": "exportRouteTargets", "type": "[str]"},
-        "route_targets": {"key": "routeTargets", "type": "RouteTargetInformation"},
-    }
-
-    def __init__(
-        self,
-        *,
-        import_route_targets: Optional[List[str]] = None,
-        export_route_targets: Optional[List[str]] = None,
-        route_targets: Optional["_models.RouteTargetInformation"] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword import_route_targets: RouteTargets to be applied. This is used for the backward
-         compatibility.
-        :paramtype import_route_targets: list[str]
-        :keyword export_route_targets: RouteTargets to be applied. This is used for the backward
-         compatibility.
-        :paramtype export_route_targets: list[str]
-        :keyword route_targets: RouteTargets to be applied.
-        :paramtype route_targets: ~azure.mgmt.managednetworkfabric.models.RouteTargetInformation
-        """
-        super().__init__(**kwargs)
-        self.import_route_targets = import_route_targets
-        self.export_route_targets = export_route_targets
-        self.route_targets = route_targets
+class Layer2Configuration(_serialization.Model):
+    """layer2Configuration.
 
+    Variables are only populated by the server, and will be ignored when sending a request.
 
-class Layer2Configuration(_serialization.Model):
-    """Common properties for Layer2 Configuration.
+    All required parameters must be populated in order to send to Azure.
 
+    :ivar port_count: Number of ports connected between PE/CE. Maximum value depends on FabricSKU.
+    :vartype port_count: int
     :ivar mtu: MTU of the packets between PE & CE.
     :vartype mtu: int
     :ivar interfaces: List of network device interfaces resource IDs.
     :vartype interfaces: list[str]
     """
 
     _validation = {
-        "mtu": {"maximum": 9200, "minimum": 64},
-        "interfaces": {"min_items": 1},
+        "mtu": {"required": True, "maximum": 9000, "minimum": 1500},
+        "interfaces": {"readonly": True},
     }
 
     _attribute_map = {
+        "port_count": {"key": "portCount", "type": "int"},
         "mtu": {"key": "mtu", "type": "int"},
         "interfaces": {"key": "interfaces", "type": "[str]"},
     }
 
-    def __init__(self, *, mtu: int = 1500, interfaces: Optional[List[str]] = None, **kwargs: Any) -> None:
+    def __init__(self, *, mtu: int = 1500, port_count: Optional[int] = None, **kwargs: Any) -> None:
         """
+        :keyword port_count: Number of ports connected between PE/CE. Maximum value depends on
+         FabricSKU.
+        :paramtype port_count: int
         :keyword mtu: MTU of the packets between PE & CE.
         :paramtype mtu: int
-        :keyword interfaces: List of network device interfaces resource IDs.
-        :paramtype interfaces: list[str]
         """
         super().__init__(**kwargs)
+        self.port_count = port_count
         self.mtu = mtu
-        self.interfaces = interfaces
+        self.interfaces = None
+
+
+class Layer3Configuration(Layer3IpPrefixProperties):
+    """layer3Configuration.
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar primary_ipv4_prefix: IPv4 Address Prefix of CE-PE interconnect links. Example:
+     172.31.0.0/31. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
+    :vartype primary_ipv4_prefix: str
+    :ivar primary_ipv6_prefix: IPv6 Address Prefix of CE-PE interconnect links. Example:
+     3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
+    :vartype primary_ipv6_prefix: str
+    :ivar secondary_ipv4_prefix: Secondary IPv4 Address Prefix of CE-PE interconnect links.
+     Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
+    :vartype secondary_ipv4_prefix: str
+    :ivar secondary_ipv6_prefix: Secondary IPv6 Address Prefix of CE-PE interconnect links.
+     Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can
+     be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st
+     and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs
+     are to be configured on PE1 and PE2 for Option B interfaces.
+    :vartype secondary_ipv6_prefix: str
+    :ivar import_route_policy_id: importRoutePolicyId.
+    :vartype import_route_policy_id: str
+    :ivar export_route_policy_id: exportRoutePolicyId.
+    :vartype export_route_policy_id: str
+    :ivar peer_asn: ASN of PE devices for CE/PE connectivity.Example : 28.
+    :vartype peer_asn: int
+    :ivar vlan_id: VLAN for CE/PE Layer 3 connectivity.Example : 501.
+    :vartype vlan_id: int
+    :ivar fabric_asn: ASN of CE devices for CE/PE connectivity.
+    :vartype fabric_asn: int
+    """
+
+    _validation = {
+        "peer_asn": {"maximum": 65535, "minimum": 1},
+        "vlan_id": {"maximum": 4095, "minimum": 501},
+        "fabric_asn": {"readonly": True, "maximum": 65535, "minimum": 1},
+    }
+
+    _attribute_map = {
+        "primary_ipv4_prefix": {"key": "primaryIpv4Prefix", "type": "str"},
+        "primary_ipv6_prefix": {"key": "primaryIpv6Prefix", "type": "str"},
+        "secondary_ipv4_prefix": {"key": "secondaryIpv4Prefix", "type": "str"},
+        "secondary_ipv6_prefix": {"key": "secondaryIpv6Prefix", "type": "str"},
+        "import_route_policy_id": {"key": "importRoutePolicyId", "type": "str"},
+        "export_route_policy_id": {"key": "exportRoutePolicyId", "type": "str"},
+        "peer_asn": {"key": "peerASN", "type": "int"},
+        "vlan_id": {"key": "vlanId", "type": "int"},
+        "fabric_asn": {"key": "fabricASN", "type": "int"},
+    }
+
+    def __init__(
+        self,
+        *,
+        primary_ipv4_prefix: Optional[str] = None,
+        primary_ipv6_prefix: Optional[str] = None,
+        secondary_ipv4_prefix: Optional[str] = None,
+        secondary_ipv6_prefix: Optional[str] = None,
+        import_route_policy_id: Optional[str] = None,
+        export_route_policy_id: Optional[str] = None,
+        peer_asn: Optional[int] = None,
+        vlan_id: Optional[int] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword primary_ipv4_prefix: IPv4 Address Prefix of CE-PE interconnect links. Example:
+         172.31.0.0/31. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
+        :paramtype primary_ipv4_prefix: str
+        :keyword primary_ipv6_prefix: IPv6 Address Prefix of CE-PE interconnect links. Example:
+         3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
+        :paramtype primary_ipv6_prefix: str
+        :keyword secondary_ipv4_prefix: Secondary IPv4 Address Prefix of CE-PE interconnect links.
+         Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
+        :paramtype secondary_ipv4_prefix: str
+        :keyword secondary_ipv6_prefix: Secondary IPv6 Address Prefix of CE-PE interconnect links.
+         Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can
+         be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st
+         and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs
+         are to be configured on PE1 and PE2 for Option B interfaces.
+        :paramtype secondary_ipv6_prefix: str
+        :keyword import_route_policy_id: importRoutePolicyId.
+        :paramtype import_route_policy_id: str
+        :keyword export_route_policy_id: exportRoutePolicyId.
+        :paramtype export_route_policy_id: str
+        :keyword peer_asn: ASN of PE devices for CE/PE connectivity.Example : 28.
+        :paramtype peer_asn: int
+        :keyword vlan_id: VLAN for CE/PE Layer 3 connectivity.Example : 501.
+        :paramtype vlan_id: int
+        """
+        super().__init__(
+            primary_ipv4_prefix=primary_ipv4_prefix,
+            primary_ipv6_prefix=primary_ipv6_prefix,
+            secondary_ipv4_prefix=secondary_ipv4_prefix,
+            secondary_ipv6_prefix=secondary_ipv6_prefix,
+            **kwargs
+        )
+        self.import_route_policy_id = import_route_policy_id
+        self.export_route_policy_id = export_route_policy_id
+        self.peer_asn = peer_asn
+        self.vlan_id = vlan_id
+        self.fabric_asn = None
 
 
 class ManagedResourceGroupConfiguration(_serialization.Model):
     """Managed Resource Group configuration properties.
 
     :ivar name: The NFC service will be hosted in a Managed resource group.
     :vartype name: str
@@ -6454,65 +4631,23 @@
         :paramtype location: str
         """
         super().__init__(**kwargs)
         self.name = name
         self.location = location
 
 
-class ManagementNetworkConfigurationPatchableProperties(_serialization.Model):
-    """Configuration to be used to setup the management network.
-
-    :ivar infrastructure_vpn_configuration: VPN Configuration properties.
-    :vartype infrastructure_vpn_configuration:
-     ~azure.mgmt.managednetworkfabric.models.VpnConfigurationPatchableProperties
-    :ivar workload_vpn_configuration: VPN Configuration properties.
-    :vartype workload_vpn_configuration:
-     ~azure.mgmt.managednetworkfabric.models.VpnConfigurationPatchableProperties
-    """
-
-    _attribute_map = {
-        "infrastructure_vpn_configuration": {
-            "key": "infrastructureVpnConfiguration",
-            "type": "VpnConfigurationPatchableProperties",
-        },
-        "workload_vpn_configuration": {
-            "key": "workloadVpnConfiguration",
-            "type": "VpnConfigurationPatchableProperties",
-        },
-    }
-
-    def __init__(
-        self,
-        *,
-        infrastructure_vpn_configuration: Optional["_models.VpnConfigurationPatchableProperties"] = None,
-        workload_vpn_configuration: Optional["_models.VpnConfigurationPatchableProperties"] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword infrastructure_vpn_configuration: VPN Configuration properties.
-        :paramtype infrastructure_vpn_configuration:
-         ~azure.mgmt.managednetworkfabric.models.VpnConfigurationPatchableProperties
-        :keyword workload_vpn_configuration: VPN Configuration properties.
-        :paramtype workload_vpn_configuration:
-         ~azure.mgmt.managednetworkfabric.models.VpnConfigurationPatchableProperties
-        """
-        super().__init__(**kwargs)
-        self.infrastructure_vpn_configuration = infrastructure_vpn_configuration
-        self.workload_vpn_configuration = workload_vpn_configuration
-
-
-class ManagementNetworkConfigurationProperties(_serialization.Model):
+class ManagementNetworkConfiguration(_serialization.Model):
     """Configuration to be used to setup the management network.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar infrastructure_vpn_configuration: VPN Configuration properties. Required.
+    :ivar infrastructure_vpn_configuration: Configuration for infrastructure vpn. Required.
     :vartype infrastructure_vpn_configuration:
      ~azure.mgmt.managednetworkfabric.models.VpnConfigurationProperties
-    :ivar workload_vpn_configuration: VPN Configuration properties. Required.
+    :ivar workload_vpn_configuration: Configuration for workload vpn. Required.
     :vartype workload_vpn_configuration:
      ~azure.mgmt.managednetworkfabric.models.VpnConfigurationProperties
     """
 
     _validation = {
         "infrastructure_vpn_configuration": {"required": True},
         "workload_vpn_configuration": {"required": True},
@@ -6530,18 +4665,18 @@
         self,
         *,
         infrastructure_vpn_configuration: "_models.VpnConfigurationProperties",
         workload_vpn_configuration: "_models.VpnConfigurationProperties",
         **kwargs: Any
     ) -> None:
         """
-        :keyword infrastructure_vpn_configuration: VPN Configuration properties. Required.
+        :keyword infrastructure_vpn_configuration: Configuration for infrastructure vpn. Required.
         :paramtype infrastructure_vpn_configuration:
          ~azure.mgmt.managednetworkfabric.models.VpnConfigurationProperties
-        :keyword workload_vpn_configuration: VPN Configuration properties. Required.
+        :keyword workload_vpn_configuration: Configuration for workload vpn. Required.
         :paramtype workload_vpn_configuration:
          ~azure.mgmt.managednetworkfabric.models.VpnConfigurationProperties
         """
         super().__init__(**kwargs)
         self.infrastructure_vpn_configuration = infrastructure_vpn_configuration
         self.workload_vpn_configuration = workload_vpn_configuration
 
@@ -6549,340 +4684,46 @@
 class NeighborAddress(_serialization.Model):
     """Neighbor Address properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar address: IP Address.
     :vartype address: str
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
+    :ivar operational_state: OperationalState of the NeighborAddress.
+    :vartype operational_state: str
     """
 
     _validation = {
-        "address": {"min_length": 1},
-        "configuration_state": {"readonly": True},
+        "operational_state": {"readonly": True},
     }
 
     _attribute_map = {
         "address": {"key": "address", "type": "str"},
-        "configuration_state": {"key": "configurationState", "type": "str"},
+        "operational_state": {"key": "operationalState", "type": "str"},
     }
 
     def __init__(self, *, address: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword address: IP Address.
         :paramtype address: str
         """
         super().__init__(**kwargs)
         self.address = address
-        self.configuration_state = None
-
-
-class NeighborGroup(TrackedResource):  # pylint: disable=too-many-instance-attributes
-    """Defines the Neighbor Group.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
-    :vartype id: str
-    :ivar name: The name of the resource.
-    :vartype name: str
-    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
-     "Microsoft.Storage/storageAccounts".
-    :vartype type: str
-    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
-     information.
-    :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
-    :ivar location: The geo-location where the resource lives. Required.
-    :vartype location: str
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar destination: An array of destination IPv4 Addresses or IPv6 Addresses.
-    :vartype destination: ~azure.mgmt.managednetworkfabric.models.NeighborGroupDestination
-    :ivar network_tap_ids: List of NetworkTap IDs where neighbor group is associated.
-    :vartype network_tap_ids: list[str]
-    :ivar network_tap_rule_ids: List of Network Tap Rule IDs where neighbor group is associated.
-    :vartype network_tap_rule_ids: list[str]
-    :ivar provisioning_state: The provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    """
-
-    _validation = {
-        "id": {"readonly": True},
-        "name": {"readonly": True},
-        "type": {"readonly": True},
-        "system_data": {"readonly": True},
-        "location": {"required": True},
-        "network_tap_ids": {"readonly": True},
-        "network_tap_rule_ids": {"readonly": True},
-        "provisioning_state": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "id": {"key": "id", "type": "str"},
-        "name": {"key": "name", "type": "str"},
-        "type": {"key": "type", "type": "str"},
-        "system_data": {"key": "systemData", "type": "SystemData"},
-        "tags": {"key": "tags", "type": "{str}"},
-        "location": {"key": "location", "type": "str"},
-        "annotation": {"key": "properties.annotation", "type": "str"},
-        "destination": {"key": "properties.destination", "type": "NeighborGroupDestination"},
-        "network_tap_ids": {"key": "properties.networkTapIds", "type": "[str]"},
-        "network_tap_rule_ids": {"key": "properties.networkTapRuleIds", "type": "[str]"},
-        "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        location: str,
-        tags: Optional[Dict[str, str]] = None,
-        annotation: Optional[str] = None,
-        destination: Optional["_models.NeighborGroupDestination"] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
-        :keyword location: The geo-location where the resource lives. Required.
-        :paramtype location: str
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword destination: An array of destination IPv4 Addresses or IPv6 Addresses.
-        :paramtype destination: ~azure.mgmt.managednetworkfabric.models.NeighborGroupDestination
-        """
-        super().__init__(tags=tags, location=location, **kwargs)
-        self.annotation = annotation
-        self.destination = destination
-        self.network_tap_ids = None
-        self.network_tap_rule_ids = None
-        self.provisioning_state = None
-
-
-class NeighborGroupDestination(_serialization.Model):
-    """An array of destination IPv4 Addresses or IPv6 Addresses.
-
-    :ivar ipv4_addresses: Array of IPv4 Addresses.
-    :vartype ipv4_addresses: list[str]
-    :ivar ipv6_addresses: Array of IPv6 Addresses.
-    :vartype ipv6_addresses: list[str]
-    """
-
-    _validation = {
-        "ipv4_addresses": {"max_items": 16, "min_items": 0},
-        "ipv6_addresses": {"max_items": 16, "min_items": 0},
-    }
-
-    _attribute_map = {
-        "ipv4_addresses": {"key": "ipv4Addresses", "type": "[str]"},
-        "ipv6_addresses": {"key": "ipv6Addresses", "type": "[str]"},
-    }
-
-    def __init__(
-        self, *, ipv4_addresses: Optional[List[str]] = None, ipv6_addresses: Optional[List[str]] = None, **kwargs: Any
-    ) -> None:
-        """
-        :keyword ipv4_addresses: Array of IPv4 Addresses.
-        :paramtype ipv4_addresses: list[str]
-        :keyword ipv6_addresses: Array of IPv6 Addresses.
-        :paramtype ipv6_addresses: list[str]
-        """
-        super().__init__(**kwargs)
-        self.ipv4_addresses = ipv4_addresses
-        self.ipv6_addresses = ipv6_addresses
-
-
-class NeighborGroupPatch(TagsUpdate):
-    """The Neighbor Group Patch definition.
-
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar destination: An array of destination IPv4 Addresses or IPv6 Addresses.
-    :vartype destination: ~azure.mgmt.managednetworkfabric.models.NeighborGroupDestination
-    """
-
-    _attribute_map = {
-        "tags": {"key": "tags", "type": "{str}"},
-        "annotation": {"key": "properties.annotation", "type": "str"},
-        "destination": {"key": "properties.destination", "type": "NeighborGroupDestination"},
-    }
-
-    def __init__(
-        self,
-        *,
-        tags: Optional[Dict[str, str]] = None,
-        annotation: Optional[str] = None,
-        destination: Optional["_models.NeighborGroupDestination"] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword destination: An array of destination IPv4 Addresses or IPv6 Addresses.
-        :paramtype destination: ~azure.mgmt.managednetworkfabric.models.NeighborGroupDestination
-        """
-        super().__init__(tags=tags, **kwargs)
-        self.annotation = annotation
-        self.destination = destination
-
-
-class NeighborGroupPatchableProperties(_serialization.Model):
-    """Neighbor Group Patchable Properties defines the patchable properties of the resource.
-
-    :ivar destination: An array of destination IPv4 Addresses or IPv6 Addresses.
-    :vartype destination: ~azure.mgmt.managednetworkfabric.models.NeighborGroupDestination
-    """
-
-    _attribute_map = {
-        "destination": {"key": "destination", "type": "NeighborGroupDestination"},
-    }
-
-    def __init__(self, *, destination: Optional["_models.NeighborGroupDestination"] = None, **kwargs: Any) -> None:
-        """
-        :keyword destination: An array of destination IPv4 Addresses or IPv6 Addresses.
-        :paramtype destination: ~azure.mgmt.managednetworkfabric.models.NeighborGroupDestination
-        """
-        super().__init__(**kwargs)
-        self.destination = destination
-
-
-class NeighborGroupPatchProperties(AnnotationResource, NeighborGroupPatchableProperties):
-    """Neighbor Group Patch properties.
-
-    :ivar destination: An array of destination IPv4 Addresses or IPv6 Addresses.
-    :vartype destination: ~azure.mgmt.managednetworkfabric.models.NeighborGroupDestination
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    """
-
-    _attribute_map = {
-        "destination": {"key": "destination", "type": "NeighborGroupDestination"},
-        "annotation": {"key": "annotation", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        destination: Optional["_models.NeighborGroupDestination"] = None,
-        annotation: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword destination: An array of destination IPv4 Addresses or IPv6 Addresses.
-        :paramtype destination: ~azure.mgmt.managednetworkfabric.models.NeighborGroupDestination
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        """
-        super().__init__(annotation=annotation, destination=destination, **kwargs)
-        self.destination = destination
-        self.annotation = annotation
-
-
-class NeighborGroupProperties(AnnotationResource, NeighborGroupPatchableProperties):
-    """Neighbor Group Properties defines the properties of the resource.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar destination: An array of destination IPv4 Addresses or IPv6 Addresses.
-    :vartype destination: ~azure.mgmt.managednetworkfabric.models.NeighborGroupDestination
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar network_tap_ids: List of NetworkTap IDs where neighbor group is associated.
-    :vartype network_tap_ids: list[str]
-    :ivar network_tap_rule_ids: List of Network Tap Rule IDs where neighbor group is associated.
-    :vartype network_tap_rule_ids: list[str]
-    :ivar provisioning_state: The provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    """
-
-    _validation = {
-        "network_tap_ids": {"readonly": True},
-        "network_tap_rule_ids": {"readonly": True},
-        "provisioning_state": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "destination": {"key": "destination", "type": "NeighborGroupDestination"},
-        "annotation": {"key": "annotation", "type": "str"},
-        "network_tap_ids": {"key": "networkTapIds", "type": "[str]"},
-        "network_tap_rule_ids": {"key": "networkTapRuleIds", "type": "[str]"},
-        "provisioning_state": {"key": "provisioningState", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        destination: Optional["_models.NeighborGroupDestination"] = None,
-        annotation: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword destination: An array of destination IPv4 Addresses or IPv6 Addresses.
-        :paramtype destination: ~azure.mgmt.managednetworkfabric.models.NeighborGroupDestination
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        """
-        super().__init__(annotation=annotation, destination=destination, **kwargs)
-        self.destination = destination
-        self.network_tap_ids = None
-        self.network_tap_rule_ids = None
-        self.provisioning_state = None
-        self.annotation = annotation
-
-
-class NeighborGroupsListResult(_serialization.Model):
-    """List of Neighbor Group.
-
-    :ivar value: List of Neighbor Group resources.
-    :vartype value: list[~azure.mgmt.managednetworkfabric.models.NeighborGroup]
-    :ivar next_link: Url to follow for getting next page of resources.
-    :vartype next_link: str
-    """
-
-    _attribute_map = {
-        "value": {"key": "value", "type": "[NeighborGroup]"},
-        "next_link": {"key": "nextLink", "type": "str"},
-    }
-
-    def __init__(
-        self, *, value: Optional[List["_models.NeighborGroup"]] = None, next_link: Optional[str] = None, **kwargs: Any
-    ) -> None:
-        """
-        :keyword value: List of Neighbor Group resources.
-        :paramtype value: list[~azure.mgmt.managednetworkfabric.models.NeighborGroup]
-        :keyword next_link: Url to follow for getting next page of resources.
-        :paramtype next_link: str
-        """
-        super().__init__(**kwargs)
-        self.value = value
-        self.next_link = next_link
+        self.operational_state = None
 
 
 class NetworkDevice(TrackedResource):  # pylint: disable=too-many-instance-attributes
-    """The Network Device resource definition.
+    """The NetworkDevice resource definition.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -6890,61 +4731,43 @@
     :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar location: The geo-location where the resource lives. Required.
     :vartype location: str
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar host_name: The host name of the device.
+    :ivar host_name: The host Name of the device.
     :vartype host_name: str
-    :ivar serial_number: Serial number of the device. Format of serial Number -
-     Make;Model;HardwareRevisionId;SerialNumber.
+    :ivar serial_number: serialNumber of the format Make;Model;HardwareRevisionId;SerialNumber.
+     Example: Arista;DCS-7280DR3-24;12.05;JPE21116969.
     :vartype serial_number: str
     :ivar version: Current version of the device as defined in SKU.
     :vartype version: str
     :ivar network_device_sku: Network Device SKU name.
     :vartype network_device_sku: str
-    :ivar network_device_role: NetworkDeviceRole is the device role: Example: CE | ToR. Known
+    :ivar network_device_role: networkDeviceRole is the device role: Example: CE | ToR. Known
      values are: "CE", "ToR", "NPB", "TS", and "Management".
-    :vartype network_device_role: str or ~azure.mgmt.managednetworkfabric.models.NetworkDeviceRole
+    :vartype network_device_role: str or
+     ~azure.mgmt.managednetworkfabric.models.NetworkDeviceRoleTypes
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
+    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
     :ivar network_rack_id: Reference to network rack resource id.
     :vartype network_rack_id: str
-    :ivar management_ipv4_address: Management IPv4 Address.
-    :vartype management_ipv4_address: str
-    :ivar management_ipv6_address: Management IPv6 Address.
-    :vartype management_ipv6_address: str
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
         "location": {"required": True},
-        "host_name": {"min_length": 1},
-        "serial_number": {"min_length": 1},
         "version": {"readonly": True},
-        "network_device_role": {"readonly": True},
-        "network_rack_id": {"readonly": True},
-        "management_ipv4_address": {"readonly": True},
-        "management_ipv6_address": {"readonly": True},
-        "configuration_state": {"readonly": True},
         "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
+        "network_rack_id": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
@@ -6952,115 +4775,102 @@
         "location": {"key": "location", "type": "str"},
         "annotation": {"key": "properties.annotation", "type": "str"},
         "host_name": {"key": "properties.hostName", "type": "str"},
         "serial_number": {"key": "properties.serialNumber", "type": "str"},
         "version": {"key": "properties.version", "type": "str"},
         "network_device_sku": {"key": "properties.networkDeviceSku", "type": "str"},
         "network_device_role": {"key": "properties.networkDeviceRole", "type": "str"},
-        "network_rack_id": {"key": "properties.networkRackId", "type": "str"},
-        "management_ipv4_address": {"key": "properties.managementIpv4Address", "type": "str"},
-        "management_ipv6_address": {"key": "properties.managementIpv6Address", "type": "str"},
-        "configuration_state": {"key": "properties.configurationState", "type": "str"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
-        "administrative_state": {"key": "properties.administrativeState", "type": "str"},
+        "network_rack_id": {"key": "properties.networkRackId", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         location: str,
         tags: Optional[Dict[str, str]] = None,
         annotation: Optional[str] = None,
         host_name: Optional[str] = None,
         serial_number: Optional[str] = None,
         network_device_sku: Optional[str] = None,
+        network_device_role: Optional[Union[str, "_models.NetworkDeviceRoleTypes"]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword host_name: The host name of the device.
+        :keyword host_name: The host Name of the device.
         :paramtype host_name: str
-        :keyword serial_number: Serial number of the device. Format of serial Number -
-         Make;Model;HardwareRevisionId;SerialNumber.
+        :keyword serial_number: serialNumber of the format Make;Model;HardwareRevisionId;SerialNumber.
+         Example: Arista;DCS-7280DR3-24;12.05;JPE21116969.
         :paramtype serial_number: str
         :keyword network_device_sku: Network Device SKU name.
         :paramtype network_device_sku: str
+        :keyword network_device_role: networkDeviceRole is the device role: Example: CE | ToR. Known
+         values are: "CE", "ToR", "NPB", "TS", and "Management".
+        :paramtype network_device_role: str or
+         ~azure.mgmt.managednetworkfabric.models.NetworkDeviceRoleTypes
         """
         super().__init__(tags=tags, location=location, **kwargs)
         self.annotation = annotation
         self.host_name = host_name
         self.serial_number = serial_number
         self.version = None
         self.network_device_sku = network_device_sku
-        self.network_device_role = None
-        self.network_rack_id = None
-        self.management_ipv4_address = None
-        self.management_ipv6_address = None
-        self.configuration_state = None
+        self.network_device_role = network_device_role
         self.provisioning_state = None
-        self.administrative_state = None
+        self.network_rack_id = None
 
 
 class NetworkDevicePatchableProperties(_serialization.Model):
     """Network Device updatable properties.
 
-    :ivar host_name: The host name of the device.
+    :ivar host_name: The host Name of the device.
     :vartype host_name: str
-    :ivar serial_number: Serial number of the device. Format of serial Number -
-     Make;Model;HardwareRevisionId;SerialNumber.
+    :ivar serial_number: serialNumber of the format Make;Model;HardwareRevisionId;SerialNumber.
+     Example: Arista;DCS-7280DR3-24;12.05;JPE21116969.
     :vartype serial_number: str
     """
 
-    _validation = {
-        "host_name": {"min_length": 1},
-        "serial_number": {"min_length": 1},
-    }
-
     _attribute_map = {
         "host_name": {"key": "hostName", "type": "str"},
         "serial_number": {"key": "serialNumber", "type": "str"},
     }
 
     def __init__(self, *, host_name: Optional[str] = None, serial_number: Optional[str] = None, **kwargs: Any) -> None:
         """
-        :keyword host_name: The host name of the device.
+        :keyword host_name: The host Name of the device.
         :paramtype host_name: str
-        :keyword serial_number: Serial number of the device. Format of serial Number -
-         Make;Model;HardwareRevisionId;SerialNumber.
+        :keyword serial_number: serialNumber of the format Make;Model;HardwareRevisionId;SerialNumber.
+         Example: Arista;DCS-7280DR3-24;12.05;JPE21116969.
         :paramtype serial_number: str
         """
         super().__init__(**kwargs)
         self.host_name = host_name
         self.serial_number = serial_number
 
 
-class NetworkDevicePatchParameters(TagsUpdate):
-    """The Network Device Patch Parameters defines the patch parameters of the resource.
+class NetworkDevicePatchParameters(_serialization.Model):
+    """The NetworkDevicePatchParameters resource definition.
 
-    :ivar tags: Resource tags.
+    :ivar tags: Azure resource tags that will replace the existing ones.
     :vartype tags: dict[str, str]
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar host_name: The host name of the device.
+    :ivar host_name: The host Name of the device.
     :vartype host_name: str
-    :ivar serial_number: Serial number of the device. Format of serial Number -
-     Make;Model;HardwareRevisionId;SerialNumber.
+    :ivar serial_number: serialNumber of the format Make;Model;HardwareRevisionId;SerialNumber.
+     Example: Arista;DCS-7280DR3-24;12.05;JPE21116969.
     :vartype serial_number: str
     """
 
-    _validation = {
-        "host_name": {"min_length": 1},
-        "serial_number": {"min_length": 1},
-    }
-
     _attribute_map = {
         "tags": {"key": "tags", "type": "{str}"},
         "annotation": {"key": "properties.annotation", "type": "str"},
         "host_name": {"key": "properties.hostName", "type": "str"},
         "serial_number": {"key": "properties.serialNumber", "type": "str"},
     }
 
@@ -7070,47 +4880,43 @@
         tags: Optional[Dict[str, str]] = None,
         annotation: Optional[str] = None,
         host_name: Optional[str] = None,
         serial_number: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword tags: Resource tags.
+        :keyword tags: Azure resource tags that will replace the existing ones.
         :paramtype tags: dict[str, str]
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword host_name: The host name of the device.
+        :keyword host_name: The host Name of the device.
         :paramtype host_name: str
-        :keyword serial_number: Serial number of the device. Format of serial Number -
-         Make;Model;HardwareRevisionId;SerialNumber.
+        :keyword serial_number: serialNumber of the format Make;Model;HardwareRevisionId;SerialNumber.
+         Example: Arista;DCS-7280DR3-24;12.05;JPE21116969.
         :paramtype serial_number: str
         """
-        super().__init__(tags=tags, **kwargs)
+        super().__init__(**kwargs)
+        self.tags = tags
         self.annotation = annotation
         self.host_name = host_name
         self.serial_number = serial_number
 
 
 class NetworkDevicePatchParametersProperties(AnnotationResource, NetworkDevicePatchableProperties):
     """Network Device Patch properties.
 
-    :ivar host_name: The host name of the device.
+    :ivar host_name: The host Name of the device.
     :vartype host_name: str
-    :ivar serial_number: Serial number of the device. Format of serial Number -
-     Make;Model;HardwareRevisionId;SerialNumber.
+    :ivar serial_number: serialNumber of the format Make;Model;HardwareRevisionId;SerialNumber.
+     Example: Arista;DCS-7280DR3-24;12.05;JPE21116969.
     :vartype serial_number: str
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
     """
 
-    _validation = {
-        "host_name": {"min_length": 1},
-        "serial_number": {"min_length": 1},
-    }
-
     _attribute_map = {
         "host_name": {"key": "hostName", "type": "str"},
         "serial_number": {"key": "serialNumber", "type": "str"},
         "annotation": {"key": "annotation", "type": "str"},
     }
 
     def __init__(
@@ -7118,163 +4924,187 @@
         *,
         host_name: Optional[str] = None,
         serial_number: Optional[str] = None,
         annotation: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword host_name: The host name of the device.
+        :keyword host_name: The host Name of the device.
         :paramtype host_name: str
-        :keyword serial_number: Serial number of the device. Format of serial Number -
-         Make;Model;HardwareRevisionId;SerialNumber.
+        :keyword serial_number: serialNumber of the format Make;Model;HardwareRevisionId;SerialNumber.
+         Example: Arista;DCS-7280DR3-24;12.05;JPE21116969.
         :paramtype serial_number: str
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
         """
         super().__init__(annotation=annotation, host_name=host_name, serial_number=serial_number, **kwargs)
         self.host_name = host_name
         self.serial_number = serial_number
         self.annotation = annotation
 
 
-class NetworkDeviceProperties(
-    AnnotationResource, NetworkDevicePatchableProperties
-):  # pylint: disable=too-many-instance-attributes
-    """Network Device Properties defines the properties of the resource.
+class NetworkDeviceProperties(AnnotationResource, NetworkDevicePatchableProperties):
+    """NetworkDeviceProperties define the resource properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar host_name: The host name of the device.
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar host_name: The host Name of the device.
     :vartype host_name: str
-    :ivar serial_number: Serial number of the device. Format of serial Number -
-     Make;Model;HardwareRevisionId;SerialNumber.
+    :ivar serial_number: serialNumber of the format Make;Model;HardwareRevisionId;SerialNumber.
+     Example: Arista;DCS-7280DR3-24;12.05;JPE21116969.
     :vartype serial_number: str
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
     :ivar version: Current version of the device as defined in SKU.
     :vartype version: str
-    :ivar network_device_sku: Network Device SKU name.
+    :ivar network_device_sku: Network Device SKU name. Required.
     :vartype network_device_sku: str
-    :ivar network_device_role: NetworkDeviceRole is the device role: Example: CE | ToR. Known
-     values are: "CE", "ToR", "NPB", "TS", and "Management".
-    :vartype network_device_role: str or ~azure.mgmt.managednetworkfabric.models.NetworkDeviceRole
+    :ivar network_device_role: networkDeviceRole is the device role: Example: CE | ToR. Required.
+     Known values are: "CE", "ToR", "NPB", "TS", and "Management".
+    :vartype network_device_role: str or
+     ~azure.mgmt.managednetworkfabric.models.NetworkDeviceRoleTypes
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
+    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
     :ivar network_rack_id: Reference to network rack resource id.
     :vartype network_rack_id: str
-    :ivar management_ipv4_address: Management IPv4 Address.
-    :vartype management_ipv4_address: str
-    :ivar management_ipv6_address: Management IPv6 Address.
-    :vartype management_ipv6_address: str
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
-        "host_name": {"min_length": 1},
-        "serial_number": {"min_length": 1},
         "version": {"readonly": True},
-        "network_device_role": {"readonly": True},
-        "network_rack_id": {"readonly": True},
-        "management_ipv4_address": {"readonly": True},
-        "management_ipv6_address": {"readonly": True},
-        "configuration_state": {"readonly": True},
+        "network_device_sku": {"required": True},
+        "network_device_role": {"required": True},
         "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
+        "network_rack_id": {"readonly": True},
     }
 
     _attribute_map = {
         "host_name": {"key": "hostName", "type": "str"},
         "serial_number": {"key": "serialNumber", "type": "str"},
         "annotation": {"key": "annotation", "type": "str"},
         "version": {"key": "version", "type": "str"},
         "network_device_sku": {"key": "networkDeviceSku", "type": "str"},
         "network_device_role": {"key": "networkDeviceRole", "type": "str"},
-        "network_rack_id": {"key": "networkRackId", "type": "str"},
-        "management_ipv4_address": {"key": "managementIpv4Address", "type": "str"},
-        "management_ipv6_address": {"key": "managementIpv6Address", "type": "str"},
-        "configuration_state": {"key": "configurationState", "type": "str"},
         "provisioning_state": {"key": "provisioningState", "type": "str"},
-        "administrative_state": {"key": "administrativeState", "type": "str"},
+        "network_rack_id": {"key": "networkRackId", "type": "str"},
     }
 
     def __init__(
         self,
         *,
+        network_device_sku: str,
+        network_device_role: Union[str, "_models.NetworkDeviceRoleTypes"],
         host_name: Optional[str] = None,
         serial_number: Optional[str] = None,
         annotation: Optional[str] = None,
-        network_device_sku: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword host_name: The host name of the device.
+        :keyword host_name: The host Name of the device.
         :paramtype host_name: str
-        :keyword serial_number: Serial number of the device. Format of serial Number -
-         Make;Model;HardwareRevisionId;SerialNumber.
+        :keyword serial_number: serialNumber of the format Make;Model;HardwareRevisionId;SerialNumber.
+         Example: Arista;DCS-7280DR3-24;12.05;JPE21116969.
         :paramtype serial_number: str
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword network_device_sku: Network Device SKU name.
+        :keyword network_device_sku: Network Device SKU name. Required.
         :paramtype network_device_sku: str
+        :keyword network_device_role: networkDeviceRole is the device role: Example: CE | ToR.
+         Required. Known values are: "CE", "ToR", "NPB", "TS", and "Management".
+        :paramtype network_device_role: str or
+         ~azure.mgmt.managednetworkfabric.models.NetworkDeviceRoleTypes
         """
         super().__init__(annotation=annotation, host_name=host_name, serial_number=serial_number, **kwargs)
         self.host_name = host_name
         self.serial_number = serial_number
         self.version = None
         self.network_device_sku = network_device_sku
-        self.network_device_role = None
-        self.network_rack_id = None
-        self.management_ipv4_address = None
-        self.management_ipv6_address = None
-        self.configuration_state = None
+        self.network_device_role = network_device_role
         self.provisioning_state = None
-        self.administrative_state = None
+        self.network_rack_id = None
         self.annotation = annotation
 
 
-class NetworkDeviceSku(ProxyResource):
+class NetworkDeviceRoleProperties(_serialization.Model):
+    """Network device properties / role for the Network Rack.
+
+    :ivar network_device_sku_name: Name of the associated Network Device SKU.
+    :vartype network_device_sku_name: str
+    :ivar role_type: Role for the network device. Known values are: "CE", "ToR", "NPB", "TS", and
+     "Management".
+    :vartype role_type: str or ~azure.mgmt.managednetworkfabric.models.NetworkDeviceRackRoleType
+    :ivar rack_slot: Rack slot for the network device.
+    :vartype rack_slot: int
+    """
+
+    _attribute_map = {
+        "network_device_sku_name": {"key": "networkDeviceSkuName", "type": "str"},
+        "role_type": {"key": "roleType", "type": "str"},
+        "rack_slot": {"key": "rackSlot", "type": "int"},
+    }
+
+    def __init__(
+        self,
+        *,
+        network_device_sku_name: Optional[str] = None,
+        role_type: Optional[Union[str, "_models.NetworkDeviceRackRoleType"]] = None,
+        rack_slot: Optional[int] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword network_device_sku_name: Name of the associated Network Device SKU.
+        :paramtype network_device_sku_name: str
+        :keyword role_type: Role for the network device. Known values are: "CE", "ToR", "NPB", "TS",
+         and "Management".
+        :paramtype role_type: str or ~azure.mgmt.managednetworkfabric.models.NetworkDeviceRackRoleType
+        :keyword rack_slot: Rack slot for the network device.
+        :paramtype rack_slot: int
+        """
+        super().__init__(**kwargs)
+        self.network_device_sku_name = network_device_sku_name
+        self.role_type = role_type
+        self.rack_slot = rack_slot
+
+
+class NetworkDeviceSku(ProxyResource):  # pylint: disable=too-many-instance-attributes
     """The NetworkDeviceSku resource definition.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
      information.
     :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
     :ivar model: Model of the network device. Required.
     :vartype model: str
     :ivar manufacturer: Manufacturer of the network device.
     :vartype manufacturer: str
-    :ivar supported_versions: List of supported version details of network device.
+    :ivar supported_versions: List of network device interfaces.
     :vartype supported_versions:
      list[~azure.mgmt.managednetworkfabric.models.SupportedVersionProperties]
+    :ivar limits: Network device limits.
+    :vartype limits: ~azure.mgmt.managednetworkfabric.models.DeviceLimits
     :ivar supported_role_types: Available roles for the network device.
     :vartype supported_role_types: list[str or
      ~azure.mgmt.managednetworkfabric.models.NetworkDeviceRoleName]
     :ivar interfaces: List of network device interfaces.
     :vartype interfaces: list[~azure.mgmt.managednetworkfabric.models.DeviceInterfaceProperties]
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
@@ -7287,56 +5117,61 @@
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "model": {"key": "properties.model", "type": "str"},
         "manufacturer": {"key": "properties.manufacturer", "type": "str"},
         "supported_versions": {"key": "properties.supportedVersions", "type": "[SupportedVersionProperties]"},
+        "limits": {"key": "properties.limits", "type": "DeviceLimits"},
         "supported_role_types": {"key": "properties.supportedRoleTypes", "type": "[str]"},
         "interfaces": {"key": "properties.interfaces", "type": "[DeviceInterfaceProperties]"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         model: str,
         manufacturer: Optional[str] = None,
         supported_versions: Optional[List["_models.SupportedVersionProperties"]] = None,
+        limits: Optional["_models.DeviceLimits"] = None,
         supported_role_types: Optional[List[Union[str, "_models.NetworkDeviceRoleName"]]] = None,
         interfaces: Optional[List["_models.DeviceInterfaceProperties"]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword model: Model of the network device. Required.
         :paramtype model: str
         :keyword manufacturer: Manufacturer of the network device.
         :paramtype manufacturer: str
-        :keyword supported_versions: List of supported version details of network device.
+        :keyword supported_versions: List of network device interfaces.
         :paramtype supported_versions:
          list[~azure.mgmt.managednetworkfabric.models.SupportedVersionProperties]
+        :keyword limits: Network device limits.
+        :paramtype limits: ~azure.mgmt.managednetworkfabric.models.DeviceLimits
         :keyword supported_role_types: Available roles for the network device.
         :paramtype supported_role_types: list[str or
          ~azure.mgmt.managednetworkfabric.models.NetworkDeviceRoleName]
         :keyword interfaces: List of network device interfaces.
         :paramtype interfaces: list[~azure.mgmt.managednetworkfabric.models.DeviceInterfaceProperties]
         """
         super().__init__(**kwargs)
         self.model = model
         self.manufacturer = manufacturer
         self.supported_versions = supported_versions
+        self.limits = limits
         self.supported_role_types = supported_role_types
         self.interfaces = interfaces
         self.provisioning_state = None
 
 
 class NetworkDeviceSkusListResult(_serialization.Model):
-    """List of Network Device SKUs.
+    """List of NetworkDeviceSkus.
 
-    :ivar value: List of Network Device SKU resources.
+    :ivar value: List of NetworkDeviceSku resources.
     :vartype value: list[~azure.mgmt.managednetworkfabric.models.NetworkDeviceSku]
     :ivar next_link: Url to follow for getting next page of resources.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[NetworkDeviceSku]"},
@@ -7347,15 +5182,15 @@
         self,
         *,
         value: Optional[List["_models.NetworkDeviceSku"]] = None,
         next_link: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword value: List of Network Device SKU resources.
+        :keyword value: List of NetworkDeviceSku resources.
         :paramtype value: list[~azure.mgmt.managednetworkfabric.models.NetworkDeviceSku]
         :keyword next_link: Url to follow for getting next page of resources.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
@@ -7386,22 +5221,22 @@
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
 class NetworkFabric(TrackedResource):  # pylint: disable=too-many-instance-attributes
-    """The Network Fabric resource definition.
+    """The NetworkFabric resource definition.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -7409,203 +5244,184 @@
     :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar location: The geo-location where the resource lives. Required.
     :vartype location: str
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
+    :ivar racks: List of NetworkRack resource IDs under the Network Fabric. The number of racks
+     allowed depends on the Network Fabric SKU.
+    :vartype racks: list[str]
+    :ivar l2_isolation_domains: List of L2IsolationDomain resource IDs under the Network Fabric.
+    :vartype l2_isolation_domains: list[str]
+    :ivar l3_isolation_domains: List of L3IsolationDomain resource IDs under the Network Fabric.
+    :vartype l3_isolation_domains: list[str]
     :ivar network_fabric_sku: Supported Network Fabric SKU.Example: Compute / Aggregate racks. Once
      the user chooses a particular SKU, only supported racks can be added to the Network Fabric. The
-     SKU determines whether it is a single / multi rack Network Fabric. Required.
+     SKU determines whether it is a single / multi rack Network Fabric.
     :vartype network_fabric_sku: str
-    :ivar fabric_version: The version of Network Fabric.
-    :vartype fabric_version: str
-    :ivar router_ids: Array of router IDs.
-    :vartype router_ids: list[str]
-    :ivar network_fabric_controller_id: Azure resource ID for the NetworkFabricController the
-     NetworkFabric belongs. Required.
-    :vartype network_fabric_controller_id: str
-    :ivar rack_count: Number of compute racks associated to Network Fabric.
+    :ivar rack_count: Number of racks associated to Network Fabric.Possible values are from 2-8.
     :vartype rack_count: int
-    :ivar server_count_per_rack: Number of servers.Possible values are from 1-16. Required.
+    :ivar server_count_per_rack: Number of servers.Possible values are from 1-16.
     :vartype server_count_per_rack: int
-    :ivar ipv4_prefix: IPv4Prefix for Management Network. Example: 10.1.0.0/19. Required.
+    :ivar ipv4_prefix: IPv4Prefix for Management Network. Example: 10.1.0.0/19.
     :vartype ipv4_prefix: str
     :ivar ipv6_prefix: IPv6Prefix for Management Network. Example: 3FFE:FFFF:0:CD40::/59.
     :vartype ipv6_prefix: str
-    :ivar fabric_asn: ASN of CE devices for CE/PE connectivity. Required.
+    :ivar router_id: Router Id of CE to be used for MP-BGP between PE and CE.
+    :vartype router_id: str
+    :ivar fabric_asn: ASN of CE devices for CE/PE connectivity.
     :vartype fabric_asn: int
+    :ivar network_fabric_controller_id: Azure resource ID for the NetworkFabricController the
+     NetworkFabric belongs.
+    :vartype network_fabric_controller_id: str
     :ivar terminal_server_configuration: Network and credentials configuration currently applied to
-     terminal server. Required.
+     terminal server.
     :vartype terminal_server_configuration:
      ~azure.mgmt.managednetworkfabric.models.TerminalServerConfiguration
     :ivar management_network_configuration: Configuration to be used to setup the management
-     network. Required.
+     network.
     :vartype management_network_configuration:
-     ~azure.mgmt.managednetworkfabric.models.ManagementNetworkConfigurationProperties
-    :ivar racks: List of NetworkRack resource IDs under the Network Fabric. The number of racks
-     allowed depends on the Network Fabric SKU.
-    :vartype racks: list[str]
-    :ivar l2_isolation_domains: List of L2 Isolation Domain resource IDs under the Network Fabric.
-    :vartype l2_isolation_domains: list[str]
-    :ivar l3_isolation_domains: List of L3 Isolation Domain resource IDs under the Network Fabric.
-    :vartype l3_isolation_domains: list[str]
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provides you the latest status of the NFC service, whether it is
-     Accepted, updating, Succeeded or Failed. During this process, the states keep changing based on
-     the status of NFC provisioning. Known values are: "Accepted", "Succeeded", "Updating",
-     "Deleting", "Failed", and "Canceled".
+     ~azure.mgmt.managednetworkfabric.models.ManagementNetworkConfiguration
+    :ivar operational_state: Gets the operational state of the resource. Known values are:
+     "Provisioning", "Provisioned", "ErrorProvisioning", "Deprovisioning", "Deprovisioned",
+     "ErrorDeprovisioning", and "DeferredControl".
+    :vartype operational_state: str or
+     ~azure.mgmt.managednetworkfabric.models.NetworkFabricOperationalState
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
         "location": {"required": True},
-        "network_fabric_sku": {"required": True, "min_length": 1},
-        "fabric_version": {"readonly": True},
-        "router_ids": {"readonly": True},
-        "network_fabric_controller_id": {"required": True},
-        "rack_count": {"maximum": 8, "minimum": 1},
-        "server_count_per_rack": {"required": True, "maximum": 16, "minimum": 1},
-        "ipv4_prefix": {"required": True, "min_length": 1},
-        "ipv6_prefix": {"min_length": 1},
-        "fabric_asn": {"required": True, "maximum": 4294967295, "minimum": 1},
-        "terminal_server_configuration": {"required": True},
-        "management_network_configuration": {"required": True},
         "racks": {"readonly": True},
         "l2_isolation_domains": {"readonly": True},
         "l3_isolation_domains": {"readonly": True},
-        "configuration_state": {"readonly": True},
+        "rack_count": {"maximum": 8, "minimum": 2},
+        "server_count_per_rack": {"maximum": 16, "minimum": 1},
+        "router_id": {"readonly": True},
+        "fabric_asn": {"maximum": 65535, "minimum": 1},
+        "operational_state": {"readonly": True},
         "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
         "annotation": {"key": "properties.annotation", "type": "str"},
+        "racks": {"key": "properties.racks", "type": "[str]"},
+        "l2_isolation_domains": {"key": "properties.l2IsolationDomains", "type": "[str]"},
+        "l3_isolation_domains": {"key": "properties.l3IsolationDomains", "type": "[str]"},
         "network_fabric_sku": {"key": "properties.networkFabricSku", "type": "str"},
-        "fabric_version": {"key": "properties.fabricVersion", "type": "str"},
-        "router_ids": {"key": "properties.routerIds", "type": "[str]"},
-        "network_fabric_controller_id": {"key": "properties.networkFabricControllerId", "type": "str"},
         "rack_count": {"key": "properties.rackCount", "type": "int"},
         "server_count_per_rack": {"key": "properties.serverCountPerRack", "type": "int"},
         "ipv4_prefix": {"key": "properties.ipv4Prefix", "type": "str"},
         "ipv6_prefix": {"key": "properties.ipv6Prefix", "type": "str"},
+        "router_id": {"key": "properties.routerId", "type": "str"},
         "fabric_asn": {"key": "properties.fabricASN", "type": "int"},
+        "network_fabric_controller_id": {"key": "properties.networkFabricControllerId", "type": "str"},
         "terminal_server_configuration": {
             "key": "properties.terminalServerConfiguration",
             "type": "TerminalServerConfiguration",
         },
         "management_network_configuration": {
             "key": "properties.managementNetworkConfiguration",
-            "type": "ManagementNetworkConfigurationProperties",
+            "type": "ManagementNetworkConfiguration",
         },
-        "racks": {"key": "properties.racks", "type": "[str]"},
-        "l2_isolation_domains": {"key": "properties.l2IsolationDomains", "type": "[str]"},
-        "l3_isolation_domains": {"key": "properties.l3IsolationDomains", "type": "[str]"},
-        "configuration_state": {"key": "properties.configurationState", "type": "str"},
+        "operational_state": {"key": "properties.operationalState", "type": "str"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
-        "administrative_state": {"key": "properties.administrativeState", "type": "str"},
     }
 
-    def __init__(  # pylint: disable=too-many-locals
+    def __init__(
         self,
         *,
         location: str,
-        network_fabric_sku: str,
-        network_fabric_controller_id: str,
-        server_count_per_rack: int,
-        ipv4_prefix: str,
-        fabric_asn: int,
-        terminal_server_configuration: "_models.TerminalServerConfiguration",
-        management_network_configuration: "_models.ManagementNetworkConfigurationProperties",
         tags: Optional[Dict[str, str]] = None,
         annotation: Optional[str] = None,
+        network_fabric_sku: Optional[str] = None,
         rack_count: Optional[int] = None,
+        server_count_per_rack: Optional[int] = None,
+        ipv4_prefix: Optional[str] = None,
         ipv6_prefix: Optional[str] = None,
+        fabric_asn: Optional[int] = None,
+        network_fabric_controller_id: Optional[str] = None,
+        terminal_server_configuration: Optional["_models.TerminalServerConfiguration"] = None,
+        management_network_configuration: Optional["_models.ManagementNetworkConfiguration"] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
         :keyword network_fabric_sku: Supported Network Fabric SKU.Example: Compute / Aggregate racks.
          Once the user chooses a particular SKU, only supported racks can be added to the Network
-         Fabric. The SKU determines whether it is a single / multi rack Network Fabric. Required.
+         Fabric. The SKU determines whether it is a single / multi rack Network Fabric.
         :paramtype network_fabric_sku: str
-        :keyword network_fabric_controller_id: Azure resource ID for the NetworkFabricController the
-         NetworkFabric belongs. Required.
-        :paramtype network_fabric_controller_id: str
-        :keyword rack_count: Number of compute racks associated to Network Fabric.
+        :keyword rack_count: Number of racks associated to Network Fabric.Possible values are from 2-8.
         :paramtype rack_count: int
-        :keyword server_count_per_rack: Number of servers.Possible values are from 1-16. Required.
+        :keyword server_count_per_rack: Number of servers.Possible values are from 1-16.
         :paramtype server_count_per_rack: int
-        :keyword ipv4_prefix: IPv4Prefix for Management Network. Example: 10.1.0.0/19. Required.
+        :keyword ipv4_prefix: IPv4Prefix for Management Network. Example: 10.1.0.0/19.
         :paramtype ipv4_prefix: str
         :keyword ipv6_prefix: IPv6Prefix for Management Network. Example: 3FFE:FFFF:0:CD40::/59.
         :paramtype ipv6_prefix: str
-        :keyword fabric_asn: ASN of CE devices for CE/PE connectivity. Required.
+        :keyword fabric_asn: ASN of CE devices for CE/PE connectivity.
         :paramtype fabric_asn: int
+        :keyword network_fabric_controller_id: Azure resource ID for the NetworkFabricController the
+         NetworkFabric belongs.
+        :paramtype network_fabric_controller_id: str
         :keyword terminal_server_configuration: Network and credentials configuration currently applied
-         to terminal server. Required.
+         to terminal server.
         :paramtype terminal_server_configuration:
          ~azure.mgmt.managednetworkfabric.models.TerminalServerConfiguration
         :keyword management_network_configuration: Configuration to be used to setup the management
-         network. Required.
+         network.
         :paramtype management_network_configuration:
-         ~azure.mgmt.managednetworkfabric.models.ManagementNetworkConfigurationProperties
+         ~azure.mgmt.managednetworkfabric.models.ManagementNetworkConfiguration
         """
         super().__init__(tags=tags, location=location, **kwargs)
         self.annotation = annotation
+        self.racks = None
+        self.l2_isolation_domains = None
+        self.l3_isolation_domains = None
         self.network_fabric_sku = network_fabric_sku
-        self.fabric_version = None
-        self.router_ids = None
-        self.network_fabric_controller_id = network_fabric_controller_id
         self.rack_count = rack_count
         self.server_count_per_rack = server_count_per_rack
         self.ipv4_prefix = ipv4_prefix
         self.ipv6_prefix = ipv6_prefix
+        self.router_id = None
         self.fabric_asn = fabric_asn
+        self.network_fabric_controller_id = network_fabric_controller_id
         self.terminal_server_configuration = terminal_server_configuration
         self.management_network_configuration = management_network_configuration
-        self.racks = None
-        self.l2_isolation_domains = None
-        self.l3_isolation_domains = None
-        self.configuration_state = None
+        self.operational_state = None
         self.provisioning_state = None
-        self.administrative_state = None
 
 
 class NetworkFabricController(TrackedResource):  # pylint: disable=too-many-instance-attributes
-    """The Network Fabric Controller resource definition.
+    """The NetworkFabricController resource definition.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -7624,63 +5440,55 @@
      list[~azure.mgmt.managednetworkfabric.models.ExpressRouteConnectionInformation]
     :ivar workload_express_route_connections: As part of an update, the workload ExpressRoute
      CircuitID should be provided to create and Provision a NFC. This Express route is dedicated for
      Workload services. (This is a Mandatory attribute).
     :vartype workload_express_route_connections:
      list[~azure.mgmt.managednetworkfabric.models.ExpressRouteConnectionInformation]
     :ivar infrastructure_services: InfrastructureServices IP ranges.
-    :vartype infrastructure_services: ~azure.mgmt.managednetworkfabric.models.ControllerServices
+    :vartype infrastructure_services:
+     ~azure.mgmt.managednetworkfabric.models.InfrastructureServices
     :ivar workload_services: WorkloadServices IP ranges.
-    :vartype workload_services: ~azure.mgmt.managednetworkfabric.models.ControllerServices
+    :vartype workload_services: ~azure.mgmt.managednetworkfabric.models.WorkloadServices
     :ivar managed_resource_group_configuration: Managed Resource Group configuration properties.
     :vartype managed_resource_group_configuration:
      ~azure.mgmt.managednetworkfabric.models.ManagedResourceGroupConfiguration
     :ivar network_fabric_ids: The NF-ID will be an input parameter used by the NF to link and get
      associated with the parent NFC Service.
     :vartype network_fabric_ids: list[str]
     :ivar workload_management_network: A workload management network is required for all the tenant
      (workload) traffic. This traffic is only dedicated for Tenant workloads which are required to
-     access internet or any other MSFT/Public endpoints. This is used for the backward
-     compatibility.
+     access internet or any other MSFT/Public endpoints.
     :vartype workload_management_network: bool
-    :ivar is_workload_management_network_enabled: A workload management network is required for all
-     the tenant (workload) traffic. This traffic is only dedicated for Tenant workloads which are
-     required to access internet or any other MSFT/Public endpoints. Known values are: "True" and
-     "False".
-    :vartype is_workload_management_network_enabled: str or
-     ~azure.mgmt.managednetworkfabric.models.IsWorkloadManagementNetworkEnabled
-    :ivar tenant_internet_gateway_ids: List of tenant InternetGateway resource IDs.
-    :vartype tenant_internet_gateway_ids: list[str]
     :ivar ipv4_address_space: IPv4 Network Fabric Controller Address Space.
     :vartype ipv4_address_space: str
     :ivar ipv6_address_space: IPv6 Network Fabric Controller Address Space.
     :vartype ipv6_address_space: str
-    :ivar nfc_sku: Network Fabric Controller SKU. Known values are: "Basic", "Standard", and
-     "HighPerformance".
-    :vartype nfc_sku: str or ~azure.mgmt.managednetworkfabric.models.NfcSku
+    :ivar operational_state: The Operational Status would always be NULL. Look only in to the
+     Provisioning state for the latest status. Known values are: "Configuring", "Succeeded", and
+     "Failed".
+    :vartype operational_state: str or
+     ~azure.mgmt.managednetworkfabric.models.NetworkFabricControllerOperationalState
     :ivar provisioning_state: Provides you the latest status of the NFC service, whether it is
      Accepted, updating, Succeeded or Failed. During this process, the states keep changing based on
-     the status of NFC provisioning. Known values are: "Accepted", "Succeeded", "Updating",
-     "Deleting", "Failed", and "Canceled".
+     the status of NFC provisioning. Known values are: "Succeeded", "Updating", "Canceled",
+     "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
         "location": {"required": True},
         "infrastructure_services": {"readonly": True},
         "workload_services": {"readonly": True},
         "network_fabric_ids": {"readonly": True},
         "workload_management_network": {"readonly": True},
-        "tenant_internet_gateway_ids": {"readonly": True},
-        "ipv4_address_space": {"min_length": 1},
-        "ipv6_address_space": {"min_length": 1},
+        "operational_state": {"readonly": True},
         "provisioning_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
@@ -7692,46 +5500,39 @@
             "key": "properties.infrastructureExpressRouteConnections",
             "type": "[ExpressRouteConnectionInformation]",
         },
         "workload_express_route_connections": {
             "key": "properties.workloadExpressRouteConnections",
             "type": "[ExpressRouteConnectionInformation]",
         },
-        "infrastructure_services": {"key": "properties.infrastructureServices", "type": "ControllerServices"},
-        "workload_services": {"key": "properties.workloadServices", "type": "ControllerServices"},
+        "infrastructure_services": {"key": "properties.infrastructureServices", "type": "InfrastructureServices"},
+        "workload_services": {"key": "properties.workloadServices", "type": "WorkloadServices"},
         "managed_resource_group_configuration": {
             "key": "properties.managedResourceGroupConfiguration",
             "type": "ManagedResourceGroupConfiguration",
         },
         "network_fabric_ids": {"key": "properties.networkFabricIds", "type": "[str]"},
         "workload_management_network": {"key": "properties.workloadManagementNetwork", "type": "bool"},
-        "is_workload_management_network_enabled": {
-            "key": "properties.isWorkloadManagementNetworkEnabled",
-            "type": "str",
-        },
-        "tenant_internet_gateway_ids": {"key": "properties.tenantInternetGatewayIds", "type": "[str]"},
         "ipv4_address_space": {"key": "properties.ipv4AddressSpace", "type": "str"},
         "ipv6_address_space": {"key": "properties.ipv6AddressSpace", "type": "str"},
-        "nfc_sku": {"key": "properties.nfcSku", "type": "str"},
+        "operational_state": {"key": "properties.operationalState", "type": "str"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         location: str,
         tags: Optional[Dict[str, str]] = None,
         annotation: Optional[str] = None,
         infrastructure_express_route_connections: Optional[List["_models.ExpressRouteConnectionInformation"]] = None,
         workload_express_route_connections: Optional[List["_models.ExpressRouteConnectionInformation"]] = None,
         managed_resource_group_configuration: Optional["_models.ManagedResourceGroupConfiguration"] = None,
-        is_workload_management_network_enabled: Union[str, "_models.IsWorkloadManagementNetworkEnabled"] = "True",
-        ipv4_address_space: str = "10.0.0.0/19",
-        ipv6_address_space: str = "FC00::/59",
-        nfc_sku: Union[str, "_models.NfcSku"] = "Standard",
+        ipv4_address_space: Optional[str] = None,
+        ipv6_address_space: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
@@ -7746,49 +5547,38 @@
          CircuitID should be provided to create and Provision a NFC. This Express route is dedicated for
          Workload services. (This is a Mandatory attribute).
         :paramtype workload_express_route_connections:
          list[~azure.mgmt.managednetworkfabric.models.ExpressRouteConnectionInformation]
         :keyword managed_resource_group_configuration: Managed Resource Group configuration properties.
         :paramtype managed_resource_group_configuration:
          ~azure.mgmt.managednetworkfabric.models.ManagedResourceGroupConfiguration
-        :keyword is_workload_management_network_enabled: A workload management network is required for
-         all the tenant (workload) traffic. This traffic is only dedicated for Tenant workloads which
-         are required to access internet or any other MSFT/Public endpoints. Known values are: "True"
-         and "False".
-        :paramtype is_workload_management_network_enabled: str or
-         ~azure.mgmt.managednetworkfabric.models.IsWorkloadManagementNetworkEnabled
         :keyword ipv4_address_space: IPv4 Network Fabric Controller Address Space.
         :paramtype ipv4_address_space: str
         :keyword ipv6_address_space: IPv6 Network Fabric Controller Address Space.
         :paramtype ipv6_address_space: str
-        :keyword nfc_sku: Network Fabric Controller SKU. Known values are: "Basic", "Standard", and
-         "HighPerformance".
-        :paramtype nfc_sku: str or ~azure.mgmt.managednetworkfabric.models.NfcSku
         """
         super().__init__(tags=tags, location=location, **kwargs)
         self.annotation = annotation
         self.infrastructure_express_route_connections = infrastructure_express_route_connections
         self.workload_express_route_connections = workload_express_route_connections
         self.infrastructure_services = None
         self.workload_services = None
         self.managed_resource_group_configuration = managed_resource_group_configuration
         self.network_fabric_ids = None
         self.workload_management_network = None
-        self.is_workload_management_network_enabled = is_workload_management_network_enabled
-        self.tenant_internet_gateway_ids = None
         self.ipv4_address_space = ipv4_address_space
         self.ipv6_address_space = ipv6_address_space
-        self.nfc_sku = nfc_sku
+        self.operational_state = None
         self.provisioning_state = None
 
 
-class NetworkFabricControllerPatch(TagsUpdate):
-    """The Network Fabric Controller Patch payload definition.
+class NetworkFabricControllerPatch(_serialization.Model):
+    """The NetworkFabricControllerPatch payload definition.
 
-    :ivar tags: Resource tags.
+    :ivar tags: Azure resource tags that will replace the existing ones.
     :vartype tags: dict[str, str]
     :ivar infrastructure_express_route_connections: As part of an update, the Infrastructure
      ExpressRoute CircuitID should be provided to create and Provision a NFC. This Express route is
      dedicated for Infrastructure services. (This is a Mandatory attribute).
     :vartype infrastructure_express_route_connections:
      list[~azure.mgmt.managednetworkfabric.models.ExpressRouteConnectionInformation]
     :ivar workload_express_route_connections: As part of an update, the workload ExpressRoute
@@ -7815,28 +5605,29 @@
         *,
         tags: Optional[Dict[str, str]] = None,
         infrastructure_express_route_connections: Optional[List["_models.ExpressRouteConnectionInformation"]] = None,
         workload_express_route_connections: Optional[List["_models.ExpressRouteConnectionInformation"]] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword tags: Resource tags.
+        :keyword tags: Azure resource tags that will replace the existing ones.
         :paramtype tags: dict[str, str]
         :keyword infrastructure_express_route_connections: As part of an update, the Infrastructure
          ExpressRoute CircuitID should be provided to create and Provision a NFC. This Express route is
          dedicated for Infrastructure services. (This is a Mandatory attribute).
         :paramtype infrastructure_express_route_connections:
          list[~azure.mgmt.managednetworkfabric.models.ExpressRouteConnectionInformation]
         :keyword workload_express_route_connections: As part of an update, the workload ExpressRoute
          CircuitID should be provided to create and Provision a NFC. This Express route is dedicated for
          Workload services. (This is a Mandatory attribute).
         :paramtype workload_express_route_connections:
          list[~azure.mgmt.managednetworkfabric.models.ExpressRouteConnectionInformation]
         """
-        super().__init__(tags=tags, **kwargs)
+        super().__init__(**kwargs)
+        self.tags = tags
         self.infrastructure_express_route_connections = infrastructure_express_route_connections
         self.workload_express_route_connections = workload_express_route_connections
 
 
 class NetworkFabricControllerPatchableProperties(_serialization.Model):
     """Network Fabric Controller updatable properties.
 
@@ -7886,15 +5677,15 @@
         self.infrastructure_express_route_connections = infrastructure_express_route_connections
         self.workload_express_route_connections = workload_express_route_connections
 
 
 class NetworkFabricControllerProperties(
     AnnotationResource, NetworkFabricControllerPatchableProperties
 ):  # pylint: disable=too-many-instance-attributes
-    """NetworkFabricControllerProperties defines the resource properties.
+    """NetworkFabricControllerProperties define the resource properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar infrastructure_express_route_connections: As part of an update, the Infrastructure
      ExpressRoute CircuitID should be provided to create and Provision a NFC. This Express route is
      dedicated for Infrastructure services. (This is a Mandatory attribute).
     :vartype infrastructure_express_route_connections:
@@ -7903,98 +5694,86 @@
      CircuitID should be provided to create and Provision a NFC. This Express route is dedicated for
      Workload services. (This is a Mandatory attribute).
     :vartype workload_express_route_connections:
      list[~azure.mgmt.managednetworkfabric.models.ExpressRouteConnectionInformation]
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
     :ivar infrastructure_services: InfrastructureServices IP ranges.
-    :vartype infrastructure_services: ~azure.mgmt.managednetworkfabric.models.ControllerServices
+    :vartype infrastructure_services:
+     ~azure.mgmt.managednetworkfabric.models.InfrastructureServices
     :ivar workload_services: WorkloadServices IP ranges.
-    :vartype workload_services: ~azure.mgmt.managednetworkfabric.models.ControllerServices
+    :vartype workload_services: ~azure.mgmt.managednetworkfabric.models.WorkloadServices
     :ivar managed_resource_group_configuration: Managed Resource Group configuration properties.
     :vartype managed_resource_group_configuration:
      ~azure.mgmt.managednetworkfabric.models.ManagedResourceGroupConfiguration
     :ivar network_fabric_ids: The NF-ID will be an input parameter used by the NF to link and get
      associated with the parent NFC Service.
     :vartype network_fabric_ids: list[str]
     :ivar workload_management_network: A workload management network is required for all the tenant
      (workload) traffic. This traffic is only dedicated for Tenant workloads which are required to
-     access internet or any other MSFT/Public endpoints. This is used for the backward
-     compatibility.
+     access internet or any other MSFT/Public endpoints.
     :vartype workload_management_network: bool
-    :ivar is_workload_management_network_enabled: A workload management network is required for all
-     the tenant (workload) traffic. This traffic is only dedicated for Tenant workloads which are
-     required to access internet or any other MSFT/Public endpoints. Known values are: "True" and
-     "False".
-    :vartype is_workload_management_network_enabled: str or
-     ~azure.mgmt.managednetworkfabric.models.IsWorkloadManagementNetworkEnabled
-    :ivar tenant_internet_gateway_ids: List of tenant InternetGateway resource IDs.
-    :vartype tenant_internet_gateway_ids: list[str]
     :ivar ipv4_address_space: IPv4 Network Fabric Controller Address Space.
     :vartype ipv4_address_space: str
     :ivar ipv6_address_space: IPv6 Network Fabric Controller Address Space.
     :vartype ipv6_address_space: str
-    :ivar nfc_sku: Network Fabric Controller SKU. Known values are: "Basic", "Standard", and
-     "HighPerformance".
-    :vartype nfc_sku: str or ~azure.mgmt.managednetworkfabric.models.NfcSku
+    :ivar operational_state: The Operational Status would always be NULL. Look only in to the
+     Provisioning state for the latest status. Known values are: "Configuring", "Succeeded", and
+     "Failed".
+    :vartype operational_state: str or
+     ~azure.mgmt.managednetworkfabric.models.NetworkFabricControllerOperationalState
     :ivar provisioning_state: Provides you the latest status of the NFC service, whether it is
      Accepted, updating, Succeeded or Failed. During this process, the states keep changing based on
-     the status of NFC provisioning. Known values are: "Accepted", "Succeeded", "Updating",
-     "Deleting", "Failed", and "Canceled".
+     the status of NFC provisioning. Known values are: "Succeeded", "Updating", "Canceled",
+     "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
     """
 
     _validation = {
         "infrastructure_services": {"readonly": True},
         "workload_services": {"readonly": True},
         "network_fabric_ids": {"readonly": True},
         "workload_management_network": {"readonly": True},
-        "tenant_internet_gateway_ids": {"readonly": True},
-        "ipv4_address_space": {"min_length": 1},
-        "ipv6_address_space": {"min_length": 1},
+        "operational_state": {"readonly": True},
         "provisioning_state": {"readonly": True},
     }
 
     _attribute_map = {
         "infrastructure_express_route_connections": {
             "key": "infrastructureExpressRouteConnections",
             "type": "[ExpressRouteConnectionInformation]",
         },
         "workload_express_route_connections": {
             "key": "workloadExpressRouteConnections",
             "type": "[ExpressRouteConnectionInformation]",
         },
         "annotation": {"key": "annotation", "type": "str"},
-        "infrastructure_services": {"key": "infrastructureServices", "type": "ControllerServices"},
-        "workload_services": {"key": "workloadServices", "type": "ControllerServices"},
+        "infrastructure_services": {"key": "infrastructureServices", "type": "InfrastructureServices"},
+        "workload_services": {"key": "workloadServices", "type": "WorkloadServices"},
         "managed_resource_group_configuration": {
             "key": "managedResourceGroupConfiguration",
             "type": "ManagedResourceGroupConfiguration",
         },
         "network_fabric_ids": {"key": "networkFabricIds", "type": "[str]"},
         "workload_management_network": {"key": "workloadManagementNetwork", "type": "bool"},
-        "is_workload_management_network_enabled": {"key": "isWorkloadManagementNetworkEnabled", "type": "str"},
-        "tenant_internet_gateway_ids": {"key": "tenantInternetGatewayIds", "type": "[str]"},
         "ipv4_address_space": {"key": "ipv4AddressSpace", "type": "str"},
         "ipv6_address_space": {"key": "ipv6AddressSpace", "type": "str"},
-        "nfc_sku": {"key": "nfcSku", "type": "str"},
+        "operational_state": {"key": "operationalState", "type": "str"},
         "provisioning_state": {"key": "provisioningState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         infrastructure_express_route_connections: Optional[List["_models.ExpressRouteConnectionInformation"]] = None,
         workload_express_route_connections: Optional[List["_models.ExpressRouteConnectionInformation"]] = None,
         annotation: Optional[str] = None,
         managed_resource_group_configuration: Optional["_models.ManagedResourceGroupConfiguration"] = None,
-        is_workload_management_network_enabled: Union[str, "_models.IsWorkloadManagementNetworkEnabled"] = "True",
-        ipv4_address_space: str = "10.0.0.0/19",
-        ipv6_address_space: str = "FC00::/59",
-        nfc_sku: Union[str, "_models.NfcSku"] = "Standard",
+        ipv4_address_space: Optional[str] = None,
+        ipv6_address_space: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword infrastructure_express_route_connections: As part of an update, the Infrastructure
          ExpressRoute CircuitID should be provided to create and Provision a NFC. This Express route is
          dedicated for Infrastructure services. (This is a Mandatory attribute).
         :paramtype infrastructure_express_route_connections:
@@ -8005,54 +5784,43 @@
         :paramtype workload_express_route_connections:
          list[~azure.mgmt.managednetworkfabric.models.ExpressRouteConnectionInformation]
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
         :keyword managed_resource_group_configuration: Managed Resource Group configuration properties.
         :paramtype managed_resource_group_configuration:
          ~azure.mgmt.managednetworkfabric.models.ManagedResourceGroupConfiguration
-        :keyword is_workload_management_network_enabled: A workload management network is required for
-         all the tenant (workload) traffic. This traffic is only dedicated for Tenant workloads which
-         are required to access internet or any other MSFT/Public endpoints. Known values are: "True"
-         and "False".
-        :paramtype is_workload_management_network_enabled: str or
-         ~azure.mgmt.managednetworkfabric.models.IsWorkloadManagementNetworkEnabled
         :keyword ipv4_address_space: IPv4 Network Fabric Controller Address Space.
         :paramtype ipv4_address_space: str
         :keyword ipv6_address_space: IPv6 Network Fabric Controller Address Space.
         :paramtype ipv6_address_space: str
-        :keyword nfc_sku: Network Fabric Controller SKU. Known values are: "Basic", "Standard", and
-         "HighPerformance".
-        :paramtype nfc_sku: str or ~azure.mgmt.managednetworkfabric.models.NfcSku
         """
         super().__init__(
             annotation=annotation,
             infrastructure_express_route_connections=infrastructure_express_route_connections,
             workload_express_route_connections=workload_express_route_connections,
             **kwargs
         )
         self.infrastructure_express_route_connections = infrastructure_express_route_connections
         self.workload_express_route_connections = workload_express_route_connections
         self.infrastructure_services = None
         self.workload_services = None
         self.managed_resource_group_configuration = managed_resource_group_configuration
         self.network_fabric_ids = None
         self.workload_management_network = None
-        self.is_workload_management_network_enabled = is_workload_management_network_enabled
-        self.tenant_internet_gateway_ids = None
         self.ipv4_address_space = ipv4_address_space
         self.ipv6_address_space = ipv6_address_space
-        self.nfc_sku = nfc_sku
+        self.operational_state = None
         self.provisioning_state = None
         self.annotation = annotation
 
 
 class NetworkFabricControllersListResult(_serialization.Model):
-    """List of Network Fabric Controllers.
+    """List of NetworkFabricControllers.
 
-    :ivar value: List of Network Fabric Controller resources.
+    :ivar value: List of NetworkFabricController resources.
     :vartype value: list[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
     :ivar next_link: Url to follow for getting next page of resources.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[NetworkFabricController]"},
@@ -8063,704 +5831,452 @@
         self,
         *,
         value: Optional[List["_models.NetworkFabricController"]] = None,
         next_link: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword value: List of Network Fabric Controller resources.
+        :keyword value: List of NetworkFabricController resources.
         :paramtype value: list[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :keyword next_link: Url to follow for getting next page of resources.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
-class NetworkFabricPatch(TagsUpdate):
-    """The Network Fabric resource definition.
+class NetworkFabricPatchableProperties(_serialization.Model):
+    """Network Fabric updatable properties.
 
-    :ivar tags: Resource tags.
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar racks: List of NetworkRack resource IDs under the Network Fabric. The number of racks
+     allowed depends on the Network Fabric SKU.
+    :vartype racks: list[str]
+    :ivar l2_isolation_domains: List of L2IsolationDomain resource IDs under the Network Fabric.
+    :vartype l2_isolation_domains: list[str]
+    :ivar l3_isolation_domains: List of L3IsolationDomain resource IDs under the Network Fabric.
+    :vartype l3_isolation_domains: list[str]
+    """
+
+    _validation = {
+        "racks": {"readonly": True},
+        "l2_isolation_domains": {"readonly": True},
+        "l3_isolation_domains": {"readonly": True},
+    }
+
+    _attribute_map = {
+        "racks": {"key": "racks", "type": "[str]"},
+        "l2_isolation_domains": {"key": "l2IsolationDomains", "type": "[str]"},
+        "l3_isolation_domains": {"key": "l3IsolationDomains", "type": "[str]"},
+    }
+
+    def __init__(self, **kwargs: Any) -> None:
+        """ """
+        super().__init__(**kwargs)
+        self.racks = None
+        self.l2_isolation_domains = None
+        self.l3_isolation_domains = None
+
+
+class NetworkFabricPatchParameters(_serialization.Model):
+    """The NetworkFabric resource definition.
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar tags: Azure resource tags that will replace the existing ones.
     :vartype tags: dict[str, str]
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar rack_count: Number of compute racks associated to Network Fabric.
-    :vartype rack_count: int
-    :ivar server_count_per_rack: Number of servers.Possible values are from 1-16.
-    :vartype server_count_per_rack: int
-    :ivar ipv4_prefix: IPv4Prefix for Management Network. Example: 10.1.0.0/19.
-    :vartype ipv4_prefix: str
-    :ivar ipv6_prefix: IPv6Prefix for Management Network. Example: 3FFE:FFFF:0:CD40::/59.
-    :vartype ipv6_prefix: str
-    :ivar fabric_asn: ASN of CE devices for CE/PE connectivity.
-    :vartype fabric_asn: int
     :ivar terminal_server_configuration: Network and credentials configuration already applied to
      terminal server.
     :vartype terminal_server_configuration:
-     ~azure.mgmt.managednetworkfabric.models.NetworkFabricPatchablePropertiesTerminalServerConfiguration
-    :ivar management_network_configuration: Configuration to be used to setup the management
-     network.
-    :vartype management_network_configuration:
-     ~azure.mgmt.managednetworkfabric.models.ManagementNetworkConfigurationPatchableProperties
+     ~azure.mgmt.managednetworkfabric.models.TerminalServerPatchableProperties
+    :ivar racks: List of NetworkRack resource IDs under the Network Fabric. The number of racks
+     allowed depends on the Network Fabric SKU.
+    :vartype racks: list[str]
+    :ivar l2_isolation_domains: List of L2IsolationDomain resource IDs under the Network Fabric.
+    :vartype l2_isolation_domains: list[str]
+    :ivar l3_isolation_domains: List of L3IsolationDomain resource IDs under the Network Fabric.
+    :vartype l3_isolation_domains: list[str]
     """
 
     _validation = {
-        "rack_count": {"maximum": 8, "minimum": 1},
-        "server_count_per_rack": {"maximum": 16, "minimum": 1},
-        "ipv4_prefix": {"min_length": 1},
-        "ipv6_prefix": {"min_length": 1},
-        "fabric_asn": {"maximum": 4294967295, "minimum": 1},
+        "racks": {"readonly": True},
+        "l2_isolation_domains": {"readonly": True},
+        "l3_isolation_domains": {"readonly": True},
     }
 
     _attribute_map = {
         "tags": {"key": "tags", "type": "{str}"},
         "annotation": {"key": "properties.annotation", "type": "str"},
-        "rack_count": {"key": "properties.rackCount", "type": "int"},
-        "server_count_per_rack": {"key": "properties.serverCountPerRack", "type": "int"},
-        "ipv4_prefix": {"key": "properties.ipv4Prefix", "type": "str"},
-        "ipv6_prefix": {"key": "properties.ipv6Prefix", "type": "str"},
-        "fabric_asn": {"key": "properties.fabricASN", "type": "int"},
         "terminal_server_configuration": {
             "key": "properties.terminalServerConfiguration",
-            "type": "NetworkFabricPatchablePropertiesTerminalServerConfiguration",
-        },
-        "management_network_configuration": {
-            "key": "properties.managementNetworkConfiguration",
-            "type": "ManagementNetworkConfigurationPatchableProperties",
+            "type": "TerminalServerPatchableProperties",
         },
+        "racks": {"key": "properties.racks", "type": "[str]"},
+        "l2_isolation_domains": {"key": "properties.l2IsolationDomains", "type": "[str]"},
+        "l3_isolation_domains": {"key": "properties.l3IsolationDomains", "type": "[str]"},
     }
 
     def __init__(
         self,
         *,
         tags: Optional[Dict[str, str]] = None,
         annotation: Optional[str] = None,
-        rack_count: Optional[int] = None,
-        server_count_per_rack: Optional[int] = None,
-        ipv4_prefix: Optional[str] = None,
-        ipv6_prefix: Optional[str] = None,
-        fabric_asn: Optional[int] = None,
-        terminal_server_configuration: Optional[
-            "_models.NetworkFabricPatchablePropertiesTerminalServerConfiguration"
-        ] = None,
-        management_network_configuration: Optional["_models.ManagementNetworkConfigurationPatchableProperties"] = None,
+        terminal_server_configuration: Optional["_models.TerminalServerPatchableProperties"] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword tags: Resource tags.
+        :keyword tags: Azure resource tags that will replace the existing ones.
         :paramtype tags: dict[str, str]
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword rack_count: Number of compute racks associated to Network Fabric.
-        :paramtype rack_count: int
-        :keyword server_count_per_rack: Number of servers.Possible values are from 1-16.
-        :paramtype server_count_per_rack: int
-        :keyword ipv4_prefix: IPv4Prefix for Management Network. Example: 10.1.0.0/19.
-        :paramtype ipv4_prefix: str
-        :keyword ipv6_prefix: IPv6Prefix for Management Network. Example: 3FFE:FFFF:0:CD40::/59.
-        :paramtype ipv6_prefix: str
-        :keyword fabric_asn: ASN of CE devices for CE/PE connectivity.
-        :paramtype fabric_asn: int
         :keyword terminal_server_configuration: Network and credentials configuration already applied
          to terminal server.
         :paramtype terminal_server_configuration:
-         ~azure.mgmt.managednetworkfabric.models.NetworkFabricPatchablePropertiesTerminalServerConfiguration
-        :keyword management_network_configuration: Configuration to be used to setup the management
-         network.
-        :paramtype management_network_configuration:
-         ~azure.mgmt.managednetworkfabric.models.ManagementNetworkConfigurationPatchableProperties
+         ~azure.mgmt.managednetworkfabric.models.TerminalServerPatchableProperties
         """
-        super().__init__(tags=tags, **kwargs)
+        super().__init__(**kwargs)
+        self.tags = tags
         self.annotation = annotation
-        self.rack_count = rack_count
-        self.server_count_per_rack = server_count_per_rack
-        self.ipv4_prefix = ipv4_prefix
-        self.ipv6_prefix = ipv6_prefix
-        self.fabric_asn = fabric_asn
         self.terminal_server_configuration = terminal_server_configuration
-        self.management_network_configuration = management_network_configuration
+        self.racks = None
+        self.l2_isolation_domains = None
+        self.l3_isolation_domains = None
 
 
-class NetworkFabricPatchableProperties(_serialization.Model):
-    """Network Fabric updatable properties.
+class TerminalServerPatchParameters(_serialization.Model):
+    """Terminal server patch parameters.
 
-    :ivar rack_count: Number of compute racks associated to Network Fabric.
-    :vartype rack_count: int
-    :ivar server_count_per_rack: Number of servers.Possible values are from 1-16.
-    :vartype server_count_per_rack: int
-    :ivar ipv4_prefix: IPv4Prefix for Management Network. Example: 10.1.0.0/19.
-    :vartype ipv4_prefix: str
-    :ivar ipv6_prefix: IPv6Prefix for Management Network. Example: 3FFE:FFFF:0:CD40::/59.
-    :vartype ipv6_prefix: str
-    :ivar fabric_asn: ASN of CE devices for CE/PE connectivity.
-    :vartype fabric_asn: int
     :ivar terminal_server_configuration: Network and credentials configuration already applied to
      terminal server.
     :vartype terminal_server_configuration:
-     ~azure.mgmt.managednetworkfabric.models.NetworkFabricPatchablePropertiesTerminalServerConfiguration
-    :ivar management_network_configuration: Configuration to be used to setup the management
-     network.
-    :vartype management_network_configuration:
-     ~azure.mgmt.managednetworkfabric.models.ManagementNetworkConfigurationPatchableProperties
+     ~azure.mgmt.managednetworkfabric.models.TerminalServerPatchableProperties
     """
 
-    _validation = {
-        "rack_count": {"maximum": 8, "minimum": 1},
-        "server_count_per_rack": {"maximum": 16, "minimum": 1},
-        "ipv4_prefix": {"min_length": 1},
-        "ipv6_prefix": {"min_length": 1},
-        "fabric_asn": {"maximum": 4294967295, "minimum": 1},
-    }
-
     _attribute_map = {
-        "rack_count": {"key": "rackCount", "type": "int"},
-        "server_count_per_rack": {"key": "serverCountPerRack", "type": "int"},
-        "ipv4_prefix": {"key": "ipv4Prefix", "type": "str"},
-        "ipv6_prefix": {"key": "ipv6Prefix", "type": "str"},
-        "fabric_asn": {"key": "fabricASN", "type": "int"},
         "terminal_server_configuration": {
             "key": "terminalServerConfiguration",
-            "type": "NetworkFabricPatchablePropertiesTerminalServerConfiguration",
-        },
-        "management_network_configuration": {
-            "key": "managementNetworkConfiguration",
-            "type": "ManagementNetworkConfigurationPatchableProperties",
+            "type": "TerminalServerPatchableProperties",
         },
     }
 
     def __init__(
         self,
         *,
-        rack_count: Optional[int] = None,
-        server_count_per_rack: Optional[int] = None,
-        ipv4_prefix: Optional[str] = None,
-        ipv6_prefix: Optional[str] = None,
-        fabric_asn: Optional[int] = None,
-        terminal_server_configuration: Optional[
-            "_models.NetworkFabricPatchablePropertiesTerminalServerConfiguration"
-        ] = None,
-        management_network_configuration: Optional["_models.ManagementNetworkConfigurationPatchableProperties"] = None,
+        terminal_server_configuration: Optional["_models.TerminalServerPatchableProperties"] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword rack_count: Number of compute racks associated to Network Fabric.
-        :paramtype rack_count: int
-        :keyword server_count_per_rack: Number of servers.Possible values are from 1-16.
-        :paramtype server_count_per_rack: int
-        :keyword ipv4_prefix: IPv4Prefix for Management Network. Example: 10.1.0.0/19.
-        :paramtype ipv4_prefix: str
-        :keyword ipv6_prefix: IPv6Prefix for Management Network. Example: 3FFE:FFFF:0:CD40::/59.
-        :paramtype ipv6_prefix: str
-        :keyword fabric_asn: ASN of CE devices for CE/PE connectivity.
-        :paramtype fabric_asn: int
         :keyword terminal_server_configuration: Network and credentials configuration already applied
          to terminal server.
         :paramtype terminal_server_configuration:
-         ~azure.mgmt.managednetworkfabric.models.NetworkFabricPatchablePropertiesTerminalServerConfiguration
-        :keyword management_network_configuration: Configuration to be used to setup the management
-         network.
-        :paramtype management_network_configuration:
-         ~azure.mgmt.managednetworkfabric.models.ManagementNetworkConfigurationPatchableProperties
+         ~azure.mgmt.managednetworkfabric.models.TerminalServerPatchableProperties
         """
         super().__init__(**kwargs)
-        self.rack_count = rack_count
-        self.server_count_per_rack = server_count_per_rack
-        self.ipv4_prefix = ipv4_prefix
-        self.ipv6_prefix = ipv6_prefix
-        self.fabric_asn = fabric_asn
         self.terminal_server_configuration = terminal_server_configuration
-        self.management_network_configuration = management_network_configuration
-
-
-class TerminalServerPatchableProperties(_serialization.Model):
-    """Network and credential configuration currently applied on terminal server.
 
-    :ivar username: Username for the terminal server connection.
-    :vartype username: str
-    :ivar password: Password for the terminal server connection.
-    :vartype password: str
-    :ivar serial_number: Serial Number of Terminal server.
-    :vartype serial_number: str
-    """
 
-    _validation = {
-        "username": {"min_length": 1},
-        "password": {"min_length": 1},
-        "serial_number": {"min_length": 1},
-    }
-
-    _attribute_map = {
-        "username": {"key": "username", "type": "str"},
-        "password": {"key": "password", "type": "str"},
-        "serial_number": {"key": "serialNumber", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        username: Optional[str] = None,
-        password: Optional[str] = None,
-        serial_number: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword username: Username for the terminal server connection.
-        :paramtype username: str
-        :keyword password: Password for the terminal server connection.
-        :paramtype password: str
-        :keyword serial_number: Serial Number of Terminal server.
-        :paramtype serial_number: str
-        """
-        super().__init__(**kwargs)
-        self.username = username
-        self.password = password
-        self.serial_number = serial_number
-
-
-class NetworkFabricPatchablePropertiesTerminalServerConfiguration(
-    TerminalServerPatchableProperties, Layer3IpPrefixProperties
+class NetworkFabricPatchParametersProperties(
+    AnnotationResource, TerminalServerPatchParameters, NetworkFabricPatchableProperties
 ):
-    """Network and credentials configuration already applied to terminal server.
-
-    :ivar primary_ipv4_prefix: IPv4 Address Prefix.
-    :vartype primary_ipv4_prefix: str
-    :ivar primary_ipv6_prefix: IPv6 Address Prefix.
-    :vartype primary_ipv6_prefix: str
-    :ivar secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
-    :vartype secondary_ipv4_prefix: str
-    :ivar secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
-    :vartype secondary_ipv6_prefix: str
-    :ivar username: Username for the terminal server connection.
-    :vartype username: str
-    :ivar password: Password for the terminal server connection.
-    :vartype password: str
-    :ivar serial_number: Serial Number of Terminal server.
-    :vartype serial_number: str
-    """
-
-    _validation = {
-        "username": {"min_length": 1},
-        "password": {"min_length": 1},
-        "serial_number": {"min_length": 1},
-    }
-
-    _attribute_map = {
-        "primary_ipv4_prefix": {"key": "primaryIpv4Prefix", "type": "str"},
-        "primary_ipv6_prefix": {"key": "primaryIpv6Prefix", "type": "str"},
-        "secondary_ipv4_prefix": {"key": "secondaryIpv4Prefix", "type": "str"},
-        "secondary_ipv6_prefix": {"key": "secondaryIpv6Prefix", "type": "str"},
-        "username": {"key": "username", "type": "str"},
-        "password": {"key": "password", "type": "str"},
-        "serial_number": {"key": "serialNumber", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        primary_ipv4_prefix: Optional[str] = None,
-        primary_ipv6_prefix: Optional[str] = None,
-        secondary_ipv4_prefix: Optional[str] = None,
-        secondary_ipv6_prefix: Optional[str] = None,
-        username: Optional[str] = None,
-        password: Optional[str] = None,
-        serial_number: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword primary_ipv4_prefix: IPv4 Address Prefix.
-        :paramtype primary_ipv4_prefix: str
-        :keyword primary_ipv6_prefix: IPv6 Address Prefix.
-        :paramtype primary_ipv6_prefix: str
-        :keyword secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
-        :paramtype secondary_ipv4_prefix: str
-        :keyword secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
-        :paramtype secondary_ipv6_prefix: str
-        :keyword username: Username for the terminal server connection.
-        :paramtype username: str
-        :keyword password: Password for the terminal server connection.
-        :paramtype password: str
-        :keyword serial_number: Serial Number of Terminal server.
-        :paramtype serial_number: str
-        """
-        super().__init__(
-            username=username,
-            password=password,
-            serial_number=serial_number,
-            primary_ipv4_prefix=primary_ipv4_prefix,
-            primary_ipv6_prefix=primary_ipv6_prefix,
-            secondary_ipv4_prefix=secondary_ipv4_prefix,
-            secondary_ipv6_prefix=secondary_ipv6_prefix,
-            **kwargs
-        )
-        self.primary_ipv4_prefix = primary_ipv4_prefix
-        self.primary_ipv6_prefix = primary_ipv6_prefix
-        self.secondary_ipv4_prefix = secondary_ipv4_prefix
-        self.secondary_ipv6_prefix = secondary_ipv6_prefix
-        self.username = username
-        self.password = password
-        self.serial_number = serial_number
-
-
-class NetworkFabricPatchProperties(AnnotationResource, NetworkFabricPatchableProperties):
     """Network Fabric Patch properties.
 
-    :ivar rack_count: Number of compute racks associated to Network Fabric.
-    :vartype rack_count: int
-    :ivar server_count_per_rack: Number of servers.Possible values are from 1-16.
-    :vartype server_count_per_rack: int
-    :ivar ipv4_prefix: IPv4Prefix for Management Network. Example: 10.1.0.0/19.
-    :vartype ipv4_prefix: str
-    :ivar ipv6_prefix: IPv6Prefix for Management Network. Example: 3FFE:FFFF:0:CD40::/59.
-    :vartype ipv6_prefix: str
-    :ivar fabric_asn: ASN of CE devices for CE/PE connectivity.
-    :vartype fabric_asn: int
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    :ivar racks: List of NetworkRack resource IDs under the Network Fabric. The number of racks
+     allowed depends on the Network Fabric SKU.
+    :vartype racks: list[str]
+    :ivar l2_isolation_domains: List of L2IsolationDomain resource IDs under the Network Fabric.
+    :vartype l2_isolation_domains: list[str]
+    :ivar l3_isolation_domains: List of L3IsolationDomain resource IDs under the Network Fabric.
+    :vartype l3_isolation_domains: list[str]
     :ivar terminal_server_configuration: Network and credentials configuration already applied to
      terminal server.
     :vartype terminal_server_configuration:
-     ~azure.mgmt.managednetworkfabric.models.NetworkFabricPatchablePropertiesTerminalServerConfiguration
-    :ivar management_network_configuration: Configuration to be used to setup the management
-     network.
-    :vartype management_network_configuration:
-     ~azure.mgmt.managednetworkfabric.models.ManagementNetworkConfigurationPatchableProperties
+     ~azure.mgmt.managednetworkfabric.models.TerminalServerPatchableProperties
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
     """
 
     _validation = {
-        "rack_count": {"maximum": 8, "minimum": 1},
-        "server_count_per_rack": {"maximum": 16, "minimum": 1},
-        "ipv4_prefix": {"min_length": 1},
-        "ipv6_prefix": {"min_length": 1},
-        "fabric_asn": {"maximum": 4294967295, "minimum": 1},
+        "racks": {"readonly": True},
+        "l2_isolation_domains": {"readonly": True},
+        "l3_isolation_domains": {"readonly": True},
     }
 
     _attribute_map = {
-        "rack_count": {"key": "rackCount", "type": "int"},
-        "server_count_per_rack": {"key": "serverCountPerRack", "type": "int"},
-        "ipv4_prefix": {"key": "ipv4Prefix", "type": "str"},
-        "ipv6_prefix": {"key": "ipv6Prefix", "type": "str"},
-        "fabric_asn": {"key": "fabricASN", "type": "int"},
+        "racks": {"key": "racks", "type": "[str]"},
+        "l2_isolation_domains": {"key": "l2IsolationDomains", "type": "[str]"},
+        "l3_isolation_domains": {"key": "l3IsolationDomains", "type": "[str]"},
         "terminal_server_configuration": {
             "key": "terminalServerConfiguration",
-            "type": "NetworkFabricPatchablePropertiesTerminalServerConfiguration",
-        },
-        "management_network_configuration": {
-            "key": "managementNetworkConfiguration",
-            "type": "ManagementNetworkConfigurationPatchableProperties",
+            "type": "TerminalServerPatchableProperties",
         },
         "annotation": {"key": "annotation", "type": "str"},
     }
 
     def __init__(
         self,
         *,
-        rack_count: Optional[int] = None,
-        server_count_per_rack: Optional[int] = None,
-        ipv4_prefix: Optional[str] = None,
-        ipv6_prefix: Optional[str] = None,
-        fabric_asn: Optional[int] = None,
-        terminal_server_configuration: Optional[
-            "_models.NetworkFabricPatchablePropertiesTerminalServerConfiguration"
-        ] = None,
-        management_network_configuration: Optional["_models.ManagementNetworkConfigurationPatchableProperties"] = None,
+        terminal_server_configuration: Optional["_models.TerminalServerPatchableProperties"] = None,
         annotation: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword rack_count: Number of compute racks associated to Network Fabric.
-        :paramtype rack_count: int
-        :keyword server_count_per_rack: Number of servers.Possible values are from 1-16.
-        :paramtype server_count_per_rack: int
-        :keyword ipv4_prefix: IPv4Prefix for Management Network. Example: 10.1.0.0/19.
-        :paramtype ipv4_prefix: str
-        :keyword ipv6_prefix: IPv6Prefix for Management Network. Example: 3FFE:FFFF:0:CD40::/59.
-        :paramtype ipv6_prefix: str
-        :keyword fabric_asn: ASN of CE devices for CE/PE connectivity.
-        :paramtype fabric_asn: int
         :keyword terminal_server_configuration: Network and credentials configuration already applied
          to terminal server.
         :paramtype terminal_server_configuration:
-         ~azure.mgmt.managednetworkfabric.models.NetworkFabricPatchablePropertiesTerminalServerConfiguration
-        :keyword management_network_configuration: Configuration to be used to setup the management
-         network.
-        :paramtype management_network_configuration:
-         ~azure.mgmt.managednetworkfabric.models.ManagementNetworkConfigurationPatchableProperties
+         ~azure.mgmt.managednetworkfabric.models.TerminalServerPatchableProperties
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
         """
-        super().__init__(
-            annotation=annotation,
-            rack_count=rack_count,
-            server_count_per_rack=server_count_per_rack,
-            ipv4_prefix=ipv4_prefix,
-            ipv6_prefix=ipv6_prefix,
-            fabric_asn=fabric_asn,
-            terminal_server_configuration=terminal_server_configuration,
-            management_network_configuration=management_network_configuration,
-            **kwargs
-        )
-        self.rack_count = rack_count
-        self.server_count_per_rack = server_count_per_rack
-        self.ipv4_prefix = ipv4_prefix
-        self.ipv6_prefix = ipv6_prefix
-        self.fabric_asn = fabric_asn
+        super().__init__(annotation=annotation, terminal_server_configuration=terminal_server_configuration, **kwargs)
+        self.racks = None
+        self.l2_isolation_domains = None
+        self.l3_isolation_domains = None
         self.terminal_server_configuration = terminal_server_configuration
-        self.management_network_configuration = management_network_configuration
         self.annotation = annotation
 
 
-class NetworkFabricProperties(AnnotationResource):  # pylint: disable=too-many-instance-attributes
-    """Network Fabric Properties defines the properties of the resource.
+class NetworkFabricProperties(
+    AnnotationResource, NetworkFabricPatchableProperties
+):  # pylint: disable=too-many-instance-attributes
+    """NetworkFabricProperties - define the resource properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
+    :ivar racks: List of NetworkRack resource IDs under the Network Fabric. The number of racks
+     allowed depends on the Network Fabric SKU.
+    :vartype racks: list[str]
+    :ivar l2_isolation_domains: List of L2IsolationDomain resource IDs under the Network Fabric.
+    :vartype l2_isolation_domains: list[str]
+    :ivar l3_isolation_domains: List of L3IsolationDomain resource IDs under the Network Fabric.
+    :vartype l3_isolation_domains: list[str]
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
     :ivar network_fabric_sku: Supported Network Fabric SKU.Example: Compute / Aggregate racks. Once
      the user chooses a particular SKU, only supported racks can be added to the Network Fabric. The
      SKU determines whether it is a single / multi rack Network Fabric. Required.
     :vartype network_fabric_sku: str
-    :ivar fabric_version: The version of Network Fabric.
-    :vartype fabric_version: str
-    :ivar router_ids: Array of router IDs.
-    :vartype router_ids: list[str]
-    :ivar network_fabric_controller_id: Azure resource ID for the NetworkFabricController the
-     NetworkFabric belongs. Required.
-    :vartype network_fabric_controller_id: str
-    :ivar rack_count: Number of compute racks associated to Network Fabric.
+    :ivar rack_count: Number of racks associated to Network Fabric.Possible values are from 2-8.
+     Required.
     :vartype rack_count: int
     :ivar server_count_per_rack: Number of servers.Possible values are from 1-16. Required.
     :vartype server_count_per_rack: int
-    :ivar ipv4_prefix: IPv4Prefix for Management Network. Example: 10.1.0.0/19. Required.
+    :ivar ipv4_prefix: IPv4Prefix for Management Network. Example: 10.1.0.0/19.
     :vartype ipv4_prefix: str
     :ivar ipv6_prefix: IPv6Prefix for Management Network. Example: 3FFE:FFFF:0:CD40::/59.
     :vartype ipv6_prefix: str
+    :ivar router_id: Router Id of CE to be used for MP-BGP between PE and CE.
+    :vartype router_id: str
     :ivar fabric_asn: ASN of CE devices for CE/PE connectivity. Required.
     :vartype fabric_asn: int
+    :ivar network_fabric_controller_id: Azure resource ID for the NetworkFabricController the
+     NetworkFabric belongs. Required.
+    :vartype network_fabric_controller_id: str
     :ivar terminal_server_configuration: Network and credentials configuration currently applied to
      terminal server. Required.
     :vartype terminal_server_configuration:
      ~azure.mgmt.managednetworkfabric.models.TerminalServerConfiguration
     :ivar management_network_configuration: Configuration to be used to setup the management
      network. Required.
     :vartype management_network_configuration:
-     ~azure.mgmt.managednetworkfabric.models.ManagementNetworkConfigurationProperties
-    :ivar racks: List of NetworkRack resource IDs under the Network Fabric. The number of racks
-     allowed depends on the Network Fabric SKU.
-    :vartype racks: list[str]
-    :ivar l2_isolation_domains: List of L2 Isolation Domain resource IDs under the Network Fabric.
-    :vartype l2_isolation_domains: list[str]
-    :ivar l3_isolation_domains: List of L3 Isolation Domain resource IDs under the Network Fabric.
-    :vartype l3_isolation_domains: list[str]
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provides you the latest status of the NFC service, whether it is
-     Accepted, updating, Succeeded or Failed. During this process, the states keep changing based on
-     the status of NFC provisioning. Known values are: "Accepted", "Succeeded", "Updating",
-     "Deleting", "Failed", and "Canceled".
+     ~azure.mgmt.managednetworkfabric.models.ManagementNetworkConfiguration
+    :ivar operational_state: Gets the operational state of the resource. Known values are:
+     "Provisioning", "Provisioned", "ErrorProvisioning", "Deprovisioning", "Deprovisioned",
+     "ErrorDeprovisioning", and "DeferredControl".
+    :vartype operational_state: str or
+     ~azure.mgmt.managednetworkfabric.models.NetworkFabricOperationalState
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
-        "network_fabric_sku": {"required": True, "min_length": 1},
-        "fabric_version": {"readonly": True},
-        "router_ids": {"readonly": True},
-        "network_fabric_controller_id": {"required": True},
-        "rack_count": {"maximum": 8, "minimum": 1},
-        "server_count_per_rack": {"required": True, "maximum": 16, "minimum": 1},
-        "ipv4_prefix": {"required": True, "min_length": 1},
-        "ipv6_prefix": {"min_length": 1},
-        "fabric_asn": {"required": True, "maximum": 4294967295, "minimum": 1},
-        "terminal_server_configuration": {"required": True},
-        "management_network_configuration": {"required": True},
         "racks": {"readonly": True},
         "l2_isolation_domains": {"readonly": True},
         "l3_isolation_domains": {"readonly": True},
-        "configuration_state": {"readonly": True},
+        "network_fabric_sku": {"required": True},
+        "rack_count": {"required": True, "maximum": 8, "minimum": 2},
+        "server_count_per_rack": {"required": True, "maximum": 16, "minimum": 1},
+        "router_id": {"readonly": True},
+        "fabric_asn": {"required": True, "maximum": 65535, "minimum": 1},
+        "network_fabric_controller_id": {"required": True},
+        "terminal_server_configuration": {"required": True},
+        "management_network_configuration": {"required": True},
+        "operational_state": {"readonly": True},
         "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
     }
 
     _attribute_map = {
+        "racks": {"key": "racks", "type": "[str]"},
+        "l2_isolation_domains": {"key": "l2IsolationDomains", "type": "[str]"},
+        "l3_isolation_domains": {"key": "l3IsolationDomains", "type": "[str]"},
         "annotation": {"key": "annotation", "type": "str"},
         "network_fabric_sku": {"key": "networkFabricSku", "type": "str"},
-        "fabric_version": {"key": "fabricVersion", "type": "str"},
-        "router_ids": {"key": "routerIds", "type": "[str]"},
-        "network_fabric_controller_id": {"key": "networkFabricControllerId", "type": "str"},
         "rack_count": {"key": "rackCount", "type": "int"},
         "server_count_per_rack": {"key": "serverCountPerRack", "type": "int"},
         "ipv4_prefix": {"key": "ipv4Prefix", "type": "str"},
         "ipv6_prefix": {"key": "ipv6Prefix", "type": "str"},
+        "router_id": {"key": "routerId", "type": "str"},
         "fabric_asn": {"key": "fabricASN", "type": "int"},
+        "network_fabric_controller_id": {"key": "networkFabricControllerId", "type": "str"},
         "terminal_server_configuration": {"key": "terminalServerConfiguration", "type": "TerminalServerConfiguration"},
         "management_network_configuration": {
             "key": "managementNetworkConfiguration",
-            "type": "ManagementNetworkConfigurationProperties",
+            "type": "ManagementNetworkConfiguration",
         },
-        "racks": {"key": "racks", "type": "[str]"},
-        "l2_isolation_domains": {"key": "l2IsolationDomains", "type": "[str]"},
-        "l3_isolation_domains": {"key": "l3IsolationDomains", "type": "[str]"},
-        "configuration_state": {"key": "configurationState", "type": "str"},
+        "operational_state": {"key": "operationalState", "type": "str"},
         "provisioning_state": {"key": "provisioningState", "type": "str"},
-        "administrative_state": {"key": "administrativeState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         network_fabric_sku: str,
-        network_fabric_controller_id: str,
+        rack_count: int,
         server_count_per_rack: int,
-        ipv4_prefix: str,
         fabric_asn: int,
+        network_fabric_controller_id: str,
         terminal_server_configuration: "_models.TerminalServerConfiguration",
-        management_network_configuration: "_models.ManagementNetworkConfigurationProperties",
+        management_network_configuration: "_models.ManagementNetworkConfiguration",
         annotation: Optional[str] = None,
-        rack_count: Optional[int] = None,
+        ipv4_prefix: Optional[str] = None,
         ipv6_prefix: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
         :keyword network_fabric_sku: Supported Network Fabric SKU.Example: Compute / Aggregate racks.
          Once the user chooses a particular SKU, only supported racks can be added to the Network
          Fabric. The SKU determines whether it is a single / multi rack Network Fabric. Required.
         :paramtype network_fabric_sku: str
-        :keyword network_fabric_controller_id: Azure resource ID for the NetworkFabricController the
-         NetworkFabric belongs. Required.
-        :paramtype network_fabric_controller_id: str
-        :keyword rack_count: Number of compute racks associated to Network Fabric.
+        :keyword rack_count: Number of racks associated to Network Fabric.Possible values are from 2-8.
+         Required.
         :paramtype rack_count: int
         :keyword server_count_per_rack: Number of servers.Possible values are from 1-16. Required.
         :paramtype server_count_per_rack: int
-        :keyword ipv4_prefix: IPv4Prefix for Management Network. Example: 10.1.0.0/19. Required.
+        :keyword ipv4_prefix: IPv4Prefix for Management Network. Example: 10.1.0.0/19.
         :paramtype ipv4_prefix: str
         :keyword ipv6_prefix: IPv6Prefix for Management Network. Example: 3FFE:FFFF:0:CD40::/59.
         :paramtype ipv6_prefix: str
         :keyword fabric_asn: ASN of CE devices for CE/PE connectivity. Required.
         :paramtype fabric_asn: int
+        :keyword network_fabric_controller_id: Azure resource ID for the NetworkFabricController the
+         NetworkFabric belongs. Required.
+        :paramtype network_fabric_controller_id: str
         :keyword terminal_server_configuration: Network and credentials configuration currently applied
          to terminal server. Required.
         :paramtype terminal_server_configuration:
          ~azure.mgmt.managednetworkfabric.models.TerminalServerConfiguration
         :keyword management_network_configuration: Configuration to be used to setup the management
          network. Required.
         :paramtype management_network_configuration:
-         ~azure.mgmt.managednetworkfabric.models.ManagementNetworkConfigurationProperties
+         ~azure.mgmt.managednetworkfabric.models.ManagementNetworkConfiguration
         """
         super().__init__(annotation=annotation, **kwargs)
+        self.racks = None
+        self.l2_isolation_domains = None
+        self.l3_isolation_domains = None
         self.network_fabric_sku = network_fabric_sku
-        self.fabric_version = None
-        self.router_ids = None
-        self.network_fabric_controller_id = network_fabric_controller_id
         self.rack_count = rack_count
         self.server_count_per_rack = server_count_per_rack
         self.ipv4_prefix = ipv4_prefix
         self.ipv6_prefix = ipv6_prefix
+        self.router_id = None
         self.fabric_asn = fabric_asn
+        self.network_fabric_controller_id = network_fabric_controller_id
         self.terminal_server_configuration = terminal_server_configuration
         self.management_network_configuration = management_network_configuration
-        self.racks = None
-        self.l2_isolation_domains = None
-        self.l3_isolation_domains = None
-        self.configuration_state = None
+        self.operational_state = None
         self.provisioning_state = None
-        self.administrative_state = None
+        self.annotation = annotation
 
 
 class NetworkFabricSku(ProxyResource):
-    """The Network Fabric SKU resource definition.
+    """The NetworkFabricSku resource definition.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
      information.
     :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
-    :ivar type_properties_type: Type of Network Fabric SKU. Known values are: "SingleRack" and
-     "MultiRack".
-    :vartype type_properties_type: str or ~azure.mgmt.managednetworkfabric.models.FabricSkuType
+    :ivar type_properties_type: Type of Network Fabric Sku.
+    :vartype type_properties_type: str
     :ivar max_compute_racks: Maximum number of compute racks available for this Network Fabric SKU.
-     The value of max count racks is 4 for 4 rack SKU and 8 for 8 rack SKU.
     :vartype max_compute_racks: int
-    :ivar maximum_server_count: Maximum number of servers available for this Network Fabric SKU.
-    :vartype maximum_server_count: int
-    :ivar supported_versions: List of supported Network Fabric SKU versions.
-    :vartype supported_versions: list[str]
-    :ivar details: URL providing detailed configuration of the fabric SKU.
-    :vartype details: str
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
+    :ivar min_supported_ver: Minimum supported version.
+    :vartype min_supported_ver: str
+    :ivar max_supported_ver: Maximum supported version.
+    :vartype max_supported_ver: str
+    :ivar details_uri: The URI gives full details of sku.
+    :vartype details_uri: str
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
         "type_properties_type": {"readonly": True},
-        "supported_versions": {"readonly": True},
-        "details": {"readonly": True},
+        "min_supported_ver": {"readonly": True},
+        "max_supported_ver": {"readonly": True},
+        "details_uri": {"readonly": True},
         "provisioning_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "type_properties_type": {"key": "properties.type", "type": "str"},
         "max_compute_racks": {"key": "properties.maxComputeRacks", "type": "int"},
-        "maximum_server_count": {"key": "properties.maximumServerCount", "type": "int"},
-        "supported_versions": {"key": "properties.supportedVersions", "type": "[str]"},
-        "details": {"key": "properties.details", "type": "str"},
+        "min_supported_ver": {"key": "properties.minSupportedVer", "type": "str"},
+        "max_supported_ver": {"key": "properties.maxSupportedVer", "type": "str"},
+        "details_uri": {"key": "properties.detailsUri", "type": "str"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
     }
 
-    def __init__(
-        self, *, max_compute_racks: Optional[int] = None, maximum_server_count: Optional[int] = None, **kwargs: Any
-    ) -> None:
+    def __init__(self, *, max_compute_racks: Optional[int] = None, **kwargs: Any) -> None:
         """
         :keyword max_compute_racks: Maximum number of compute racks available for this Network Fabric
-         SKU. The value of max count racks is 4 for 4 rack SKU and 8 for 8 rack SKU.
+         SKU.
         :paramtype max_compute_racks: int
-        :keyword maximum_server_count: Maximum number of servers available for this Network Fabric SKU.
-        :paramtype maximum_server_count: int
         """
         super().__init__(**kwargs)
         self.type_properties_type = None
         self.max_compute_racks = max_compute_racks
-        self.maximum_server_count = maximum_server_count
-        self.supported_versions = None
-        self.details = None
+        self.min_supported_ver = None
+        self.max_supported_ver = None
+        self.details_uri = None
         self.provisioning_state = None
 
 
 class NetworkFabricSkusListResult(_serialization.Model):
-    """List of Network Fabric SKUs.
+    """List of NetworkFabricSkus.
 
-    :ivar value: List of Network Fabric SKU resources.
+    :ivar value: List of NetworkFabricSku resources.
     :vartype value: list[~azure.mgmt.managednetworkfabric.models.NetworkFabricSku]
     :ivar next_link: Url to follow for getting next page of resources.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[NetworkFabricSku]"},
@@ -8771,133 +6287,133 @@
         self,
         *,
         value: Optional[List["_models.NetworkFabricSku"]] = None,
         next_link: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword value: List of Network Fabric SKU resources.
+        :keyword value: List of NetworkFabricSku resources.
         :paramtype value: list[~azure.mgmt.managednetworkfabric.models.NetworkFabricSku]
         :keyword next_link: Url to follow for getting next page of resources.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
 class NetworkFabricsListResult(_serialization.Model):
-    """List of Network Fabrics.
+    """List of NetworkFabrics.
 
-    :ivar value: List of Network Fabric resources.
+    :ivar value: List of NetworkFabric resources.
     :vartype value: list[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
     :ivar next_link: Url to follow for getting next page of resources.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[NetworkFabric]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
     def __init__(
         self, *, value: Optional[List["_models.NetworkFabric"]] = None, next_link: Optional[str] = None, **kwargs: Any
     ) -> None:
         """
-        :keyword value: List of Network Fabric resources.
+        :keyword value: List of NetworkFabric resources.
         :paramtype value: list[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :keyword next_link: Url to follow for getting next page of resources.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
 class NetworkInterface(ProxyResource):  # pylint: disable=too-many-instance-attributes
     """Defines the NetworkInterface resource.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
      information.
     :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar physical_identifier: Physical Identifier of the network interface.
+    :ivar physical_identifier: physicalIdentifier of the network interface.
     :vartype physical_identifier: str
-    :ivar connected_to: The ARM resource id of the interface or compute server its connected to.
+    :ivar administrative_state: administrativeState of the network interface. Example: Enabled |
+     Disabled. Known values are: "Enabled" and "Disabled".
+    :vartype administrative_state: str or
+     ~azure.mgmt.managednetworkfabric.models.EnabledDisabledState
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
+    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
+    :ivar connected_to: The arm resource id of the interface or compute server its connected to.
     :vartype connected_to: str
     :ivar interface_type: The Interface Type. Example: Management/Data. Known values are:
      "Management" and "Data".
     :vartype interface_type: str or ~azure.mgmt.managednetworkfabric.models.InterfaceType
-    :ivar ipv4_address: IPv4Address of the interface.
+    :ivar ipv4_address: ipv4Address.
     :vartype ipv4_address: str
-    :ivar ipv6_address: IPv6Address of the interface.
+    :ivar ipv6_address: ipv6Address.
     :vartype ipv6_address: str
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
         "physical_identifier": {"readonly": True},
+        "administrative_state": {"readonly": True},
+        "provisioning_state": {"readonly": True},
         "connected_to": {"readonly": True},
         "interface_type": {"readonly": True},
         "ipv4_address": {"readonly": True},
         "ipv6_address": {"readonly": True},
-        "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "annotation": {"key": "properties.annotation", "type": "str"},
         "physical_identifier": {"key": "properties.physicalIdentifier", "type": "str"},
+        "administrative_state": {"key": "properties.administrativeState", "type": "str"},
+        "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
         "connected_to": {"key": "properties.connectedTo", "type": "str"},
         "interface_type": {"key": "properties.interfaceType", "type": "str"},
         "ipv4_address": {"key": "properties.ipv4Address", "type": "str"},
         "ipv6_address": {"key": "properties.ipv6Address", "type": "str"},
-        "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
-        "administrative_state": {"key": "properties.administrativeState", "type": "str"},
     }
 
     def __init__(self, *, annotation: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
         """
         super().__init__(**kwargs)
         self.annotation = annotation
         self.physical_identifier = None
+        self.administrative_state = None
+        self.provisioning_state = None
         self.connected_to = None
         self.interface_type = None
         self.ipv4_address = None
         self.ipv6_address = None
-        self.provisioning_state = None
-        self.administrative_state = None
 
 
 class NetworkInterfacePatch(_serialization.Model):
     """The NetworkInterfacePatch resource definition.
 
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
@@ -8932,74 +6448,74 @@
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
         """
         super().__init__(annotation=annotation, **kwargs)
 
 
 class NetworkInterfaceProperties(AnnotationResource):
-    """Network Interface Properties defines the properties of the resource.
+    """NetworkInterfaceProperties define the resource properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar physical_identifier: Physical Identifier of the network interface.
+    :ivar physical_identifier: physicalIdentifier of the network interface.
     :vartype physical_identifier: str
-    :ivar connected_to: The ARM resource id of the interface or compute server its connected to.
+    :ivar administrative_state: administrativeState of the network interface. Example: Enabled |
+     Disabled. Known values are: "Enabled" and "Disabled".
+    :vartype administrative_state: str or
+     ~azure.mgmt.managednetworkfabric.models.EnabledDisabledState
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
+    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
+    :ivar connected_to: The arm resource id of the interface or compute server its connected to.
     :vartype connected_to: str
     :ivar interface_type: The Interface Type. Example: Management/Data. Known values are:
      "Management" and "Data".
     :vartype interface_type: str or ~azure.mgmt.managednetworkfabric.models.InterfaceType
-    :ivar ipv4_address: IPv4Address of the interface.
+    :ivar ipv4_address: ipv4Address.
     :vartype ipv4_address: str
-    :ivar ipv6_address: IPv6Address of the interface.
+    :ivar ipv6_address: ipv6Address.
     :vartype ipv6_address: str
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
         "physical_identifier": {"readonly": True},
+        "administrative_state": {"readonly": True},
+        "provisioning_state": {"readonly": True},
         "connected_to": {"readonly": True},
         "interface_type": {"readonly": True},
         "ipv4_address": {"readonly": True},
         "ipv6_address": {"readonly": True},
-        "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
     }
 
     _attribute_map = {
         "annotation": {"key": "annotation", "type": "str"},
         "physical_identifier": {"key": "physicalIdentifier", "type": "str"},
+        "administrative_state": {"key": "administrativeState", "type": "str"},
+        "provisioning_state": {"key": "provisioningState", "type": "str"},
         "connected_to": {"key": "connectedTo", "type": "str"},
         "interface_type": {"key": "interfaceType", "type": "str"},
         "ipv4_address": {"key": "ipv4Address", "type": "str"},
         "ipv6_address": {"key": "ipv6Address", "type": "str"},
-        "provisioning_state": {"key": "provisioningState", "type": "str"},
-        "administrative_state": {"key": "administrativeState", "type": "str"},
     }
 
     def __init__(self, *, annotation: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
         """
         super().__init__(annotation=annotation, **kwargs)
         self.physical_identifier = None
+        self.administrative_state = None
+        self.provisioning_state = None
         self.connected_to = None
         self.interface_type = None
         self.ipv4_address = None
         self.ipv6_address = None
-        self.provisioning_state = None
-        self.administrative_state = None
 
 
 class NetworkInterfacesList(_serialization.Model):
     """List of NetworkInterfaces.
 
     :ivar value: List of NetworkInterfaces resources.
     :vartype value: list[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
@@ -9026,161 +6542,23 @@
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
-class NetworkPacketBroker(TrackedResource):  # pylint: disable=too-many-instance-attributes
-    """The NetworkPacketBroker resource definition.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
-    :vartype id: str
-    :ivar name: The name of the resource.
-    :vartype name: str
-    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
-     "Microsoft.Storage/storageAccounts".
-    :vartype type: str
-    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
-     information.
-    :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
-    :ivar location: The geo-location where the resource lives. Required.
-    :vartype location: str
-    :ivar network_fabric_id: ARM resource ID of the Network Fabric. Required.
-    :vartype network_fabric_id: str
-    :ivar network_device_ids: List of ARM resource IDs of Network Devices [NPB].
-    :vartype network_device_ids: list[str]
-    :ivar source_interface_ids: List of network interfaces across NPB devices that are used to
-     mirror source traffic.
-    :vartype source_interface_ids: list[str]
-    :ivar network_tap_ids: List of network Tap IDs configured on NPB.
-    :vartype network_tap_ids: list[str]
-    :ivar neighbor_group_ids: List of neighbor group IDs configured on NPB.
-    :vartype neighbor_group_ids: list[str]
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    """
-
-    _validation = {
-        "id": {"readonly": True},
-        "name": {"readonly": True},
-        "type": {"readonly": True},
-        "system_data": {"readonly": True},
-        "location": {"required": True},
-        "network_fabric_id": {"required": True},
-        "network_device_ids": {"readonly": True},
-        "source_interface_ids": {"readonly": True},
-        "network_tap_ids": {"readonly": True},
-        "neighbor_group_ids": {"readonly": True},
-        "provisioning_state": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "id": {"key": "id", "type": "str"},
-        "name": {"key": "name", "type": "str"},
-        "type": {"key": "type", "type": "str"},
-        "system_data": {"key": "systemData", "type": "SystemData"},
-        "tags": {"key": "tags", "type": "{str}"},
-        "location": {"key": "location", "type": "str"},
-        "network_fabric_id": {"key": "properties.networkFabricId", "type": "str"},
-        "network_device_ids": {"key": "properties.networkDeviceIds", "type": "[str]"},
-        "source_interface_ids": {"key": "properties.sourceInterfaceIds", "type": "[str]"},
-        "network_tap_ids": {"key": "properties.networkTapIds", "type": "[str]"},
-        "neighbor_group_ids": {"key": "properties.neighborGroupIds", "type": "[str]"},
-        "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
-    }
-
-    def __init__(
-        self, *, location: str, network_fabric_id: str, tags: Optional[Dict[str, str]] = None, **kwargs: Any
-    ) -> None:
-        """
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
-        :keyword location: The geo-location where the resource lives. Required.
-        :paramtype location: str
-        :keyword network_fabric_id: ARM resource ID of the Network Fabric. Required.
-        :paramtype network_fabric_id: str
-        """
-        super().__init__(tags=tags, location=location, **kwargs)
-        self.network_fabric_id = network_fabric_id
-        self.network_device_ids = None
-        self.source_interface_ids = None
-        self.network_tap_ids = None
-        self.neighbor_group_ids = None
-        self.provisioning_state = None
-
-
-class NetworkPacketBrokerPatch(TagsUpdate):
-    """The NetworkPacketBroker patch resource definition.
-
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
-    """
-
-    _attribute_map = {
-        "tags": {"key": "tags", "type": "{str}"},
-    }
-
-    def __init__(self, *, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
-        """
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
-        """
-        super().__init__(tags=tags, **kwargs)
-
-
-class NetworkPacketBrokersListResult(_serialization.Model):
-    """List of NetworkPacketBrokers.
-
-    :ivar value: List of NetworkPacketBroker resources.
-    :vartype value: list[~azure.mgmt.managednetworkfabric.models.NetworkPacketBroker]
-    :ivar next_link: Url to follow for getting next page of resources.
-    :vartype next_link: str
-    """
-
-    _attribute_map = {
-        "value": {"key": "value", "type": "[NetworkPacketBroker]"},
-        "next_link": {"key": "nextLink", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        value: Optional[List["_models.NetworkPacketBroker"]] = None,
-        next_link: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword value: List of NetworkPacketBroker resources.
-        :paramtype value: list[~azure.mgmt.managednetworkfabric.models.NetworkPacketBroker]
-        :keyword next_link: Url to follow for getting next page of resources.
-        :paramtype next_link: str
-        """
-        super().__init__(**kwargs)
-        self.value = value
-        self.next_link = next_link
-
-
 class NetworkRack(TrackedResource):  # pylint: disable=too-many-instance-attributes
-    """The Network Rack resource definition.
+    """The NetworkRack resource definition.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -9188,1719 +6566,405 @@
     :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar location: The geo-location where the resource lives. Required.
     :vartype location: str
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar network_rack_type: Network Rack SKU name. Known values are: "Aggregate", "Compute", and
-     "Combined".
-    :vartype network_rack_type: str or ~azure.mgmt.managednetworkfabric.models.NetworkRackType
-    :ivar network_fabric_id: ARM resource ID of the Network Fabric. Required.
+    :ivar network_rack_sku: Network Rack SKU name. Required.
+    :vartype network_rack_sku: str
+    :ivar network_fabric_id: Network Fabric ARM resource id. Required.
     :vartype network_fabric_id: str
-    :ivar network_devices: List of network device ARM resource IDs.
+    :ivar network_devices: List of network device ARM resource ids.
     :vartype network_devices: list[str]
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
         "location": {"required": True},
+        "network_rack_sku": {"required": True},
         "network_fabric_id": {"required": True},
         "network_devices": {"readonly": True},
         "provisioning_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
         "annotation": {"key": "properties.annotation", "type": "str"},
-        "network_rack_type": {"key": "properties.networkRackType", "type": "str"},
+        "network_rack_sku": {"key": "properties.networkRackSku", "type": "str"},
         "network_fabric_id": {"key": "properties.networkFabricId", "type": "str"},
         "network_devices": {"key": "properties.networkDevices", "type": "[str]"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         location: str,
+        network_rack_sku: str,
         network_fabric_id: str,
         tags: Optional[Dict[str, str]] = None,
         annotation: Optional[str] = None,
-        network_rack_type: Optional[Union[str, "_models.NetworkRackType"]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword network_rack_type: Network Rack SKU name. Known values are: "Aggregate", "Compute",
-         and "Combined".
-        :paramtype network_rack_type: str or ~azure.mgmt.managednetworkfabric.models.NetworkRackType
-        :keyword network_fabric_id: ARM resource ID of the Network Fabric. Required.
+        :keyword network_rack_sku: Network Rack SKU name. Required.
+        :paramtype network_rack_sku: str
+        :keyword network_fabric_id: Network Fabric ARM resource id. Required.
         :paramtype network_fabric_id: str
         """
         super().__init__(tags=tags, location=location, **kwargs)
         self.annotation = annotation
-        self.network_rack_type = network_rack_type
-        self.network_fabric_id = network_fabric_id
-        self.network_devices = None
-        self.provisioning_state = None
-
-
-class NetworkRackProperties(AnnotationResource):
-    """Network Rack Properties defines the properties of the resource.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar network_rack_type: Network Rack SKU name. Known values are: "Aggregate", "Compute", and
-     "Combined".
-    :vartype network_rack_type: str or ~azure.mgmt.managednetworkfabric.models.NetworkRackType
-    :ivar network_fabric_id: ARM resource ID of the Network Fabric. Required.
-    :vartype network_fabric_id: str
-    :ivar network_devices: List of network device ARM resource IDs.
-    :vartype network_devices: list[str]
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    """
-
-    _validation = {
-        "network_fabric_id": {"required": True},
-        "network_devices": {"readonly": True},
-        "provisioning_state": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "annotation": {"key": "annotation", "type": "str"},
-        "network_rack_type": {"key": "networkRackType", "type": "str"},
-        "network_fabric_id": {"key": "networkFabricId", "type": "str"},
-        "network_devices": {"key": "networkDevices", "type": "[str]"},
-        "provisioning_state": {"key": "provisioningState", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        network_fabric_id: str,
-        annotation: Optional[str] = None,
-        network_rack_type: Optional[Union[str, "_models.NetworkRackType"]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword network_rack_type: Network Rack SKU name. Known values are: "Aggregate", "Compute",
-         and "Combined".
-        :paramtype network_rack_type: str or ~azure.mgmt.managednetworkfabric.models.NetworkRackType
-        :keyword network_fabric_id: ARM resource ID of the Network Fabric. Required.
-        :paramtype network_fabric_id: str
-        """
-        super().__init__(annotation=annotation, **kwargs)
-        self.network_rack_type = network_rack_type
+        self.network_rack_sku = network_rack_sku
         self.network_fabric_id = network_fabric_id
         self.network_devices = None
         self.provisioning_state = None
 
 
-class NetworkRacksListResult(_serialization.Model):
-    """List of Network Racks.
-
-    :ivar value: List of Network Rack resources.
-    :vartype value: list[~azure.mgmt.managednetworkfabric.models.NetworkRack]
-    :ivar next_link: Url to follow for getting next page of resources.
-    :vartype next_link: str
-    """
-
-    _attribute_map = {
-        "value": {"key": "value", "type": "[NetworkRack]"},
-        "next_link": {"key": "nextLink", "type": "str"},
-    }
-
-    def __init__(
-        self, *, value: Optional[List["_models.NetworkRack"]] = None, next_link: Optional[str] = None, **kwargs: Any
-    ) -> None:
-        """
-        :keyword value: List of Network Rack resources.
-        :paramtype value: list[~azure.mgmt.managednetworkfabric.models.NetworkRack]
-        :keyword next_link: Url to follow for getting next page of resources.
-        :paramtype next_link: str
-        """
-        super().__init__(**kwargs)
-        self.value = value
-        self.next_link = next_link
-
-
-class NetworkTap(TrackedResource):  # pylint: disable=too-many-instance-attributes
-    """The Network Tap resource definition.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
-    :vartype id: str
-    :ivar name: The name of the resource.
-    :vartype name: str
-    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
-     "Microsoft.Storage/storageAccounts".
-    :vartype type: str
-    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
-     information.
-    :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
-    :ivar location: The geo-location where the resource lives. Required.
-    :vartype location: str
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar network_packet_broker_id: ARM resource ID of the Network Packet Broker. Required.
-    :vartype network_packet_broker_id: str
-    :ivar source_tap_rule_id: Source Tap Rule Id. ARM Resource ID of the Network Tap Rule.
-    :vartype source_tap_rule_id: str
-    :ivar destinations: List of destinations to send the filter traffic. Required.
-    :vartype destinations:
-     list[~azure.mgmt.managednetworkfabric.models.NetworkTapPropertiesDestinationsItem]
-    :ivar polling_type: Polling type. Known values are: "Pull" and "Push".
-    :vartype polling_type: str or ~azure.mgmt.managednetworkfabric.models.PollingType
-    :ivar configuration_state: Gets the configurations state of the resource. Known values are:
-     "Succeeded", "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning",
-     "Deprovisioning", "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provides you the latest status of the NFC service, whether it is
-     Accepted, updating, Succeeded or Failed. During this process, the states keep changing based on
-     the status of Network Tap provisioning. Known values are: "Accepted", "Succeeded", "Updating",
-     "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Example -Enabled/Disabled.
-     Known values are: "Enabled", "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
-    """
-
-    _validation = {
-        "id": {"readonly": True},
-        "name": {"readonly": True},
-        "type": {"readonly": True},
-        "system_data": {"readonly": True},
-        "location": {"required": True},
-        "network_packet_broker_id": {"required": True},
-        "source_tap_rule_id": {"readonly": True},
-        "destinations": {"required": True, "min_items": 1},
-        "configuration_state": {"readonly": True},
-        "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "id": {"key": "id", "type": "str"},
-        "name": {"key": "name", "type": "str"},
-        "type": {"key": "type", "type": "str"},
-        "system_data": {"key": "systemData", "type": "SystemData"},
-        "tags": {"key": "tags", "type": "{str}"},
-        "location": {"key": "location", "type": "str"},
-        "annotation": {"key": "properties.annotation", "type": "str"},
-        "network_packet_broker_id": {"key": "properties.networkPacketBrokerId", "type": "str"},
-        "source_tap_rule_id": {"key": "properties.sourceTapRuleId", "type": "str"},
-        "destinations": {"key": "properties.destinations", "type": "[NetworkTapPropertiesDestinationsItem]"},
-        "polling_type": {"key": "properties.pollingType", "type": "str"},
-        "configuration_state": {"key": "properties.configurationState", "type": "str"},
-        "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
-        "administrative_state": {"key": "properties.administrativeState", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        location: str,
-        network_packet_broker_id: str,
-        destinations: List["_models.NetworkTapPropertiesDestinationsItem"],
-        tags: Optional[Dict[str, str]] = None,
-        annotation: Optional[str] = None,
-        polling_type: Optional[Union[str, "_models.PollingType"]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
-        :keyword location: The geo-location where the resource lives. Required.
-        :paramtype location: str
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword network_packet_broker_id: ARM resource ID of the Network Packet Broker. Required.
-        :paramtype network_packet_broker_id: str
-        :keyword destinations: List of destinations to send the filter traffic. Required.
-        :paramtype destinations:
-         list[~azure.mgmt.managednetworkfabric.models.NetworkTapPropertiesDestinationsItem]
-        :keyword polling_type: Polling type. Known values are: "Pull" and "Push".
-        :paramtype polling_type: str or ~azure.mgmt.managednetworkfabric.models.PollingType
-        """
-        super().__init__(tags=tags, location=location, **kwargs)
-        self.annotation = annotation
-        self.network_packet_broker_id = network_packet_broker_id
-        self.source_tap_rule_id = None
-        self.destinations = destinations
-        self.polling_type = polling_type
-        self.configuration_state = None
-        self.provisioning_state = None
-        self.administrative_state = None
-
-
-class NetworkTapPatch(TagsUpdate):
-    """The NetworkFabric resource definition.
+class NetworkRackPatch(_serialization.Model):
+    """The NetworkRack patch resource definition.
 
+    :ivar properties: Resource properties.
+    :vartype properties: JSON
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar polling_type: Polling type. Known values are: "Pull" and "Push".
-    :vartype polling_type: str or ~azure.mgmt.managednetworkfabric.models.PollingType
-    :ivar destinations: List of destination properties to send the filter traffic.
-    :vartype destinations:
-     list[~azure.mgmt.managednetworkfabric.models.NetworkTapPatchableParametersDestinationsItem]
     """
 
     _attribute_map = {
+        "properties": {"key": "properties", "type": "object"},
         "tags": {"key": "tags", "type": "{str}"},
-        "annotation": {"key": "properties.annotation", "type": "str"},
-        "polling_type": {"key": "properties.pollingType", "type": "str"},
-        "destinations": {"key": "properties.destinations", "type": "[NetworkTapPatchableParametersDestinationsItem]"},
     }
 
     def __init__(
-        self,
-        *,
-        tags: Optional[Dict[str, str]] = None,
-        annotation: Optional[str] = None,
-        polling_type: Optional[Union[str, "_models.PollingType"]] = None,
-        destinations: Optional[List["_models.NetworkTapPatchableParametersDestinationsItem"]] = None,
-        **kwargs: Any
+        self, *, properties: Optional[JSON] = None, tags: Optional[Dict[str, str]] = None, **kwargs: Any
     ) -> None:
         """
+        :keyword properties: Resource properties.
+        :paramtype properties: JSON
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword polling_type: Polling type. Known values are: "Pull" and "Push".
-        :paramtype polling_type: str or ~azure.mgmt.managednetworkfabric.models.PollingType
-        :keyword destinations: List of destination properties to send the filter traffic.
-        :paramtype destinations:
-         list[~azure.mgmt.managednetworkfabric.models.NetworkTapPatchableParametersDestinationsItem]
-        """
-        super().__init__(tags=tags, **kwargs)
-        self.annotation = annotation
-        self.polling_type = polling_type
-        self.destinations = destinations
-
-
-class NetworkTapPatchableParameters(AnnotationResource):
-    """The Network Tap resource patch definition.
-
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar polling_type: Polling type. Known values are: "Pull" and "Push".
-    :vartype polling_type: str or ~azure.mgmt.managednetworkfabric.models.PollingType
-    :ivar destinations: List of destination properties to send the filter traffic.
-    :vartype destinations:
-     list[~azure.mgmt.managednetworkfabric.models.NetworkTapPatchableParametersDestinationsItem]
-    """
-
-    _attribute_map = {
-        "annotation": {"key": "annotation", "type": "str"},
-        "polling_type": {"key": "pollingType", "type": "str"},
-        "destinations": {"key": "destinations", "type": "[NetworkTapPatchableParametersDestinationsItem]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        annotation: Optional[str] = None,
-        polling_type: Optional[Union[str, "_models.PollingType"]] = None,
-        destinations: Optional[List["_models.NetworkTapPatchableParametersDestinationsItem"]] = None,
-        **kwargs: Any
-    ) -> None:
         """
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword polling_type: Polling type. Known values are: "Pull" and "Push".
-        :paramtype polling_type: str or ~azure.mgmt.managednetworkfabric.models.PollingType
-        :keyword destinations: List of destination properties to send the filter traffic.
-        :paramtype destinations:
-         list[~azure.mgmt.managednetworkfabric.models.NetworkTapPatchableParametersDestinationsItem]
-        """
-        super().__init__(annotation=annotation, **kwargs)
-        self.polling_type = polling_type
-        self.destinations = destinations
-
-
-class NetworkTapPatchableParametersDestinationsItem(DestinationProperties):
-    """Destination.
-
-    :ivar name: Destination name.
-    :vartype name: str
-    :ivar destination_type: Type of destination. Input can be IsolationDomain or Direct. Known
-     values are: "IsolationDomain" and "Direct".
-    :vartype destination_type: str or ~azure.mgmt.managednetworkfabric.models.DestinationType
-    :ivar destination_id: The destination Id. ARM Resource ID of either NNI or Internal Networks.
-    :vartype destination_id: str
-    :ivar isolation_domain_properties: Isolation Domain Properties.
-    :vartype isolation_domain_properties:
-     ~azure.mgmt.managednetworkfabric.models.IsolationDomainProperties
-    :ivar destination_tap_rule_id: ARM Resource ID of destination Tap Rule that contains match
-     configurations.
-    :vartype destination_tap_rule_id: str
-    """
-
-    _validation = {
-        "name": {"min_length": 1},
-    }
-
-    _attribute_map = {
-        "name": {"key": "name", "type": "str"},
-        "destination_type": {"key": "destinationType", "type": "str"},
-        "destination_id": {"key": "destinationId", "type": "str"},
-        "isolation_domain_properties": {"key": "isolationDomainProperties", "type": "IsolationDomainProperties"},
-        "destination_tap_rule_id": {"key": "destinationTapRuleId", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        name: Optional[str] = None,
-        destination_type: Optional[Union[str, "_models.DestinationType"]] = None,
-        destination_id: Optional[str] = None,
-        isolation_domain_properties: Optional["_models.IsolationDomainProperties"] = None,
-        destination_tap_rule_id: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword name: Destination name.
-        :paramtype name: str
-        :keyword destination_type: Type of destination. Input can be IsolationDomain or Direct. Known
-         values are: "IsolationDomain" and "Direct".
-        :paramtype destination_type: str or ~azure.mgmt.managednetworkfabric.models.DestinationType
-        :keyword destination_id: The destination Id. ARM Resource ID of either NNI or Internal
-         Networks.
-        :paramtype destination_id: str
-        :keyword isolation_domain_properties: Isolation Domain Properties.
-        :paramtype isolation_domain_properties:
-         ~azure.mgmt.managednetworkfabric.models.IsolationDomainProperties
-        :keyword destination_tap_rule_id: ARM Resource ID of destination Tap Rule that contains match
-         configurations.
-        :paramtype destination_tap_rule_id: str
-        """
-        super().__init__(
-            name=name,
-            destination_type=destination_type,
-            destination_id=destination_id,
-            isolation_domain_properties=isolation_domain_properties,
-            destination_tap_rule_id=destination_tap_rule_id,
-            **kwargs
-        )
+        super().__init__(**kwargs)
+        self.properties = properties
+        self.tags = tags
 
 
-class NetworkTapProperties(AnnotationResource):
-    """Network Tap Properties defines the properties of the resource.
+class NetworkRackProperties(AnnotationResource):
+    """NetworkRackProperties define the resource properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar network_packet_broker_id: ARM resource ID of the Network Packet Broker. Required.
-    :vartype network_packet_broker_id: str
-    :ivar source_tap_rule_id: Source Tap Rule Id. ARM Resource ID of the Network Tap Rule.
-    :vartype source_tap_rule_id: str
-    :ivar destinations: List of destinations to send the filter traffic. Required.
-    :vartype destinations:
-     list[~azure.mgmt.managednetworkfabric.models.NetworkTapPropertiesDestinationsItem]
-    :ivar polling_type: Polling type. Known values are: "Pull" and "Push".
-    :vartype polling_type: str or ~azure.mgmt.managednetworkfabric.models.PollingType
-    :ivar configuration_state: Gets the configurations state of the resource. Known values are:
-     "Succeeded", "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning",
-     "Deprovisioning", "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provides you the latest status of the NFC service, whether it is
-     Accepted, updating, Succeeded or Failed. During this process, the states keep changing based on
-     the status of Network Tap provisioning. Known values are: "Accepted", "Succeeded", "Updating",
-     "Deleting", "Failed", and "Canceled".
+    :ivar network_rack_sku: Network Rack SKU name. Required.
+    :vartype network_rack_sku: str
+    :ivar network_fabric_id: Network Fabric ARM resource id. Required.
+    :vartype network_fabric_id: str
+    :ivar network_devices: List of network device ARM resource ids.
+    :vartype network_devices: list[str]
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Example -Enabled/Disabled.
-     Known values are: "Enabled", "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
-        "network_packet_broker_id": {"required": True},
-        "source_tap_rule_id": {"readonly": True},
-        "destinations": {"required": True, "min_items": 1},
-        "configuration_state": {"readonly": True},
+        "network_rack_sku": {"required": True},
+        "network_fabric_id": {"required": True},
+        "network_devices": {"readonly": True},
         "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
     }
 
     _attribute_map = {
         "annotation": {"key": "annotation", "type": "str"},
-        "network_packet_broker_id": {"key": "networkPacketBrokerId", "type": "str"},
-        "source_tap_rule_id": {"key": "sourceTapRuleId", "type": "str"},
-        "destinations": {"key": "destinations", "type": "[NetworkTapPropertiesDestinationsItem]"},
-        "polling_type": {"key": "pollingType", "type": "str"},
-        "configuration_state": {"key": "configurationState", "type": "str"},
+        "network_rack_sku": {"key": "networkRackSku", "type": "str"},
+        "network_fabric_id": {"key": "networkFabricId", "type": "str"},
+        "network_devices": {"key": "networkDevices", "type": "[str]"},
         "provisioning_state": {"key": "provisioningState", "type": "str"},
-        "administrative_state": {"key": "administrativeState", "type": "str"},
     }
 
     def __init__(
-        self,
-        *,
-        network_packet_broker_id: str,
-        destinations: List["_models.NetworkTapPropertiesDestinationsItem"],
-        annotation: Optional[str] = None,
-        polling_type: Optional[Union[str, "_models.PollingType"]] = None,
-        **kwargs: Any
+        self, *, network_rack_sku: str, network_fabric_id: str, annotation: Optional[str] = None, **kwargs: Any
     ) -> None:
         """
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword network_packet_broker_id: ARM resource ID of the Network Packet Broker. Required.
-        :paramtype network_packet_broker_id: str
-        :keyword destinations: List of destinations to send the filter traffic. Required.
-        :paramtype destinations:
-         list[~azure.mgmt.managednetworkfabric.models.NetworkTapPropertiesDestinationsItem]
-        :keyword polling_type: Polling type. Known values are: "Pull" and "Push".
-        :paramtype polling_type: str or ~azure.mgmt.managednetworkfabric.models.PollingType
+        :keyword network_rack_sku: Network Rack SKU name. Required.
+        :paramtype network_rack_sku: str
+        :keyword network_fabric_id: Network Fabric ARM resource id. Required.
+        :paramtype network_fabric_id: str
         """
         super().__init__(annotation=annotation, **kwargs)
-        self.network_packet_broker_id = network_packet_broker_id
-        self.source_tap_rule_id = None
-        self.destinations = destinations
-        self.polling_type = polling_type
-        self.configuration_state = None
+        self.network_rack_sku = network_rack_sku
+        self.network_fabric_id = network_fabric_id
+        self.network_devices = None
         self.provisioning_state = None
-        self.administrative_state = None
-
-
-class NetworkTapPropertiesDestinationsItem(DestinationProperties):
-    """Destination.
-
-    :ivar name: Destination name.
-    :vartype name: str
-    :ivar destination_type: Type of destination. Input can be IsolationDomain or Direct. Known
-     values are: "IsolationDomain" and "Direct".
-    :vartype destination_type: str or ~azure.mgmt.managednetworkfabric.models.DestinationType
-    :ivar destination_id: The destination Id. ARM Resource ID of either NNI or Internal Networks.
-    :vartype destination_id: str
-    :ivar isolation_domain_properties: Isolation Domain Properties.
-    :vartype isolation_domain_properties:
-     ~azure.mgmt.managednetworkfabric.models.IsolationDomainProperties
-    :ivar destination_tap_rule_id: ARM Resource ID of destination Tap Rule that contains match
-     configurations.
-    :vartype destination_tap_rule_id: str
-    """
-
-    _validation = {
-        "name": {"min_length": 1},
-    }
-
-    _attribute_map = {
-        "name": {"key": "name", "type": "str"},
-        "destination_type": {"key": "destinationType", "type": "str"},
-        "destination_id": {"key": "destinationId", "type": "str"},
-        "isolation_domain_properties": {"key": "isolationDomainProperties", "type": "IsolationDomainProperties"},
-        "destination_tap_rule_id": {"key": "destinationTapRuleId", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        name: Optional[str] = None,
-        destination_type: Optional[Union[str, "_models.DestinationType"]] = None,
-        destination_id: Optional[str] = None,
-        isolation_domain_properties: Optional["_models.IsolationDomainProperties"] = None,
-        destination_tap_rule_id: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword name: Destination name.
-        :paramtype name: str
-        :keyword destination_type: Type of destination. Input can be IsolationDomain or Direct. Known
-         values are: "IsolationDomain" and "Direct".
-        :paramtype destination_type: str or ~azure.mgmt.managednetworkfabric.models.DestinationType
-        :keyword destination_id: The destination Id. ARM Resource ID of either NNI or Internal
-         Networks.
-        :paramtype destination_id: str
-        :keyword isolation_domain_properties: Isolation Domain Properties.
-        :paramtype isolation_domain_properties:
-         ~azure.mgmt.managednetworkfabric.models.IsolationDomainProperties
-        :keyword destination_tap_rule_id: ARM Resource ID of destination Tap Rule that contains match
-         configurations.
-        :paramtype destination_tap_rule_id: str
-        """
-        super().__init__(
-            name=name,
-            destination_type=destination_type,
-            destination_id=destination_id,
-            isolation_domain_properties=isolation_domain_properties,
-            destination_tap_rule_id=destination_tap_rule_id,
-            **kwargs
-        )
 
 
-class NetworkTapRule(TrackedResource):  # pylint: disable=too-many-instance-attributes
-    """The NetworkTapRule resource definition.
+class NetworkRackSku(ProxyResource):
+    """The NetworkRackSku resource definition.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
      information.
     :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
-    :ivar location: The geo-location where the resource lives. Required.
-    :vartype location: str
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar configuration_type: Input method to configure Network Tap Rule. Known values are: "File"
-     and "Inline".
-    :vartype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-    :ivar tap_rules_url: Network Tap Rules file URL.
-    :vartype tap_rules_url: str
-    :ivar match_configurations: List of match configurations.
-    :vartype match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.NetworkTapRuleMatchConfiguration]
-    :ivar dynamic_match_configurations: List of dynamic match configurations.
-    :vartype dynamic_match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
-    :ivar network_tap_id: The ARM resource Id of the NetworkTap.
-    :vartype network_tap_id: str
-    :ivar polling_interval_in_seconds: Polling interval in seconds. Known values are: 30, 60, 90,
-     and 120.
-    :vartype polling_interval_in_seconds: int or
-     ~azure.mgmt.managednetworkfabric.models.PollingIntervalInSeconds
-    :ivar last_synced_time: The last sync timestamp.
-    :vartype last_synced_time: ~datetime.datetime
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
+    :ivar role_name: The role of the Network Rack: Aggregate or Compute. Required. Known values
+     are: "ComputeRack" and "AggregateRack".
+    :vartype role_name: str or ~azure.mgmt.managednetworkfabric.models.NetworkRackRoleName
+    :ivar maximum_server_count: Maximum number of servers available for this SKU.
+    :vartype maximum_server_count: int
+    :ivar maximum_storage_count: Maximum number of storage devices available for this SKU.
+    :vartype maximum_storage_count: int
+    :ivar maximum_uplinks: Maximum number of network uplinks available for this SKU.
+    :vartype maximum_uplinks: int
+    :ivar network_devices: List of network device properties / role for the Network Rack.
+    :vartype network_devices:
+     list[~azure.mgmt.managednetworkfabric.models.NetworkDeviceRoleProperties]
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
-        "location": {"required": True},
-        "tap_rules_url": {"min_length": 1},
-        "match_configurations": {"min_items": 1},
-        "dynamic_match_configurations": {"min_items": 1},
-        "network_tap_id": {"readonly": True},
-        "last_synced_time": {"readonly": True},
-        "configuration_state": {"readonly": True},
+        "role_name": {"required": True},
         "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
-        "tags": {"key": "tags", "type": "{str}"},
-        "location": {"key": "location", "type": "str"},
-        "annotation": {"key": "properties.annotation", "type": "str"},
-        "configuration_type": {"key": "properties.configurationType", "type": "str"},
-        "tap_rules_url": {"key": "properties.tapRulesUrl", "type": "str"},
-        "match_configurations": {"key": "properties.matchConfigurations", "type": "[NetworkTapRuleMatchConfiguration]"},
-        "dynamic_match_configurations": {
-            "key": "properties.dynamicMatchConfigurations",
-            "type": "[CommonDynamicMatchConfiguration]",
-        },
-        "network_tap_id": {"key": "properties.networkTapId", "type": "str"},
-        "polling_interval_in_seconds": {"key": "properties.pollingIntervalInSeconds", "type": "int"},
-        "last_synced_time": {"key": "properties.lastSyncedTime", "type": "iso-8601"},
-        "configuration_state": {"key": "properties.configurationState", "type": "str"},
+        "role_name": {"key": "properties.roleName", "type": "str"},
+        "maximum_server_count": {"key": "properties.maximumServerCount", "type": "int"},
+        "maximum_storage_count": {"key": "properties.maximumStorageCount", "type": "int"},
+        "maximum_uplinks": {"key": "properties.maximumUplinks", "type": "int"},
+        "network_devices": {"key": "properties.networkDevices", "type": "[NetworkDeviceRoleProperties]"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
-        "administrative_state": {"key": "properties.administrativeState", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        location: str,
-        tags: Optional[Dict[str, str]] = None,
-        annotation: Optional[str] = None,
-        configuration_type: Optional[Union[str, "_models.ConfigurationType"]] = None,
-        tap_rules_url: Optional[str] = None,
-        match_configurations: Optional[List["_models.NetworkTapRuleMatchConfiguration"]] = None,
-        dynamic_match_configurations: Optional[List["_models.CommonDynamicMatchConfiguration"]] = None,
-        polling_interval_in_seconds: Union[int, "_models.PollingIntervalInSeconds"] = 30,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
-        :keyword location: The geo-location where the resource lives. Required.
-        :paramtype location: str
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword configuration_type: Input method to configure Network Tap Rule. Known values are:
-         "File" and "Inline".
-        :paramtype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-        :keyword tap_rules_url: Network Tap Rules file URL.
-        :paramtype tap_rules_url: str
-        :keyword match_configurations: List of match configurations.
-        :paramtype match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.NetworkTapRuleMatchConfiguration]
-        :keyword dynamic_match_configurations: List of dynamic match configurations.
-        :paramtype dynamic_match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
-        :keyword polling_interval_in_seconds: Polling interval in seconds. Known values are: 30, 60,
-         90, and 120.
-        :paramtype polling_interval_in_seconds: int or
-         ~azure.mgmt.managednetworkfabric.models.PollingIntervalInSeconds
-        """
-        super().__init__(tags=tags, location=location, **kwargs)
-        self.annotation = annotation
-        self.configuration_type = configuration_type
-        self.tap_rules_url = tap_rules_url
-        self.match_configurations = match_configurations
-        self.dynamic_match_configurations = dynamic_match_configurations
-        self.network_tap_id = None
-        self.polling_interval_in_seconds = polling_interval_in_seconds
-        self.last_synced_time = None
-        self.configuration_state = None
-        self.provisioning_state = None
-        self.administrative_state = None
-
-
-class NetworkTapRuleAction(_serialization.Model):
-    """Action that need to performed.
-
-    :ivar type: Type of actions that can be performed. Known values are: "Drop", "Count", "Log",
-     "Replicate", "Goto", "Redirect", and "Mirror".
-    :vartype type: str or ~azure.mgmt.managednetworkfabric.models.TapRuleActionType
-    :ivar truncate: Truncate. 0 indicates do not truncate.
-    :vartype truncate: str
-    :ivar is_timestamp_enabled: The parameter to enable or disable the timestamp. Known values are:
-     "True" and "False".
-    :vartype is_timestamp_enabled: str or
-     ~azure.mgmt.managednetworkfabric.models.BooleanEnumProperty
-    :ivar destination_id: Destination Id. The ARM resource Id may be either Network To Network
-     Interconnect or NeighborGroup.
-    :vartype destination_id: str
-    :ivar match_configuration_name: The name of the match configuration. This is used when Goto
-     type is provided. If Goto type is selected and no match configuration name is provided. It goes
-     to next configuration.
-    :vartype match_configuration_name: str
-    """
-
-    _validation = {
-        "truncate": {"min_length": 1},
-        "match_configuration_name": {"min_length": 1},
-    }
-
-    _attribute_map = {
-        "type": {"key": "type", "type": "str"},
-        "truncate": {"key": "truncate", "type": "str"},
-        "is_timestamp_enabled": {"key": "isTimestampEnabled", "type": "str"},
-        "destination_id": {"key": "destinationId", "type": "str"},
-        "match_configuration_name": {"key": "matchConfigurationName", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        type: Optional[Union[str, "_models.TapRuleActionType"]] = None,
-        truncate: Optional[str] = None,
-        is_timestamp_enabled: Optional[Union[str, "_models.BooleanEnumProperty"]] = None,
-        destination_id: Optional[str] = None,
-        match_configuration_name: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword type: Type of actions that can be performed. Known values are: "Drop", "Count", "Log",
-         "Replicate", "Goto", "Redirect", and "Mirror".
-        :paramtype type: str or ~azure.mgmt.managednetworkfabric.models.TapRuleActionType
-        :keyword truncate: Truncate. 0 indicates do not truncate.
-        :paramtype truncate: str
-        :keyword is_timestamp_enabled: The parameter to enable or disable the timestamp. Known values
-         are: "True" and "False".
-        :paramtype is_timestamp_enabled: str or
-         ~azure.mgmt.managednetworkfabric.models.BooleanEnumProperty
-        :keyword destination_id: Destination Id. The ARM resource Id may be either Network To Network
-         Interconnect or NeighborGroup.
-        :paramtype destination_id: str
-        :keyword match_configuration_name: The name of the match configuration. This is used when Goto
-         type is provided. If Goto type is selected and no match configuration name is provided. It goes
-         to next configuration.
-        :paramtype match_configuration_name: str
-        """
-        super().__init__(**kwargs)
-        self.type = type
-        self.truncate = truncate
-        self.is_timestamp_enabled = is_timestamp_enabled
-        self.destination_id = destination_id
-        self.match_configuration_name = match_configuration_name
-
-
-class NetworkTapRuleMatchCondition(CommonMatchConditions):
-    """Defines the match condition that is supported to filter the traffic.
-
-    :ivar protocol_types: List of the protocols that need to be matched.
-    :vartype protocol_types: list[str]
-    :ivar vlan_match_condition: Vlan match condition that needs to be matched.
-    :vartype vlan_match_condition: ~azure.mgmt.managednetworkfabric.models.VlanMatchCondition
-    :ivar ip_condition: IP condition that needs to be matched.
-    :vartype ip_condition: ~azure.mgmt.managednetworkfabric.models.IpMatchCondition
-    :ivar encapsulation_type: Encapsulation Type. Known values are: "None" and "GTPv1".
-    :vartype encapsulation_type: str or ~azure.mgmt.managednetworkfabric.models.EncapsulationType
-    :ivar port_condition: Defines the port condition that needs to be matched.
-    :vartype port_condition: ~azure.mgmt.managednetworkfabric.models.PortCondition
-    """
-
-    _validation = {
-        "protocol_types": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "protocol_types": {"key": "protocolTypes", "type": "[str]"},
-        "vlan_match_condition": {"key": "vlanMatchCondition", "type": "VlanMatchCondition"},
-        "ip_condition": {"key": "ipCondition", "type": "IpMatchCondition"},
-        "encapsulation_type": {"key": "encapsulationType", "type": "str"},
-        "port_condition": {"key": "portCondition", "type": "PortCondition"},
-    }
-
-    def __init__(
-        self,
-        *,
-        protocol_types: Optional[List[str]] = None,
-        vlan_match_condition: Optional["_models.VlanMatchCondition"] = None,
-        ip_condition: Optional["_models.IpMatchCondition"] = None,
-        encapsulation_type: Union[str, "_models.EncapsulationType"] = "None",
-        port_condition: Optional["_models.PortCondition"] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword protocol_types: List of the protocols that need to be matched.
-        :paramtype protocol_types: list[str]
-        :keyword vlan_match_condition: Vlan match condition that needs to be matched.
-        :paramtype vlan_match_condition: ~azure.mgmt.managednetworkfabric.models.VlanMatchCondition
-        :keyword ip_condition: IP condition that needs to be matched.
-        :paramtype ip_condition: ~azure.mgmt.managednetworkfabric.models.IpMatchCondition
-        :keyword encapsulation_type: Encapsulation Type. Known values are: "None" and "GTPv1".
-        :paramtype encapsulation_type: str or ~azure.mgmt.managednetworkfabric.models.EncapsulationType
-        :keyword port_condition: Defines the port condition that needs to be matched.
-        :paramtype port_condition: ~azure.mgmt.managednetworkfabric.models.PortCondition
-        """
-        super().__init__(
-            protocol_types=protocol_types,
-            vlan_match_condition=vlan_match_condition,
-            ip_condition=ip_condition,
-            **kwargs
-        )
-        self.encapsulation_type = encapsulation_type
-        self.port_condition = port_condition
-
-
-class NetworkTapRuleMatchConfiguration(_serialization.Model):
-    """Defines the match configuration that are supported to filter the traffic.
-
-    :ivar match_configuration_name: The name of the match configuration.
-    :vartype match_configuration_name: str
-    :ivar sequence_number: Sequence Number of the match configuration..
-    :vartype sequence_number: int
-    :ivar ip_address_type: Type of IP Address. IPv4 or IPv6. Known values are: "IPv4" and "IPv6".
-    :vartype ip_address_type: str or ~azure.mgmt.managednetworkfabric.models.IPAddressType
-    :ivar match_conditions: List of the match conditions.
-    :vartype match_conditions:
-     list[~azure.mgmt.managednetworkfabric.models.NetworkTapRuleMatchCondition]
-    :ivar actions: List of actions that need to be performed for the matched conditions.
-    :vartype actions: list[~azure.mgmt.managednetworkfabric.models.NetworkTapRuleAction]
-    """
-
-    _validation = {
-        "match_configuration_name": {"min_length": 1},
-        "sequence_number": {"maximum": 4294967295, "minimum": 1},
-        "match_conditions": {"min_items": 1},
-        "actions": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "match_configuration_name": {"key": "matchConfigurationName", "type": "str"},
-        "sequence_number": {"key": "sequenceNumber", "type": "int"},
-        "ip_address_type": {"key": "ipAddressType", "type": "str"},
-        "match_conditions": {"key": "matchConditions", "type": "[NetworkTapRuleMatchCondition]"},
-        "actions": {"key": "actions", "type": "[NetworkTapRuleAction]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        match_configuration_name: Optional[str] = None,
-        sequence_number: Optional[int] = None,
-        ip_address_type: Optional[Union[str, "_models.IPAddressType"]] = None,
-        match_conditions: Optional[List["_models.NetworkTapRuleMatchCondition"]] = None,
-        actions: Optional[List["_models.NetworkTapRuleAction"]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword match_configuration_name: The name of the match configuration.
-        :paramtype match_configuration_name: str
-        :keyword sequence_number: Sequence Number of the match configuration..
-        :paramtype sequence_number: int
-        :keyword ip_address_type: Type of IP Address. IPv4 or IPv6. Known values are: "IPv4" and
-         "IPv6".
-        :paramtype ip_address_type: str or ~azure.mgmt.managednetworkfabric.models.IPAddressType
-        :keyword match_conditions: List of the match conditions.
-        :paramtype match_conditions:
-         list[~azure.mgmt.managednetworkfabric.models.NetworkTapRuleMatchCondition]
-        :keyword actions: List of actions that need to be performed for the matched conditions.
-        :paramtype actions: list[~azure.mgmt.managednetworkfabric.models.NetworkTapRuleAction]
-        """
-        super().__init__(**kwargs)
-        self.match_configuration_name = match_configuration_name
-        self.sequence_number = sequence_number
-        self.ip_address_type = ip_address_type
-        self.match_conditions = match_conditions
-        self.actions = actions
-
-
-class NetworkTapRulePatch(TagsUpdate):
-    """The NetworkTapRule resource definition.
-
-    :ivar tags: Resource tags.
-    :vartype tags: dict[str, str]
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar configuration_type: Input method to configure Network Tap Rule. Known values are: "File"
-     and "Inline".
-    :vartype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-    :ivar tap_rules_url: Network Tap Rules file URL.
-    :vartype tap_rules_url: str
-    :ivar match_configurations: List of match configurations.
-    :vartype match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.NetworkTapRuleMatchConfiguration]
-    :ivar dynamic_match_configurations: List of dynamic match configurations.
-    :vartype dynamic_match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
-    """
-
-    _validation = {
-        "tap_rules_url": {"min_length": 1},
-        "match_configurations": {"min_items": 1},
-        "dynamic_match_configurations": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "tags": {"key": "tags", "type": "{str}"},
-        "annotation": {"key": "properties.annotation", "type": "str"},
-        "configuration_type": {"key": "properties.configurationType", "type": "str"},
-        "tap_rules_url": {"key": "properties.tapRulesUrl", "type": "str"},
-        "match_configurations": {"key": "properties.matchConfigurations", "type": "[NetworkTapRuleMatchConfiguration]"},
-        "dynamic_match_configurations": {
-            "key": "properties.dynamicMatchConfigurations",
-            "type": "[CommonDynamicMatchConfiguration]",
-        },
-    }
-
-    def __init__(
-        self,
-        *,
-        tags: Optional[Dict[str, str]] = None,
-        annotation: Optional[str] = None,
-        configuration_type: Optional[Union[str, "_models.ConfigurationType"]] = None,
-        tap_rules_url: Optional[str] = None,
-        match_configurations: Optional[List["_models.NetworkTapRuleMatchConfiguration"]] = None,
-        dynamic_match_configurations: Optional[List["_models.CommonDynamicMatchConfiguration"]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword tags: Resource tags.
-        :paramtype tags: dict[str, str]
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword configuration_type: Input method to configure Network Tap Rule. Known values are:
-         "File" and "Inline".
-        :paramtype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-        :keyword tap_rules_url: Network Tap Rules file URL.
-        :paramtype tap_rules_url: str
-        :keyword match_configurations: List of match configurations.
-        :paramtype match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.NetworkTapRuleMatchConfiguration]
-        :keyword dynamic_match_configurations: List of dynamic match configurations.
-        :paramtype dynamic_match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
-        """
-        super().__init__(tags=tags, **kwargs)
-        self.annotation = annotation
-        self.configuration_type = configuration_type
-        self.tap_rules_url = tap_rules_url
-        self.match_configurations = match_configurations
-        self.dynamic_match_configurations = dynamic_match_configurations
-
-
-class NetworkTapRulePatchableProperties(_serialization.Model):
-    """Network Tap Rule updatable properties.
-
-    :ivar configuration_type: Input method to configure Network Tap Rule. Known values are: "File"
-     and "Inline".
-    :vartype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-    :ivar tap_rules_url: Network Tap Rules file URL.
-    :vartype tap_rules_url: str
-    :ivar match_configurations: List of match configurations.
-    :vartype match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.NetworkTapRuleMatchConfiguration]
-    :ivar dynamic_match_configurations: List of dynamic match configurations.
-    :vartype dynamic_match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
-    """
-
-    _validation = {
-        "tap_rules_url": {"min_length": 1},
-        "match_configurations": {"min_items": 1},
-        "dynamic_match_configurations": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "configuration_type": {"key": "configurationType", "type": "str"},
-        "tap_rules_url": {"key": "tapRulesUrl", "type": "str"},
-        "match_configurations": {"key": "matchConfigurations", "type": "[NetworkTapRuleMatchConfiguration]"},
-        "dynamic_match_configurations": {
-            "key": "dynamicMatchConfigurations",
-            "type": "[CommonDynamicMatchConfiguration]",
-        },
     }
 
     def __init__(
         self,
         *,
-        configuration_type: Optional[Union[str, "_models.ConfigurationType"]] = None,
-        tap_rules_url: Optional[str] = None,
-        match_configurations: Optional[List["_models.NetworkTapRuleMatchConfiguration"]] = None,
-        dynamic_match_configurations: Optional[List["_models.CommonDynamicMatchConfiguration"]] = None,
+        role_name: Union[str, "_models.NetworkRackRoleName"],
+        maximum_server_count: Optional[int] = None,
+        maximum_storage_count: Optional[int] = None,
+        maximum_uplinks: Optional[int] = None,
+        network_devices: Optional[List["_models.NetworkDeviceRoleProperties"]] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword configuration_type: Input method to configure Network Tap Rule. Known values are:
-         "File" and "Inline".
-        :paramtype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-        :keyword tap_rules_url: Network Tap Rules file URL.
-        :paramtype tap_rules_url: str
-        :keyword match_configurations: List of match configurations.
-        :paramtype match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.NetworkTapRuleMatchConfiguration]
-        :keyword dynamic_match_configurations: List of dynamic match configurations.
-        :paramtype dynamic_match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
+        :keyword role_name: The role of the Network Rack: Aggregate or Compute. Required. Known values
+         are: "ComputeRack" and "AggregateRack".
+        :paramtype role_name: str or ~azure.mgmt.managednetworkfabric.models.NetworkRackRoleName
+        :keyword maximum_server_count: Maximum number of servers available for this SKU.
+        :paramtype maximum_server_count: int
+        :keyword maximum_storage_count: Maximum number of storage devices available for this SKU.
+        :paramtype maximum_storage_count: int
+        :keyword maximum_uplinks: Maximum number of network uplinks available for this SKU.
+        :paramtype maximum_uplinks: int
+        :keyword network_devices: List of network device properties / role for the Network Rack.
+        :paramtype network_devices:
+         list[~azure.mgmt.managednetworkfabric.models.NetworkDeviceRoleProperties]
         """
         super().__init__(**kwargs)
-        self.configuration_type = configuration_type
-        self.tap_rules_url = tap_rules_url
-        self.match_configurations = match_configurations
-        self.dynamic_match_configurations = dynamic_match_configurations
-
-
-class NetworkTapRulePatchProperties(AnnotationResource, NetworkTapRulePatchableProperties):
-    """Network Tap Rule Patch properties.
-
-    :ivar configuration_type: Input method to configure Network Tap Rule. Known values are: "File"
-     and "Inline".
-    :vartype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-    :ivar tap_rules_url: Network Tap Rules file URL.
-    :vartype tap_rules_url: str
-    :ivar match_configurations: List of match configurations.
-    :vartype match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.NetworkTapRuleMatchConfiguration]
-    :ivar dynamic_match_configurations: List of dynamic match configurations.
-    :vartype dynamic_match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    """
-
-    _validation = {
-        "tap_rules_url": {"min_length": 1},
-        "match_configurations": {"min_items": 1},
-        "dynamic_match_configurations": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "configuration_type": {"key": "configurationType", "type": "str"},
-        "tap_rules_url": {"key": "tapRulesUrl", "type": "str"},
-        "match_configurations": {"key": "matchConfigurations", "type": "[NetworkTapRuleMatchConfiguration]"},
-        "dynamic_match_configurations": {
-            "key": "dynamicMatchConfigurations",
-            "type": "[CommonDynamicMatchConfiguration]",
-        },
-        "annotation": {"key": "annotation", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        configuration_type: Optional[Union[str, "_models.ConfigurationType"]] = None,
-        tap_rules_url: Optional[str] = None,
-        match_configurations: Optional[List["_models.NetworkTapRuleMatchConfiguration"]] = None,
-        dynamic_match_configurations: Optional[List["_models.CommonDynamicMatchConfiguration"]] = None,
-        annotation: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword configuration_type: Input method to configure Network Tap Rule. Known values are:
-         "File" and "Inline".
-        :paramtype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-        :keyword tap_rules_url: Network Tap Rules file URL.
-        :paramtype tap_rules_url: str
-        :keyword match_configurations: List of match configurations.
-        :paramtype match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.NetworkTapRuleMatchConfiguration]
-        :keyword dynamic_match_configurations: List of dynamic match configurations.
-        :paramtype dynamic_match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        """
-        super().__init__(
-            annotation=annotation,
-            configuration_type=configuration_type,
-            tap_rules_url=tap_rules_url,
-            match_configurations=match_configurations,
-            dynamic_match_configurations=dynamic_match_configurations,
-            **kwargs
-        )
-        self.configuration_type = configuration_type
-        self.tap_rules_url = tap_rules_url
-        self.match_configurations = match_configurations
-        self.dynamic_match_configurations = dynamic_match_configurations
-        self.annotation = annotation
-
-
-class NetworkTapRuleProperties(
-    AnnotationResource, NetworkTapRulePatchableProperties
-):  # pylint: disable=too-many-instance-attributes
-    """Network Tap Rule Properties defines the resource properties.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar configuration_type: Input method to configure Network Tap Rule. Known values are: "File"
-     and "Inline".
-    :vartype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-    :ivar tap_rules_url: Network Tap Rules file URL.
-    :vartype tap_rules_url: str
-    :ivar match_configurations: List of match configurations.
-    :vartype match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.NetworkTapRuleMatchConfiguration]
-    :ivar dynamic_match_configurations: List of dynamic match configurations.
-    :vartype dynamic_match_configurations:
-     list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
-    :ivar annotation: Switch configuration description.
-    :vartype annotation: str
-    :ivar network_tap_id: The ARM resource Id of the NetworkTap.
-    :vartype network_tap_id: str
-    :ivar polling_interval_in_seconds: Polling interval in seconds. Known values are: 30, 60, 90,
-     and 120.
-    :vartype polling_interval_in_seconds: int or
-     ~azure.mgmt.managednetworkfabric.models.PollingIntervalInSeconds
-    :ivar last_synced_time: The last sync timestamp.
-    :vartype last_synced_time: ~datetime.datetime
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
-    :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
-    """
-
-    _validation = {
-        "tap_rules_url": {"min_length": 1},
-        "match_configurations": {"min_items": 1},
-        "dynamic_match_configurations": {"min_items": 1},
-        "network_tap_id": {"readonly": True},
-        "last_synced_time": {"readonly": True},
-        "configuration_state": {"readonly": True},
-        "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "configuration_type": {"key": "configurationType", "type": "str"},
-        "tap_rules_url": {"key": "tapRulesUrl", "type": "str"},
-        "match_configurations": {"key": "matchConfigurations", "type": "[NetworkTapRuleMatchConfiguration]"},
-        "dynamic_match_configurations": {
-            "key": "dynamicMatchConfigurations",
-            "type": "[CommonDynamicMatchConfiguration]",
-        },
-        "annotation": {"key": "annotation", "type": "str"},
-        "network_tap_id": {"key": "networkTapId", "type": "str"},
-        "polling_interval_in_seconds": {"key": "pollingIntervalInSeconds", "type": "int"},
-        "last_synced_time": {"key": "lastSyncedTime", "type": "iso-8601"},
-        "configuration_state": {"key": "configurationState", "type": "str"},
-        "provisioning_state": {"key": "provisioningState", "type": "str"},
-        "administrative_state": {"key": "administrativeState", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        configuration_type: Optional[Union[str, "_models.ConfigurationType"]] = None,
-        tap_rules_url: Optional[str] = None,
-        match_configurations: Optional[List["_models.NetworkTapRuleMatchConfiguration"]] = None,
-        dynamic_match_configurations: Optional[List["_models.CommonDynamicMatchConfiguration"]] = None,
-        annotation: Optional[str] = None,
-        polling_interval_in_seconds: Union[int, "_models.PollingIntervalInSeconds"] = 30,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword configuration_type: Input method to configure Network Tap Rule. Known values are:
-         "File" and "Inline".
-        :paramtype configuration_type: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationType
-        :keyword tap_rules_url: Network Tap Rules file URL.
-        :paramtype tap_rules_url: str
-        :keyword match_configurations: List of match configurations.
-        :paramtype match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.NetworkTapRuleMatchConfiguration]
-        :keyword dynamic_match_configurations: List of dynamic match configurations.
-        :paramtype dynamic_match_configurations:
-         list[~azure.mgmt.managednetworkfabric.models.CommonDynamicMatchConfiguration]
-        :keyword annotation: Switch configuration description.
-        :paramtype annotation: str
-        :keyword polling_interval_in_seconds: Polling interval in seconds. Known values are: 30, 60,
-         90, and 120.
-        :paramtype polling_interval_in_seconds: int or
-         ~azure.mgmt.managednetworkfabric.models.PollingIntervalInSeconds
-        """
-        super().__init__(
-            annotation=annotation,
-            configuration_type=configuration_type,
-            tap_rules_url=tap_rules_url,
-            match_configurations=match_configurations,
-            dynamic_match_configurations=dynamic_match_configurations,
-            **kwargs
-        )
-        self.configuration_type = configuration_type
-        self.tap_rules_url = tap_rules_url
-        self.match_configurations = match_configurations
-        self.dynamic_match_configurations = dynamic_match_configurations
-        self.network_tap_id = None
-        self.polling_interval_in_seconds = polling_interval_in_seconds
-        self.last_synced_time = None
-        self.configuration_state = None
+        self.role_name = role_name
+        self.maximum_server_count = maximum_server_count
+        self.maximum_storage_count = maximum_storage_count
+        self.maximum_uplinks = maximum_uplinks
+        self.network_devices = network_devices
         self.provisioning_state = None
-        self.administrative_state = None
-        self.annotation = annotation
 
 
-class NetworkTapRulesListResult(_serialization.Model):
-    """List of NetworkTapRules.
+class NetworkRackSkusListResult(_serialization.Model):
+    """List of NetworkRackSkus.
 
-    :ivar value: List of NetworkTapRule resources.
-    :vartype value: list[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+    :ivar value: List of NetworkRackSku resources.
+    :vartype value: list[~azure.mgmt.managednetworkfabric.models.NetworkRackSku]
     :ivar next_link: Url to follow for getting next page of resources.
     :vartype next_link: str
     """
 
     _attribute_map = {
-        "value": {"key": "value", "type": "[NetworkTapRule]"},
+        "value": {"key": "value", "type": "[NetworkRackSku]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
     def __init__(
-        self, *, value: Optional[List["_models.NetworkTapRule"]] = None, next_link: Optional[str] = None, **kwargs: Any
+        self, *, value: Optional[List["_models.NetworkRackSku"]] = None, next_link: Optional[str] = None, **kwargs: Any
     ) -> None:
         """
-        :keyword value: List of NetworkTapRule resources.
-        :paramtype value: list[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+        :keyword value: List of NetworkRackSku resources.
+        :paramtype value: list[~azure.mgmt.managednetworkfabric.models.NetworkRackSku]
         :keyword next_link: Url to follow for getting next page of resources.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
-class NetworkTapsListResult(_serialization.Model):
-    """List of NetworkTaps.
+class NetworkRacksListResult(_serialization.Model):
+    """List of NetworkRacks.
 
-    :ivar value: List of NetworkTap resources.
-    :vartype value: list[~azure.mgmt.managednetworkfabric.models.NetworkTap]
+    :ivar value: List of NetworkRack resources.
+    :vartype value: list[~azure.mgmt.managednetworkfabric.models.NetworkRack]
     :ivar next_link: Url to follow for getting next page of resources.
     :vartype next_link: str
     """
 
     _attribute_map = {
-        "value": {"key": "value", "type": "[NetworkTap]"},
+        "value": {"key": "value", "type": "[NetworkRack]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
     def __init__(
-        self, *, value: Optional[List["_models.NetworkTap"]] = None, next_link: Optional[str] = None, **kwargs: Any
+        self, *, value: Optional[List["_models.NetworkRack"]] = None, next_link: Optional[str] = None, **kwargs: Any
     ) -> None:
         """
-        :keyword value: List of NetworkTap resources.
-        :paramtype value: list[~azure.mgmt.managednetworkfabric.models.NetworkTap]
+        :keyword value: List of NetworkRack resources.
+        :paramtype value: list[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :keyword next_link: Url to follow for getting next page of resources.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
 class NetworkToNetworkInterconnect(ProxyResource):  # pylint: disable=too-many-instance-attributes
-    """The Network To Network Interconnect resource definition.
+    """The NetworkToNetworkInterconnect resource definition.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
      information.
     :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
     :ivar nni_type: Type of NNI used. Example: CE | NPB. Known values are: "CE" and "NPB".
     :vartype nni_type: str or ~azure.mgmt.managednetworkfabric.models.NniType
+    :ivar administrative_state: Gets the administrativeState of the resource. Example
+     -Enabled/Disabled. Known values are: "Enabled" and "Disabled".
+    :vartype administrative_state: str or
+     ~azure.mgmt.managednetworkfabric.models.EnabledDisabledState
     :ivar is_management_type: Configuration to use NNI for Infrastructure Management. Example:
      True/False. Known values are: "True" and "False".
-    :vartype is_management_type: str or ~azure.mgmt.managednetworkfabric.models.IsManagementType
-    :ivar use_option_b: Based on this option layer3 parameters are mandatory. Example: True/False.
-     Required. Known values are: "True" and "False".
+    :vartype is_management_type: str or ~azure.mgmt.managednetworkfabric.models.BooleanEnumProperty
+    :ivar use_option_b: Based on this parameter the layer2/layer3 is made as mandatory. Example:
+     True/False. Known values are: "True" and "False".
     :vartype use_option_b: str or ~azure.mgmt.managednetworkfabric.models.BooleanEnumProperty
-    :ivar layer2_configuration: Common properties for Layer2 Configuration.
+    :ivar layer2_configuration: Common properties for Layer2Configuration.
     :vartype layer2_configuration: ~azure.mgmt.managednetworkfabric.models.Layer2Configuration
-    :ivar option_b_layer3_configuration: Common properties for Layer3Configuration.
-    :vartype option_b_layer3_configuration:
-     ~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnectPropertiesOptionBLayer3Configuration
-    :ivar npb_static_route_configuration: NPB Static Route Configuration properties.
-    :vartype npb_static_route_configuration:
-     ~azure.mgmt.managednetworkfabric.models.NpbStaticRouteConfiguration
-    :ivar import_route_policy: Import Route Policy configuration.
-    :vartype import_route_policy:
-     ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicyInformation
-    :ivar export_route_policy: Export Route Policy configuration.
-    :vartype export_route_policy:
-     ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicyInformation
-    :ivar egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-    :vartype egress_acl_id: str
-    :ivar ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-    :vartype ingress_acl_id: str
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
+    :ivar layer3_configuration: Common properties for Layer3Configuration.
+    :vartype layer3_configuration: ~azure.mgmt.managednetworkfabric.models.Layer3Configuration
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
-        "use_option_b": {"required": True},
-        "configuration_state": {"readonly": True},
-        "provisioning_state": {"readonly": True},
         "administrative_state": {"readonly": True},
+        "provisioning_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "nni_type": {"key": "properties.nniType", "type": "str"},
+        "administrative_state": {"key": "properties.administrativeState", "type": "str"},
         "is_management_type": {"key": "properties.isManagementType", "type": "str"},
         "use_option_b": {"key": "properties.useOptionB", "type": "str"},
         "layer2_configuration": {"key": "properties.layer2Configuration", "type": "Layer2Configuration"},
-        "option_b_layer3_configuration": {
-            "key": "properties.optionBLayer3Configuration",
-            "type": "NetworkToNetworkInterconnectPropertiesOptionBLayer3Configuration",
-        },
-        "npb_static_route_configuration": {
-            "key": "properties.npbStaticRouteConfiguration",
-            "type": "NpbStaticRouteConfiguration",
-        },
-        "import_route_policy": {"key": "properties.importRoutePolicy", "type": "ImportRoutePolicyInformation"},
-        "export_route_policy": {"key": "properties.exportRoutePolicy", "type": "ExportRoutePolicyInformation"},
-        "egress_acl_id": {"key": "properties.egressAclId", "type": "str"},
-        "ingress_acl_id": {"key": "properties.ingressAclId", "type": "str"},
-        "configuration_state": {"key": "properties.configurationState", "type": "str"},
+        "layer3_configuration": {"key": "properties.layer3Configuration", "type": "Layer3Configuration"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
-        "administrative_state": {"key": "properties.administrativeState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
-        use_option_b: Union[str, "_models.BooleanEnumProperty"],
         nni_type: Union[str, "_models.NniType"] = "CE",
-        is_management_type: Union[str, "_models.IsManagementType"] = "True",
+        is_management_type: Optional[Union[str, "_models.BooleanEnumProperty"]] = None,
+        use_option_b: Optional[Union[str, "_models.BooleanEnumProperty"]] = None,
         layer2_configuration: Optional["_models.Layer2Configuration"] = None,
-        option_b_layer3_configuration: Optional[
-            "_models.NetworkToNetworkInterconnectPropertiesOptionBLayer3Configuration"
-        ] = None,
-        npb_static_route_configuration: Optional["_models.NpbStaticRouteConfiguration"] = None,
-        import_route_policy: Optional["_models.ImportRoutePolicyInformation"] = None,
-        export_route_policy: Optional["_models.ExportRoutePolicyInformation"] = None,
-        egress_acl_id: Optional[str] = None,
-        ingress_acl_id: Optional[str] = None,
+        layer3_configuration: Optional["_models.Layer3Configuration"] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword nni_type: Type of NNI used. Example: CE | NPB. Known values are: "CE" and "NPB".
         :paramtype nni_type: str or ~azure.mgmt.managednetworkfabric.models.NniType
         :keyword is_management_type: Configuration to use NNI for Infrastructure Management. Example:
          True/False. Known values are: "True" and "False".
-        :paramtype is_management_type: str or ~azure.mgmt.managednetworkfabric.models.IsManagementType
-        :keyword use_option_b: Based on this option layer3 parameters are mandatory. Example:
-         True/False. Required. Known values are: "True" and "False".
+        :paramtype is_management_type: str or
+         ~azure.mgmt.managednetworkfabric.models.BooleanEnumProperty
+        :keyword use_option_b: Based on this parameter the layer2/layer3 is made as mandatory. Example:
+         True/False. Known values are: "True" and "False".
         :paramtype use_option_b: str or ~azure.mgmt.managednetworkfabric.models.BooleanEnumProperty
-        :keyword layer2_configuration: Common properties for Layer2 Configuration.
+        :keyword layer2_configuration: Common properties for Layer2Configuration.
         :paramtype layer2_configuration: ~azure.mgmt.managednetworkfabric.models.Layer2Configuration
-        :keyword option_b_layer3_configuration: Common properties for Layer3Configuration.
-        :paramtype option_b_layer3_configuration:
-         ~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnectPropertiesOptionBLayer3Configuration
-        :keyword npb_static_route_configuration: NPB Static Route Configuration properties.
-        :paramtype npb_static_route_configuration:
-         ~azure.mgmt.managednetworkfabric.models.NpbStaticRouteConfiguration
-        :keyword import_route_policy: Import Route Policy configuration.
-        :paramtype import_route_policy:
-         ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicyInformation
-        :keyword export_route_policy: Export Route Policy configuration.
-        :paramtype export_route_policy:
-         ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicyInformation
-        :keyword egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-        :paramtype egress_acl_id: str
-        :keyword ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-        :paramtype ingress_acl_id: str
+        :keyword layer3_configuration: Common properties for Layer3Configuration.
+        :paramtype layer3_configuration: ~azure.mgmt.managednetworkfabric.models.Layer3Configuration
         """
         super().__init__(**kwargs)
         self.nni_type = nni_type
+        self.administrative_state = None
         self.is_management_type = is_management_type
         self.use_option_b = use_option_b
         self.layer2_configuration = layer2_configuration
-        self.option_b_layer3_configuration = option_b_layer3_configuration
-        self.npb_static_route_configuration = npb_static_route_configuration
-        self.import_route_policy = import_route_policy
-        self.export_route_policy = export_route_policy
-        self.egress_acl_id = egress_acl_id
-        self.ingress_acl_id = ingress_acl_id
-        self.configuration_state = None
+        self.layer3_configuration = layer3_configuration
         self.provisioning_state = None
-        self.administrative_state = None
-
-
-class NetworkToNetworkInterconnectPatch(ProxyResource):  # pylint: disable=too-many-instance-attributes
-    """The Network To Network Interconnect resource patch definition.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
-    :vartype id: str
-    :ivar name: The name of the resource.
-    :vartype name: str
-    :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
-     "Microsoft.Storage/storageAccounts".
-    :vartype type: str
-    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
-     information.
-    :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
-    :ivar layer2_configuration: Common properties for Layer2Configuration.
-    :vartype layer2_configuration: ~azure.mgmt.managednetworkfabric.models.Layer2Configuration
-    :ivar option_b_layer3_configuration: Common properties for Layer3Configuration.
-    :vartype option_b_layer3_configuration:
-     ~azure.mgmt.managednetworkfabric.models.OptionBLayer3Configuration
-    :ivar npb_static_route_configuration: NPB Static Route Configuration properties.
-    :vartype npb_static_route_configuration:
-     ~azure.mgmt.managednetworkfabric.models.NpbStaticRouteConfiguration
-    :ivar import_route_policy: Import Route Policy information.
-    :vartype import_route_policy:
-     ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicyInformation
-    :ivar export_route_policy: Export Route Policy information.
-    :vartype export_route_policy:
-     ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicyInformation
-    :ivar egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-    :vartype egress_acl_id: str
-    :ivar ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-    :vartype ingress_acl_id: str
-    """
-
-    _validation = {
-        "id": {"readonly": True},
-        "name": {"readonly": True},
-        "type": {"readonly": True},
-        "system_data": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "id": {"key": "id", "type": "str"},
-        "name": {"key": "name", "type": "str"},
-        "type": {"key": "type", "type": "str"},
-        "system_data": {"key": "systemData", "type": "SystemData"},
-        "layer2_configuration": {"key": "properties.layer2Configuration", "type": "Layer2Configuration"},
-        "option_b_layer3_configuration": {
-            "key": "properties.optionBLayer3Configuration",
-            "type": "OptionBLayer3Configuration",
-        },
-        "npb_static_route_configuration": {
-            "key": "properties.npbStaticRouteConfiguration",
-            "type": "NpbStaticRouteConfiguration",
-        },
-        "import_route_policy": {"key": "properties.importRoutePolicy", "type": "ImportRoutePolicyInformation"},
-        "export_route_policy": {"key": "properties.exportRoutePolicy", "type": "ExportRoutePolicyInformation"},
-        "egress_acl_id": {"key": "properties.egressAclId", "type": "str"},
-        "ingress_acl_id": {"key": "properties.ingressAclId", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        layer2_configuration: Optional["_models.Layer2Configuration"] = None,
-        option_b_layer3_configuration: Optional["_models.OptionBLayer3Configuration"] = None,
-        npb_static_route_configuration: Optional["_models.NpbStaticRouteConfiguration"] = None,
-        import_route_policy: Optional["_models.ImportRoutePolicyInformation"] = None,
-        export_route_policy: Optional["_models.ExportRoutePolicyInformation"] = None,
-        egress_acl_id: Optional[str] = None,
-        ingress_acl_id: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword layer2_configuration: Common properties for Layer2Configuration.
-        :paramtype layer2_configuration: ~azure.mgmt.managednetworkfabric.models.Layer2Configuration
-        :keyword option_b_layer3_configuration: Common properties for Layer3Configuration.
-        :paramtype option_b_layer3_configuration:
-         ~azure.mgmt.managednetworkfabric.models.OptionBLayer3Configuration
-        :keyword npb_static_route_configuration: NPB Static Route Configuration properties.
-        :paramtype npb_static_route_configuration:
-         ~azure.mgmt.managednetworkfabric.models.NpbStaticRouteConfiguration
-        :keyword import_route_policy: Import Route Policy information.
-        :paramtype import_route_policy:
-         ~azure.mgmt.managednetworkfabric.models.ImportRoutePolicyInformation
-        :keyword export_route_policy: Export Route Policy information.
-        :paramtype export_route_policy:
-         ~azure.mgmt.managednetworkfabric.models.ExportRoutePolicyInformation
-        :keyword egress_acl_id: Egress Acl. ARM resource ID of Access Control Lists.
-        :paramtype egress_acl_id: str
-        :keyword ingress_acl_id: Ingress Acl. ARM resource ID of Access Control Lists.
-        :paramtype ingress_acl_id: str
-        """
-        super().__init__(**kwargs)
-        self.layer2_configuration = layer2_configuration
-        self.option_b_layer3_configuration = option_b_layer3_configuration
-        self.npb_static_route_configuration = npb_static_route_configuration
-        self.import_route_policy = import_route_policy
-        self.export_route_policy = export_route_policy
-        self.egress_acl_id = egress_acl_id
-        self.ingress_acl_id = ingress_acl_id
-
-
-class OptionBLayer3Configuration(Layer3IpPrefixProperties):
-    """OptionB Layer3 Configuration properties.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar primary_ipv4_prefix: IPv4 Address Prefix.
-    :vartype primary_ipv4_prefix: str
-    :ivar primary_ipv6_prefix: IPv6 Address Prefix.
-    :vartype primary_ipv6_prefix: str
-    :ivar secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
-    :vartype secondary_ipv4_prefix: str
-    :ivar secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
-    :vartype secondary_ipv6_prefix: str
-    :ivar peer_asn: ASN of PE devices for CE/PE connectivity.Example : 28.
-    :vartype peer_asn: int
-    :ivar vlan_id: VLAN for CE/PE Layer 3 connectivity.Example : 501.
-    :vartype vlan_id: int
-    :ivar fabric_asn: ASN of CE devices for CE/PE connectivity.
-    :vartype fabric_asn: int
-    """
-
-    _validation = {
-        "peer_asn": {"maximum": 4294967295, "minimum": 1},
-        "vlan_id": {"maximum": 4094, "minimum": 100},
-        "fabric_asn": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "primary_ipv4_prefix": {"key": "primaryIpv4Prefix", "type": "str"},
-        "primary_ipv6_prefix": {"key": "primaryIpv6Prefix", "type": "str"},
-        "secondary_ipv4_prefix": {"key": "secondaryIpv4Prefix", "type": "str"},
-        "secondary_ipv6_prefix": {"key": "secondaryIpv6Prefix", "type": "str"},
-        "peer_asn": {"key": "peerASN", "type": "int"},
-        "vlan_id": {"key": "vlanId", "type": "int"},
-        "fabric_asn": {"key": "fabricASN", "type": "int"},
-    }
-
-    def __init__(
-        self,
-        *,
-        primary_ipv4_prefix: Optional[str] = None,
-        primary_ipv6_prefix: Optional[str] = None,
-        secondary_ipv4_prefix: Optional[str] = None,
-        secondary_ipv6_prefix: Optional[str] = None,
-        peer_asn: Optional[int] = None,
-        vlan_id: Optional[int] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword primary_ipv4_prefix: IPv4 Address Prefix.
-        :paramtype primary_ipv4_prefix: str
-        :keyword primary_ipv6_prefix: IPv6 Address Prefix.
-        :paramtype primary_ipv6_prefix: str
-        :keyword secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
-        :paramtype secondary_ipv4_prefix: str
-        :keyword secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
-        :paramtype secondary_ipv6_prefix: str
-        :keyword peer_asn: ASN of PE devices for CE/PE connectivity.Example : 28.
-        :paramtype peer_asn: int
-        :keyword vlan_id: VLAN for CE/PE Layer 3 connectivity.Example : 501.
-        :paramtype vlan_id: int
-        """
-        super().__init__(
-            primary_ipv4_prefix=primary_ipv4_prefix,
-            primary_ipv6_prefix=primary_ipv6_prefix,
-            secondary_ipv4_prefix=secondary_ipv4_prefix,
-            secondary_ipv6_prefix=secondary_ipv6_prefix,
-            **kwargs
-        )
-        self.peer_asn = peer_asn
-        self.vlan_id = vlan_id
-        self.fabric_asn = None
-
-
-class NetworkToNetworkInterconnectPropertiesOptionBLayer3Configuration(OptionBLayer3Configuration):
-    """Common properties for Layer3Configuration.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar primary_ipv4_prefix: IPv4 Address Prefix.
-    :vartype primary_ipv4_prefix: str
-    :ivar primary_ipv6_prefix: IPv6 Address Prefix.
-    :vartype primary_ipv6_prefix: str
-    :ivar secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
-    :vartype secondary_ipv4_prefix: str
-    :ivar secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
-    :vartype secondary_ipv6_prefix: str
-    :ivar peer_asn: ASN of PE devices for CE/PE connectivity.Example : 28.
-    :vartype peer_asn: int
-    :ivar vlan_id: VLAN for CE/PE Layer 3 connectivity.Example : 501.
-    :vartype vlan_id: int
-    :ivar fabric_asn: ASN of CE devices for CE/PE connectivity.
-    :vartype fabric_asn: int
-    """
-
-    _validation = {
-        "peer_asn": {"maximum": 4294967295, "minimum": 1},
-        "vlan_id": {"maximum": 4094, "minimum": 100},
-        "fabric_asn": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "primary_ipv4_prefix": {"key": "primaryIpv4Prefix", "type": "str"},
-        "primary_ipv6_prefix": {"key": "primaryIpv6Prefix", "type": "str"},
-        "secondary_ipv4_prefix": {"key": "secondaryIpv4Prefix", "type": "str"},
-        "secondary_ipv6_prefix": {"key": "secondaryIpv6Prefix", "type": "str"},
-        "peer_asn": {"key": "peerASN", "type": "int"},
-        "vlan_id": {"key": "vlanId", "type": "int"},
-        "fabric_asn": {"key": "fabricASN", "type": "int"},
-    }
-
-    def __init__(
-        self,
-        *,
-        primary_ipv4_prefix: Optional[str] = None,
-        primary_ipv6_prefix: Optional[str] = None,
-        secondary_ipv4_prefix: Optional[str] = None,
-        secondary_ipv6_prefix: Optional[str] = None,
-        peer_asn: Optional[int] = None,
-        vlan_id: Optional[int] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword primary_ipv4_prefix: IPv4 Address Prefix.
-        :paramtype primary_ipv4_prefix: str
-        :keyword primary_ipv6_prefix: IPv6 Address Prefix.
-        :paramtype primary_ipv6_prefix: str
-        :keyword secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
-        :paramtype secondary_ipv4_prefix: str
-        :keyword secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
-        :paramtype secondary_ipv6_prefix: str
-        :keyword peer_asn: ASN of PE devices for CE/PE connectivity.Example : 28.
-        :paramtype peer_asn: int
-        :keyword vlan_id: VLAN for CE/PE Layer 3 connectivity.Example : 501.
-        :paramtype vlan_id: int
-        """
-        super().__init__(
-            primary_ipv4_prefix=primary_ipv4_prefix,
-            primary_ipv6_prefix=primary_ipv6_prefix,
-            secondary_ipv4_prefix=secondary_ipv4_prefix,
-            secondary_ipv6_prefix=secondary_ipv6_prefix,
-            peer_asn=peer_asn,
-            vlan_id=vlan_id,
-            **kwargs
-        )
 
 
 class NetworkToNetworkInterconnectsList(_serialization.Model):
-    """List of Network To Network Interconnects.
+    """List of NetworkToNetworkInterconnects.
 
     :ivar value: List of NetworkToNetworkInterconnects resources.
     :vartype value: list[~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect]
     :ivar next_link: Url to follow for getting next page of resources.
     :vartype next_link: str
     """
 
@@ -10923,58 +6987,14 @@
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
-class NpbStaticRouteConfiguration(_serialization.Model):
-    """NPB Static Route Configuration properties.
-
-    :ivar bfd_configuration: BFD Configuration properties.
-    :vartype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
-    :ivar ipv4_routes: List of IPv4 Routes.
-    :vartype ipv4_routes: list[~azure.mgmt.managednetworkfabric.models.StaticRouteProperties]
-    :ivar ipv6_routes: List of IPv6 Routes.
-    :vartype ipv6_routes: list[~azure.mgmt.managednetworkfabric.models.StaticRouteProperties]
-    """
-
-    _validation = {
-        "ipv4_routes": {"min_items": 1},
-        "ipv6_routes": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "bfd_configuration": {"key": "bfdConfiguration", "type": "BfdConfiguration"},
-        "ipv4_routes": {"key": "ipv4Routes", "type": "[StaticRouteProperties]"},
-        "ipv6_routes": {"key": "ipv6Routes", "type": "[StaticRouteProperties]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        bfd_configuration: Optional["_models.BfdConfiguration"] = None,
-        ipv4_routes: Optional[List["_models.StaticRouteProperties"]] = None,
-        ipv6_routes: Optional[List["_models.StaticRouteProperties"]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword bfd_configuration: BFD Configuration properties.
-        :paramtype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
-        :keyword ipv4_routes: List of IPv4 Routes.
-        :paramtype ipv4_routes: list[~azure.mgmt.managednetworkfabric.models.StaticRouteProperties]
-        :keyword ipv6_routes: List of IPv6 Routes.
-        :paramtype ipv6_routes: list[~azure.mgmt.managednetworkfabric.models.StaticRouteProperties]
-        """
-        super().__init__(**kwargs)
-        self.bfd_configuration = bfd_configuration
-        self.ipv4_routes = ipv4_routes
-        self.ipv6_routes = ipv6_routes
-
-
 class Operation(_serialization.Model):
     """Details of a REST API operation, returned from the Resource Provider Operations API.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar name: The name of the operation, as per Resource-Based Access Control (RBAC). Examples:
      "Microsoft.Compute/virtualMachines/write", "Microsoft.Compute/virtualMachines/capture/action".
@@ -11088,162 +7108,193 @@
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
-class OptionAProperties(_serialization.Model):
+class OptionAProperties(Layer3IpPrefixProperties):
     """Peering optionA properties.
 
+    :ivar primary_ipv4_prefix: IPv4 Address Prefix of CE-PE interconnect links. Example:
+     172.31.0.0/31. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
+    :vartype primary_ipv4_prefix: str
+    :ivar primary_ipv6_prefix: IPv6 Address Prefix of CE-PE interconnect links. Example:
+     3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
+    :vartype primary_ipv6_prefix: str
+    :ivar secondary_ipv4_prefix: Secondary IPv4 Address Prefix of CE-PE interconnect links.
+     Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
+    :vartype secondary_ipv4_prefix: str
+    :ivar secondary_ipv6_prefix: Secondary IPv6 Address Prefix of CE-PE interconnect links.
+     Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can
+     be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st
+     and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs
+     are to be configured on PE1 and PE2 for Option B interfaces.
+    :vartype secondary_ipv6_prefix: str
     :ivar mtu: MTU to use for option A peering.
     :vartype mtu: int
-    :ivar vlan_id: Vlan Id.Example : 501.
+    :ivar vlan_id: Vlan identifier. Example : 501.
     :vartype vlan_id: int
     :ivar peer_asn: Peer ASN number.Example : 28.
     :vartype peer_asn: int
     :ivar bfd_configuration: BFD Configuration properties.
-    :vartype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
+    :vartype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.FabricBfdConfiguration
     """
 
     _validation = {
-        "mtu": {"maximum": 9200, "minimum": 64},
-        "vlan_id": {"maximum": 4094, "minimum": 501},
-        "peer_asn": {"maximum": 4294967295, "minimum": 1},
+        "mtu": {"maximum": 9000, "minimum": 1500},
+        "vlan_id": {"maximum": 4095, "minimum": 501},
+        "peer_asn": {"maximum": 65535, "minimum": 1},
     }
 
     _attribute_map = {
+        "primary_ipv4_prefix": {"key": "primaryIpv4Prefix", "type": "str"},
+        "primary_ipv6_prefix": {"key": "primaryIpv6Prefix", "type": "str"},
+        "secondary_ipv4_prefix": {"key": "secondaryIpv4Prefix", "type": "str"},
+        "secondary_ipv6_prefix": {"key": "secondaryIpv6Prefix", "type": "str"},
         "mtu": {"key": "mtu", "type": "int"},
         "vlan_id": {"key": "vlanId", "type": "int"},
         "peer_asn": {"key": "peerASN", "type": "int"},
-        "bfd_configuration": {"key": "bfdConfiguration", "type": "BfdConfiguration"},
+        "bfd_configuration": {"key": "bfdConfiguration", "type": "FabricBfdConfiguration"},
     }
 
     def __init__(
         self,
         *,
+        primary_ipv4_prefix: Optional[str] = None,
+        primary_ipv6_prefix: Optional[str] = None,
+        secondary_ipv4_prefix: Optional[str] = None,
+        secondary_ipv6_prefix: Optional[str] = None,
         mtu: int = 1500,
         vlan_id: Optional[int] = None,
         peer_asn: Optional[int] = None,
-        bfd_configuration: Optional["_models.BfdConfiguration"] = None,
+        bfd_configuration: Optional["_models.FabricBfdConfiguration"] = None,
         **kwargs: Any
     ) -> None:
         """
+        :keyword primary_ipv4_prefix: IPv4 Address Prefix of CE-PE interconnect links. Example:
+         172.31.0.0/31. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
+        :paramtype primary_ipv4_prefix: str
+        :keyword primary_ipv6_prefix: IPv6 Address Prefix of CE-PE interconnect links. Example:
+         3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
+        :paramtype primary_ipv6_prefix: str
+        :keyword secondary_ipv4_prefix: Secondary IPv4 Address Prefix of CE-PE interconnect links.
+         Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
+        :paramtype secondary_ipv4_prefix: str
+        :keyword secondary_ipv6_prefix: Secondary IPv6 Address Prefix of CE-PE interconnect links.
+         Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can
+         be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st
+         and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs
+         are to be configured on PE1 and PE2 for Option B interfaces.
+        :paramtype secondary_ipv6_prefix: str
         :keyword mtu: MTU to use for option A peering.
         :paramtype mtu: int
-        :keyword vlan_id: Vlan Id.Example : 501.
+        :keyword vlan_id: Vlan identifier. Example : 501.
         :paramtype vlan_id: int
         :keyword peer_asn: Peer ASN number.Example : 28.
         :paramtype peer_asn: int
         :keyword bfd_configuration: BFD Configuration properties.
-        :paramtype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
+        :paramtype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.FabricBfdConfiguration
         """
-        super().__init__(**kwargs)
+        super().__init__(
+            primary_ipv4_prefix=primary_ipv4_prefix,
+            primary_ipv6_prefix=primary_ipv6_prefix,
+            secondary_ipv4_prefix=secondary_ipv4_prefix,
+            secondary_ipv6_prefix=secondary_ipv6_prefix,
+            **kwargs
+        )
         self.mtu = mtu
         self.vlan_id = vlan_id
         self.peer_asn = peer_asn
         self.bfd_configuration = bfd_configuration
 
 
 class OptionBProperties(_serialization.Model):
-    """Option B configuration to be used for Management VPN.
+    """Option B configuration.
 
-    :ivar import_route_targets: Route Targets to be applied for incoming routes into CE. This is
-     for backward compatibility.
+    :ivar import_route_targets: Route Targets to be applied for incoming routes into CE.
     :vartype import_route_targets: list[str]
-    :ivar export_route_targets: Route Targets to be applied for outgoing routes from CE. This is
-     for backward compatibility.
+    :ivar export_route_targets: Route Targets to be applied for outgoing routes from CE.
     :vartype export_route_targets: list[str]
-    :ivar route_targets: Route Targets to be applied.
-    :vartype route_targets: ~azure.mgmt.managednetworkfabric.models.RouteTargetInformation
     """
 
     _attribute_map = {
         "import_route_targets": {"key": "importRouteTargets", "type": "[str]"},
         "export_route_targets": {"key": "exportRouteTargets", "type": "[str]"},
-        "route_targets": {"key": "routeTargets", "type": "RouteTargetInformation"},
     }
 
     def __init__(
         self,
         *,
         import_route_targets: Optional[List[str]] = None,
         export_route_targets: Optional[List[str]] = None,
-        route_targets: Optional["_models.RouteTargetInformation"] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword import_route_targets: Route Targets to be applied for incoming routes into CE. This is
-         for backward compatibility.
+        :keyword import_route_targets: Route Targets to be applied for incoming routes into CE.
         :paramtype import_route_targets: list[str]
-        :keyword export_route_targets: Route Targets to be applied for outgoing routes from CE. This is
-         for backward compatibility.
+        :keyword export_route_targets: Route Targets to be applied for outgoing routes from CE.
         :paramtype export_route_targets: list[str]
-        :keyword route_targets: Route Targets to be applied.
-        :paramtype route_targets: ~azure.mgmt.managednetworkfabric.models.RouteTargetInformation
         """
         super().__init__(**kwargs)
         self.import_route_targets = import_route_targets
         self.export_route_targets = export_route_targets
-        self.route_targets = route_targets
 
 
-class PortGroupProperties(_serialization.Model):
-    """Port Group properties.
+class OptionBPropertiesAutoGenerated(_serialization.Model):
+    """Option B configuration.
 
-    :ivar name: The name of the port group.
-    :vartype name: str
-    :ivar ports: List of the ports that needs to be matched.
-    :vartype ports: list[str]
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar import_route_targets: Route Targets to be applied for incoming routes into CE. Required.
+    :vartype import_route_targets: list[str]
+    :ivar export_route_targets: Route Targets to be applied for outgoing routes from CE. Required.
+    :vartype export_route_targets: list[str]
     """
 
     _validation = {
-        "name": {"min_length": 1},
-        "ports": {"min_items": 1},
+        "import_route_targets": {"required": True},
+        "export_route_targets": {"required": True},
     }
 
     _attribute_map = {
-        "name": {"key": "name", "type": "str"},
-        "ports": {"key": "ports", "type": "[str]"},
-    }
-
-    def __init__(self, *, name: Optional[str] = None, ports: Optional[List[str]] = None, **kwargs: Any) -> None:
-        """
-        :keyword name: The name of the port group.
-        :paramtype name: str
-        :keyword ports: List of the ports that needs to be matched.
-        :paramtype ports: list[str]
-        """
-        super().__init__(**kwargs)
-        self.name = name
-        self.ports = ports
-
-
-class RebootProperties(_serialization.Model):
-    """Reboot properties.
-
-    :ivar reboot_type: Type of reboot to be performed. Example: GracefulRebootWithZTP. Known values
-     are: "GracefulRebootWithZTP", "GracefulRebootWithoutZTP", "UngracefulRebootWithZTP", and
-     "UngracefulRebootWithoutZTP".
-    :vartype reboot_type: str or ~azure.mgmt.managednetworkfabric.models.RebootType
-    """
-
-    _attribute_map = {
-        "reboot_type": {"key": "rebootType", "type": "str"},
+        "import_route_targets": {"key": "importRouteTargets", "type": "[str]"},
+        "export_route_targets": {"key": "exportRouteTargets", "type": "[str]"},
     }
 
-    def __init__(self, *, reboot_type: Optional[Union[str, "_models.RebootType"]] = None, **kwargs: Any) -> None:
+    def __init__(self, *, import_route_targets: List[str], export_route_targets: List[str], **kwargs: Any) -> None:
         """
-        :keyword reboot_type: Type of reboot to be performed. Example: GracefulRebootWithZTP. Known
-         values are: "GracefulRebootWithZTP", "GracefulRebootWithoutZTP", "UngracefulRebootWithZTP", and
-         "UngracefulRebootWithoutZTP".
-        :paramtype reboot_type: str or ~azure.mgmt.managednetworkfabric.models.RebootType
+        :keyword import_route_targets: Route Targets to be applied for incoming routes into CE.
+         Required.
+        :paramtype import_route_targets: list[str]
+        :keyword export_route_targets: Route Targets to be applied for outgoing routes from CE.
+         Required.
+        :paramtype export_route_targets: list[str]
         """
         super().__init__(**kwargs)
-        self.reboot_type = reboot_type
+        self.import_route_targets = import_route_targets
+        self.export_route_targets = export_route_targets
 
 
 class RoutePoliciesListResult(_serialization.Model):
     """List of RoutePolicies.
 
     :ivar value: List of RoutePolicy resources.
     :vartype value: list[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
@@ -11266,23 +7317,23 @@
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
-class RoutePolicy(TrackedResource):  # pylint: disable=too-many-instance-attributes
+class RoutePolicy(TrackedResource):
     """The RoutePolicy resource definition.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar id: Fully qualified resource ID for the resource. E.g.
-     "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}".
+    :ivar id: Fully qualified resource ID for the resource. Ex -
+     /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
     :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
@@ -11290,239 +7341,139 @@
     :vartype system_data: ~azure.mgmt.managednetworkfabric.models.SystemData
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar location: The geo-location where the resource lives. Required.
     :vartype location: str
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar statements: Route Policy statements.
+    :ivar statements: Route Policy statements. Required.
     :vartype statements:
      list[~azure.mgmt.managednetworkfabric.models.RoutePolicyStatementProperties]
-    :ivar network_fabric_id: Arm Resource ID of Network Fabric. Required.
-    :vartype network_fabric_id: str
-    :ivar address_family_type: AddressFamilyType. This parameter decides whether the given ipv4 or
-     ipv6 route policy. Known values are: "IPv4" and "IPv6".
-    :vartype address_family_type: str or ~azure.mgmt.managednetworkfabric.models.AddressFamilyType
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
         "system_data": {"readonly": True},
         "location": {"required": True},
-        "network_fabric_id": {"required": True},
-        "configuration_state": {"readonly": True},
+        "statements": {"required": True},
         "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
         "annotation": {"key": "properties.annotation", "type": "str"},
         "statements": {"key": "properties.statements", "type": "[RoutePolicyStatementProperties]"},
-        "network_fabric_id": {"key": "properties.networkFabricId", "type": "str"},
-        "address_family_type": {"key": "properties.addressFamilyType", "type": "str"},
-        "configuration_state": {"key": "properties.configurationState", "type": "str"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
-        "administrative_state": {"key": "properties.administrativeState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         location: str,
-        network_fabric_id: str,
+        statements: List["_models.RoutePolicyStatementProperties"],
         tags: Optional[Dict[str, str]] = None,
         annotation: Optional[str] = None,
-        statements: Optional[List["_models.RoutePolicyStatementProperties"]] = None,
-        address_family_type: Union[str, "_models.AddressFamilyType"] = "IPv4",
         **kwargs: Any
     ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword statements: Route Policy statements.
+        :keyword statements: Route Policy statements. Required.
         :paramtype statements:
          list[~azure.mgmt.managednetworkfabric.models.RoutePolicyStatementProperties]
-        :keyword network_fabric_id: Arm Resource ID of Network Fabric. Required.
-        :paramtype network_fabric_id: str
-        :keyword address_family_type: AddressFamilyType. This parameter decides whether the given ipv4
-         or ipv6 route policy. Known values are: "IPv4" and "IPv6".
-        :paramtype address_family_type: str or
-         ~azure.mgmt.managednetworkfabric.models.AddressFamilyType
         """
         super().__init__(tags=tags, location=location, **kwargs)
         self.annotation = annotation
         self.statements = statements
-        self.network_fabric_id = network_fabric_id
-        self.address_family_type = address_family_type
-        self.configuration_state = None
         self.provisioning_state = None
-        self.administrative_state = None
 
 
-class RoutePolicyPatch(TagsUpdate):
-    """The Route Policy patch resource definition.
+class RoutePolicyPatch(_serialization.Model):
+    """The RoutePolicy patch resource definition.
 
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
-    :ivar statements: Route Policy statements.
-    :vartype statements:
-     list[~azure.mgmt.managednetworkfabric.models.RoutePolicyStatementProperties]
     """
 
     _attribute_map = {
         "tags": {"key": "tags", "type": "{str}"},
-        "statements": {"key": "properties.statements", "type": "[RoutePolicyStatementProperties]"},
     }
 
-    def __init__(
-        self,
-        *,
-        tags: Optional[Dict[str, str]] = None,
-        statements: Optional[List["_models.RoutePolicyStatementProperties"]] = None,
-        **kwargs: Any
-    ) -> None:
+    def __init__(self, *, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
-        :keyword statements: Route Policy statements.
-        :paramtype statements:
-         list[~azure.mgmt.managednetworkfabric.models.RoutePolicyStatementProperties]
-        """
-        super().__init__(tags=tags, **kwargs)
-        self.statements = statements
-
-
-class RoutePolicyPatchableProperties(_serialization.Model):
-    """Route Policy patchable properties.
-
-    :ivar statements: Route Policy statements.
-    :vartype statements:
-     list[~azure.mgmt.managednetworkfabric.models.RoutePolicyStatementProperties]
-    """
-
-    _attribute_map = {
-        "statements": {"key": "statements", "type": "[RoutePolicyStatementProperties]"},
-    }
-
-    def __init__(
-        self, *, statements: Optional[List["_models.RoutePolicyStatementProperties"]] = None, **kwargs: Any
-    ) -> None:
-        """
-        :keyword statements: Route Policy statements.
-        :paramtype statements:
-         list[~azure.mgmt.managednetworkfabric.models.RoutePolicyStatementProperties]
         """
         super().__init__(**kwargs)
-        self.statements = statements
+        self.tags = tags
 
 
-class RoutePolicyProperties(AnnotationResource, RoutePolicyPatchableProperties):
-    """RoutePolicyProperties defines the resource properties.
+class RoutePolicyProperties(AnnotationResource):
+    """RoutePolicy Properties define the resource properties.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar statements: Route Policy statements.
-    :vartype statements:
-     list[~azure.mgmt.managednetworkfabric.models.RoutePolicyStatementProperties]
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
-    :ivar network_fabric_id: Arm Resource ID of Network Fabric. Required.
-    :vartype network_fabric_id: str
-    :ivar address_family_type: AddressFamilyType. This parameter decides whether the given ipv4 or
-     ipv6 route policy. Known values are: "IPv4" and "IPv6".
-    :vartype address_family_type: str or ~azure.mgmt.managednetworkfabric.models.AddressFamilyType
-    :ivar configuration_state: Configuration state of the resource. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar provisioning_state: Provisioning state of the resource. Known values are: "Accepted",
-     "Succeeded", "Updating", "Deleting", "Failed", and "Canceled".
+    :ivar statements: Route Policy statements. Required.
+    :vartype statements:
+     list[~azure.mgmt.managednetworkfabric.models.RoutePolicyStatementProperties]
+    :ivar provisioning_state: Gets the provisioning state of the resource. Known values are:
+     "Succeeded", "Updating", "Canceled", "Deleting", and "Failed".
     :vartype provisioning_state: str or ~azure.mgmt.managednetworkfabric.models.ProvisioningState
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
-    :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _validation = {
-        "network_fabric_id": {"required": True},
-        "configuration_state": {"readonly": True},
+        "statements": {"required": True},
         "provisioning_state": {"readonly": True},
-        "administrative_state": {"readonly": True},
     }
 
     _attribute_map = {
-        "statements": {"key": "statements", "type": "[RoutePolicyStatementProperties]"},
         "annotation": {"key": "annotation", "type": "str"},
-        "network_fabric_id": {"key": "networkFabricId", "type": "str"},
-        "address_family_type": {"key": "addressFamilyType", "type": "str"},
-        "configuration_state": {"key": "configurationState", "type": "str"},
+        "statements": {"key": "statements", "type": "[RoutePolicyStatementProperties]"},
         "provisioning_state": {"key": "provisioningState", "type": "str"},
-        "administrative_state": {"key": "administrativeState", "type": "str"},
     }
 
     def __init__(
         self,
         *,
-        network_fabric_id: str,
-        statements: Optional[List["_models.RoutePolicyStatementProperties"]] = None,
+        statements: List["_models.RoutePolicyStatementProperties"],
         annotation: Optional[str] = None,
-        address_family_type: Union[str, "_models.AddressFamilyType"] = "IPv4",
         **kwargs: Any
     ) -> None:
         """
-        :keyword statements: Route Policy statements.
-        :paramtype statements:
-         list[~azure.mgmt.managednetworkfabric.models.RoutePolicyStatementProperties]
         :keyword annotation: Switch configuration description.
         :paramtype annotation: str
-        :keyword network_fabric_id: Arm Resource ID of Network Fabric. Required.
-        :paramtype network_fabric_id: str
-        :keyword address_family_type: AddressFamilyType. This parameter decides whether the given ipv4
-         or ipv6 route policy. Known values are: "IPv4" and "IPv6".
-        :paramtype address_family_type: str or
-         ~azure.mgmt.managednetworkfabric.models.AddressFamilyType
+        :keyword statements: Route Policy statements. Required.
+        :paramtype statements:
+         list[~azure.mgmt.managednetworkfabric.models.RoutePolicyStatementProperties]
         """
-        super().__init__(annotation=annotation, statements=statements, **kwargs)
+        super().__init__(annotation=annotation, **kwargs)
         self.statements = statements
-        self.network_fabric_id = network_fabric_id
-        self.address_family_type = address_family_type
-        self.configuration_state = None
         self.provisioning_state = None
-        self.administrative_state = None
-        self.annotation = annotation
 
 
 class RoutePolicyStatementProperties(AnnotationResource):
-    """Route Policy Statement properties.
+    """Route Policy Statement properties..
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar annotation: Switch configuration description.
     :vartype annotation: str
     :ivar sequence_number: Sequence to insert to/delete from existing route. Required.
     :vartype sequence_number: int
@@ -11566,110 +7517,24 @@
         """
         super().__init__(annotation=annotation, **kwargs)
         self.sequence_number = sequence_number
         self.condition = condition
         self.action = action
 
 
-class RouteTargetInformation(_serialization.Model):
-    """Route Target Configuration.
-
-    :ivar import_ipv4_route_targets: Route Targets to be applied for incoming routes into CE.
-    :vartype import_ipv4_route_targets: list[str]
-    :ivar import_ipv6_route_targets: Route Targets to be applied for incoming routes from CE.
-    :vartype import_ipv6_route_targets: list[str]
-    :ivar export_ipv4_route_targets: Route Targets to be applied for outgoing routes into CE.
-    :vartype export_ipv4_route_targets: list[str]
-    :ivar export_ipv6_route_targets: Route Targets to be applied for outgoing routes from CE.
-    :vartype export_ipv6_route_targets: list[str]
-    """
-
-    _validation = {
-        "import_ipv4_route_targets": {"min_items": 1},
-        "import_ipv6_route_targets": {"min_items": 1},
-        "export_ipv4_route_targets": {"min_items": 1},
-        "export_ipv6_route_targets": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "import_ipv4_route_targets": {"key": "importIpv4RouteTargets", "type": "[str]"},
-        "import_ipv6_route_targets": {"key": "importIpv6RouteTargets", "type": "[str]"},
-        "export_ipv4_route_targets": {"key": "exportIpv4RouteTargets", "type": "[str]"},
-        "export_ipv6_route_targets": {"key": "exportIpv6RouteTargets", "type": "[str]"},
-    }
-
-    def __init__(
-        self,
-        *,
-        import_ipv4_route_targets: Optional[List[str]] = None,
-        import_ipv6_route_targets: Optional[List[str]] = None,
-        export_ipv4_route_targets: Optional[List[str]] = None,
-        export_ipv6_route_targets: Optional[List[str]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword import_ipv4_route_targets: Route Targets to be applied for incoming routes into CE.
-        :paramtype import_ipv4_route_targets: list[str]
-        :keyword import_ipv6_route_targets: Route Targets to be applied for incoming routes from CE.
-        :paramtype import_ipv6_route_targets: list[str]
-        :keyword export_ipv4_route_targets: Route Targets to be applied for outgoing routes into CE.
-        :paramtype export_ipv4_route_targets: list[str]
-        :keyword export_ipv6_route_targets: Route Targets to be applied for outgoing routes from CE.
-        :paramtype export_ipv6_route_targets: list[str]
-        """
-        super().__init__(**kwargs)
-        self.import_ipv4_route_targets = import_ipv4_route_targets
-        self.import_ipv6_route_targets = import_ipv6_route_targets
-        self.export_ipv4_route_targets = export_ipv4_route_targets
-        self.export_ipv6_route_targets = export_ipv6_route_targets
-
-
-class RuleProperties(_serialization.Model):
-    """Rules for the InternetGateways.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar action: Specify action. Required. Known values are: "Allow" and "Deny".
-    :vartype action: str or ~azure.mgmt.managednetworkfabric.models.Action
-    :ivar address_list: List of Addresses to be allowed or denied. Required.
-    :vartype address_list: list[str]
-    """
-
-    _validation = {
-        "action": {"required": True},
-        "address_list": {"required": True, "min_items": 1},
-    }
-
-    _attribute_map = {
-        "action": {"key": "action", "type": "str"},
-        "address_list": {"key": "addressList", "type": "[str]"},
-    }
-
-    def __init__(self, *, action: Union[str, "_models.Action"], address_list: List[str], **kwargs: Any) -> None:
-        """
-        :keyword action: Specify action. Required. Known values are: "Allow" and "Deny".
-        :paramtype action: str or ~azure.mgmt.managednetworkfabric.models.Action
-        :keyword address_list: List of Addresses to be allowed or denied. Required.
-        :paramtype address_list: list[str]
-        """
-        super().__init__(**kwargs)
-        self.action = action
-        self.address_list = address_list
-
-
 class StatementActionProperties(_serialization.Model):
     """Route policy action properties.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar local_preference: Local Preference of the route policy.
+    :ivar local_preference: localPreference of the route policy.
     :vartype local_preference: int
-    :ivar action_type: Action type. Example: Permit | Deny | Continue. Required. Known values are:
-     "Permit", "Deny", "Continue", and "Continue".
-    :vartype action_type: str or ~azure.mgmt.managednetworkfabric.models.RoutePolicyActionType
+    :ivar action_type: action. Example: Permit | Deny. Required. Known values are: "Permit" and
+     "Deny".
+    :vartype action_type: str or ~azure.mgmt.managednetworkfabric.models.CommunityActionTypes
     :ivar ip_community_properties: IP Community Properties.
     :vartype ip_community_properties:
      ~azure.mgmt.managednetworkfabric.models.ActionIpCommunityProperties
     :ivar ip_extended_community_properties: IP Extended Community Properties.
     :vartype ip_extended_community_properties:
      ~azure.mgmt.managednetworkfabric.models.ActionIpExtendedCommunityProperties
     """
@@ -11688,26 +7553,26 @@
             "type": "ActionIpExtendedCommunityProperties",
         },
     }
 
     def __init__(
         self,
         *,
-        action_type: Union[str, "_models.RoutePolicyActionType"],
+        action_type: Union[str, "_models.CommunityActionTypes"],
         local_preference: Optional[int] = None,
         ip_community_properties: Optional["_models.ActionIpCommunityProperties"] = None,
         ip_extended_community_properties: Optional["_models.ActionIpExtendedCommunityProperties"] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword local_preference: Local Preference of the route policy.
+        :keyword local_preference: localPreference of the route policy.
         :paramtype local_preference: int
-        :keyword action_type: Action type. Example: Permit | Deny | Continue. Required. Known values
-         are: "Permit", "Deny", "Continue", and "Continue".
-        :paramtype action_type: str or ~azure.mgmt.managednetworkfabric.models.RoutePolicyActionType
+        :keyword action_type: action. Example: Permit | Deny. Required. Known values are: "Permit" and
+         "Deny".
+        :paramtype action_type: str or ~azure.mgmt.managednetworkfabric.models.CommunityActionTypes
         :keyword ip_community_properties: IP Community Properties.
         :paramtype ip_community_properties:
          ~azure.mgmt.managednetworkfabric.models.ActionIpCommunityProperties
         :keyword ip_extended_community_properties: IP Extended Community Properties.
         :paramtype ip_extended_community_properties:
          ~azure.mgmt.managednetworkfabric.models.ActionIpExtendedCommunityProperties
         """
@@ -11721,162 +7586,226 @@
 class StatementConditionProperties(IpCommunityIdList, IpExtendedCommunityIdList):
     """Route policy statement condition properties.
 
     :ivar ip_extended_community_ids: List of IP Extended Community resource IDs.
     :vartype ip_extended_community_ids: list[str]
     :ivar ip_community_ids: List of IP Community resource IDs.
     :vartype ip_community_ids: list[str]
-    :ivar type: Type of the condition used. Known values are: "Or", "And", "Or", and "And".
-    :vartype type: str or ~azure.mgmt.managednetworkfabric.models.RoutePolicyConditionType
     :ivar ip_prefix_id: Arm Resource Id of IpPrefix.
     :vartype ip_prefix_id: str
     """
 
     _attribute_map = {
         "ip_extended_community_ids": {"key": "ipExtendedCommunityIds", "type": "[str]"},
         "ip_community_ids": {"key": "ipCommunityIds", "type": "[str]"},
-        "type": {"key": "type", "type": "str"},
         "ip_prefix_id": {"key": "ipPrefixId", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         ip_extended_community_ids: Optional[List[str]] = None,
         ip_community_ids: Optional[List[str]] = None,
-        type: Union[str, "_models.RoutePolicyConditionType"] = "Or",
         ip_prefix_id: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword ip_extended_community_ids: List of IP Extended Community resource IDs.
         :paramtype ip_extended_community_ids: list[str]
         :keyword ip_community_ids: List of IP Community resource IDs.
         :paramtype ip_community_ids: list[str]
-        :keyword type: Type of the condition used. Known values are: "Or", "And", "Or", and "And".
-        :paramtype type: str or ~azure.mgmt.managednetworkfabric.models.RoutePolicyConditionType
         :keyword ip_prefix_id: Arm Resource Id of IpPrefix.
         :paramtype ip_prefix_id: str
         """
         super().__init__(
             ip_community_ids=ip_community_ids, ip_extended_community_ids=ip_extended_community_ids, **kwargs
         )
         self.ip_extended_community_ids = ip_extended_community_ids
-        self.type = type
         self.ip_prefix_id = ip_prefix_id
         self.ip_community_ids = ip_community_ids
 
 
+class StaticRouteConfiguration(_serialization.Model):
+    """staticRouteConfiguration model.
+
+    :ivar bfd_configuration: BFD configuration properties.
+    :vartype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
+    :ivar ipv4_routes: List with object IPv4Routes.
+    :vartype ipv4_routes: list[~azure.mgmt.managednetworkfabric.models.StaticRouteProperties]
+    :ivar ipv6_routes: List with object IPv6Routes.
+    :vartype ipv6_routes: list[~azure.mgmt.managednetworkfabric.models.StaticRouteProperties]
+    """
+
+    _attribute_map = {
+        "bfd_configuration": {"key": "bfdConfiguration", "type": "BfdConfiguration"},
+        "ipv4_routes": {"key": "ipv4Routes", "type": "[StaticRouteProperties]"},
+        "ipv6_routes": {"key": "ipv6Routes", "type": "[StaticRouteProperties]"},
+    }
+
+    def __init__(
+        self,
+        *,
+        bfd_configuration: Optional["_models.BfdConfiguration"] = None,
+        ipv4_routes: Optional[List["_models.StaticRouteProperties"]] = None,
+        ipv6_routes: Optional[List["_models.StaticRouteProperties"]] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword bfd_configuration: BFD configuration properties.
+        :paramtype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
+        :keyword ipv4_routes: List with object IPv4Routes.
+        :paramtype ipv4_routes: list[~azure.mgmt.managednetworkfabric.models.StaticRouteProperties]
+        :keyword ipv6_routes: List with object IPv6Routes.
+        :paramtype ipv6_routes: list[~azure.mgmt.managednetworkfabric.models.StaticRouteProperties]
+        """
+        super().__init__(**kwargs)
+        self.bfd_configuration = bfd_configuration
+        self.ipv4_routes = ipv4_routes
+        self.ipv6_routes = ipv6_routes
+
+
 class StaticRouteProperties(_serialization.Model):
-    """Route Properties.
+    """Static Route properties.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar prefix: Prefix of the route. Required.
+    :ivar prefix: IPv4 | IPv6 Prefix. Required.
     :vartype prefix: str
-    :ivar next_hop: List of next hop addresses. Required.
+    :ivar next_hop: List of next hop IPv4 | IPv6 addresses. Required.
     :vartype next_hop: list[str]
     """
 
     _validation = {
-        "prefix": {"required": True, "min_length": 1},
-        "next_hop": {"required": True, "min_items": 1},
+        "prefix": {"required": True},
+        "next_hop": {"required": True},
     }
 
     _attribute_map = {
         "prefix": {"key": "prefix", "type": "str"},
         "next_hop": {"key": "nextHop", "type": "[str]"},
     }
 
     def __init__(self, *, prefix: str, next_hop: List[str], **kwargs: Any) -> None:
         """
-        :keyword prefix: Prefix of the route. Required.
+        :keyword prefix: IPv4 | IPv6 Prefix. Required.
         :paramtype prefix: str
-        :keyword next_hop: List of next hop addresses. Required.
+        :keyword next_hop: List of next hop IPv4 | IPv6 addresses. Required.
         :paramtype next_hop: list[str]
         """
         super().__init__(**kwargs)
         self.prefix = prefix
         self.next_hop = next_hop
 
 
 class SupportedConnectorProperties(_serialization.Model):
     """Supported connector properties.
 
-    :ivar connector_type: Type of connector used. Example: Optical.
+    :ivar connector_type: Connector type. Example: Optical.
     :vartype connector_type: str
     :ivar max_speed_in_mbps: Maximum speed of the connector in Mbps.
     :vartype max_speed_in_mbps: int
     """
 
     _attribute_map = {
         "connector_type": {"key": "connectorType", "type": "str"},
         "max_speed_in_mbps": {"key": "maxSpeedInMbps", "type": "int"},
     }
 
     def __init__(
         self, *, connector_type: Optional[str] = None, max_speed_in_mbps: Optional[int] = None, **kwargs: Any
     ) -> None:
         """
-        :keyword connector_type: Type of connector used. Example: Optical.
+        :keyword connector_type: Connector type. Example: Optical.
         :paramtype connector_type: str
         :keyword max_speed_in_mbps: Maximum speed of the connector in Mbps.
         :paramtype max_speed_in_mbps: int
         """
         super().__init__(**kwargs)
         self.connector_type = connector_type
         self.max_speed_in_mbps = max_speed_in_mbps
 
 
 class SupportedVersionProperties(_serialization.Model):
-    """Supported version details of the network device.
+    """Network device supported version properties.
 
     :ivar version: Operating system and firmware combined versions.
     :vartype version: str
     :ivar vendor_os_version: Operating system version.
     :vartype vendor_os_version: str
     :ivar vendor_firmware_version: Firmware version.
     :vartype vendor_firmware_version: str
-    :ivar is_default: If true newly provisioned Fabric will use this device version by default to
-     bootstrap the network devices for the first time. Known values are: "True" and "False".
-    :vartype is_default: str or ~azure.mgmt.managednetworkfabric.models.BooleanEnumProperty
+    :ivar is_current: If the current version is in use. Known values are: "true" and "false".
+    :vartype is_current: str or ~azure.mgmt.managednetworkfabric.models.IsCurrentVersion
+    :ivar is_test: If the current version is a test version. Known values are: "true" and "false".
+    :vartype is_test: str or ~azure.mgmt.managednetworkfabric.models.IsTestVersion
     """
 
     _attribute_map = {
         "version": {"key": "version", "type": "str"},
         "vendor_os_version": {"key": "vendorOsVersion", "type": "str"},
         "vendor_firmware_version": {"key": "vendorFirmwareVersion", "type": "str"},
-        "is_default": {"key": "isDefault", "type": "str"},
+        "is_current": {"key": "isCurrent", "type": "str"},
+        "is_test": {"key": "isTest", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         version: Optional[str] = None,
         vendor_os_version: Optional[str] = None,
         vendor_firmware_version: Optional[str] = None,
-        is_default: Optional[Union[str, "_models.BooleanEnumProperty"]] = None,
+        is_current: Optional[Union[str, "_models.IsCurrentVersion"]] = None,
+        is_test: Optional[Union[str, "_models.IsTestVersion"]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword version: Operating system and firmware combined versions.
         :paramtype version: str
         :keyword vendor_os_version: Operating system version.
         :paramtype vendor_os_version: str
         :keyword vendor_firmware_version: Firmware version.
         :paramtype vendor_firmware_version: str
-        :keyword is_default: If true newly provisioned Fabric will use this device version by default
-         to bootstrap the network devices for the first time. Known values are: "True" and "False".
-        :paramtype is_default: str or ~azure.mgmt.managednetworkfabric.models.BooleanEnumProperty
+        :keyword is_current: If the current version is in use. Known values are: "true" and "false".
+        :paramtype is_current: str or ~azure.mgmt.managednetworkfabric.models.IsCurrentVersion
+        :keyword is_test: If the current version is a test version. Known values are: "true" and
+         "false".
+        :paramtype is_test: str or ~azure.mgmt.managednetworkfabric.models.IsTestVersion
         """
         super().__init__(**kwargs)
         self.version = version
         self.vendor_os_version = vendor_os_version
         self.vendor_firmware_version = vendor_firmware_version
-        self.is_default = is_default
+        self.is_current = is_current
+        self.is_test = is_test
+
+
+class SupportPackageProperties(_serialization.Model):
+    """Generate support package post action properties.
+
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar support_package_url: The URL to fetch the generated support package from. Required.
+    :vartype support_package_url: str
+    """
+
+    _validation = {
+        "support_package_url": {"required": True},
+    }
+
+    _attribute_map = {
+        "support_package_url": {"key": "supportPackageURL", "type": "str"},
+    }
+
+    def __init__(self, *, support_package_url: str, **kwargs: Any) -> None:
+        """
+        :keyword support_package_url: The URL to fetch the generated support package from. Required.
+        :paramtype support_package_url: str
+        """
+        super().__init__(**kwargs)
+        self.support_package_url = support_package_url
 
 
 class SystemData(_serialization.Model):
     """Metadata pertaining to creation and last modification of the resource.
 
     :ivar created_by: The identity that created the resource.
     :vartype created_by: str
@@ -11935,616 +7864,355 @@
         self.created_by_type = created_by_type
         self.created_at = created_at
         self.last_modified_by = last_modified_by
         self.last_modified_by_type = last_modified_by_type
         self.last_modified_at = last_modified_at
 
 
-class TerminalServerConfiguration(TerminalServerPatchableProperties, Layer3IpPrefixProperties):
+class TerminalServerPatchableProperties(_serialization.Model):
+    """Network and credential configuration currently applied on terminal server.
+
+    :ivar username: Username for the terminal server connection.
+    :vartype username: str
+    :ivar password: Password for the terminal server connection.
+    :vartype password: str
+    :ivar serial_number: Serial Number of Terminal server.
+    :vartype serial_number: str
+    """
+
+    _attribute_map = {
+        "username": {"key": "username", "type": "str"},
+        "password": {"key": "password", "type": "str"},
+        "serial_number": {"key": "serialNumber", "type": "str"},
+    }
+
+    def __init__(
+        self,
+        *,
+        username: Optional[str] = None,
+        password: Optional[str] = None,
+        serial_number: Optional[str] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword username: Username for the terminal server connection.
+        :paramtype username: str
+        :keyword password: Password for the terminal server connection.
+        :paramtype password: str
+        :keyword serial_number: Serial Number of Terminal server.
+        :paramtype serial_number: str
+        """
+        super().__init__(**kwargs)
+        self.username = username
+        self.password = password
+        self.serial_number = serial_number
+
+
+class TerminalServerConfiguration(Layer3IpPrefixProperties, TerminalServerPatchableProperties):
     """Network and credentials configuration currently applied to terminal server.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
-    :ivar primary_ipv4_prefix: IPv4 Address Prefix.
-    :vartype primary_ipv4_prefix: str
-    :ivar primary_ipv6_prefix: IPv6 Address Prefix.
-    :vartype primary_ipv6_prefix: str
-    :ivar secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
-    :vartype secondary_ipv4_prefix: str
-    :ivar secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
-    :vartype secondary_ipv6_prefix: str
     :ivar username: Username for the terminal server connection.
     :vartype username: str
     :ivar password: Password for the terminal server connection.
     :vartype password: str
     :ivar serial_number: Serial Number of Terminal server.
     :vartype serial_number: str
+    :ivar primary_ipv4_prefix: IPv4 Address Prefix of CE-PE interconnect links. Example:
+     172.31.0.0/31. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
+    :vartype primary_ipv4_prefix: str
+    :ivar primary_ipv6_prefix: IPv6 Address Prefix of CE-PE interconnect links. Example:
+     3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
+    :vartype primary_ipv6_prefix: str
+    :ivar secondary_ipv4_prefix: Secondary IPv4 Address Prefix of CE-PE interconnect links.
+     Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated
+     afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+     are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+     configured on PE1 and PE2 for Option B interfaces.
+    :vartype secondary_ipv4_prefix: str
+    :ivar secondary_ipv6_prefix: Secondary IPv6 Address Prefix of CE-PE interconnect links.
+     Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can
+     be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st
+     and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs
+     are to be configured on PE1 and PE2 for Option B interfaces.
+    :vartype secondary_ipv6_prefix: str
     :ivar network_device_id: ARM Resource ID used for the NetworkDevice.
     :vartype network_device_id: str
     """
 
     _validation = {
-        "username": {"min_length": 1},
-        "password": {"min_length": 1},
-        "serial_number": {"min_length": 1},
         "network_device_id": {"readonly": True},
     }
 
     _attribute_map = {
+        "username": {"key": "username", "type": "str"},
+        "password": {"key": "password", "type": "str"},
+        "serial_number": {"key": "serialNumber", "type": "str"},
         "primary_ipv4_prefix": {"key": "primaryIpv4Prefix", "type": "str"},
         "primary_ipv6_prefix": {"key": "primaryIpv6Prefix", "type": "str"},
         "secondary_ipv4_prefix": {"key": "secondaryIpv4Prefix", "type": "str"},
         "secondary_ipv6_prefix": {"key": "secondaryIpv6Prefix", "type": "str"},
-        "username": {"key": "username", "type": "str"},
-        "password": {"key": "password", "type": "str"},
-        "serial_number": {"key": "serialNumber", "type": "str"},
         "network_device_id": {"key": "networkDeviceId", "type": "str"},
     }
 
     def __init__(
         self,
         *,
+        username: Optional[str] = None,
+        password: Optional[str] = None,
+        serial_number: Optional[str] = None,
         primary_ipv4_prefix: Optional[str] = None,
         primary_ipv6_prefix: Optional[str] = None,
         secondary_ipv4_prefix: Optional[str] = None,
         secondary_ipv6_prefix: Optional[str] = None,
-        username: Optional[str] = None,
-        password: Optional[str] = None,
-        serial_number: Optional[str] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword primary_ipv4_prefix: IPv4 Address Prefix.
-        :paramtype primary_ipv4_prefix: str
-        :keyword primary_ipv6_prefix: IPv6 Address Prefix.
-        :paramtype primary_ipv6_prefix: str
-        :keyword secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
-        :paramtype secondary_ipv4_prefix: str
-        :keyword secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
-        :paramtype secondary_ipv6_prefix: str
         :keyword username: Username for the terminal server connection.
         :paramtype username: str
         :keyword password: Password for the terminal server connection.
         :paramtype password: str
         :keyword serial_number: Serial Number of Terminal server.
         :paramtype serial_number: str
+        :keyword primary_ipv4_prefix: IPv4 Address Prefix of CE-PE interconnect links. Example:
+         172.31.0.0/31. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
+        :paramtype primary_ipv4_prefix: str
+        :keyword primary_ipv6_prefix: IPv6 Address Prefix of CE-PE interconnect links. Example:
+         3FFE:FFFF:0:CD30::a0/126. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
+        :paramtype primary_ipv6_prefix: str
+        :keyword secondary_ipv4_prefix: Secondary IPv4 Address Prefix of CE-PE interconnect links.
+         Example: 172.31.0.20/31. The values can be specified at the time of creation or can be updated
+         afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st and 3rd IPs
+         are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs are to be
+         configured on PE1 and PE2 for Option B interfaces.
+        :paramtype secondary_ipv4_prefix: str
+        :keyword secondary_ipv6_prefix: Secondary IPv6 Address Prefix of CE-PE interconnect links.
+         Example: 3FFE:FFFF:0:CD30::a4/126. The values can be specified at the time of creation or can
+         be updated afterwards. Any update to the values post-provisioning may disrupt traffic. The 1st
+         and 3rd IPs are to be configured on CE1 and CE2 for Option B interfaces. The 2nd and 4th IPs
+         are to be configured on PE1 and PE2 for Option B interfaces.
+        :paramtype secondary_ipv6_prefix: str
         """
         super().__init__(
-            username=username,
-            password=password,
-            serial_number=serial_number,
             primary_ipv4_prefix=primary_ipv4_prefix,
             primary_ipv6_prefix=primary_ipv6_prefix,
             secondary_ipv4_prefix=secondary_ipv4_prefix,
             secondary_ipv6_prefix=secondary_ipv6_prefix,
+            username=username,
+            password=password,
+            serial_number=serial_number,
             **kwargs
         )
+        self.username = username
+        self.password = password
+        self.serial_number = serial_number
+        self.network_device_id = None
         self.primary_ipv4_prefix = primary_ipv4_prefix
         self.primary_ipv6_prefix = primary_ipv6_prefix
         self.secondary_ipv4_prefix = secondary_ipv4_prefix
         self.secondary_ipv6_prefix = secondary_ipv6_prefix
-        self.network_device_id = None
-        self.username = username
-        self.password = password
-        self.serial_number = serial_number
 
 
 class UpdateAdministrativeState(EnableDisableOnResources):
     """Update administrative state on list of resources.
 
     :ivar resource_ids: Network Fabrics or Network Rack resource Id.
     :vartype resource_ids: list[str]
     :ivar state: Administrative state. Known values are: "Enable" and "Disable".
-    :vartype state: str or ~azure.mgmt.managednetworkfabric.models.EnableDisableState
+    :vartype state: str or ~azure.mgmt.managednetworkfabric.models.AdministrativeState
     """
 
     _attribute_map = {
         "resource_ids": {"key": "resourceIds", "type": "[str]"},
         "state": {"key": "state", "type": "str"},
     }
 
     def __init__(
         self,
         *,
         resource_ids: Optional[List[str]] = None,
-        state: Optional[Union[str, "_models.EnableDisableState"]] = None,
+        state: Optional[Union[str, "_models.AdministrativeState"]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword resource_ids: Network Fabrics or Network Rack resource Id.
         :paramtype resource_ids: list[str]
         :keyword state: Administrative state. Known values are: "Enable" and "Disable".
-        :paramtype state: str or ~azure.mgmt.managednetworkfabric.models.EnableDisableState
-        """
-        super().__init__(resource_ids=resource_ids, **kwargs)
-        self.state = state
-
-
-class UpdateDeviceAdministrativeState(EnableDisableOnResources):
-    """Update the administrative state on list of resources.
-
-    :ivar resource_ids: Network Fabrics or Network Rack resource Id.
-    :vartype resource_ids: list[str]
-    :ivar state: Administrative state. Known values are: "RMA", "Resync", "GracefulQuarantine", and
-     "Quarantine".
-    :vartype state: str or ~azure.mgmt.managednetworkfabric.models.DeviceAdministrativeState
-    """
-
-    _attribute_map = {
-        "resource_ids": {"key": "resourceIds", "type": "[str]"},
-        "state": {"key": "state", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        resource_ids: Optional[List[str]] = None,
-        state: Optional[Union[str, "_models.DeviceAdministrativeState"]] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword resource_ids: Network Fabrics or Network Rack resource Id.
-        :paramtype resource_ids: list[str]
-        :keyword state: Administrative state. Known values are: "RMA", "Resync", "GracefulQuarantine",
-         and "Quarantine".
-        :paramtype state: str or ~azure.mgmt.managednetworkfabric.models.DeviceAdministrativeState
+        :paramtype state: str or ~azure.mgmt.managednetworkfabric.models.AdministrativeState
         """
         super().__init__(resource_ids=resource_ids, **kwargs)
         self.state = state
 
 
-class UpdateVersion(_serialization.Model):
-    """Update version properties.
-
-    :ivar version: Specify the version.
-    :vartype version: str
-    """
-
-    _attribute_map = {
-        "version": {"key": "version", "type": "str"},
-    }
-
-    def __init__(self, *, version: Optional[str] = None, **kwargs: Any) -> None:
-        """
-        :keyword version: Specify the version.
-        :paramtype version: str
-        """
-        super().__init__(**kwargs)
-        self.version = version
-
-
-class ValidateConfigurationProperties(_serialization.Model):
-    """Validation configuration properties.
-
-    :ivar validate_action: Validate action that to be performed. Known values are: "Cabling",
-     "Configuration", and "Connectivity".
-    :vartype validate_action: str or ~azure.mgmt.managednetworkfabric.models.ValidateAction
-    """
-
-    _attribute_map = {
-        "validate_action": {"key": "validateAction", "type": "str"},
-    }
-
-    def __init__(
-        self, *, validate_action: Optional[Union[str, "_models.ValidateAction"]] = None, **kwargs: Any
-    ) -> None:
-        """
-        :keyword validate_action: Validate action that to be performed. Known values are: "Cabling",
-         "Configuration", and "Connectivity".
-        :paramtype validate_action: str or ~azure.mgmt.managednetworkfabric.models.ValidateAction
-        """
-        super().__init__(**kwargs)
-        self.validate_action = validate_action
-
-
-class ValidateConfigurationResponse(ErrorResponse):
-    """The response of the action validate configuration.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar error: The error object.
-    :vartype error: ~azure.mgmt.managednetworkfabric.models.ErrorDetail
-    :ivar configuration_state: Gets the configuration state. Known values are: "Succeeded",
-     "Failed", "Rejected", "Accepted", "Provisioned", "ErrorProvisioning", "Deprovisioning",
-     "Deprovisioned", "ErrorDeprovisioning", and "DeferredControl".
-    :vartype configuration_state: str or ~azure.mgmt.managednetworkfabric.models.ConfigurationState
-    :ivar url: URL for the details of the response.
-    :vartype url: str
-    """
-
-    _validation = {
-        "configuration_state": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "error": {"key": "error", "type": "ErrorDetail"},
-        "configuration_state": {"key": "configurationState", "type": "str"},
-        "url": {"key": "url", "type": "str"},
-    }
-
-    def __init__(
-        self, *, error: Optional["_models.ErrorDetail"] = None, url: Optional[str] = None, **kwargs: Any
-    ) -> None:
-        """
-        :keyword error: The error object.
-        :paramtype error: ~azure.mgmt.managednetworkfabric.models.ErrorDetail
-        :keyword url: URL for the details of the response.
-        :paramtype url: str
-        """
-        super().__init__(error=error, **kwargs)
-        self.configuration_state = None
-        self.url = url
-
-
-class VlanGroupProperties(_serialization.Model):
-    """Vlan group properties.
-
-    :ivar name: Vlan group name.
-    :vartype name: str
-    :ivar vlans: List of vlans.
-    :vartype vlans: list[str]
-    """
-
-    _validation = {
-        "name": {"min_length": 1},
-        "vlans": {"min_items": 1},
-    }
-
-    _attribute_map = {
-        "name": {"key": "name", "type": "str"},
-        "vlans": {"key": "vlans", "type": "[str]"},
-    }
-
-    def __init__(self, *, name: Optional[str] = None, vlans: Optional[List[str]] = None, **kwargs: Any) -> None:
-        """
-        :keyword name: Vlan group name.
-        :paramtype name: str
-        :keyword vlans: List of vlans.
-        :paramtype vlans: list[str]
-        """
-        super().__init__(**kwargs)
-        self.name = name
-        self.vlans = vlans
-
+class UpdatePowerCycleProperties(_serialization.Model):
+    """Update power cycle input properties.
 
-class VlanMatchCondition(_serialization.Model):
-    """The vlan match conditions that needs to be matched.
+    All required parameters must be populated in order to send to Azure.
 
-    :ivar vlans: List of vlans that needs to be matched.
-    :vartype vlans: list[str]
-    :ivar inner_vlans: List of inner vlans that needs to be matched.
-    :vartype inner_vlans: list[str]
-    :ivar vlan_group_names: List of vlan group names that to be matched.
-    :vartype vlan_group_names: list[str]
+    :ivar power_end: Primary or Secondary power end. Required. Known values are: "Primary" and
+     "Secondary".
+    :vartype power_end: str or ~azure.mgmt.managednetworkfabric.models.PowerEnd
+    :ivar state: On or Off toggle state. Required. Known values are: "On" and "Off".
+    :vartype state: str or ~azure.mgmt.managednetworkfabric.models.State
     """
 
     _validation = {
-        "vlans": {"min_items": 1},
-        "inner_vlans": {"min_items": 1},
-        "vlan_group_names": {"min_items": 1},
+        "power_end": {"required": True},
+        "state": {"required": True},
     }
 
     _attribute_map = {
-        "vlans": {"key": "vlans", "type": "[str]"},
-        "inner_vlans": {"key": "innerVlans", "type": "[str]"},
-        "vlan_group_names": {"key": "vlanGroupNames", "type": "[str]"},
+        "power_end": {"key": "powerEnd", "type": "str"},
+        "state": {"key": "state", "type": "str"},
     }
 
     def __init__(
-        self,
-        *,
-        vlans: Optional[List[str]] = None,
-        inner_vlans: Optional[List[str]] = None,
-        vlan_group_names: Optional[List[str]] = None,
-        **kwargs: Any
+        self, *, power_end: Union[str, "_models.PowerEnd"], state: Union[str, "_models.State"], **kwargs: Any
     ) -> None:
         """
-        :keyword vlans: List of vlans that needs to be matched.
-        :paramtype vlans: list[str]
-        :keyword inner_vlans: List of inner vlans that needs to be matched.
-        :paramtype inner_vlans: list[str]
-        :keyword vlan_group_names: List of vlan group names that to be matched.
-        :paramtype vlan_group_names: list[str]
+        :keyword power_end: Primary or Secondary power end. Required. Known values are: "Primary" and
+         "Secondary".
+        :paramtype power_end: str or ~azure.mgmt.managednetworkfabric.models.PowerEnd
+        :keyword state: On or Off toggle state. Required. Known values are: "On" and "Off".
+        :paramtype state: str or ~azure.mgmt.managednetworkfabric.models.State
         """
         super().__init__(**kwargs)
-        self.vlans = vlans
-        self.inner_vlans = inner_vlans
-        self.vlan_group_names = vlan_group_names
+        self.power_end = power_end
+        self.state = state
 
 
-class VpnConfigurationPatchableProperties(_serialization.Model):
-    """Network and credential configuration currently applied on terminal server.
+class UpdateVersionProperties(_serialization.Model):
+    """Generate support package post action properties.
 
-    :ivar network_to_network_interconnect_id: ARM Resource ID of the Network To Network
-     Interconnect.
-    :vartype network_to_network_interconnect_id: str
-    :ivar peering_option: Peering option list. Known values are: "OptionA" and "OptionB".
-    :vartype peering_option: str or ~azure.mgmt.managednetworkfabric.models.PeeringOption
-    :ivar option_b_properties: option B properties.
-    :vartype option_b_properties: ~azure.mgmt.managednetworkfabric.models.OptionBProperties
-    :ivar option_a_properties: option A properties.
-    :vartype option_a_properties:
-     ~azure.mgmt.managednetworkfabric.models.VpnConfigurationPatchablePropertiesOptionAProperties
-    """
-
-    _attribute_map = {
-        "network_to_network_interconnect_id": {"key": "networkToNetworkInterconnectId", "type": "str"},
-        "peering_option": {"key": "peeringOption", "type": "str"},
-        "option_b_properties": {"key": "optionBProperties", "type": "OptionBProperties"},
-        "option_a_properties": {
-            "key": "optionAProperties",
-            "type": "VpnConfigurationPatchablePropertiesOptionAProperties",
-        },
-    }
-
-    def __init__(
-        self,
-        *,
-        network_to_network_interconnect_id: Optional[str] = None,
-        peering_option: Optional[Union[str, "_models.PeeringOption"]] = None,
-        option_b_properties: Optional["_models.OptionBProperties"] = None,
-        option_a_properties: Optional["_models.VpnConfigurationPatchablePropertiesOptionAProperties"] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword network_to_network_interconnect_id: ARM Resource ID of the Network To Network
-         Interconnect.
-        :paramtype network_to_network_interconnect_id: str
-        :keyword peering_option: Peering option list. Known values are: "OptionA" and "OptionB".
-        :paramtype peering_option: str or ~azure.mgmt.managednetworkfabric.models.PeeringOption
-        :keyword option_b_properties: option B properties.
-        :paramtype option_b_properties: ~azure.mgmt.managednetworkfabric.models.OptionBProperties
-        :keyword option_a_properties: option A properties.
-        :paramtype option_a_properties:
-         ~azure.mgmt.managednetworkfabric.models.VpnConfigurationPatchablePropertiesOptionAProperties
-        """
-        super().__init__(**kwargs)
-        self.network_to_network_interconnect_id = network_to_network_interconnect_id
-        self.peering_option = peering_option
-        self.option_b_properties = option_b_properties
-        self.option_a_properties = option_a_properties
-
-
-class VpnConfigurationPatchablePropertiesOptionAProperties(OptionAProperties, Layer3IpPrefixProperties):
-    """option A properties.
+    All required parameters must be populated in order to send to Azure.
 
-    :ivar primary_ipv4_prefix: IPv4 Address Prefix.
-    :vartype primary_ipv4_prefix: str
-    :ivar primary_ipv6_prefix: IPv6 Address Prefix.
-    :vartype primary_ipv6_prefix: str
-    :ivar secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
-    :vartype secondary_ipv4_prefix: str
-    :ivar secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
-    :vartype secondary_ipv6_prefix: str
-    :ivar mtu: MTU to use for option A peering.
-    :vartype mtu: int
-    :ivar vlan_id: Vlan Id.Example : 501.
-    :vartype vlan_id: int
-    :ivar peer_asn: Peer ASN number.Example : 28.
-    :vartype peer_asn: int
-    :ivar bfd_configuration: BFD Configuration properties.
-    :vartype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
+    :ivar sku_version: The supported version defined in network device SKU. Required.
+    :vartype sku_version: str
     """
 
     _validation = {
-        "mtu": {"maximum": 9200, "minimum": 64},
-        "vlan_id": {"maximum": 4094, "minimum": 501},
-        "peer_asn": {"maximum": 4294967295, "minimum": 1},
+        "sku_version": {"required": True},
     }
 
     _attribute_map = {
-        "primary_ipv4_prefix": {"key": "primaryIpv4Prefix", "type": "str"},
-        "primary_ipv6_prefix": {"key": "primaryIpv6Prefix", "type": "str"},
-        "secondary_ipv4_prefix": {"key": "secondaryIpv4Prefix", "type": "str"},
-        "secondary_ipv6_prefix": {"key": "secondaryIpv6Prefix", "type": "str"},
-        "mtu": {"key": "mtu", "type": "int"},
-        "vlan_id": {"key": "vlanId", "type": "int"},
-        "peer_asn": {"key": "peerASN", "type": "int"},
-        "bfd_configuration": {"key": "bfdConfiguration", "type": "BfdConfiguration"},
+        "sku_version": {"key": "skuVersion", "type": "str"},
     }
 
-    def __init__(
-        self,
-        *,
-        primary_ipv4_prefix: Optional[str] = None,
-        primary_ipv6_prefix: Optional[str] = None,
-        secondary_ipv4_prefix: Optional[str] = None,
-        secondary_ipv6_prefix: Optional[str] = None,
-        mtu: int = 1500,
-        vlan_id: Optional[int] = None,
-        peer_asn: Optional[int] = None,
-        bfd_configuration: Optional["_models.BfdConfiguration"] = None,
-        **kwargs: Any
-    ) -> None:
+    def __init__(self, *, sku_version: str, **kwargs: Any) -> None:
         """
-        :keyword primary_ipv4_prefix: IPv4 Address Prefix.
-        :paramtype primary_ipv4_prefix: str
-        :keyword primary_ipv6_prefix: IPv6 Address Prefix.
-        :paramtype primary_ipv6_prefix: str
-        :keyword secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
-        :paramtype secondary_ipv4_prefix: str
-        :keyword secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
-        :paramtype secondary_ipv6_prefix: str
-        :keyword mtu: MTU to use for option A peering.
-        :paramtype mtu: int
-        :keyword vlan_id: Vlan Id.Example : 501.
-        :paramtype vlan_id: int
-        :keyword peer_asn: Peer ASN number.Example : 28.
-        :paramtype peer_asn: int
-        :keyword bfd_configuration: BFD Configuration properties.
-        :paramtype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
+        :keyword sku_version: The supported version defined in network device SKU. Required.
+        :paramtype sku_version: str
         """
-        super().__init__(
-            mtu=mtu,
-            vlan_id=vlan_id,
-            peer_asn=peer_asn,
-            bfd_configuration=bfd_configuration,
-            primary_ipv4_prefix=primary_ipv4_prefix,
-            primary_ipv6_prefix=primary_ipv6_prefix,
-            secondary_ipv4_prefix=secondary_ipv4_prefix,
-            secondary_ipv6_prefix=secondary_ipv6_prefix,
-            **kwargs
-        )
-        self.primary_ipv4_prefix = primary_ipv4_prefix
-        self.primary_ipv6_prefix = primary_ipv6_prefix
-        self.secondary_ipv4_prefix = secondary_ipv4_prefix
-        self.secondary_ipv6_prefix = secondary_ipv6_prefix
-        self.mtu = mtu
-        self.vlan_id = vlan_id
-        self.peer_asn = peer_asn
-        self.bfd_configuration = bfd_configuration
+        super().__init__(**kwargs)
+        self.sku_version = sku_version
 
 
 class VpnConfigurationProperties(_serialization.Model):
-    """Network and credential configuration currently applied on terminal server.
+    """Configuration for infrastructure vpn.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
-    :ivar network_to_network_interconnect_id: ARM Resource ID of the Network To Network
-     Interconnect.
-    :vartype network_to_network_interconnect_id: str
-    :ivar administrative_state: Administrative state of the resource. Known values are: "Enabled",
-     "Disabled", "MAT", and "RMA".
+    :ivar administrative_state: Indicates configuration state. Example: Enabled | Disabled. Known
+     values are: "Enabled" and "Disabled".
     :vartype administrative_state: str or
-     ~azure.mgmt.managednetworkfabric.models.AdministrativeState
+     ~azure.mgmt.managednetworkfabric.models.EnabledDisabledState
+    :ivar network_to_network_interconnect_id: Gets the networkToNetworkInterconnectId of the
+     resource.
+    :vartype network_to_network_interconnect_id: str
     :ivar peering_option: Peering option list. Required. Known values are: "OptionA" and "OptionB".
     :vartype peering_option: str or ~azure.mgmt.managednetworkfabric.models.PeeringOption
     :ivar option_b_properties: option B properties.
-    :vartype option_b_properties: ~azure.mgmt.managednetworkfabric.models.OptionBProperties
+    :vartype option_b_properties:
+     ~azure.mgmt.managednetworkfabric.models.OptionBPropertiesAutoGenerated
     :ivar option_a_properties: option A properties.
-    :vartype option_a_properties:
-     ~azure.mgmt.managednetworkfabric.models.VpnConfigurationPropertiesOptionAProperties
+    :vartype option_a_properties: ~azure.mgmt.managednetworkfabric.models.OptionAProperties
     """
 
     _validation = {
         "administrative_state": {"readonly": True},
+        "network_to_network_interconnect_id": {"readonly": True},
         "peering_option": {"required": True},
     }
 
     _attribute_map = {
-        "network_to_network_interconnect_id": {"key": "networkToNetworkInterconnectId", "type": "str"},
         "administrative_state": {"key": "administrativeState", "type": "str"},
+        "network_to_network_interconnect_id": {"key": "networkToNetworkInterconnectId", "type": "str"},
         "peering_option": {"key": "peeringOption", "type": "str"},
-        "option_b_properties": {"key": "optionBProperties", "type": "OptionBProperties"},
-        "option_a_properties": {"key": "optionAProperties", "type": "VpnConfigurationPropertiesOptionAProperties"},
+        "option_b_properties": {"key": "optionBProperties", "type": "OptionBPropertiesAutoGenerated"},
+        "option_a_properties": {"key": "optionAProperties", "type": "OptionAProperties"},
     }
 
     def __init__(
         self,
         *,
         peering_option: Union[str, "_models.PeeringOption"],
-        network_to_network_interconnect_id: Optional[str] = None,
-        option_b_properties: Optional["_models.OptionBProperties"] = None,
-        option_a_properties: Optional["_models.VpnConfigurationPropertiesOptionAProperties"] = None,
+        option_b_properties: Optional["_models.OptionBPropertiesAutoGenerated"] = None,
+        option_a_properties: Optional["_models.OptionAProperties"] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword network_to_network_interconnect_id: ARM Resource ID of the Network To Network
-         Interconnect.
-        :paramtype network_to_network_interconnect_id: str
         :keyword peering_option: Peering option list. Required. Known values are: "OptionA" and
          "OptionB".
         :paramtype peering_option: str or ~azure.mgmt.managednetworkfabric.models.PeeringOption
         :keyword option_b_properties: option B properties.
-        :paramtype option_b_properties: ~azure.mgmt.managednetworkfabric.models.OptionBProperties
+        :paramtype option_b_properties:
+         ~azure.mgmt.managednetworkfabric.models.OptionBPropertiesAutoGenerated
         :keyword option_a_properties: option A properties.
-        :paramtype option_a_properties:
-         ~azure.mgmt.managednetworkfabric.models.VpnConfigurationPropertiesOptionAProperties
+        :paramtype option_a_properties: ~azure.mgmt.managednetworkfabric.models.OptionAProperties
         """
         super().__init__(**kwargs)
-        self.network_to_network_interconnect_id = network_to_network_interconnect_id
         self.administrative_state = None
+        self.network_to_network_interconnect_id = None
         self.peering_option = peering_option
         self.option_b_properties = option_b_properties
         self.option_a_properties = option_a_properties
 
 
-class VpnConfigurationPropertiesOptionAProperties(OptionAProperties, Layer3IpPrefixProperties):
-    """option A properties.
+class WorkloadServices(_serialization.Model):
+    """WorkloadServices IP ranges.
 
-    :ivar primary_ipv4_prefix: IPv4 Address Prefix.
-    :vartype primary_ipv4_prefix: str
-    :ivar primary_ipv6_prefix: IPv6 Address Prefix.
-    :vartype primary_ipv6_prefix: str
-    :ivar secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
-    :vartype secondary_ipv4_prefix: str
-    :ivar secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
-    :vartype secondary_ipv6_prefix: str
-    :ivar mtu: MTU to use for option A peering.
-    :vartype mtu: int
-    :ivar vlan_id: Vlan Id.Example : 501.
-    :vartype vlan_id: int
-    :ivar peer_asn: Peer ASN number.Example : 28.
-    :vartype peer_asn: int
-    :ivar bfd_configuration: BFD Configuration properties.
-    :vartype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
+    :ivar ipv4_address_spaces: The IPv4 Address space is optional, if the value is defined at the
+     time of NFC creation, then the default value 10.0.0.0/19 is considered. The IPV4 address subnet
+     is an optional attribute.
+    :vartype ipv4_address_spaces: list[str]
+    :ivar ipv6_address_spaces: The IPv6 is not supported right now.
+    :vartype ipv6_address_spaces: list[str]
     """
 
-    _validation = {
-        "mtu": {"maximum": 9200, "minimum": 64},
-        "vlan_id": {"maximum": 4094, "minimum": 501},
-        "peer_asn": {"maximum": 4294967295, "minimum": 1},
-    }
-
     _attribute_map = {
-        "primary_ipv4_prefix": {"key": "primaryIpv4Prefix", "type": "str"},
-        "primary_ipv6_prefix": {"key": "primaryIpv6Prefix", "type": "str"},
-        "secondary_ipv4_prefix": {"key": "secondaryIpv4Prefix", "type": "str"},
-        "secondary_ipv6_prefix": {"key": "secondaryIpv6Prefix", "type": "str"},
-        "mtu": {"key": "mtu", "type": "int"},
-        "vlan_id": {"key": "vlanId", "type": "int"},
-        "peer_asn": {"key": "peerASN", "type": "int"},
-        "bfd_configuration": {"key": "bfdConfiguration", "type": "BfdConfiguration"},
+        "ipv4_address_spaces": {"key": "ipv4AddressSpaces", "type": "[str]"},
+        "ipv6_address_spaces": {"key": "ipv6AddressSpaces", "type": "[str]"},
     }
 
     def __init__(
         self,
         *,
-        primary_ipv4_prefix: Optional[str] = None,
-        primary_ipv6_prefix: Optional[str] = None,
-        secondary_ipv4_prefix: Optional[str] = None,
-        secondary_ipv6_prefix: Optional[str] = None,
-        mtu: int = 1500,
-        vlan_id: Optional[int] = None,
-        peer_asn: Optional[int] = None,
-        bfd_configuration: Optional["_models.BfdConfiguration"] = None,
+        ipv4_address_spaces: Optional[List[str]] = None,
+        ipv6_address_spaces: Optional[List[str]] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword primary_ipv4_prefix: IPv4 Address Prefix.
-        :paramtype primary_ipv4_prefix: str
-        :keyword primary_ipv6_prefix: IPv6 Address Prefix.
-        :paramtype primary_ipv6_prefix: str
-        :keyword secondary_ipv4_prefix: Secondary IPv4 Address Prefix.
-        :paramtype secondary_ipv4_prefix: str
-        :keyword secondary_ipv6_prefix: Secondary IPv6 Address Prefix.
-        :paramtype secondary_ipv6_prefix: str
-        :keyword mtu: MTU to use for option A peering.
-        :paramtype mtu: int
-        :keyword vlan_id: Vlan Id.Example : 501.
-        :paramtype vlan_id: int
-        :keyword peer_asn: Peer ASN number.Example : 28.
-        :paramtype peer_asn: int
-        :keyword bfd_configuration: BFD Configuration properties.
-        :paramtype bfd_configuration: ~azure.mgmt.managednetworkfabric.models.BfdConfiguration
+        :keyword ipv4_address_spaces: The IPv4 Address space is optional, if the value is defined at
+         the time of NFC creation, then the default value 10.0.0.0/19 is considered. The IPV4 address
+         subnet is an optional attribute.
+        :paramtype ipv4_address_spaces: list[str]
+        :keyword ipv6_address_spaces: The IPv6 is not supported right now.
+        :paramtype ipv6_address_spaces: list[str]
         """
-        super().__init__(
-            mtu=mtu,
-            vlan_id=vlan_id,
-            peer_asn=peer_asn,
-            bfd_configuration=bfd_configuration,
-            primary_ipv4_prefix=primary_ipv4_prefix,
-            primary_ipv6_prefix=primary_ipv6_prefix,
-            secondary_ipv4_prefix=secondary_ipv4_prefix,
-            secondary_ipv6_prefix=secondary_ipv6_prefix,
-            **kwargs
-        )
-        self.primary_ipv4_prefix = primary_ipv4_prefix
-        self.primary_ipv6_prefix = primary_ipv6_prefix
-        self.secondary_ipv4_prefix = secondary_ipv4_prefix
-        self.secondary_ipv6_prefix = secondary_ipv6_prefix
-        self.mtu = mtu
-        self.vlan_id = vlan_id
-        self.peer_asn = peer_asn
-        self.bfd_configuration = bfd_configuration
+        super().__init__(**kwargs)
+        self.ipv4_address_spaces = ipv4_address_spaces
+        self.ipv6_address_spaces = ipv6_address_spaces
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/models/__init__.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/models/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -2,542 +2,380 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+from ._models_py3 import ARPProperties
 from ._models_py3 import AccessControlList
-from ._models_py3 import AccessControlListAction
-from ._models_py3 import AccessControlListMatchCondition
-from ._models_py3 import AccessControlListMatchConfiguration
+from ._models_py3 import AccessControlListConditionProperties
 from ._models_py3 import AccessControlListPatch
 from ._models_py3 import AccessControlListPatchProperties
-from ._models_py3 import AccessControlListPatchableProperties
-from ._models_py3 import AccessControlListPortCondition
 from ._models_py3 import AccessControlListProperties
 from ._models_py3 import AccessControlListsListResult
 from ._models_py3 import ActionIpCommunityProperties
 from ._models_py3 import ActionIpExtendedCommunityProperties
 from ._models_py3 import AggregateRoute
 from ._models_py3 import AggregateRouteConfiguration
 from ._models_py3 import AnnotationResource
 from ._models_py3 import BfdConfiguration
 from ._models_py3 import BgpConfiguration
-from ._models_py3 import CommonDynamicMatchConfiguration
-from ._models_py3 import CommonMatchConditions
-from ._models_py3 import CommonPostActionResponseForDeviceUpdate
-from ._models_py3 import CommonPostActionResponseForStateUpdate
 from ._models_py3 import ConnectedSubnet
-from ._models_py3 import ConnectedSubnetRoutePolicy
-from ._models_py3 import ControllerServices
-from ._models_py3 import DestinationProperties
 from ._models_py3 import DeviceInterfaceProperties
+from ._models_py3 import DeviceLimits
 from ._models_py3 import EnableDisableOnResources
 from ._models_py3 import ErrorAdditionalInfo
 from ._models_py3 import ErrorDetail
 from ._models_py3 import ErrorResponse
-from ._models_py3 import ExportRoutePolicy
-from ._models_py3 import ExportRoutePolicyInformation
 from ._models_py3 import ExpressRouteConnectionInformation
+from ._models_py3 import ExpressRouteStatusDef
 from ._models_py3 import ExtendedLocation
-from ._models_py3 import ExtensionEnumProperty
 from ._models_py3 import ExternalNetwork
 from ._models_py3 import ExternalNetworkPatch
 from ._models_py3 import ExternalNetworkPatchProperties
-from ._models_py3 import ExternalNetworkPatchPropertiesOptionAProperties
 from ._models_py3 import ExternalNetworkPatchableProperties
 from ._models_py3 import ExternalNetworkProperties
 from ._models_py3 import ExternalNetworkPropertiesOptionAProperties
 from ._models_py3 import ExternalNetworksList
-from ._models_py3 import ImportRoutePolicy
-from ._models_py3 import ImportRoutePolicyInformation
+from ._models_py3 import FabricBfdConfiguration
+from ._models_py3 import GetDeviceStatusProperties
+from ._models_py3 import GetDynamicInterfaceMapsPropertiesItem
+from ._models_py3 import GetStaticInterfaceMapsPropertiesItem
+from ._models_py3 import InfrastructureServices
+from ._models_py3 import InterfaceStatus
 from ._models_py3 import InternalNetwork
 from ._models_py3 import InternalNetworkPatch
 from ._models_py3 import InternalNetworkPatchProperties
 from ._models_py3 import InternalNetworkPatchableProperties
 from ._models_py3 import InternalNetworkProperties
-from ._models_py3 import InternalNetworkPropertiesBgpConfiguration
-from ._models_py3 import InternalNetworkPropertiesStaticRouteConfiguration
 from ._models_py3 import InternalNetworksList
-from ._models_py3 import InternetGateway
-from ._models_py3 import InternetGatewayPatch
-from ._models_py3 import InternetGatewayPatchableProperties
-from ._models_py3 import InternetGatewayProperties
-from ._models_py3 import InternetGatewayRule
-from ._models_py3 import InternetGatewayRulePatch
-from ._models_py3 import InternetGatewayRuleProperties
-from ._models_py3 import InternetGatewayRulesListResult
-from ._models_py3 import InternetGatewaysListResult
 from ._models_py3 import IpCommunitiesListResult
 from ._models_py3 import IpCommunity
 from ._models_py3 import IpCommunityAddOperationProperties
 from ._models_py3 import IpCommunityDeleteOperationProperties
 from ._models_py3 import IpCommunityIdList
 from ._models_py3 import IpCommunityPatch
-from ._models_py3 import IpCommunityPatchableProperties
 from ._models_py3 import IpCommunityProperties
-from ._models_py3 import IpCommunityRule
 from ._models_py3 import IpCommunitySetOperationProperties
 from ._models_py3 import IpExtendedCommunity
 from ._models_py3 import IpExtendedCommunityAddOperationProperties
 from ._models_py3 import IpExtendedCommunityDeleteOperationProperties
 from ._models_py3 import IpExtendedCommunityIdList
 from ._models_py3 import IpExtendedCommunityListResult
 from ._models_py3 import IpExtendedCommunityPatch
-from ._models_py3 import IpExtendedCommunityPatchProperties
-from ._models_py3 import IpExtendedCommunityPatchableProperties
 from ._models_py3 import IpExtendedCommunityProperties
-from ._models_py3 import IpExtendedCommunityRule
 from ._models_py3 import IpExtendedCommunitySetOperationProperties
-from ._models_py3 import IpGroupProperties
-from ._models_py3 import IpMatchCondition
 from ._models_py3 import IpPrefix
 from ._models_py3 import IpPrefixPatch
-from ._models_py3 import IpPrefixPatchProperties
-from ._models_py3 import IpPrefixPatchableProperties
 from ._models_py3 import IpPrefixProperties
-from ._models_py3 import IpPrefixRule
+from ._models_py3 import IpPrefixPropertiesIpPrefixRulesItem
 from ._models_py3 import IpPrefixesListResult
-from ._models_py3 import IsolationDomainProperties
 from ._models_py3 import L2IsolationDomain
 from ._models_py3 import L2IsolationDomainPatch
 from ._models_py3 import L2IsolationDomainPatchProperties
 from ._models_py3 import L2IsolationDomainProperties
 from ._models_py3 import L2IsolationDomainsListResult
-from ._models_py3 import L3ExportRoutePolicy
 from ._models_py3 import L3IsolationDomain
 from ._models_py3 import L3IsolationDomainPatch
 from ._models_py3 import L3IsolationDomainPatchProperties
-from ._models_py3 import L3IsolationDomainPatchableProperties
+from ._models_py3 import L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy
 from ._models_py3 import L3IsolationDomainProperties
 from ._models_py3 import L3IsolationDomainsListResult
-from ._models_py3 import L3OptionAProperties
-from ._models_py3 import L3OptionBProperties
 from ._models_py3 import Layer2Configuration
+from ._models_py3 import Layer3Configuration
 from ._models_py3 import Layer3IpPrefixProperties
+from ._models_py3 import Layer3OptionAProperties
 from ._models_py3 import ManagedResourceGroupConfiguration
-from ._models_py3 import ManagementNetworkConfigurationPatchableProperties
-from ._models_py3 import ManagementNetworkConfigurationProperties
+from ._models_py3 import ManagementNetworkConfiguration
 from ._models_py3 import NeighborAddress
-from ._models_py3 import NeighborGroup
-from ._models_py3 import NeighborGroupDestination
-from ._models_py3 import NeighborGroupPatch
-from ._models_py3 import NeighborGroupPatchProperties
-from ._models_py3 import NeighborGroupPatchableProperties
-from ._models_py3 import NeighborGroupProperties
-from ._models_py3 import NeighborGroupsListResult
 from ._models_py3 import NetworkDevice
 from ._models_py3 import NetworkDevicePatchParameters
 from ._models_py3 import NetworkDevicePatchParametersProperties
 from ._models_py3 import NetworkDevicePatchableProperties
 from ._models_py3 import NetworkDeviceProperties
+from ._models_py3 import NetworkDeviceRoleProperties
 from ._models_py3 import NetworkDeviceSku
 from ._models_py3 import NetworkDeviceSkusListResult
 from ._models_py3 import NetworkDevicesListResult
 from ._models_py3 import NetworkFabric
 from ._models_py3 import NetworkFabricController
 from ._models_py3 import NetworkFabricControllerPatch
 from ._models_py3 import NetworkFabricControllerPatchableProperties
 from ._models_py3 import NetworkFabricControllerProperties
 from ._models_py3 import NetworkFabricControllersListResult
-from ._models_py3 import NetworkFabricPatch
-from ._models_py3 import NetworkFabricPatchProperties
+from ._models_py3 import NetworkFabricPatchParameters
+from ._models_py3 import NetworkFabricPatchParametersProperties
 from ._models_py3 import NetworkFabricPatchableProperties
-from ._models_py3 import NetworkFabricPatchablePropertiesTerminalServerConfiguration
 from ._models_py3 import NetworkFabricProperties
 from ._models_py3 import NetworkFabricSku
 from ._models_py3 import NetworkFabricSkusListResult
 from ._models_py3 import NetworkFabricsListResult
 from ._models_py3 import NetworkInterface
 from ._models_py3 import NetworkInterfacePatch
 from ._models_py3 import NetworkInterfacePatchProperties
 from ._models_py3 import NetworkInterfaceProperties
 from ._models_py3 import NetworkInterfacesList
-from ._models_py3 import NetworkPacketBroker
-from ._models_py3 import NetworkPacketBrokerPatch
-from ._models_py3 import NetworkPacketBrokersListResult
 from ._models_py3 import NetworkRack
+from ._models_py3 import NetworkRackPatch
 from ._models_py3 import NetworkRackProperties
+from ._models_py3 import NetworkRackSku
+from ._models_py3 import NetworkRackSkusListResult
 from ._models_py3 import NetworkRacksListResult
-from ._models_py3 import NetworkTap
-from ._models_py3 import NetworkTapPatch
-from ._models_py3 import NetworkTapPatchableParameters
-from ._models_py3 import NetworkTapPatchableParametersDestinationsItem
-from ._models_py3 import NetworkTapProperties
-from ._models_py3 import NetworkTapPropertiesDestinationsItem
-from ._models_py3 import NetworkTapRule
-from ._models_py3 import NetworkTapRuleAction
-from ._models_py3 import NetworkTapRuleMatchCondition
-from ._models_py3 import NetworkTapRuleMatchConfiguration
-from ._models_py3 import NetworkTapRulePatch
-from ._models_py3 import NetworkTapRulePatchProperties
-from ._models_py3 import NetworkTapRulePatchableProperties
-from ._models_py3 import NetworkTapRuleProperties
-from ._models_py3 import NetworkTapRulesListResult
-from ._models_py3 import NetworkTapsListResult
 from ._models_py3 import NetworkToNetworkInterconnect
-from ._models_py3 import NetworkToNetworkInterconnectPatch
-from ._models_py3 import NetworkToNetworkInterconnectPropertiesOptionBLayer3Configuration
 from ._models_py3 import NetworkToNetworkInterconnectsList
-from ._models_py3 import NpbStaticRouteConfiguration
 from ._models_py3 import Operation
 from ._models_py3 import OperationDisplay
 from ._models_py3 import OperationListResult
 from ._models_py3 import OptionAProperties
-from ._models_py3 import OptionBLayer3Configuration
 from ._models_py3 import OptionBProperties
-from ._models_py3 import PortCondition
-from ._models_py3 import PortGroupProperties
+from ._models_py3 import OptionBPropertiesAutoGenerated
 from ._models_py3 import ProxyResource
-from ._models_py3 import RebootProperties
 from ._models_py3 import Resource
 from ._models_py3 import RoutePoliciesListResult
 from ._models_py3 import RoutePolicy
 from ._models_py3 import RoutePolicyPatch
-from ._models_py3 import RoutePolicyPatchableProperties
 from ._models_py3 import RoutePolicyProperties
 from ._models_py3 import RoutePolicyStatementProperties
-from ._models_py3 import RouteTargetInformation
-from ._models_py3 import RuleProperties
 from ._models_py3 import StatementActionProperties
 from ._models_py3 import StatementConditionProperties
 from ._models_py3 import StaticRouteConfiguration
 from ._models_py3 import StaticRouteProperties
+from ._models_py3 import SupportPackageProperties
 from ._models_py3 import SupportedConnectorProperties
 from ._models_py3 import SupportedVersionProperties
 from ._models_py3 import SystemData
-from ._models_py3 import TagsUpdate
 from ._models_py3 import TerminalServerConfiguration
+from ._models_py3 import TerminalServerPatchParameters
 from ._models_py3 import TerminalServerPatchableProperties
 from ._models_py3 import TrackedResource
 from ._models_py3 import UpdateAdministrativeState
-from ._models_py3 import UpdateDeviceAdministrativeState
-from ._models_py3 import UpdateVersion
-from ._models_py3 import ValidateConfigurationProperties
-from ._models_py3 import ValidateConfigurationResponse
-from ._models_py3 import VlanGroupProperties
-from ._models_py3 import VlanMatchCondition
-from ._models_py3 import VpnConfigurationPatchableProperties
-from ._models_py3 import VpnConfigurationPatchablePropertiesOptionAProperties
+from ._models_py3 import UpdatePowerCycleProperties
+from ._models_py3 import UpdateVersionProperties
 from ._models_py3 import VpnConfigurationProperties
-from ._models_py3 import VpnConfigurationPropertiesOptionAProperties
+from ._models_py3 import WorkloadServices
 
-from ._managed_network_fabric_mgmt_client_enums import AclActionType
-from ._managed_network_fabric_mgmt_client_enums import Action
 from ._managed_network_fabric_mgmt_client_enums import ActionType
-from ._managed_network_fabric_mgmt_client_enums import AddressFamilyType
+from ._managed_network_fabric_mgmt_client_enums import AddressFamily
 from ._managed_network_fabric_mgmt_client_enums import AdministrativeState
 from ._managed_network_fabric_mgmt_client_enums import AllowASOverride
-from ._managed_network_fabric_mgmt_client_enums import BfdAdministrativeState
 from ._managed_network_fabric_mgmt_client_enums import BooleanEnumProperty
 from ._managed_network_fabric_mgmt_client_enums import CommunityActionTypes
 from ._managed_network_fabric_mgmt_client_enums import Condition
-from ._managed_network_fabric_mgmt_client_enums import ConfigurationState
-from ._managed_network_fabric_mgmt_client_enums import ConfigurationType
+from ._managed_network_fabric_mgmt_client_enums import ConditionActionType
 from ._managed_network_fabric_mgmt_client_enums import CreatedByType
-from ._managed_network_fabric_mgmt_client_enums import DestinationType
-from ._managed_network_fabric_mgmt_client_enums import DeviceAdministrativeState
-from ._managed_network_fabric_mgmt_client_enums import EnableDisableState
-from ._managed_network_fabric_mgmt_client_enums import Encapsulation
-from ._managed_network_fabric_mgmt_client_enums import EncapsulationType
-from ._managed_network_fabric_mgmt_client_enums import Extension
-from ._managed_network_fabric_mgmt_client_enums import FabricSkuType
-from ._managed_network_fabric_mgmt_client_enums import GatewayType
-from ._managed_network_fabric_mgmt_client_enums import IPAddressType
+from ._managed_network_fabric_mgmt_client_enums import EnabledDisabledState
+from ._managed_network_fabric_mgmt_client_enums import ExpressRouteConnectionState
+from ._managed_network_fabric_mgmt_client_enums import FailedSucceededState
 from ._managed_network_fabric_mgmt_client_enums import InterfaceType
-from ._managed_network_fabric_mgmt_client_enums import IsManagementType
-from ._managed_network_fabric_mgmt_client_enums import IsMonitoringEnabled
-from ._managed_network_fabric_mgmt_client_enums import IsWorkloadManagementNetworkEnabled
-from ._managed_network_fabric_mgmt_client_enums import Layer4Protocol
-from ._managed_network_fabric_mgmt_client_enums import NetworkDeviceRole
+from ._managed_network_fabric_mgmt_client_enums import IsCurrentVersion
+from ._managed_network_fabric_mgmt_client_enums import IsTestVersion
+from ._managed_network_fabric_mgmt_client_enums import NetworkDeviceRackRoleType
 from ._managed_network_fabric_mgmt_client_enums import NetworkDeviceRoleName
-from ._managed_network_fabric_mgmt_client_enums import NetworkRackType
-from ._managed_network_fabric_mgmt_client_enums import NfcSku
+from ._managed_network_fabric_mgmt_client_enums import NetworkDeviceRoleTypes
+from ._managed_network_fabric_mgmt_client_enums import NetworkFabricControllerOperationalState
+from ._managed_network_fabric_mgmt_client_enums import NetworkFabricOperationalState
+from ._managed_network_fabric_mgmt_client_enums import NetworkRackRoleName
 from ._managed_network_fabric_mgmt_client_enums import NniType
+from ._managed_network_fabric_mgmt_client_enums import OperationalState
+from ._managed_network_fabric_mgmt_client_enums import OperationalStatus
 from ._managed_network_fabric_mgmt_client_enums import Origin
 from ._managed_network_fabric_mgmt_client_enums import PeeringOption
-from ._managed_network_fabric_mgmt_client_enums import PollingIntervalInSeconds
-from ._managed_network_fabric_mgmt_client_enums import PollingType
-from ._managed_network_fabric_mgmt_client_enums import PortType
-from ._managed_network_fabric_mgmt_client_enums import PrefixType
+from ._managed_network_fabric_mgmt_client_enums import PowerCycleState
+from ._managed_network_fabric_mgmt_client_enums import PowerEnd
 from ._managed_network_fabric_mgmt_client_enums import ProvisioningState
-from ._managed_network_fabric_mgmt_client_enums import RebootType
+from ._managed_network_fabric_mgmt_client_enums import ReachabilityState
 from ._managed_network_fabric_mgmt_client_enums import RedistributeConnectedSubnets
 from ._managed_network_fabric_mgmt_client_enums import RedistributeStaticRoutes
-from ._managed_network_fabric_mgmt_client_enums import RoutePolicyActionType
-from ._managed_network_fabric_mgmt_client_enums import RoutePolicyConditionType
-from ._managed_network_fabric_mgmt_client_enums import SourceDestinationType
-from ._managed_network_fabric_mgmt_client_enums import TapRuleActionType
-from ._managed_network_fabric_mgmt_client_enums import ValidateAction
+from ._managed_network_fabric_mgmt_client_enums import State
+from ._managed_network_fabric_mgmt_client_enums import TerminalServerConnectivityState
 from ._managed_network_fabric_mgmt_client_enums import WellKnownCommunities
 from ._patch import __all__ as _patch_all
 from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
+    "ARPProperties",
     "AccessControlList",
-    "AccessControlListAction",
-    "AccessControlListMatchCondition",
-    "AccessControlListMatchConfiguration",
+    "AccessControlListConditionProperties",
     "AccessControlListPatch",
     "AccessControlListPatchProperties",
-    "AccessControlListPatchableProperties",
-    "AccessControlListPortCondition",
     "AccessControlListProperties",
     "AccessControlListsListResult",
     "ActionIpCommunityProperties",
     "ActionIpExtendedCommunityProperties",
     "AggregateRoute",
     "AggregateRouteConfiguration",
     "AnnotationResource",
     "BfdConfiguration",
     "BgpConfiguration",
-    "CommonDynamicMatchConfiguration",
-    "CommonMatchConditions",
-    "CommonPostActionResponseForDeviceUpdate",
-    "CommonPostActionResponseForStateUpdate",
     "ConnectedSubnet",
-    "ConnectedSubnetRoutePolicy",
-    "ControllerServices",
-    "DestinationProperties",
     "DeviceInterfaceProperties",
+    "DeviceLimits",
     "EnableDisableOnResources",
     "ErrorAdditionalInfo",
     "ErrorDetail",
     "ErrorResponse",
-    "ExportRoutePolicy",
-    "ExportRoutePolicyInformation",
     "ExpressRouteConnectionInformation",
+    "ExpressRouteStatusDef",
     "ExtendedLocation",
-    "ExtensionEnumProperty",
     "ExternalNetwork",
     "ExternalNetworkPatch",
     "ExternalNetworkPatchProperties",
-    "ExternalNetworkPatchPropertiesOptionAProperties",
     "ExternalNetworkPatchableProperties",
     "ExternalNetworkProperties",
     "ExternalNetworkPropertiesOptionAProperties",
     "ExternalNetworksList",
-    "ImportRoutePolicy",
-    "ImportRoutePolicyInformation",
+    "FabricBfdConfiguration",
+    "GetDeviceStatusProperties",
+    "GetDynamicInterfaceMapsPropertiesItem",
+    "GetStaticInterfaceMapsPropertiesItem",
+    "InfrastructureServices",
+    "InterfaceStatus",
     "InternalNetwork",
     "InternalNetworkPatch",
     "InternalNetworkPatchProperties",
     "InternalNetworkPatchableProperties",
     "InternalNetworkProperties",
-    "InternalNetworkPropertiesBgpConfiguration",
-    "InternalNetworkPropertiesStaticRouteConfiguration",
     "InternalNetworksList",
-    "InternetGateway",
-    "InternetGatewayPatch",
-    "InternetGatewayPatchableProperties",
-    "InternetGatewayProperties",
-    "InternetGatewayRule",
-    "InternetGatewayRulePatch",
-    "InternetGatewayRuleProperties",
-    "InternetGatewayRulesListResult",
-    "InternetGatewaysListResult",
     "IpCommunitiesListResult",
     "IpCommunity",
     "IpCommunityAddOperationProperties",
     "IpCommunityDeleteOperationProperties",
     "IpCommunityIdList",
     "IpCommunityPatch",
-    "IpCommunityPatchableProperties",
     "IpCommunityProperties",
-    "IpCommunityRule",
     "IpCommunitySetOperationProperties",
     "IpExtendedCommunity",
     "IpExtendedCommunityAddOperationProperties",
     "IpExtendedCommunityDeleteOperationProperties",
     "IpExtendedCommunityIdList",
     "IpExtendedCommunityListResult",
     "IpExtendedCommunityPatch",
-    "IpExtendedCommunityPatchProperties",
-    "IpExtendedCommunityPatchableProperties",
     "IpExtendedCommunityProperties",
-    "IpExtendedCommunityRule",
     "IpExtendedCommunitySetOperationProperties",
-    "IpGroupProperties",
-    "IpMatchCondition",
     "IpPrefix",
     "IpPrefixPatch",
-    "IpPrefixPatchProperties",
-    "IpPrefixPatchableProperties",
     "IpPrefixProperties",
-    "IpPrefixRule",
+    "IpPrefixPropertiesIpPrefixRulesItem",
     "IpPrefixesListResult",
-    "IsolationDomainProperties",
     "L2IsolationDomain",
     "L2IsolationDomainPatch",
     "L2IsolationDomainPatchProperties",
     "L2IsolationDomainProperties",
     "L2IsolationDomainsListResult",
-    "L3ExportRoutePolicy",
     "L3IsolationDomain",
     "L3IsolationDomainPatch",
     "L3IsolationDomainPatchProperties",
-    "L3IsolationDomainPatchableProperties",
+    "L3IsolationDomainPatchPropertiesConnectedSubnetRoutePolicy",
     "L3IsolationDomainProperties",
     "L3IsolationDomainsListResult",
-    "L3OptionAProperties",
-    "L3OptionBProperties",
     "Layer2Configuration",
+    "Layer3Configuration",
     "Layer3IpPrefixProperties",
+    "Layer3OptionAProperties",
     "ManagedResourceGroupConfiguration",
-    "ManagementNetworkConfigurationPatchableProperties",
-    "ManagementNetworkConfigurationProperties",
+    "ManagementNetworkConfiguration",
     "NeighborAddress",
-    "NeighborGroup",
-    "NeighborGroupDestination",
-    "NeighborGroupPatch",
-    "NeighborGroupPatchProperties",
-    "NeighborGroupPatchableProperties",
-    "NeighborGroupProperties",
-    "NeighborGroupsListResult",
     "NetworkDevice",
     "NetworkDevicePatchParameters",
     "NetworkDevicePatchParametersProperties",
     "NetworkDevicePatchableProperties",
     "NetworkDeviceProperties",
+    "NetworkDeviceRoleProperties",
     "NetworkDeviceSku",
     "NetworkDeviceSkusListResult",
     "NetworkDevicesListResult",
     "NetworkFabric",
     "NetworkFabricController",
     "NetworkFabricControllerPatch",
     "NetworkFabricControllerPatchableProperties",
     "NetworkFabricControllerProperties",
     "NetworkFabricControllersListResult",
-    "NetworkFabricPatch",
-    "NetworkFabricPatchProperties",
+    "NetworkFabricPatchParameters",
+    "NetworkFabricPatchParametersProperties",
     "NetworkFabricPatchableProperties",
-    "NetworkFabricPatchablePropertiesTerminalServerConfiguration",
     "NetworkFabricProperties",
     "NetworkFabricSku",
     "NetworkFabricSkusListResult",
     "NetworkFabricsListResult",
     "NetworkInterface",
     "NetworkInterfacePatch",
     "NetworkInterfacePatchProperties",
     "NetworkInterfaceProperties",
     "NetworkInterfacesList",
-    "NetworkPacketBroker",
-    "NetworkPacketBrokerPatch",
-    "NetworkPacketBrokersListResult",
     "NetworkRack",
+    "NetworkRackPatch",
     "NetworkRackProperties",
+    "NetworkRackSku",
+    "NetworkRackSkusListResult",
     "NetworkRacksListResult",
-    "NetworkTap",
-    "NetworkTapPatch",
-    "NetworkTapPatchableParameters",
-    "NetworkTapPatchableParametersDestinationsItem",
-    "NetworkTapProperties",
-    "NetworkTapPropertiesDestinationsItem",
-    "NetworkTapRule",
-    "NetworkTapRuleAction",
-    "NetworkTapRuleMatchCondition",
-    "NetworkTapRuleMatchConfiguration",
-    "NetworkTapRulePatch",
-    "NetworkTapRulePatchProperties",
-    "NetworkTapRulePatchableProperties",
-    "NetworkTapRuleProperties",
-    "NetworkTapRulesListResult",
-    "NetworkTapsListResult",
     "NetworkToNetworkInterconnect",
-    "NetworkToNetworkInterconnectPatch",
-    "NetworkToNetworkInterconnectPropertiesOptionBLayer3Configuration",
     "NetworkToNetworkInterconnectsList",
-    "NpbStaticRouteConfiguration",
     "Operation",
     "OperationDisplay",
     "OperationListResult",
     "OptionAProperties",
-    "OptionBLayer3Configuration",
     "OptionBProperties",
-    "PortCondition",
-    "PortGroupProperties",
+    "OptionBPropertiesAutoGenerated",
     "ProxyResource",
-    "RebootProperties",
     "Resource",
     "RoutePoliciesListResult",
     "RoutePolicy",
     "RoutePolicyPatch",
-    "RoutePolicyPatchableProperties",
     "RoutePolicyProperties",
     "RoutePolicyStatementProperties",
-    "RouteTargetInformation",
-    "RuleProperties",
     "StatementActionProperties",
     "StatementConditionProperties",
     "StaticRouteConfiguration",
     "StaticRouteProperties",
+    "SupportPackageProperties",
     "SupportedConnectorProperties",
     "SupportedVersionProperties",
     "SystemData",
-    "TagsUpdate",
     "TerminalServerConfiguration",
+    "TerminalServerPatchParameters",
     "TerminalServerPatchableProperties",
     "TrackedResource",
     "UpdateAdministrativeState",
-    "UpdateDeviceAdministrativeState",
-    "UpdateVersion",
-    "ValidateConfigurationProperties",
-    "ValidateConfigurationResponse",
-    "VlanGroupProperties",
-    "VlanMatchCondition",
-    "VpnConfigurationPatchableProperties",
-    "VpnConfigurationPatchablePropertiesOptionAProperties",
+    "UpdatePowerCycleProperties",
+    "UpdateVersionProperties",
     "VpnConfigurationProperties",
-    "VpnConfigurationPropertiesOptionAProperties",
-    "AclActionType",
-    "Action",
+    "WorkloadServices",
     "ActionType",
-    "AddressFamilyType",
+    "AddressFamily",
     "AdministrativeState",
     "AllowASOverride",
-    "BfdAdministrativeState",
     "BooleanEnumProperty",
     "CommunityActionTypes",
     "Condition",
-    "ConfigurationState",
-    "ConfigurationType",
+    "ConditionActionType",
     "CreatedByType",
-    "DestinationType",
-    "DeviceAdministrativeState",
-    "EnableDisableState",
-    "Encapsulation",
-    "EncapsulationType",
-    "Extension",
-    "FabricSkuType",
-    "GatewayType",
-    "IPAddressType",
+    "EnabledDisabledState",
+    "ExpressRouteConnectionState",
+    "FailedSucceededState",
     "InterfaceType",
-    "IsManagementType",
-    "IsMonitoringEnabled",
-    "IsWorkloadManagementNetworkEnabled",
-    "Layer4Protocol",
-    "NetworkDeviceRole",
+    "IsCurrentVersion",
+    "IsTestVersion",
+    "NetworkDeviceRackRoleType",
     "NetworkDeviceRoleName",
-    "NetworkRackType",
-    "NfcSku",
+    "NetworkDeviceRoleTypes",
+    "NetworkFabricControllerOperationalState",
+    "NetworkFabricOperationalState",
+    "NetworkRackRoleName",
     "NniType",
+    "OperationalState",
+    "OperationalStatus",
     "Origin",
     "PeeringOption",
-    "PollingIntervalInSeconds",
-    "PollingType",
-    "PortType",
-    "PrefixType",
+    "PowerCycleState",
+    "PowerEnd",
     "ProvisioningState",
-    "RebootType",
+    "ReachabilityState",
     "RedistributeConnectedSubnets",
     "RedistributeStaticRoutes",
-    "RoutePolicyActionType",
-    "RoutePolicyConditionType",
-    "SourceDestinationType",
-    "TapRuleActionType",
-    "ValidateAction",
+    "State",
+    "TerminalServerConnectivityState",
     "WellKnownCommunities",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/models/_managed_network_fabric_mgmt_client_enums.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/models/_managed_network_fabric_mgmt_client_enums.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,67 +6,41 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from enum import Enum
 from azure.core import CaseInsensitiveEnumMeta
 
 
-class AclActionType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Type of actions that can be performed."""
-
-    DROP = "Drop"
-    COUNT = "Count"
-    LOG = "Log"
-
-
-class Action(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Specify action."""
-
-    ALLOW = "Allow"
-    DENY = "Deny"
-
-
 class ActionType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Enum. Indicates the action type. "Internal" refers to actions that are for internal only APIs."""
 
     INTERNAL = "Internal"
 
 
-class AddressFamilyType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """AddressFamilyType. This parameter decides whether the given ipv4 or ipv6 route policy."""
+class AddressFamily(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """IP address family. Example: ipv4 | ipv6."""
 
-    I_PV4 = "IPv4"
-    I_PV6 = "IPv6"
+    IPV4 = "ipv4"
+    IPV6 = "ipv6"
 
 
 class AdministrativeState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """State defined to represent administrative actions or post actions on a particular resource."""
+    """Administrative state."""
 
-    ENABLED = "Enabled"
-    DISABLED = "Disabled"
-    MAT = "MAT"
-    RMA = "RMA"
+    ENABLE = "Enable"
+    DISABLE = "Disable"
 
 
 class AllowASOverride(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Enable Or Disable state."""
 
     ENABLE = "Enable"
     DISABLE = "Disable"
 
 
-class BfdAdministrativeState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Administrative state of the BfdConfiguration. Example: Enabled | Disabled."""
-
-    ENABLED = "Enabled"
-    DISABLED = "Disabled"
-    MAT = "MAT"
-    RMA = "RMA"
-
-
 class BooleanEnumProperty(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Boolean Enum. Example- True/False."""
 
     TRUE = "True"
     FALSE = "False"
 
 
@@ -79,194 +53,155 @@
 
 class Condition(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Specify prefix-list bounds."""
 
     EQUAL_TO = "EqualTo"
     GREATER_THAN_OR_EQUAL_TO = "GreaterThanOrEqualTo"
     LESSER_THAN_OR_EQUAL_TO = "LesserThanOrEqualTo"
-    RANGE = "Range"
-
-
-class ConfigurationState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Configuration state for the resource."""
-
-    SUCCEEDED = "Succeeded"
-    FAILED = "Failed"
-    REJECTED = "Rejected"
-    ACCEPTED = "Accepted"
-    PROVISIONED = "Provisioned"
-    ERROR_PROVISIONING = "ErrorProvisioning"
-    DEPROVISIONING = "Deprovisioning"
-    DEPROVISIONED = "Deprovisioned"
-    ERROR_DEPROVISIONING = "ErrorDeprovisioning"
-    DEFERRED_CONTROL = "DeferredControl"
 
 
-class ConfigurationType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Input method to configure Access Control List."""
+class ConditionActionType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """action. Example: allow | deny."""
 
-    FILE = "File"
-    INLINE = "Inline"
+    ALLOW = "allow"
+    DENY = "deny"
 
 
 class CreatedByType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The type of identity that created the resource."""
 
     USER = "User"
     APPLICATION = "Application"
     MANAGED_IDENTITY = "ManagedIdentity"
     KEY = "Key"
 
 
-class DestinationType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Type of destination. Input can be IsolationDomain or Direct."""
+class EnabledDisabledState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """EnabledDisabledState state for the resource."""
 
-    ISOLATION_DOMAIN = "IsolationDomain"
-    DIRECT = "Direct"
-
-
-class DeviceAdministrativeState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Administrative state."""
-
-    RMA = "RMA"
-    RESYNC = "Resync"
-    GRACEFUL_QUARANTINE = "GracefulQuarantine"
-    QUARANTINE = "Quarantine"
-
-
-class EnableDisableState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Administrative state."""
-
-    ENABLE = "Enable"
-    DISABLE = "Disable"
-
-
-class Encapsulation(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Type of encapsulation."""
-
-    NONE = "None"
-    GRE = "GRE"
-
-
-class EncapsulationType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Encapsulation Type."""
-
-    NONE = "None"
-    GT_PV1 = "GTPv1"
-
-
-class Extension(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Extension. Example: NoExtension | NPB."""
-
-    NO_EXTENSION = "NoExtension"
-    NPB = "NPB"
+    ENABLED = "Enabled"
+    DISABLED = "Disabled"
 
 
-class FabricSkuType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Type of Network Fabric SKU."""
+class ExpressRouteConnectionState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """Express route connection state for the resource."""
 
-    SINGLE_RACK = "SingleRack"
-    MULTI_RACK = "MultiRack"
+    CONNECTING = "Connecting"
+    CONNECTED = "Connected"
+    DISCONNECTED = "Disconnected"
 
 
-class GatewayType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Gateway Type of the resource."""
+class FailedSucceededState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """FailedSucceeded state for the resource."""
 
-    INFRASTRUCTURE = "Infrastructure"
-    WORKLOAD = "Workload"
+    SUCCEEDED = "Succeeded"
+    FAILED = "Failed"
 
 
 class InterfaceType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The Interface Type. Example: Management/Data."""
 
     MANAGEMENT = "Management"
     DATA = "Data"
 
 
-class IPAddressType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """IP Address type."""
+class IsCurrentVersion(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """If the current version is in use."""
 
-    I_PV4 = "IPv4"
-    I_PV6 = "IPv6"
+    TRUE = "true"
+    FALSE = "false"
 
 
-class IsManagementType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Configuration to use NNI for Infrastructure Management. Example: True/False."""
+class IsTestVersion(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """If the current version is a test version."""
 
-    TRUE = "True"
-    FALSE = "False"
+    TRUE = "true"
+    FALSE = "false"
 
 
-class IsMonitoringEnabled(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """To check whether monitoring of internal network is enabled or not."""
+class NetworkDeviceRackRoleType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """Role for the network device."""
 
-    TRUE = "True"
-    FALSE = "False"
-
-
-class IsWorkloadManagementNetworkEnabled(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """A workload management network is required for all the tenant (workload) traffic. This traffic
-    is only dedicated for Tenant workloads which are required to access internet or any other
-    MSFT/Public endpoints.
-    """
-
-    TRUE = "True"
-    FALSE = "False"
-
-
-class Layer4Protocol(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Layer4 protocol type that needs to be matched."""
-
-    TCP = "TCP"
-    UDP = "UDP"
+    CE = "CE"
+    TO_R = "ToR"
+    NPB = "NPB"
+    TS = "TS"
+    MANAGEMENT = "Management"
 
 
-class NetworkDeviceRole(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """NetworkDeviceRole is the device role: Example: CE | ToR."""
+class NetworkDeviceRoleName(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """Available roles for the network device."""
 
     CE = "CE"
     TO_R = "ToR"
     NPB = "NPB"
     TS = "TS"
     MANAGEMENT = "Management"
 
 
-class NetworkDeviceRoleName(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+class NetworkDeviceRoleTypes(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Available roles for the network device."""
 
     CE = "CE"
     TO_R = "ToR"
     NPB = "NPB"
     TS = "TS"
     MANAGEMENT = "Management"
 
 
-class NetworkRackType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Network Rack SKU name."""
+class NetworkFabricControllerOperationalState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """Operational state for the resource."""
+
+    CONFIGURING = "Configuring"
+    SUCCEEDED = "Succeeded"
+    FAILED = "Failed"
+
+
+class NetworkFabricOperationalState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """Operational state for the resource."""
 
-    AGGREGATE = "Aggregate"
-    COMPUTE = "Compute"
-    COMBINED = "Combined"
+    PROVISIONING = "Provisioning"
+    PROVISIONED = "Provisioned"
+    ERROR_PROVISIONING = "ErrorProvisioning"
+    DEPROVISIONING = "Deprovisioning"
+    DEPROVISIONED = "Deprovisioned"
+    ERROR_DEPROVISIONING = "ErrorDeprovisioning"
+    DEFERRED_CONTROL = "DeferredControl"
 
 
-class NfcSku(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Network Fabric Controller SKU."""
+class NetworkRackRoleName(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """The role of the Network Rack: Aggregate or Compute."""
 
-    BASIC = "Basic"
-    STANDARD = "Standard"
-    HIGH_PERFORMANCE = "HighPerformance"
+    COMPUTE_RACK = "ComputeRack"
+    AGGREGATE_RACK = "AggregateRack"
 
 
 class NniType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Type of NNI used. Example: CE | NPB."""
 
     CE = "CE"
     NPB = "NPB"
 
 
+class OperationalState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """Operational state for the resource."""
+
+    CONFIGURING = "Configuring"
+    SUCCEEDED = "Succeeded"
+    FAILED = "Failed"
+
+
+class OperationalStatus(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """Primary or Secondary power end."""
+
+    BOOTED = "Booted"
+    BOOT_PROMPT = "BootPrompt"
+    ZTP = "Ztp"
+
+
 class Origin(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The intended executor of the operation; as in Resource Based Access Control (RBAC) and audit
     logs UX. Default value is "user,system".
     """
 
     USER = "user"
     SYSTEM = "system"
@@ -276,62 +211,43 @@
 class PeeringOption(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Peering option list."""
 
     OPTION_A = "OptionA"
     OPTION_B = "OptionB"
 
 
-class PollingIntervalInSeconds(int, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Polling interval in seconds."""
-
-    THIRTY = 30
-    SIXTY = 60
-    NINETY = 90
-    ONE_HUNDRED_TWENTY = 120
-
-
-class PollingType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Polling type."""
-
-    PULL = "Pull"
-    PUSH = "Push"
-
-
-class PortType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Port type that needs to be matched."""
+class PowerCycleState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """On or Off power cycle state."""
 
-    SOURCE_PORT = "SourcePort"
-    DESTINATION_PORT = "DestinationPort"
+    ON = "On"
+    OFF = "Off"
 
 
-class PrefixType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """IP Prefix Type."""
+class PowerEnd(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """Primary or Secondary power end."""
 
-    PREFIX = "Prefix"
-    LONGEST_PREFIX = "LongestPrefix"
+    PRIMARY = "Primary"
+    SECONDARY = "Secondary"
 
 
 class ProvisioningState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The current provisioning state."""
 
-    ACCEPTED = "Accepted"
     SUCCEEDED = "Succeeded"
     UPDATING = "Updating"
+    CANCELED = "Canceled"
     DELETING = "Deleting"
     FAILED = "Failed"
-    CANCELED = "Canceled"
 
 
-class RebootType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Type of reboot to be performed. Example: GracefulRebootWithZTP."""
+class ReachabilityState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """Generic network reachability state."""
 
-    GRACEFUL_REBOOT_WITH_ZTP = "GracefulRebootWithZTP"
-    GRACEFUL_REBOOT_WITHOUT_ZTP = "GracefulRebootWithoutZTP"
-    UNGRACEFUL_REBOOT_WITH_ZTP = "UngracefulRebootWithZTP"
-    UNGRACEFUL_REBOOT_WITHOUT_ZTP = "UngracefulRebootWithoutZTP"
+    REACHABLE = "Reachable"
+    UNREACHABLE = "Unreachable"
 
 
 class RedistributeConnectedSubnets(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Advertise Connected Subnets. Ex: "True" | "False"."""
 
     TRUE = "True"
     FALSE = "False"
@@ -340,57 +256,26 @@
 class RedistributeStaticRoutes(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """Advertise Static Routes. Ex: "True" | "False"."""
 
     TRUE = "True"
     FALSE = "False"
 
 
-class RoutePolicyActionType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Action type. Example: Permit | Deny | Continue."""
-
-    PERMIT = "Permit"
-    DENY = "Deny"
-    CONTINUE = "Continue"
-    CONTINUE_ENUM = "Continue"
-
-
-class RoutePolicyConditionType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Type of the condition used."""
-
-    OR = "Or"
-    AND = "And"
-    OR_ENUM = "Or"
-    AND_ENUM = "And"
-
-
-class SourceDestinationType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """IP Address type."""
-
-    SOURCE_IP = "SourceIP"
-    DESTINATION_IP = "DestinationIP"
-
-
-class TapRuleActionType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Type of actions that can be performed."""
+class State(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """On or Off toggle state."""
 
-    DROP = "Drop"
-    COUNT = "Count"
-    LOG = "Log"
-    REPLICATE = "Replicate"
-    GOTO = "Goto"
-    REDIRECT = "Redirect"
-    MIRROR = "Mirror"
+    ON = "On"
+    OFF = "Off"
 
 
-class ValidateAction(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Validate action that to be performed."""
+class TerminalServerConnectivityState(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """TerminalServerConnectivity state for the resource."""
 
-    CABLING = "Cabling"
-    CONFIGURATION = "Configuration"
-    CONNECTIVITY = "Connectivity"
+    IPV4_REACHABLE = "Ipv4Reachable"
+    IPV4_UNREACHABLE = "Ipv4Unreachable"
 
 
 class WellKnownCommunities(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """``Internet`` - Advertise routes to internet community.
      ``LocalAS`` - Advertise routes to only localAS peers.
      ``NoAdvertise`` - Don't advertise routes to any peer.
     ``NoExport`` - Don't export to next AS.
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/models/_patch.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/_configuration.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -6,41 +6,41 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
+from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
-from .._version import VERSION
+from ._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.credentials import TokenCredential
 
 
 class ManagedNetworkFabricMgmtClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for ManagedNetworkFabricMgmtClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
-    :param subscription_id: The ID of the target subscription. The value must be an UUID. Required.
+    :type credential: ~azure.core.credentials.TokenCredential
+    :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2023-06-15". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2023-02-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(ManagedNetworkFabricMgmtClientConfiguration, self).__init__(**kwargs)
-        api_version: str = kwargs.pop("api_version", "2023-06-15")
+        api_version: str = kwargs.pop("api_version", "2023-02-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -52,15 +52,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
+            self.authentication_policy = ARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/__init__.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/_patch.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/_managed_network_fabric_mgmt_client.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/_managed_network_fabric_mgmt_client.py`

 * *Files 18% similar despite different names*

```diff
@@ -15,32 +15,27 @@
 from .. import models as _models
 from .._serialization import Deserializer, Serializer
 from ._configuration import ManagedNetworkFabricMgmtClientConfiguration
 from .operations import (
     AccessControlListsOperations,
     ExternalNetworksOperations,
     InternalNetworksOperations,
-    InternetGatewayRulesOperations,
-    InternetGatewaysOperations,
     IpCommunitiesOperations,
     IpExtendedCommunitiesOperations,
     IpPrefixesOperations,
     L2IsolationDomainsOperations,
     L3IsolationDomainsOperations,
-    NeighborGroupsOperations,
     NetworkDeviceSkusOperations,
     NetworkDevicesOperations,
     NetworkFabricControllersOperations,
     NetworkFabricSkusOperations,
     NetworkFabricsOperations,
     NetworkInterfacesOperations,
-    NetworkPacketBrokersOperations,
+    NetworkRackSkusOperations,
     NetworkRacksOperations,
-    NetworkTapRulesOperations,
-    NetworkTapsOperations,
     NetworkToNetworkInterconnectsOperations,
     Operations,
     RoutePoliciesOperations,
 )
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
@@ -49,20 +44,14 @@
 
 class ManagedNetworkFabricMgmtClient:  # pylint: disable=client-accepts-api-version-keyword,too-many-instance-attributes
     """Self service experience for Azure Network Fabric API.
 
     :ivar access_control_lists: AccessControlListsOperations operations
     :vartype access_control_lists:
      azure.mgmt.managednetworkfabric.aio.operations.AccessControlListsOperations
-    :ivar internet_gateways: InternetGatewaysOperations operations
-    :vartype internet_gateways:
-     azure.mgmt.managednetworkfabric.aio.operations.InternetGatewaysOperations
-    :ivar internet_gateway_rules: InternetGatewayRulesOperations operations
-    :vartype internet_gateway_rules:
-     azure.mgmt.managednetworkfabric.aio.operations.InternetGatewayRulesOperations
     :ivar ip_communities: IpCommunitiesOperations operations
     :vartype ip_communities: azure.mgmt.managednetworkfabric.aio.operations.IpCommunitiesOperations
     :ivar ip_extended_communities: IpExtendedCommunitiesOperations operations
     :vartype ip_extended_communities:
      azure.mgmt.managednetworkfabric.aio.operations.IpExtendedCommunitiesOperations
     :ivar ip_prefixes: IpPrefixesOperations operations
     :vartype ip_prefixes: azure.mgmt.managednetworkfabric.aio.operations.IpPrefixesOperations
@@ -74,17 +63,14 @@
      azure.mgmt.managednetworkfabric.aio.operations.L3IsolationDomainsOperations
     :ivar internal_networks: InternalNetworksOperations operations
     :vartype internal_networks:
      azure.mgmt.managednetworkfabric.aio.operations.InternalNetworksOperations
     :ivar external_networks: ExternalNetworksOperations operations
     :vartype external_networks:
      azure.mgmt.managednetworkfabric.aio.operations.ExternalNetworksOperations
-    :ivar neighbor_groups: NeighborGroupsOperations operations
-    :vartype neighbor_groups:
-     azure.mgmt.managednetworkfabric.aio.operations.NeighborGroupsOperations
     :ivar network_device_skus: NetworkDeviceSkusOperations operations
     :vartype network_device_skus:
      azure.mgmt.managednetworkfabric.aio.operations.NetworkDeviceSkusOperations
     :ivar network_devices: NetworkDevicesOperations operations
     :vartype network_devices:
      azure.mgmt.managednetworkfabric.aio.operations.NetworkDevicesOperations
     :ivar network_interfaces: NetworkInterfacesOperations operations
@@ -98,36 +84,31 @@
      azure.mgmt.managednetworkfabric.aio.operations.NetworkFabricSkusOperations
     :ivar network_fabrics: NetworkFabricsOperations operations
     :vartype network_fabrics:
      azure.mgmt.managednetworkfabric.aio.operations.NetworkFabricsOperations
     :ivar network_to_network_interconnects: NetworkToNetworkInterconnectsOperations operations
     :vartype network_to_network_interconnects:
      azure.mgmt.managednetworkfabric.aio.operations.NetworkToNetworkInterconnectsOperations
-    :ivar network_packet_brokers: NetworkPacketBrokersOperations operations
-    :vartype network_packet_brokers:
-     azure.mgmt.managednetworkfabric.aio.operations.NetworkPacketBrokersOperations
+    :ivar network_rack_skus: NetworkRackSkusOperations operations
+    :vartype network_rack_skus:
+     azure.mgmt.managednetworkfabric.aio.operations.NetworkRackSkusOperations
     :ivar network_racks: NetworkRacksOperations operations
     :vartype network_racks: azure.mgmt.managednetworkfabric.aio.operations.NetworkRacksOperations
-    :ivar network_tap_rules: NetworkTapRulesOperations operations
-    :vartype network_tap_rules:
-     azure.mgmt.managednetworkfabric.aio.operations.NetworkTapRulesOperations
-    :ivar network_taps: NetworkTapsOperations operations
-    :vartype network_taps: azure.mgmt.managednetworkfabric.aio.operations.NetworkTapsOperations
     :ivar operations: Operations operations
     :vartype operations: azure.mgmt.managednetworkfabric.aio.operations.Operations
     :ivar route_policies: RoutePoliciesOperations operations
     :vartype route_policies: azure.mgmt.managednetworkfabric.aio.operations.RoutePoliciesOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
-    :param subscription_id: The ID of the target subscription. The value must be an UUID. Required.
+    :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2023-06-15". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2023-02-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
         self,
@@ -144,20 +125,14 @@
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.access_control_lists = AccessControlListsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
-        self.internet_gateways = InternetGatewaysOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
-        self.internet_gateway_rules = InternetGatewayRulesOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
         self.ip_communities = IpCommunitiesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.ip_extended_communities = IpExtendedCommunitiesOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.ip_prefixes = IpPrefixesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.l2_isolation_domains = L2IsolationDomainsOperations(
             self._client, self._config, self._serialize, self._deserialize
@@ -167,15 +142,14 @@
         )
         self.internal_networks = InternalNetworksOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.external_networks = ExternalNetworksOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
-        self.neighbor_groups = NeighborGroupsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.network_device_skus = NetworkDeviceSkusOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.network_devices = NetworkDevicesOperations(self._client, self._config, self._serialize, self._deserialize)
         self.network_interfaces = NetworkInterfacesOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
@@ -185,22 +159,18 @@
         self.network_fabric_skus = NetworkFabricSkusOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.network_fabrics = NetworkFabricsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.network_to_network_interconnects = NetworkToNetworkInterconnectsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
-        self.network_packet_brokers = NetworkPacketBrokersOperations(
+        self.network_rack_skus = NetworkRackSkusOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
         self.network_racks = NetworkRacksOperations(self._client, self._config, self._serialize, self._deserialize)
-        self.network_tap_rules = NetworkTapRulesOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
-        self.network_taps = NetworkTapsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.route_policies = RoutePoliciesOperations(self._client, self._config, self._serialize, self._deserialize)
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_access_control_lists_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_fabric_controllers_operations.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,623 +3,882 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 from io import IOBase
-from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
+from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
-from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
+from azure.core.pipeline.transport import HttpResponse
+from azure.core.polling import LROPoller, NoPolling, PollingMethod
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
-from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
+from azure.mgmt.core.polling.arm_polling import ARMPolling
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._access_control_lists_operations import (
-    build_create_request,
-    build_delete_request,
-    build_get_request,
-    build_list_by_resource_group_request,
-    build_list_by_subscription_request,
-    build_resync_request,
-    build_update_administrative_state_request,
-    build_update_request,
-    build_validate_configuration_request,
-)
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request, _format_url_section
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_create_request(
+    resource_group_name: str, network_fabric_controller_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "networkFabricControllerName": _SERIALIZER.url(
+            "network_fabric_controller_name", network_fabric_controller_name, "str"
+        ),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_get_request(
+    resource_group_name: str, network_fabric_controller_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "networkFabricControllerName": _SERIALIZER.url(
+            "network_fabric_controller_name", network_fabric_controller_name, "str"
+        ),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_update_request(
+    resource_group_name: str, network_fabric_controller_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "networkFabricControllerName": _SERIALIZER.url(
+            "network_fabric_controller_name", network_fabric_controller_name, "str"
+        ),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_delete_request(
+    resource_group_name: str, network_fabric_controller_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "networkFabricControllerName": _SERIALIZER.url(
+            "network_fabric_controller_name", network_fabric_controller_name, "str"
+        ),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
-class AccessControlListsOperations:
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_enable_workload_management_network_request(
+    resource_group_name: str, network_fabric_controller_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}/enableWorkloadManagementNetwork",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "networkFabricControllerName": _SERIALIZER.url(
+            "network_fabric_controller_name", network_fabric_controller_name, "str"
+        ),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_disable_workload_management_network_request(
+    resource_group_name: str, network_fabric_controller_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}/disableWorkloadManagementNetwork",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "networkFabricControllerName": _SERIALIZER.url(
+            "network_fabric_controller_name", network_fabric_controller_name, "str"
+        ),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class NetworkFabricControllersOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.managednetworkfabric.aio.ManagedNetworkFabricMgmtClient`'s
-        :attr:`access_control_lists` attribute.
+        :class:`~azure.mgmt.managednetworkfabric.ManagedNetworkFabricMgmtClient`'s
+        :attr:`network_fabric_controllers` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    async def _create_initial(
+    def _create_initial(
         self,
         resource_group_name: str,
-        access_control_list_name: str,
-        body: Union[_models.AccessControlList, IO],
+        network_fabric_controller_name: str,
+        body: Union[_models.NetworkFabricController, IO],
         **kwargs: Any
-    ) -> _models.AccessControlList:
+    ) -> _models.NetworkFabricController:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.AccessControlList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabricController] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "AccessControlList")
+            _json = self._serialize.body(body, "NetworkFabricController")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            access_control_list_name=access_control_list_name,
+            network_fabric_controller_name=network_fabric_controller_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("AccessControlList", pipeline_response)
+            deserialized = self._deserialize("NetworkFabricController", pipeline_response)
 
         if response.status_code == 201:
-            response_headers["Azure-AsyncOperation"] = self._deserialize(
-                "str", response.headers.get("Azure-AsyncOperation")
-            )
-
-            deserialized = self._deserialize("AccessControlList", pipeline_response)
+            deserialized = self._deserialize("NetworkFabricController", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
     }
 
     @overload
-    async def begin_create(
+    def begin_create(
         self,
         resource_group_name: str,
-        access_control_list_name: str,
-        body: _models.AccessControlList,
+        network_fabric_controller_name: str,
+        body: _models.NetworkFabricController,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.AccessControlList]:
-        """Creates Access Control List.
+    ) -> LROPoller[_models.NetworkFabricController]:
+        """Create Network fabric controller.
 
-        Implements Access Control List PUT method.
+        Creates a Network Fabric Controller.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
+        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
+        :type network_fabric_controller_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.AccessControlList
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricController
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either AccessControlList or the result of
+        :return: An instance of LROPoller that returns either NetworkFabricController or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.AccessControlList]
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_create(
+    def begin_create(
         self,
         resource_group_name: str,
-        access_control_list_name: str,
+        network_fabric_controller_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.AccessControlList]:
-        """Creates Access Control List.
+    ) -> LROPoller[_models.NetworkFabricController]:
+        """Create Network fabric controller.
 
-        Implements Access Control List PUT method.
+        Creates a Network Fabric Controller.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
+        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
+        :type network_fabric_controller_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either AccessControlList or the result of
+        :return: An instance of LROPoller that returns either NetworkFabricController or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.AccessControlList]
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_create(
+    @distributed_trace
+    def begin_create(
         self,
         resource_group_name: str,
-        access_control_list_name: str,
-        body: Union[_models.AccessControlList, IO],
+        network_fabric_controller_name: str,
+        body: Union[_models.NetworkFabricController, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.AccessControlList]:
-        """Creates Access Control List.
+    ) -> LROPoller[_models.NetworkFabricController]:
+        """Create Network fabric controller.
 
-        Implements Access Control List PUT method.
+        Creates a Network Fabric Controller.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
-        :param body: Request payload. Is either a AccessControlList type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.AccessControlList or IO
+        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
+        :type network_fabric_controller_name: str
+        :param body: Request payload. Is either a NetworkFabricController type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricController or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either AccessControlList or the result of
+        :return: An instance of LROPoller that returns either NetworkFabricController or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.AccessControlList]
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.AccessControlList] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[_models.NetworkFabricController] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._create_initial(
+            raw_result = self._create_initial(
                 resource_group_name=resource_group_name,
-                access_control_list_name=access_control_list_name,
+                network_fabric_controller_name=network_fabric_controller_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("AccessControlList", pipeline_response)
+            deserialized = self._deserialize("NetworkFabricController", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
     }
 
-    @distributed_trace_async
-    async def get(
-        self, resource_group_name: str, access_control_list_name: str, **kwargs: Any
-    ) -> _models.AccessControlList:
-        """Gets a Access Control List.
+    @distributed_trace
+    def get(
+        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
+    ) -> _models.NetworkFabricController:
+        """Gets a Network Fabric Controller.
 
-        Implements Access Control List GET method.
+        Shows the provisioning status of Network Fabric Controller.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
+        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
+        :type network_fabric_controller_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessControlList or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.AccessControlList
+        :return: NetworkFabricController or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkFabricController
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.AccessControlList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabricController] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            access_control_list_name=access_control_list_name,
+            network_fabric_controller_name=network_fabric_controller_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("AccessControlList", pipeline_response)
+        deserialized = self._deserialize("NetworkFabricController", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
     }
 
-    async def _update_initial(
+    def _update_initial(
         self,
         resource_group_name: str,
-        access_control_list_name: str,
-        body: Union[_models.AccessControlListPatch, IO],
+        network_fabric_controller_name: str,
+        body: Union[_models.NetworkFabricControllerPatch, IO],
         **kwargs: Any
-    ) -> Optional[_models.AccessControlList]:
+    ) -> Optional[_models.NetworkFabricController]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.AccessControlList]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.NetworkFabricController]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "AccessControlListPatch")
+            _json = self._serialize.body(body, "NetworkFabricControllerPatch")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            access_control_list_name=access_control_list_name,
+            network_fabric_controller_name=network_fabric_controller_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("AccessControlList", pipeline_response)
+            deserialized = self._deserialize("NetworkFabricController", pipeline_response)
 
         if response.status_code == 202:
             response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
     }
 
     @overload
-    async def begin_update(
+    def begin_update(
         self,
         resource_group_name: str,
-        access_control_list_name: str,
-        body: _models.AccessControlListPatch,
+        network_fabric_controller_name: str,
+        body: _models.NetworkFabricControllerPatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.AccessControlList]:
-        """Updates the Access Control List.
+    ) -> LROPoller[_models.NetworkFabricController]:
+        """Updates a Network Fabric Controller.
 
-        API to update certain properties of the Access Control List resource.
+        Updates are currently not supported for the Network Fabric Controller resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
-        :param body: Access Control List properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.AccessControlListPatch
+        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
+        :type network_fabric_controller_name: str
+        :param body: Network Fabric Controller properties to update. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricControllerPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either AccessControlList or the result of
+        :return: An instance of LROPoller that returns either NetworkFabricController or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.AccessControlList]
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_update(
+    def begin_update(
         self,
         resource_group_name: str,
-        access_control_list_name: str,
+        network_fabric_controller_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.AccessControlList]:
-        """Updates the Access Control List.
+    ) -> LROPoller[_models.NetworkFabricController]:
+        """Updates a Network Fabric Controller.
 
-        API to update certain properties of the Access Control List resource.
+        Updates are currently not supported for the Network Fabric Controller resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
-        :param body: Access Control List properties to update. Required.
+        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
+        :type network_fabric_controller_name: str
+        :param body: Network Fabric Controller properties to update. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either AccessControlList or the result of
+        :return: An instance of LROPoller that returns either NetworkFabricController or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.AccessControlList]
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_update(
+    @distributed_trace
+    def begin_update(
         self,
         resource_group_name: str,
-        access_control_list_name: str,
-        body: Union[_models.AccessControlListPatch, IO],
+        network_fabric_controller_name: str,
+        body: Union[_models.NetworkFabricControllerPatch, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.AccessControlList]:
-        """Updates the Access Control List.
+    ) -> LROPoller[_models.NetworkFabricController]:
+        """Updates a Network Fabric Controller.
 
-        API to update certain properties of the Access Control List resource.
+        Updates are currently not supported for the Network Fabric Controller resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
-        :param body: Access Control List properties to update. Is either a AccessControlListPatch type
-         or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.AccessControlListPatch or IO
+        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
+        :type network_fabric_controller_name: str
+        :param body: Network Fabric Controller properties to update. Is either a
+         NetworkFabricControllerPatch type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricControllerPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either AccessControlList or the result of
+        :return: An instance of LROPoller that returns either NetworkFabricController or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.AccessControlList]
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.AccessControlList] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[_models.NetworkFabricController] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_initial(
+            raw_result = self._update_initial(
                 resource_group_name=resource_group_name,
-                access_control_list_name=access_control_list_name,
+                network_fabric_controller_name=network_fabric_controller_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("AccessControlList", pipeline_response)
+            deserialized = self._deserialize("NetworkFabricController", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
     }
 
-    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, access_control_list_name: str, **kwargs: Any
+    def _delete_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -629,140 +888,140 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            access_control_list_name=access_control_list_name,
+            network_fabric_controller_name=network_fabric_controller_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 202:
             response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
     }
 
-    @distributed_trace_async
-    async def begin_delete(
-        self, resource_group_name: str, access_control_list_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[None]:
-        """Deletes a Access Control List.
+    @distributed_trace
+    def begin_delete(
+        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
+    ) -> LROPoller[None]:
+        """Deletes a Network Fabric Controller.
 
-        Implements Access Control List DELETE method.
+        Deletes the Network Fabric Controller resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
+        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
+        :type network_fabric_controller_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._delete_initial(  # type: ignore
+            raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                access_control_list_name=access_control_list_name,
+                network_fabric_controller_name=network_fabric_controller_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
     }
 
     @distributed_trace
     def list_by_resource_group(
         self, resource_group_name: str, **kwargs: Any
-    ) -> AsyncIterable["_models.AccessControlList"]:
-        """List AccessControlLists by resource group.
+    ) -> Iterable["_models.NetworkFabricController"]:
+        """List NetworkFabricControllers by resource group.
 
-        Implements AccessControlLists list by resource group GET method.
+        Lists all the NetworkFabricControllers thats available in the resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessControlList or the result of cls(response)
+        :return: An iterator like instance of either NetworkFabricController or the result of
+         cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.AccessControlList]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.AccessControlListsListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabricControllersListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -796,60 +1055,61 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessControlListsListResult", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("NetworkFabricControllersListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
     list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers"
     }
 
     @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.AccessControlList"]:
-        """List AccessControlLists by subscription.
+    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.NetworkFabricController"]:
+        """List NetworkFabricControllers by subscription.
 
-        Implements AccessControlLists list by subscription GET method.
+        Lists all the NetworkFabricControllers by subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessControlList or the result of cls(response)
+        :return: An iterator like instance of either NetworkFabricController or the result of
+         cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.AccessControlList]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.AccessControlListsListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabricControllersListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -882,541 +1142,277 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessControlListsListResult", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("NetworkFabricControllersListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
     list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/accessControlLists"
-    }
-
-    async def _update_administrative_state_initial(
-        self,
-        resource_group_name: str,
-        access_control_list_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
-        **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "UpdateAdministrativeState")
-
-        request = build_update_administrative_state_request(
-            resource_group_name=resource_group_name,
-            access_control_list_name=access_control_list_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self._update_administrative_state_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
-
-    _update_administrative_state_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/updateAdministrativeState"
-    }
-
-    @overload
-    async def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        access_control_list_name: str,
-        body: _models.UpdateAdministrativeState,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Updates administrative state of Access Control Lists.
-
-        Implements the operation to the underlying resources.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
-        :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    async def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        access_control_list_name: str,
-        body: IO,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Updates administrative state of Access Control Lists.
-
-        Implements the operation to the underlying resources.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
-        :param body: Request payload. Required.
-        :type body: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @distributed_trace_async
-    async def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        access_control_list_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Updates administrative state of Access Control Lists.
-
-        Implements the operation to the underlying resources.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
-        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._update_administrative_state_initial(
-                resource_group_name=resource_group_name,
-                access_control_list_name=access_control_list_name,
-                body=body,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_update_administrative_state.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/updateAdministrativeState"
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers"
     }
 
-    async def _resync_initial(
-        self, resource_group_name: str, access_control_list_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    def _enable_workload_management_network_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_resync_request(
+        request = build_enable_workload_management_network_request(
             resource_group_name=resource_group_name,
-            access_control_list_name=access_control_list_name,
+            network_fabric_controller_name=network_fabric_controller_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._resync_initial.metadata["url"],
+            template_url=self._enable_workload_management_network_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _resync_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/resync"
+    _enable_workload_management_network_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}/enableWorkloadManagementNetwork"
     }
 
-    @distributed_trace_async
-    async def begin_resync(
-        self, resource_group_name: str, access_control_list_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Resync operation on the Access Control Lists.
+    @distributed_trace
+    def begin_enable_workload_management_network(
+        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        Implements the operation to the underlying resources.
+        Enables the workloadManagementNetwork (Tenant Network).
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
+        :param network_fabric_controller_name: Name of the networkFabricController. Required.
+        :type network_fabric_controller_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._resync_initial(
+            raw_result = self._enable_workload_management_network_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                access_control_list_name=access_control_list_name,
+                network_fabric_controller_name=network_fabric_controller_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_resync.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/resync"
+    begin_enable_workload_management_network.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}/enableWorkloadManagementNetwork"
     }
 
-    async def _validate_configuration_initial(
-        self, resource_group_name: str, access_control_list_name: str, **kwargs: Any
-    ) -> _models.ValidateConfigurationResponse:
+    def _disable_workload_management_network_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_validate_configuration_request(
+        request = build_disable_workload_management_network_request(
             resource_group_name=resource_group_name,
-            access_control_list_name=access_control_list_name,
+            network_fabric_controller_name=network_fabric_controller_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._validate_configuration_initial.metadata["url"],
+            template_url=self._disable_workload_management_network_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _validate_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/validateConfiguration"
+    _disable_workload_management_network_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}/disableWorkloadManagementNetwork"
     }
 
-    @distributed_trace_async
-    async def begin_validate_configuration(
-        self, resource_group_name: str, access_control_list_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.ValidateConfigurationResponse]:
-        """Validates the configuration of the Access Control Lists.
+    @distributed_trace
+    def begin_disable_workload_management_network(
+        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        Implements the operation to the underlying resources.
+        Disables the workloadManagementNetwork (Tenant Network).
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
+        :param network_fabric_controller_name: Name of the networkFabricController. Required.
+        :type network_fabric_controller_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._validate_configuration_initial(
+            raw_result = self._disable_workload_management_network_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                access_control_list_name=access_control_list_name,
+                network_fabric_controller_name=network_fabric_controller_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_validate_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/validateConfiguration"
+    begin_disable_workload_management_network.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}/disableWorkloadManagementNetwork"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_l3_isolation_domains_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_l2_isolation_domains_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -27,82 +27,83 @@
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._l3_isolation_domains_operations import (
-    build_commit_configuration_request,
+from ...operations._l2_isolation_domains_operations import (
+    build_clear_arp_table_request,
+    build_clear_neighbor_table_request,
     build_create_request,
     build_delete_request,
+    build_get_arp_entries_request,
     build_get_request,
     build_list_by_resource_group_request,
     build_list_by_subscription_request,
     build_update_administrative_state_request,
     build_update_request,
-    build_validate_configuration_request,
 )
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class L3IsolationDomainsOperations:
+class L2IsolationDomainsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.managednetworkfabric.aio.ManagedNetworkFabricMgmtClient`'s
-        :attr:`l3_isolation_domains` attribute.
+        :attr:`l2_isolation_domains` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     async def _create_initial(
         self,
         resource_group_name: str,
-        l3_isolation_domain_name: str,
-        body: Union[_models.L3IsolationDomain, IO],
+        l2_isolation_domain_name: str,
+        body: Union[_models.L2IsolationDomain, IO],
         **kwargs: Any
-    ) -> _models.L3IsolationDomain:
+    ) -> _models.L2IsolationDomain:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.L3IsolationDomain] = kwargs.pop("cls", None)
+        cls: ClsType[_models.L2IsolationDomain] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "L3IsolationDomain")
+            _json = self._serialize.body(body, "L2IsolationDomain")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            l3_isolation_domain_name=l3_isolation_domain_name,
+            l2_isolation_domain_name=l2_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
@@ -120,173 +121,170 @@
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
-            deserialized = self._deserialize("L3IsolationDomain", pipeline_response)
+            deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
 
         if response.status_code == 201:
-            deserialized = self._deserialize("L3IsolationDomain", pipeline_response)
+            deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
     }
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
-        l3_isolation_domain_name: str,
-        body: _models.L3IsolationDomain,
+        l2_isolation_domain_name: str,
+        body: _models.L2IsolationDomain,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.L3IsolationDomain]:
-        """Create L3 Isolation Domain.
+    ) -> AsyncLROPoller[_models.L2IsolationDomain]:
+        """Create L2 Isolation Domain.
 
-        Create isolation domain resources for layer 3 connectivity between compute nodes and for
-        communication with external services .This configuration is applied on the devices only after
-        the creation of networks is completed and isolation domain is enabled.
+        Creates layer 2 network connectivity between compute nodes within a rack and across racks.The
+        configuration is applied on the devices only after the isolation domain is enabled.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
-        :type l3_isolation_domain_name: str
+        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
+        :type l2_isolation_domain_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.L3IsolationDomain
+        :type body: ~azure.mgmt.managednetworkfabric.models.L2IsolationDomain
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either L3IsolationDomain or the result of
+        :return: An instance of AsyncLROPoller that returns either L2IsolationDomain or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
-        l3_isolation_domain_name: str,
+        l2_isolation_domain_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.L3IsolationDomain]:
-        """Create L3 Isolation Domain.
+    ) -> AsyncLROPoller[_models.L2IsolationDomain]:
+        """Create L2 Isolation Domain.
 
-        Create isolation domain resources for layer 3 connectivity between compute nodes and for
-        communication with external services .This configuration is applied on the devices only after
-        the creation of networks is completed and isolation domain is enabled.
+        Creates layer 2 network connectivity between compute nodes within a rack and across racks.The
+        configuration is applied on the devices only after the isolation domain is enabled.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
-        :type l3_isolation_domain_name: str
+        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
+        :type l2_isolation_domain_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either L3IsolationDomain or the result of
+        :return: An instance of AsyncLROPoller that returns either L2IsolationDomain or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create(
         self,
         resource_group_name: str,
-        l3_isolation_domain_name: str,
-        body: Union[_models.L3IsolationDomain, IO],
+        l2_isolation_domain_name: str,
+        body: Union[_models.L2IsolationDomain, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.L3IsolationDomain]:
-        """Create L3 Isolation Domain.
+    ) -> AsyncLROPoller[_models.L2IsolationDomain]:
+        """Create L2 Isolation Domain.
 
-        Create isolation domain resources for layer 3 connectivity between compute nodes and for
-        communication with external services .This configuration is applied on the devices only after
-        the creation of networks is completed and isolation domain is enabled.
+        Creates layer 2 network connectivity between compute nodes within a rack and across racks.The
+        configuration is applied on the devices only after the isolation domain is enabled.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
-        :type l3_isolation_domain_name: str
-        :param body: Request payload. Is either a L3IsolationDomain type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.L3IsolationDomain or IO
+        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: Request payload. Is either a L2IsolationDomain type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.L2IsolationDomain or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either L3IsolationDomain or the result of
+        :return: An instance of AsyncLROPoller that returns either L2IsolationDomain or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.L3IsolationDomain] = kwargs.pop("cls", None)
+        cls: ClsType[_models.L2IsolationDomain] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
                 resource_group_name=resource_group_name,
-                l3_isolation_domain_name=l3_isolation_domain_name,
+                l2_isolation_domain_name=l2_isolation_domain_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("L3IsolationDomain", pipeline_response)
+            deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
@@ -302,52 +300,52 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
     }
 
     @distributed_trace_async
     async def get(
-        self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
-    ) -> _models.L3IsolationDomain:
-        """Gets a L3 Isolation Domain.
+        self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any
+    ) -> _models.L2IsolationDomain:
+        """Retrieves details of this L2 Isolation Domain.
 
-        Retrieves details of this L3 Isolation Domain.
+        Implements L2 Isolation Domain GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
-        :type l3_isolation_domain_name: str
+        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
+        :type l2_isolation_domain_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: L3IsolationDomain or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.L3IsolationDomain
+        :return: L2IsolationDomain or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.L2IsolationDomain
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.L3IsolationDomain] = kwargs.pop("cls", None)
+        cls: ClsType[_models.L2IsolationDomain] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            l3_isolation_domain_name=l3_isolation_domain_name,
+            l2_isolation_domain_name=l2_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -361,58 +359,58 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("L3IsolationDomain", pipeline_response)
+        deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
     }
 
     async def _update_initial(
         self,
         resource_group_name: str,
-        l3_isolation_domain_name: str,
-        body: Union[_models.L3IsolationDomainPatch, IO],
+        l2_isolation_domain_name: str,
+        body: Union[_models.L2IsolationDomainPatch, IO],
         **kwargs: Any
-    ) -> Optional[_models.L3IsolationDomain]:
+    ) -> Optional[_models.L2IsolationDomain]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.L3IsolationDomain]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.L2IsolationDomain]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "L3IsolationDomainPatch")
+            _json = self._serialize.body(body, "L2IsolationDomainPatch")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            l3_isolation_domain_name=l3_isolation_domain_name,
+            l2_isolation_domain_name=l2_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
@@ -432,168 +430,170 @@
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("L3IsolationDomain", pipeline_response)
+            deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
     }
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
-        l3_isolation_domain_name: str,
-        body: _models.L3IsolationDomainPatch,
+        l2_isolation_domain_name: str,
+        body: _models.L2IsolationDomainPatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.L3IsolationDomain]:
-        """Updates a L3 Isolation Domain.
+    ) -> AsyncLROPoller[_models.L2IsolationDomain]:
+        """Updates a L2 Isolation Domain.
 
-        API to update certain properties of the L3 Isolation Domain resource.
+        API to update certain properties of the L2 Isolation Domain resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
-        :type l3_isolation_domain_name: str
-        :param body: API to update certain properties of the L3 Isolation Domain resource. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.L3IsolationDomainPatch
+        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: API to update certain properties of the L2 Isolation Domain resource.. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.L2IsolationDomainPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either L3IsolationDomain or the result of
+        :return: An instance of AsyncLROPoller that returns either L2IsolationDomain or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
-        l3_isolation_domain_name: str,
+        l2_isolation_domain_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.L3IsolationDomain]:
-        """Updates a L3 Isolation Domain.
+    ) -> AsyncLROPoller[_models.L2IsolationDomain]:
+        """Updates a L2 Isolation Domain.
 
-        API to update certain properties of the L3 Isolation Domain resource.
+        API to update certain properties of the L2 Isolation Domain resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
-        :type l3_isolation_domain_name: str
-        :param body: API to update certain properties of the L3 Isolation Domain resource. Required.
+        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: API to update certain properties of the L2 Isolation Domain resource.. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either L3IsolationDomain or the result of
+        :return: An instance of AsyncLROPoller that returns either L2IsolationDomain or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update(
         self,
         resource_group_name: str,
-        l3_isolation_domain_name: str,
-        body: Union[_models.L3IsolationDomainPatch, IO],
+        l2_isolation_domain_name: str,
+        body: Union[_models.L2IsolationDomainPatch, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.L3IsolationDomain]:
-        """Updates a L3 Isolation Domain.
+    ) -> AsyncLROPoller[_models.L2IsolationDomain]:
+        """Updates a L2 Isolation Domain.
 
-        API to update certain properties of the L3 Isolation Domain resource.
+        API to update certain properties of the L2 Isolation Domain resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
-        :type l3_isolation_domain_name: str
-        :param body: API to update certain properties of the L3 Isolation Domain resource. Is either a
-         L3IsolationDomainPatch type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.L3IsolationDomainPatch or IO
+        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: API to update certain properties of the L2 Isolation Domain resource.. Is either a
+         L2IsolationDomainPatch type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.L2IsolationDomainPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either L3IsolationDomain or the result of
+        :return: An instance of AsyncLROPoller that returns either L2IsolationDomain or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.L3IsolationDomain] = kwargs.pop("cls", None)
+        cls: ClsType[_models.L2IsolationDomain] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
                 resource_group_name=resource_group_name,
-                l3_isolation_domain_name=l3_isolation_domain_name,
+                l2_isolation_domain_name=l2_isolation_domain_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("L3IsolationDomain", pipeline_response)
+            deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
@@ -608,19 +608,19 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
     }
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
+        self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -630,15 +630,15 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            l3_isolation_domain_name=l3_isolation_domain_name,
+            l2_isolation_domain_name=l2_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -647,39 +647,39 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
     }
 
     @distributed_trace_async
     async def begin_delete(
-        self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
+        self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
-        """Deletes a L3 Isolation Domain.
+        """Deletes named L2 Isolation Domain.
 
-        Deletes layer 3 connectivity between compute nodes by managed by named L3 Isolation name.
+        Deletes layer 2 connectivity between compute nodes by managed by named L2 Isolation name.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
-        :type l3_isolation_domain_name: str
+        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
+        :type l2_isolation_domain_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
@@ -695,15 +695,15 @@
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                l3_isolation_domain_name=l3_isolation_domain_name,
+                l2_isolation_domain_name=l2_isolation_domain_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
@@ -726,413 +726,442 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
     }
 
-    @distributed_trace
-    def list_by_resource_group(
-        self, resource_group_name: str, **kwargs: Any
-    ) -> AsyncIterable["_models.L3IsolationDomain"]:
-        """List L3IsolationDomains by resource group.
-
-        Displays L3IsolationDomains list by resource group GET method.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either L3IsolationDomain or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.L3IsolationDomainsListResult] = kwargs.pop("cls", None)
-
+    async def _update_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        def prepare_request(next_link=None):
-            if not next_link:
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-                request = build_list_by_resource_group_request(
-                    resource_group_name=resource_group_name,
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    template_url=self.list_by_resource_group.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "UpdateAdministrativeState")
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("L3IsolationDomainsListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+        request = build_update_administrative_state_request(
+            resource_group_name=resource_group_name,
+            l2_isolation_domain_name=l2_isolation_domain_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._update_administrative_state_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
-        async def get_next(next_link=None):
-            request = prepare_request(next_link)
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
 
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
-            )
-            response = pipeline_response.http_response
+        response = pipeline_response.http_response
 
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-            return pipeline_response
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        return AsyncItemPaged(get_next, extract_data)
+        if cls:
+            return cls(pipeline_response, None, response_headers)
 
-    list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains"
+    _update_administrative_state_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/updateAdministrativeState"
     }
 
-    @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.L3IsolationDomain"]:
-        """List L3IsolationDomains by subscription.
+    @overload
+    async def begin_update_administrative_state(
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: _models.UpdateAdministrativeState,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        Displays L3IsolationDomains list by subscription GET method.
+        Enables isolation domain across the fabric or on specified racks.
 
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either L3IsolationDomain or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.L3IsolationDomainsListResult] = kwargs.pop("cls", None)
 
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
+    @overload
+    async def begin_update_administrative_state(
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        def prepare_request(next_link=None):
-            if not next_link:
+        Enables isolation domain across the fabric or on specified racks.
 
-                request = build_list_by_subscription_request(
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    template_url=self.list_by_subscription.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
 
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+    @distributed_trace_async
+    async def begin_update_administrative_state(
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("L3IsolationDomainsListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+        Enables isolation domain across the fabric or on specified racks.
 
-        async def get_next(next_link=None):
-            request = prepare_request(next_link)
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = await self._update_administrative_state_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                l2_isolation_domain_name=l2_isolation_domain_name,
+                body=body,
+                api_version=api_version,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
             )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+        kwargs.pop("error_map", None)
 
-            return pipeline_response
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
 
-        return AsyncItemPaged(get_next, extract_data)
+        if polling is True:
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains"
+    begin_update_administrative_state.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/updateAdministrativeState"
     }
 
-    async def _update_administrative_state_initial(
+    async def _clear_arp_table_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
-        l3_isolation_domain_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
+        l2_isolation_domain_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForDeviceUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "UpdateAdministrativeState")
+            _json = self._serialize.body(body, "EnableDisableOnResources")
 
-        request = build_update_administrative_state_request(
+        request = build_clear_arp_table_request(
             resource_group_name=resource_group_name,
-            l3_isolation_domain_name=l3_isolation_domain_name,
+            l2_isolation_domain_name=l2_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._update_administrative_state_initial.metadata["url"],
+            template_url=self._clear_arp_table_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _update_administrative_state_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/updateAdministrativeState"
+    _clear_arp_table_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/clearArpTable"
     }
 
     @overload
-    async def begin_update_administrative_state(
+    async def begin_clear_arp_table(
         self,
         resource_group_name: str,
-        l3_isolation_domain_name: str,
-        body: _models.UpdateAdministrativeState,
+        l2_isolation_domain_name: str,
+        body: _models.EnableDisableOnResources,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """executes enable operation to the underlying resources.
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        Enables racks for this Isolation Domain.
+        Clears ARP tables for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
-        :type l3_isolation_domain_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForDeviceUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_update_administrative_state(
+    async def begin_clear_arp_table(
         self,
         resource_group_name: str,
-        l3_isolation_domain_name: str,
+        l2_isolation_domain_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """executes enable operation to the underlying resources.
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        Enables racks for this Isolation Domain.
+        Clears ARP tables for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
-        :type l3_isolation_domain_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForDeviceUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
-    async def begin_update_administrative_state(
+    async def begin_clear_arp_table(
         self,
         resource_group_name: str,
-        l3_isolation_domain_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
+        l2_isolation_domain_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """executes enable operation to the underlying resources.
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        Enables racks for this Isolation Domain.
+        Clears ARP tables for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
-        :type l3_isolation_domain_name: str
-        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: Request payload. Is either a EnableDisableOnResources type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForDeviceUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_administrative_state_initial(
+            raw_result = await self._clear_arp_table_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                l3_isolation_domain_name=l3_isolation_domain_name,
+                l2_isolation_domain_name=l2_isolation_domain_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
@@ -1143,127 +1172,219 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_update_administrative_state.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/updateAdministrativeState"
+    begin_clear_arp_table.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/clearArpTable"
     }
 
-    async def _validate_configuration_initial(
-        self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
-    ) -> _models.ValidateConfigurationResponse:
+    async def _clear_neighbor_table_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_validate_configuration_request(
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "EnableDisableOnResources")
+
+        request = build_clear_neighbor_table_request(
             resource_group_name=resource_group_name,
-            l3_isolation_domain_name=l3_isolation_domain_name,
+            l2_isolation_domain_name=l2_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._validate_configuration_initial.metadata["url"],
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._clear_neighbor_table_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        if cls:
+            return cls(pipeline_response, None, response_headers)
 
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+    _clear_neighbor_table_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/clearNeighborTable"
+    }
 
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+    @overload
+    async def begin_clear_neighbor_table(
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: _models.EnableDisableOnResources,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        return deserialized  # type: ignore
+        Clears IPv6 neighbors for this Isolation Domain.
 
-    _validate_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/validateConfiguration"
-    }
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    async def begin_clear_neighbor_table(
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
+
+        Clears IPv6 neighbors for this Isolation Domain.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
 
     @distributed_trace_async
-    async def begin_validate_configuration(
-        self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.ValidateConfigurationResponse]:
-        """Validates the configuration of the resources.
+    async def begin_clear_neighbor_table(
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
+
+        Clears IPv6 neighbors for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
-        :type l3_isolation_domain_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: Request payload. Is either a EnableDisableOnResources type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._validate_configuration_initial(
+            raw_result = await self._clear_neighbor_table_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                l3_isolation_domain_name=l3_isolation_domain_name,
+                l2_isolation_domain_name=l2_isolation_domain_name,
+                body=body,
                 api_version=api_version,
+                content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
@@ -1274,128 +1395,128 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_validate_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/validateConfiguration"
+    begin_clear_neighbor_table.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/clearNeighborTable"
     }
 
-    async def _commit_configuration_initial(
-        self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    async def _get_arp_entries_initial(
+        self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any
+    ) -> Dict[str, _models.ARPProperties]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[Dict[str, _models.ARPProperties]] = kwargs.pop("cls", None)
 
-        request = build_commit_configuration_request(
+        request = build_get_arp_entries_request(
             resource_group_name=resource_group_name,
-            l3_isolation_domain_name=l3_isolation_domain_name,
+            l2_isolation_domain_name=l2_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._commit_configuration_initial.metadata["url"],
+            template_url=self._get_arp_entries_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        deserialized = self._deserialize("{ARPProperties}", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)
 
-        return deserialized  # type: ignore
+        return deserialized
 
-    _commit_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/commitConfiguration"
+    _get_arp_entries_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/getArpEntries"
     }
 
     @distributed_trace_async
-    async def begin_commit_configuration(
-        self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Execute the commit on the resources.
+    async def begin_get_arp_entries(
+        self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any
+    ) -> AsyncLROPoller[Dict[str, _models.ARPProperties]]:
+        """Implements the operation to the underlying resources.
 
-        Commits the configuration of the given resources.
+        Clears IPv6 neighbors for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
-        :type l3_isolation_domain_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either dict mapping str to ARPProperties or
+         the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[dict[str,
+         ~azure.mgmt.managednetworkfabric.models.ARPProperties]]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[Dict[str, _models.ARPProperties]] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._commit_configuration_initial(
+            raw_result = await self._get_arp_entries_initial(
                 resource_group_name=resource_group_name,
-                l3_isolation_domain_name=l3_isolation_domain_name,
+                l2_isolation_domain_name=l2_isolation_domain_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+            response_headers = {}
+            response = pipeline_response.http_response
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+            deserialized = self._deserialize("{ARPProperties}", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})
+                return cls(pipeline_response, deserialized, response_headers)
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
@@ -1407,10 +1528,188 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_commit_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/commitConfiguration"
+    begin_get_arp_entries.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/getArpEntries"
+    }
+
+    @distributed_trace
+    def list_by_resource_group(
+        self, resource_group_name: str, **kwargs: Any
+    ) -> AsyncIterable["_models.L2IsolationDomain"]:
+        """List L2IsolationDomains by resource group.
+
+        Displays L2IsolationDomains list by resource group GET method.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either L2IsolationDomain or the result of cls(response)
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.L2IsolationDomainsListResult] = kwargs.pop("cls", None)
+
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        def prepare_request(next_link=None):
+            if not next_link:
+
+                request = build_list_by_resource_group_request(
+                    resource_group_name=resource_group_name,
+                    subscription_id=self._config.subscription_id,
+                    api_version=api_version,
+                    template_url=self.list_by_resource_group.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("L2IsolationDomainsListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, AsyncList(list_of_elem)
+
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+            return pipeline_response
+
+        return AsyncItemPaged(get_next, extract_data)
+
+    list_by_resource_group.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains"
+    }
+
+    @distributed_trace
+    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.L2IsolationDomain"]:
+        """List L2IsolationDomains by subscription.
+
+        Displays L2IsolationDomains list by subscription GET method.
+
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either L2IsolationDomain or the result of cls(response)
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.L2IsolationDomainsListResult] = kwargs.pop("cls", None)
+
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        def prepare_request(next_link=None):
+            if not next_link:
+
+                request = build_list_by_subscription_request(
+                    subscription_id=self._config.subscription_id,
+                    api_version=api_version,
+                    template_url=self.list_by_subscription.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("L2IsolationDomainsListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, AsyncList(list_of_elem)
+
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+            return pipeline_response
+
+        return AsyncItemPaged(get_next, extract_data)
+
+    list_by_subscription.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_ip_extended_communities_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_ip_extended_communities_operations.py`

 * *Files 0% similar despite different names*

```diff
@@ -431,15 +431,17 @@
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("IpExtendedCommunity", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
@@ -643,15 +645,15 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 202:
             response_headers["Azure-AsyncOperation"] = self._deserialize(
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_fabrics_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_internal_networks_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,619 +3,1068 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 from io import IOBase
-from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
+from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
-from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
+from azure.core.pipeline.transport import HttpResponse
+from azure.core.polling import LROPoller, NoPolling, PollingMethod
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
-from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
+from azure.mgmt.core.polling.arm_polling import ARMPolling
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._network_fabrics_operations import (
-    build_commit_configuration_request,
-    build_create_request,
-    build_delete_request,
-    build_deprovision_request,
-    build_get_request,
-    build_get_topology_request,
-    build_list_by_resource_group_request,
-    build_list_by_subscription_request,
-    build_provision_request,
-    build_refresh_configuration_request,
-    build_update_infra_management_bfd_configuration_request,
-    build_update_request,
-    build_update_workload_management_bfd_configuration_request,
-    build_upgrade_request,
-    build_validate_configuration_request,
-)
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request, _format_url_section
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_create_request(
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    internal_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "internalNetworkName": _SERIALIZER.url("internal_network_name", internal_network_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_get_request(
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    internal_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "internalNetworkName": _SERIALIZER.url("internal_network_name", internal_network_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_update_request(
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    internal_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "internalNetworkName": _SERIALIZER.url("internal_network_name", internal_network_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_delete_request(
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    internal_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "internalNetworkName": _SERIALIZER.url("internal_network_name", internal_network_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_request(
+    resource_group_name: str, l3_isolation_domain_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_update_administrative_state_request(
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    internal_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateAdministrativeState",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "internalNetworkName": _SERIALIZER.url("internal_network_name", internal_network_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_update_bgp_administrative_state_request(
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    internal_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBgpAdministrativeState",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "internalNetworkName": _SERIALIZER.url("internal_network_name", internal_network_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_update_bfd_for_bgp_administrative_state_request(
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    internal_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBfdForBgpAdministrativeState",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "internalNetworkName": _SERIALIZER.url("internal_network_name", internal_network_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_clear_ipv6_neighbors_request(
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    internal_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/clearIpv6Neighbors",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "internalNetworkName": _SERIALIZER.url("internal_network_name", internal_network_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_clear_arp_entries_request(
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    internal_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/clearArpEntries",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "internalNetworkName": _SERIALIZER.url("internal_network_name", internal_network_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_update_bfd_for_static_route_administrative_state_request(
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    internal_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBfdForStaticRouteAdministrativeState",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "internalNetworkName": _SERIALIZER.url("internal_network_name", internal_network_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class NetworkFabricsOperations:  # pylint: disable=too-many-public-methods
+class InternalNetworksOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.managednetworkfabric.aio.ManagedNetworkFabricMgmtClient`'s
-        :attr:`network_fabrics` attribute.
+        :class:`~azure.mgmt.managednetworkfabric.ManagedNetworkFabricMgmtClient`'s
+        :attr:`internal_networks` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    async def _create_initial(
-        self, resource_group_name: str, network_fabric_name: str, body: Union[_models.NetworkFabric, IO], **kwargs: Any
-    ) -> _models.NetworkFabric:
+    def _create_initial(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.InternalNetwork, IO],
+        **kwargs: Any
+    ) -> _models.InternalNetwork:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkFabric] = kwargs.pop("cls", None)
+        cls: ClsType[_models.InternalNetwork] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkFabric")
+            _json = self._serialize.body(body, "InternalNetwork")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            internal_network_name=internal_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkFabric", pipeline_response)
+            deserialized = self._deserialize("InternalNetwork", pipeline_response)
 
         if response.status_code == 201:
-            response_headers["Azure-AsyncOperation"] = self._deserialize(
-                "str", response.headers.get("Azure-AsyncOperation")
-            )
-
-            deserialized = self._deserialize("NetworkFabric", pipeline_response)
+            deserialized = self._deserialize("InternalNetwork", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}"
     }
 
     @overload
-    async def begin_create(
+    def begin_create(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: _models.NetworkFabric,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: _models.InternalNetwork,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkFabric]:
-        """Create Network Fabric.
+    ) -> LROPoller[_models.InternalNetwork]:
+        """Creates InternalNetwork for Layer3 Isolation Domain for communication of compute within and
+        across racks.
 
-        Create Network Fabric resource.
+        Creates InternalNetwork PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabric
+        :type body: ~azure.mgmt.managednetworkfabric.models.InternalNetwork
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkFabric or the result of
+        :return: An instance of LROPoller that returns either InternalNetwork or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.InternalNetwork]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_create(
+    def begin_create(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkFabric]:
-        """Create Network Fabric.
+    ) -> LROPoller[_models.InternalNetwork]:
+        """Creates InternalNetwork for Layer3 Isolation Domain for communication of compute within and
+        across racks.
 
-        Create Network Fabric resource.
+        Creates InternalNetwork PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkFabric or the result of
+        :return: An instance of LROPoller that returns either InternalNetwork or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.InternalNetwork]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_create(
-        self, resource_group_name: str, network_fabric_name: str, body: Union[_models.NetworkFabric, IO], **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkFabric]:
-        """Create Network Fabric.
+    @distributed_trace
+    def begin_create(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.InternalNetwork, IO],
+        **kwargs: Any
+    ) -> LROPoller[_models.InternalNetwork]:
+        """Creates InternalNetwork for Layer3 Isolation Domain for communication of compute within and
+        across racks.
 
-        Create Network Fabric resource.
+        Creates InternalNetwork PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Request payload. Is either a NetworkFabric type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabric or IO
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Is either a InternalNetwork type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.InternalNetwork or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkFabric or the result of
+        :return: An instance of LROPoller that returns either InternalNetwork or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.InternalNetwork]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkFabric] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[_models.InternalNetwork] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._create_initial(
+            raw_result = self._create_initial(
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                internal_network_name=internal_network_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkFabric", pipeline_response)
+            deserialized = self._deserialize("InternalNetwork", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}"
     }
 
-    @distributed_trace_async
-    async def get(self, resource_group_name: str, network_fabric_name: str, **kwargs: Any) -> _models.NetworkFabric:
-        """Gets a Network Fabric.
+    @distributed_trace
+    def get(
+        self, resource_group_name: str, l3_isolation_domain_name: str, internal_network_name: str, **kwargs: Any
+    ) -> _models.InternalNetwork:
+        """Retrieves details of InternalNetworks using GET method.
 
-        Get Network Fabric resource details.
+        Gets a InternalNetworks.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NetworkFabric or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkFabric
+        :return: InternalNetwork or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.InternalNetwork
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkFabric] = kwargs.pop("cls", None)
+        cls: ClsType[_models.InternalNetwork] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            internal_network_name=internal_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("NetworkFabric", pipeline_response)
+        deserialized = self._deserialize("InternalNetwork", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}"
     }
 
-    async def _update_initial(
+    def _update_initial(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: Union[_models.NetworkFabricPatch, IO],
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.InternalNetworkPatch, IO],
         **kwargs: Any
-    ) -> Optional[_models.NetworkFabric]:
+    ) -> _models.InternalNetwork:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.NetworkFabric]] = kwargs.pop("cls", None)
+        cls: ClsType[_models.InternalNetwork] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkFabricPatch")
+            _json = self._serialize.body(body, "InternalNetworkPatch")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            internal_network_name=internal_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = None
-        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkFabric", pipeline_response)
+            deserialized = self._deserialize("InternalNetwork", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            deserialized = self._deserialize("InternalNetwork", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}"
     }
 
     @overload
-    async def begin_update(
+    def begin_update(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: _models.NetworkFabricPatch,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: _models.InternalNetworkPatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkFabric]:
-        """Updates a Network Fabric.
+    ) -> LROPoller[_models.InternalNetwork]:
+        """API to update certain properties of the InternalNetworks resources.
 
-        Update certain properties of the Network Fabric resource.
+        Updates a InternalNetworks.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Network Fabric properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricPatch
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: InternalNetwork properties to update. Only annotations are supported. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.InternalNetworkPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkFabric or the result of
+        :return: An instance of LROPoller that returns either InternalNetwork or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.InternalNetwork]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_update(
+    def begin_update(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkFabric]:
-        """Updates a Network Fabric.
+    ) -> LROPoller[_models.InternalNetwork]:
+        """API to update certain properties of the InternalNetworks resources.
 
-        Update certain properties of the Network Fabric resource.
+        Updates a InternalNetworks.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Network Fabric properties to update. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: InternalNetwork properties to update. Only annotations are supported. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkFabric or the result of
+        :return: An instance of LROPoller that returns either InternalNetwork or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.InternalNetwork]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_update(
+    @distributed_trace
+    def begin_update(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: Union[_models.NetworkFabricPatch, IO],
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.InternalNetworkPatch, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkFabric]:
-        """Updates a Network Fabric.
+    ) -> LROPoller[_models.InternalNetwork]:
+        """API to update certain properties of the InternalNetworks resources.
 
-        Update certain properties of the Network Fabric resource.
+        Updates a InternalNetworks.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Network Fabric properties to update. Is either a NetworkFabricPatch type or a IO
-         type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricPatch or IO
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: InternalNetwork properties to update. Only annotations are supported. Is either a
+         InternalNetworkPatch type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.InternalNetworkPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkFabric or the result of
+        :return: An instance of LROPoller that returns either InternalNetwork or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.InternalNetwork]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkFabric] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[_models.InternalNetwork] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_initial(
+            raw_result = self._update_initial(
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                internal_network_name=internal_network_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkFabric", pipeline_response)
+            deserialized = self._deserialize("InternalNetwork", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}"
     }
 
-    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
+    def _delete_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, l3_isolation_domain_name: str, internal_network_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -625,240 +1074,158 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            internal_network_name=internal_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
         if cls:
-            return cls(pipeline_response, None, response_headers)
+            return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}"
     }
 
-    @distributed_trace_async
-    async def begin_delete(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[None]:
-        """Deletes a Network Fabric.
+    @distributed_trace
+    def begin_delete(
+        self, resource_group_name: str, l3_isolation_domain_name: str, internal_network_name: str, **kwargs: Any
+    ) -> LROPoller[None]:
+        """Deletes a InternalNetworks.
 
-        Delete Network Fabric resource.
+        Implements InternalNetworks DELETE method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._delete_initial(  # type: ignore
+            raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                internal_network_name=internal_network_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}"
     }
 
     @distributed_trace
-    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.NetworkFabric"]:
-        """List Network Fabrics by resource group.
+    def list(
+        self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
+    ) -> Iterable["_models.InternalNetwork"]:
+        """Executes list operation to display list of all internal networks.
 
-        List all the Network Fabric resources in the given resource group.
+        Displays InternalNetworks list by resource group GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkFabric or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
+        :return: An iterator like instance of either InternalNetwork or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.InternalNetwork]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkFabricsListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.InternalNetworksList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_by_resource_group_request(
+                request = build_list_request(
                     resource_group_name=resource_group_name,
+                    l3_isolation_domain_name=l3_isolation_domain_name,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
-                    template_url=self.list_by_resource_group.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
-
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkFabricsListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
-
-        async def get_next(next_link=None):
-            request = prepare_request(next_link)
-
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
-            )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-            return pipeline_response
-
-        return AsyncItemPaged(get_next, extract_data)
-
-    list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics"
-    }
-
-    @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.NetworkFabric"]:
-        """List Network Fabrics by subscription.
-
-        List all the Network Fabric resources in the given subscription.
-
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkFabric or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkFabricsListResult] = kwargs.pop("cls", None)
-
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        def prepare_request(next_link=None):
-            if not next_link:
-
-                request = build_list_by_subscription_request(
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    template_url=self.list_by_subscription.metadata["url"],
+                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
@@ -875,1659 +1242,1449 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkFabricsListResult", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("InternalNetworksList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
-    list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabrics"
+    list.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks"
     }
 
-    async def _provision_initial(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForDeviceUpdate:
+    def _update_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_provision_request(
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "UpdateAdministrativeState")
+
+        request = build_update_administrative_state_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            internal_network_name=internal_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._provision_initial.metadata["url"],
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._update_administrative_state_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _provision_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/provision"
+    _update_administrative_state_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateAdministrativeState"
     }
 
-    @distributed_trace_async
-    async def begin_provision(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """Implements the operation to the underlying resources.
+    @overload
+    def begin_update_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: _models.UpdateAdministrativeState,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Executes the operation to the underlying resources.
 
-        Provisions the underlying resources in the given Network Fabric instance.
+        Update Administrative state of  InternalNetworks on resources referred by their resource ids.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForDeviceUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._provision_initial(
-                resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
-                api_version=api_version,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_provision.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/provision"
-    }
-
-    async def _deprovision_initial(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForDeviceUpdate:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
-
-        request = build_deprovision_request(
-            resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            template_url=self._deprovision_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
 
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+    @overload
+    def begin_update_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Executes the operation to the underlying resources.
 
-        return deserialized  # type: ignore
+        Update Administrative state of  InternalNetworks on resources referred by their resource ids.
 
-    _deprovision_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/deprovision"
-    }
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
 
-    @distributed_trace_async
-    async def begin_deprovision(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """Implements the operation to the underlying resources.
+    @distributed_trace
+    def begin_update_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Executes the operation to the underlying resources.
 
-        Deprovisions the underlying resources in the given Network Fabric instance.
+        Update Administrative state of  InternalNetworks on resources referred by their resource ids.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForDeviceUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._deprovision_initial(
+            raw_result = self._update_administrative_state_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                internal_network_name=internal_network_name,
+                body=body,
                 api_version=api_version,
+                content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_deprovision.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/deprovision"
+    begin_update_administrative_state.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateAdministrativeState"
     }
 
-    async def _upgrade_initial(
-        self, resource_group_name: str, network_fabric_name: str, body: Union[_models.UpdateVersion, IO], **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    def _update_bgp_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "UpdateVersion")
+            _json = self._serialize.body(body, "UpdateAdministrativeState")
 
-        request = build_upgrade_request(
+        request = build_update_bgp_administrative_state_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            internal_network_name=internal_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._upgrade_initial.metadata["url"],
+            template_url=self._update_bgp_administrative_state_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _upgrade_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/upgrade"
+    _update_bgp_administrative_state_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBgpAdministrativeState"
     }
 
     @overload
-    async def begin_upgrade(
+    def begin_update_bgp_administrative_state(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: _models.UpdateVersion,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: _models.UpdateAdministrativeState,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    ) -> LROPoller[None]:
+        """Executes the operation to the underlying resources for updating BGP state on edge devices.
 
-        Upgrades the version of the underlying resources in the given Network Fabric instance.
+        Update BGP state for internalNetwork. Allowed only on edge devices.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Network Fabric properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateVersion
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_upgrade(
+    def begin_update_bgp_administrative_state(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    ) -> LROPoller[None]:
+        """Executes the operation to the underlying resources for updating BGP state on edge devices.
 
-        Upgrades the version of the underlying resources in the given Network Fabric instance.
+        Update BGP state for internalNetwork. Allowed only on edge devices.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Network Fabric properties to update. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_upgrade(
-        self, resource_group_name: str, network_fabric_name: str, body: Union[_models.UpdateVersion, IO], **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    @distributed_trace
+    def begin_update_bgp_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Executes the operation to the underlying resources for updating BGP state on edge devices.
 
-        Upgrades the version of the underlying resources in the given Network Fabric instance.
+        Update BGP state for internalNetwork. Allowed only on edge devices.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Network Fabric properties to update. Is either a UpdateVersion type or a IO type.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
          Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateVersion or IO
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._upgrade_initial(
+            raw_result = self._update_bgp_administrative_state_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                internal_network_name=internal_network_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_upgrade.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/upgrade"
-    }
-
-    async def _refresh_configuration_initial(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-
-        request = build_refresh_configuration_request(
-            resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            template_url=self._refresh_configuration_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
-
-    _refresh_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/refreshConfiguration"
-    }
-
-    @distributed_trace_async
-    async def begin_refresh_configuration(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
-
-        Refreshes the configuration of the underlying resources in the given Network Fabric instance.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._refresh_configuration_initial(
-                resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
-                api_version=api_version,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_refresh_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/refreshConfiguration"
+    begin_update_bgp_administrative_state.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBgpAdministrativeState"
     }
 
-    async def _update_workload_management_bfd_configuration_initial(
+    def _update_bfd_for_bgp_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
-        network_fabric_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "UpdateAdministrativeState")
 
-        request = build_update_workload_management_bfd_configuration_request(
+        request = build_update_bfd_for_bgp_administrative_state_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            internal_network_name=internal_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._update_workload_management_bfd_configuration_initial.metadata["url"],
+            template_url=self._update_bfd_for_bgp_administrative_state_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _update_workload_management_bfd_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/updateWorkloadManagementBfdConfiguration"
+    _update_bfd_for_bgp_administrative_state_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBfdForBgpAdministrativeState"
     }
 
     @overload
-    async def begin_update_workload_management_bfd_configuration(
+    def begin_update_bfd_for_bgp_administrative_state(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
         body: _models.UpdateAdministrativeState,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> LROPoller[None]:
         """Implements the operation to the underlying resources.
 
-        Updates the Workload Management BFD Configuration of the underlying resources in the given
-        Network Fabric instance.
+        Update BfdForBgp for internalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
         :param body: Request payload. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_update_workload_management_bfd_configuration(
+    def begin_update_bfd_for_bgp_administrative_state(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> LROPoller[None]:
         """Implements the operation to the underlying resources.
 
-        Updates the Workload Management BFD Configuration of the underlying resources in the given
-        Network Fabric instance.
+        Update BfdForBgp for internalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_update_workload_management_bfd_configuration(
+    @distributed_trace
+    def begin_update_bfd_for_bgp_administrative_state(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> LROPoller[None]:
         """Implements the operation to the underlying resources.
 
-        Updates the Workload Management BFD Configuration of the underlying resources in the given
-        Network Fabric instance.
+        Update BfdForBgp for internalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
         :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
          Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_workload_management_bfd_configuration_initial(
+            raw_result = self._update_bfd_for_bgp_administrative_state_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                internal_network_name=internal_network_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_update_workload_management_bfd_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/updateWorkloadManagementBfdConfiguration"
+    begin_update_bfd_for_bgp_administrative_state.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBfdForBgpAdministrativeState"
     }
 
-    async def _update_infra_management_bfd_configuration_initial(
+    def _clear_ipv6_neighbors_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "UpdateAdministrativeState")
+            _json = self._serialize.body(body, "EnableDisableOnResources")
 
-        request = build_update_infra_management_bfd_configuration_request(
+        request = build_clear_ipv6_neighbors_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            internal_network_name=internal_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._update_infra_management_bfd_configuration_initial.metadata["url"],
+            template_url=self._clear_ipv6_neighbors_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _update_infra_management_bfd_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/updateInfraManagementBfdConfiguration"
+    _clear_ipv6_neighbors_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/clearIpv6Neighbors"
     }
 
     @overload
-    async def begin_update_infra_management_bfd_configuration(
+    def begin_clear_ipv6_neighbors(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: _models.UpdateAdministrativeState,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: _models.EnableDisableOnResources,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> LROPoller[None]:
         """Implements the operation to the underlying resources.
 
-        Updates the Infra Management BFD Configuration of the underlying resources in the given Network
-        Fabric instance.
+        clearIpv6Neighbors for internalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_update_infra_management_bfd_configuration(
+    def begin_clear_ipv6_neighbors(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> LROPoller[None]:
         """Implements the operation to the underlying resources.
 
-        Updates the Infra Management BFD Configuration of the underlying resources in the given Network
-        Fabric instance.
+        clearIpv6Neighbors for internalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_update_infra_management_bfd_configuration(
+    @distributed_trace
+    def begin_clear_ipv6_neighbors(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> LROPoller[None]:
         """Implements the operation to the underlying resources.
 
-        Updates the Infra Management BFD Configuration of the underlying resources in the given Network
-        Fabric instance.
+        clearIpv6Neighbors for internalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Is either a EnableDisableOnResources type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_infra_management_bfd_configuration_initial(
+            raw_result = self._clear_ipv6_neighbors_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                internal_network_name=internal_network_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_update_infra_management_bfd_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/updateInfraManagementBfdConfiguration"
+    begin_clear_ipv6_neighbors.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/clearIpv6Neighbors"
     }
 
-    async def _validate_configuration_initial(
+    def _clear_arp_entries_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: Union[_models.ValidateConfigurationProperties, IO],
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
         **kwargs: Any
-    ) -> _models.ValidateConfigurationResponse:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "ValidateConfigurationProperties")
+            _json = self._serialize.body(body, "EnableDisableOnResources")
 
-        request = build_validate_configuration_request(
+        request = build_clear_arp_entries_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            internal_network_name=internal_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._validate_configuration_initial.metadata["url"],
+            template_url=self._clear_arp_entries_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _validate_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/validateConfiguration"
+    _clear_arp_entries_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/clearArpEntries"
     }
 
     @overload
-    async def begin_validate_configuration(
+    def begin_clear_arp_entries(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: _models.ValidateConfigurationProperties,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: _models.EnableDisableOnResources,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.ValidateConfigurationResponse]:
-        """Implements the operation to the underlying resources.
+    ) -> LROPoller[None]:
+        """Executes clearArpEntries operation to the underlying resources.
 
-        Validates the configuration of the underlying resources in the given Network Fabric instance.
+        clearArpEntries for internalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Validate configuration properties. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.ValidateConfigurationProperties
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_validate_configuration(
+    def begin_clear_arp_entries(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.ValidateConfigurationResponse]:
-        """Implements the operation to the underlying resources.
+    ) -> LROPoller[None]:
+        """Executes clearArpEntries operation to the underlying resources.
 
-        Validates the configuration of the underlying resources in the given Network Fabric instance.
+        clearArpEntries for internalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Validate configuration properties. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_validate_configuration(
+    @distributed_trace
+    def begin_clear_arp_entries(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: Union[_models.ValidateConfigurationProperties, IO],
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.ValidateConfigurationResponse]:
-        """Implements the operation to the underlying resources.
+    ) -> LROPoller[None]:
+        """Executes clearArpEntries operation to the underlying resources.
 
-        Validates the configuration of the underlying resources in the given Network Fabric instance.
+        clearArpEntries for internalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Validate configuration properties. Is either a ValidateConfigurationProperties
-         type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.ValidateConfigurationProperties or IO
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Is either a EnableDisableOnResources type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._validate_configuration_initial(
+            raw_result = self._clear_arp_entries_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                internal_network_name=internal_network_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_validate_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/validateConfiguration"
+    begin_clear_arp_entries.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/clearArpEntries"
     }
 
-    async def _get_topology_initial(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> _models.ValidateConfigurationResponse:
+    def _update_bfd_for_static_route_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_get_topology_request(
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "UpdateAdministrativeState")
+
+        request = build_update_bfd_for_static_route_administrative_state_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            internal_network_name=internal_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._get_topology_initial.metadata["url"],
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._update_bfd_for_static_route_administrative_state_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _get_topology_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/getTopology"
+    _update_bfd_for_static_route_administrative_state_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBfdForStaticRouteAdministrativeState"
     }
 
-    @distributed_trace_async
-    async def begin_get_topology(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.ValidateConfigurationResponse]:
-        """Implements the operation to the underlying resources.
+    @overload
+    def begin_update_bfd_for_static_route_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: _models.UpdateAdministrativeState,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Executes update BfdForStaticRoutes operation to the underlying resources.
 
-        Gets Topology of the underlying resources in the given Network Fabric instance.
+        Update BfdForStaticRoutes for internalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._get_topology_initial(
-                resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
-                api_version=api_version,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_get_topology.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/getTopology"
-    }
-
-    async def _commit_configuration_initial(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-
-        request = build_commit_configuration_request(
-            resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            template_url=self._commit_configuration_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+    @overload
+    def begin_update_bfd_for_static_route_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Executes update BfdForStaticRoutes operation to the underlying resources.
 
-        return deserialized  # type: ignore
+        Update BfdForStaticRoutes for internalNetwork.
 
-    _commit_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/commitConfiguration"
-    }
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
 
-    @distributed_trace_async
-    async def begin_commit_configuration(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    @distributed_trace
+    def begin_update_bfd_for_static_route_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Executes update BfdForStaticRoutes operation to the underlying resources.
 
-        Atomic update of the given Network Fabric instance. Sync update of NFA resources at Fabric
-        level.
+        Update BfdForStaticRoutes for internalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._commit_configuration_initial(
+            raw_result = self._update_bfd_for_static_route_administrative_state_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                internal_network_name=internal_network_name,
+                body=body,
                 api_version=api_version,
+                content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_commit_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/commitConfiguration"
+    begin_update_bfd_for_static_route_administrative_state.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBfdForStaticRouteAdministrativeState"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/__init__.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,63 +3,53 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._access_control_lists_operations import AccessControlListsOperations
-from ._internet_gateways_operations import InternetGatewaysOperations
-from ._internet_gateway_rules_operations import InternetGatewayRulesOperations
 from ._ip_communities_operations import IpCommunitiesOperations
 from ._ip_extended_communities_operations import IpExtendedCommunitiesOperations
 from ._ip_prefixes_operations import IpPrefixesOperations
 from ._l2_isolation_domains_operations import L2IsolationDomainsOperations
 from ._l3_isolation_domains_operations import L3IsolationDomainsOperations
 from ._internal_networks_operations import InternalNetworksOperations
 from ._external_networks_operations import ExternalNetworksOperations
-from ._neighbor_groups_operations import NeighborGroupsOperations
 from ._network_device_skus_operations import NetworkDeviceSkusOperations
 from ._network_devices_operations import NetworkDevicesOperations
 from ._network_interfaces_operations import NetworkInterfacesOperations
 from ._network_fabric_controllers_operations import NetworkFabricControllersOperations
 from ._network_fabric_skus_operations import NetworkFabricSkusOperations
 from ._network_fabrics_operations import NetworkFabricsOperations
 from ._network_to_network_interconnects_operations import NetworkToNetworkInterconnectsOperations
-from ._network_packet_brokers_operations import NetworkPacketBrokersOperations
+from ._network_rack_skus_operations import NetworkRackSkusOperations
 from ._network_racks_operations import NetworkRacksOperations
-from ._network_tap_rules_operations import NetworkTapRulesOperations
-from ._network_taps_operations import NetworkTapsOperations
 from ._operations import Operations
 from ._route_policies_operations import RoutePoliciesOperations
 
 from ._patch import __all__ as _patch_all
 from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "AccessControlListsOperations",
-    "InternetGatewaysOperations",
-    "InternetGatewayRulesOperations",
     "IpCommunitiesOperations",
     "IpExtendedCommunitiesOperations",
     "IpPrefixesOperations",
     "L2IsolationDomainsOperations",
     "L3IsolationDomainsOperations",
     "InternalNetworksOperations",
     "ExternalNetworksOperations",
-    "NeighborGroupsOperations",
     "NetworkDeviceSkusOperations",
     "NetworkDevicesOperations",
     "NetworkInterfacesOperations",
     "NetworkFabricControllersOperations",
     "NetworkFabricSkusOperations",
     "NetworkFabricsOperations",
     "NetworkToNetworkInterconnectsOperations",
-    "NetworkPacketBrokersOperations",
+    "NetworkRackSkusOperations",
     "NetworkRacksOperations",
-    "NetworkTapRulesOperations",
-    "NetworkTapsOperations",
     "Operations",
     "RoutePoliciesOperations",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_ip_communities_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_ip_communities_operations.py`

 * *Files 0% similar despite different names*

```diff
@@ -414,15 +414,17 @@
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("IpCommunity", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
@@ -619,15 +621,15 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 202:
             response_headers["Azure-AsyncOperation"] = self._deserialize(
@@ -709,17 +711,17 @@
 
     begin_delete.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}"
     }
 
     @distributed_trace
     def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.IpCommunity"]:
-        """List IP Communities by resource group.
+        """List IpCommunities by resource group.
 
-        Implements IP Communities list by resource group GET method.
+        Implements IpCommunities list by resource group GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either IpCommunity or the result of cls(response)
         :rtype:
@@ -799,17 +801,17 @@
 
     list_by_resource_group.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities"
     }
 
     @distributed_trace
     def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.IpCommunity"]:
-        """List IP Communities by subscription.
+        """List IpCommunities by subscription.
 
-        Implements IP Communities list by subscription GET method.
+        Implements IpCommunities list by subscription GET method.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either IpCommunity or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.IpCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_devices_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_devices_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 from io import IOBase
-from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
+from typing import Any, AsyncIterable, Callable, Dict, IO, List, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -30,29 +30,33 @@
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._network_devices_operations import (
     build_create_request,
     build_delete_request,
+    build_generate_support_package_request,
+    build_get_dynamic_interface_maps_request,
     build_get_request,
+    build_get_static_interface_maps_request,
+    build_get_status_request,
     build_list_by_resource_group_request,
     build_list_by_subscription_request,
     build_reboot_request,
-    build_refresh_configuration_request,
-    build_update_administrative_state_request,
+    build_restore_config_request,
+    build_update_power_cycle_request,
     build_update_request,
-    build_upgrade_request,
+    build_update_version_request,
 )
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class NetworkDevicesOperations:
+class NetworkDevicesOperations:  # pylint: disable=too-many-public-methods
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.managednetworkfabric.aio.ManagedNetworkFabricMgmtClient`'s
         :attr:`network_devices` attribute.
@@ -296,15 +300,15 @@
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}"
     }
 
     @distributed_trace_async
     async def get(self, resource_group_name: str, network_device_name: str, **kwargs: Any) -> _models.NetworkDevice:
         """Gets a Network Device.
 
-        Gets the Network Device resource details.
+        Get the Network Device resource details.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param network_device_name: Name of the Network Device. Required.
         :type network_device_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -420,15 +424,17 @@
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("NetworkDevice", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
@@ -632,15 +638,15 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
@@ -890,231 +896,457 @@
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_by_subscription.metadata = {
         "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkDevices"
     }
 
-    async def _reboot_initial(
+    async def _reboot_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        request = build_reboot_request(
+            resource_group_name=resource_group_name,
+            network_device_name=network_device_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            template_url=self._reboot_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    _reboot_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/reboot"
+    }
+
+    @distributed_trace_async
+    async def begin_reboot(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
+
+        Reboot the Network Device.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = await self._reboot_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                network_device_name=network_device_name,
+                api_version=api_version,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
+
+        if polling is True:
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_reboot.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/reboot"
+    }
+
+    async def _restore_config_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        request = build_restore_config_request(
+            resource_group_name=resource_group_name,
+            network_device_name=network_device_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            template_url=self._restore_config_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    _restore_config_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/restoreConfig"
+    }
+
+    @distributed_trace_async
+    async def begin_restore_config(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Restores the configuration to last applied good configuration from Azure.
+
+        Restore the configuration of the Network Device resource to last known good configuration.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = await self._restore_config_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                network_device_name=network_device_name,
+                api_version=api_version,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
+
+        if polling is True:
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_restore_config.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/restoreConfig"
+    }
+
+    async def _update_version_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         network_device_name: str,
-        body: Union[_models.RebootProperties, IO],
+        body: Union[_models.UpdateVersionProperties, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "RebootProperties")
+            _json = self._serialize.body(body, "UpdateVersionProperties")
 
-        request = build_reboot_request(
+        request = build_update_version_request(
             resource_group_name=resource_group_name,
             network_device_name=network_device_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._reboot_initial.metadata["url"],
+            template_url=self._update_version_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-        return deserialized  # type: ignore
-
-    _reboot_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/reboot"
+    _update_version_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updateVersion"
     }
 
     @overload
-    async def begin_reboot(
+    async def begin_update_version(
         self,
         resource_group_name: str,
         network_device_name: str,
-        body: _models.RebootProperties,
+        body: _models.UpdateVersionProperties,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    ) -> AsyncLROPoller[None]:
+        """Implements SKU version upgrade of network device.
 
-        Reboot the Network Device.
+        Update the SKU version of the Network Device resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.RebootProperties
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateVersionProperties
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_reboot(
+    async def begin_update_version(
         self,
         resource_group_name: str,
         network_device_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    ) -> AsyncLROPoller[None]:
+        """Implements SKU version upgrade of network device.
 
-        Reboot the Network Device.
+        Update the SKU version of the Network Device resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
-    async def begin_reboot(
+    async def begin_update_version(
         self,
         resource_group_name: str,
         network_device_name: str,
-        body: Union[_models.RebootProperties, IO],
+        body: Union[_models.UpdateVersionProperties, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    ) -> AsyncLROPoller[None]:
+        """Implements SKU version upgrade of network device.
 
-        Reboot the Network Device.
+        Update the SKU version of the Network Device resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
-        :param body: Request payload. Is either a RebootProperties type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.RebootProperties or IO
+        :param body: Request payload. Is either a UpdateVersionProperties type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateVersionProperties or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._reboot_initial(
+            raw_result = await self._update_version_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 network_device_name=network_device_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
@@ -1125,128 +1357,128 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_reboot.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/reboot"
+    begin_update_version.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updateVersion"
     }
 
-    async def _refresh_configuration_initial(
+    async def _generate_support_package_initial(
         self, resource_group_name: str, network_device_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    ) -> _models.SupportPackageProperties:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[_models.SupportPackageProperties] = kwargs.pop("cls", None)
 
-        request = build_refresh_configuration_request(
+        request = build_generate_support_package_request(
             resource_group_name=resource_group_name,
             network_device_name=network_device_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._refresh_configuration_initial.metadata["url"],
+            template_url=self._generate_support_package_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        deserialized = self._deserialize("SupportPackageProperties", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)
 
-        return deserialized  # type: ignore
+        return deserialized
 
-    _refresh_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/refreshConfiguration"
+    _generate_support_package_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/generateSupportPackage"
     }
 
     @distributed_trace_async
-    async def begin_refresh_configuration(
+    async def begin_generate_support_package(
         self, resource_group_name: str, network_device_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> AsyncLROPoller[_models.SupportPackageProperties]:
         """Implements the operation to the underlying resources.
 
-        Refreshes the configuration the Network Device.
+        Generate Support Package for the given Network Device.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
+        :return: An instance of AsyncLROPoller that returns either SupportPackageProperties or the
+         result of cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.SupportPackageProperties]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[_models.SupportPackageProperties] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._refresh_configuration_initial(
+            raw_result = await self._generate_support_package_initial(
                 resource_group_name=resource_group_name,
                 network_device_name=network_device_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+            response_headers = {}
+            response = pipeline_response.http_response
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+            deserialized = self._deserialize("SupportPackageProperties", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})
+                return cls(pipeline_response, deserialized, response_headers)
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
@@ -1258,236 +1490,220 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_refresh_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/refreshConfiguration"
+    begin_generate_support_package.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/generateSupportPackage"
     }
 
-    async def _update_administrative_state_initial(
+    async def _update_power_cycle_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         network_device_name: str,
-        body: Union[_models.UpdateDeviceAdministrativeState, IO],
+        body: Union[_models.UpdatePowerCycleProperties, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "UpdateDeviceAdministrativeState")
+            _json = self._serialize.body(body, "UpdatePowerCycleProperties")
 
-        request = build_update_administrative_state_request(
+        request = build_update_power_cycle_request(
             resource_group_name=resource_group_name,
             network_device_name=network_device_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._update_administrative_state_initial.metadata["url"],
+            template_url=self._update_power_cycle_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-        return deserialized  # type: ignore
-
-    _update_administrative_state_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updateAdministrativeState"
+    _update_power_cycle_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updatePowerCycle"
     }
 
     @overload
-    async def begin_update_administrative_state(
+    async def begin_update_power_cycle(
         self,
         resource_group_name: str,
         network_device_name: str,
-        body: _models.UpdateDeviceAdministrativeState,
+        body: _models.UpdatePowerCycleProperties,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> AsyncLROPoller[None]:
         """Implements the operation to the underlying resources.
 
-        Updates the Administrative state of the Network Device.
+        Update PDU power cycle of the Network Device.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateDeviceAdministrativeState
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdatePowerCycleProperties
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_update_administrative_state(
+    async def begin_update_power_cycle(
         self,
         resource_group_name: str,
         network_device_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> AsyncLROPoller[None]:
         """Implements the operation to the underlying resources.
 
-        Updates the Administrative state of the Network Device.
+        Update PDU power cycle of the Network Device.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
-    async def begin_update_administrative_state(
+    async def begin_update_power_cycle(
         self,
         resource_group_name: str,
         network_device_name: str,
-        body: Union[_models.UpdateDeviceAdministrativeState, IO],
+        body: Union[_models.UpdatePowerCycleProperties, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> AsyncLROPoller[None]:
         """Implements the operation to the underlying resources.
 
-        Updates the Administrative state of the Network Device.
+        Update PDU power cycle of the Network Device.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
-        :param body: Request payload. Is either a UpdateDeviceAdministrativeState type or a IO type.
+        :param body: Request payload. Is either a UpdatePowerCycleProperties type or a IO type.
          Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateDeviceAdministrativeState or IO
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdatePowerCycleProperties or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_administrative_state_initial(
+            raw_result = await self._update_power_cycle_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 network_device_name=network_device_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
@@ -1498,226 +1714,394 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_update_administrative_state.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updateAdministrativeState"
+    begin_update_power_cycle.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updatePowerCycle"
     }
 
-    async def _upgrade_initial(
-        self, resource_group_name: str, network_device_name: str, body: Union[_models.UpdateVersion, IO], **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    async def _get_status_initial(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> _models.GetDeviceStatusProperties:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "UpdateVersion")
+        cls: ClsType[_models.GetDeviceStatusProperties] = kwargs.pop("cls", None)
 
-        request = build_upgrade_request(
+        request = build_get_status_request(
             resource_group_name=resource_group_name,
             network_device_name=network_device_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self._upgrade_initial.metadata["url"],
+            template_url=self._get_status_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        deserialized = self._deserialize("GetDeviceStatusProperties", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)
 
-        return deserialized  # type: ignore
+        return deserialized
 
-    _upgrade_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/upgrade"
+    _get_status_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/getStatus"
     }
 
-    @overload
-    async def begin_upgrade(
-        self,
-        resource_group_name: str,
-        network_device_name: str,
-        body: _models.UpdateVersion,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    @distributed_trace_async
+    async def begin_get_status(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> AsyncLROPoller[_models.GetDeviceStatusProperties]:
+        """Gets the running status of the network device.
 
-        Upgrades the version of the Network Device.
+        Get the running status of the Network Device.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
-        :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateVersion
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
+        :return: An instance of AsyncLROPoller that returns either GetDeviceStatusProperties or the
+         result of cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.GetDeviceStatusProperties]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    @overload
-    async def begin_upgrade(
-        self,
-        resource_group_name: str,
-        network_device_name: str,
-        body: IO,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.GetDeviceStatusProperties] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = await self._get_status_initial(
+                resource_group_name=resource_group_name,
+                network_device_name=network_device_name,
+                api_version=api_version,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):
+            response_headers = {}
+            response = pipeline_response.http_response
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+            deserialized = self._deserialize("GetDeviceStatusProperties", pipeline_response)
+            if cls:
+                return cls(pipeline_response, deserialized, response_headers)
+            return deserialized
+
+        if polling is True:
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_get_status.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/getStatus"
+    }
+
+    async def _get_static_interface_maps_initial(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> List[_models.GetStaticInterfaceMapsPropertiesItem]:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[List[_models.GetStaticInterfaceMapsPropertiesItem]] = kwargs.pop("cls", None)
+
+        request = build_get_static_interface_maps_request(
+            resource_group_name=resource_group_name,
+            network_device_name=network_device_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            template_url=self._get_static_interface_maps_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
 
-        Upgrades the version of the Network Device.
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+        deserialized = self._deserialize("[GetStaticInterfaceMapsPropertiesItem]", pipeline_response)
+
+        if cls:
+            return cls(pipeline_response, deserialized, response_headers)
+
+        return deserialized
+
+    _get_static_interface_maps_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/getStaticInterfaceMaps"
+    }
+
+    @distributed_trace_async
+    async def begin_get_static_interface_maps(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> AsyncLROPoller[List[_models.GetStaticInterfaceMapsPropertiesItem]]:
+        """Show the interface maps as per the topology.
+
+        Get the static interface maps for the given Network Device.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
-        :param body: Request payload. Required.
-        :type body: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
+        :return: An instance of AsyncLROPoller that returns either list of
+         GetStaticInterfaceMapsPropertiesItem or the result of cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+         ~azure.core.polling.AsyncLROPoller[list[~azure.mgmt.managednetworkfabric.models.GetStaticInterfaceMapsPropertiesItem]]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[List[_models.GetStaticInterfaceMapsPropertiesItem]] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = await self._get_static_interface_maps_initial(
+                resource_group_name=resource_group_name,
+                network_device_name=network_device_name,
+                api_version=api_version,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):
+            response_headers = {}
+            response = pipeline_response.http_response
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+            deserialized = self._deserialize("[GetStaticInterfaceMapsPropertiesItem]", pipeline_response)
+            if cls:
+                return cls(pipeline_response, deserialized, response_headers)
+            return deserialized
+
+        if polling is True:
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_get_static_interface_maps.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/getStaticInterfaceMaps"
+    }
+
+    async def _get_dynamic_interface_maps_initial(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> List[_models.GetDynamicInterfaceMapsPropertiesItem]:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[List[_models.GetDynamicInterfaceMapsPropertiesItem]] = kwargs.pop("cls", None)
+
+        request = build_get_dynamic_interface_maps_request(
+            resource_group_name=resource_group_name,
+            network_device_name=network_device_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            template_url=self._get_dynamic_interface_maps_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+        deserialized = self._deserialize("[GetDynamicInterfaceMapsPropertiesItem]", pipeline_response)
+
+        if cls:
+            return cls(pipeline_response, deserialized, response_headers)
+
+        return deserialized
+
+    _get_dynamic_interface_maps_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/getDynamicInterfaceMaps"
+    }
 
     @distributed_trace_async
-    async def begin_upgrade(
-        self, resource_group_name: str, network_device_name: str, body: Union[_models.UpdateVersion, IO], **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    async def begin_get_dynamic_interface_maps(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> AsyncLROPoller[List[_models.GetDynamicInterfaceMapsPropertiesItem]]:
         """Implements the operation to the underlying resources.
 
-        Upgrades the version of the Network Device.
+        Get the dynamic interface maps for the given Network Device.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
-        :param body: Request payload. Is either a UpdateVersion type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateVersion or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
+        :return: An instance of AsyncLROPoller that returns either list of
+         GetDynamicInterfaceMapsPropertiesItem or the result of cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+         ~azure.core.polling.AsyncLROPoller[list[~azure.mgmt.managednetworkfabric.models.GetDynamicInterfaceMapsPropertiesItem]]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[List[_models.GetDynamicInterfaceMapsPropertiesItem]] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._upgrade_initial(
+            raw_result = await self._get_dynamic_interface_maps_initial(
                 resource_group_name=resource_group_name,
                 network_device_name=network_device_name,
-                body=body,
                 api_version=api_version,
-                content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+            response_headers = {}
+            response = pipeline_response.http_response
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+            deserialized = self._deserialize("[GetDynamicInterfaceMapsPropertiesItem]", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})
+                return cls(pipeline_response, deserialized, response_headers)
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
@@ -1729,10 +2113,10 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_upgrade.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/upgrade"
+    begin_get_dynamic_interface_maps.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/getDynamicInterfaceMaps"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_internet_gateway_rules_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_racks_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -27,79 +27,75 @@
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._internet_gateway_rules_operations import (
+from ...operations._network_racks_operations import (
     build_create_request,
     build_delete_request,
     build_get_request,
     build_list_by_resource_group_request,
     build_list_by_subscription_request,
     build_update_request,
 )
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class InternetGatewayRulesOperations:
+class NetworkRacksOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.managednetworkfabric.aio.ManagedNetworkFabricMgmtClient`'s
-        :attr:`internet_gateway_rules` attribute.
+        :attr:`network_racks` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     async def _create_initial(
-        self,
-        resource_group_name: str,
-        internet_gateway_rule_name: str,
-        body: Union[_models.InternetGatewayRule, IO],
-        **kwargs: Any
-    ) -> _models.InternetGatewayRule:
+        self, resource_group_name: str, network_rack_name: str, body: Union[_models.NetworkRack, IO], **kwargs: Any
+    ) -> _models.NetworkRack:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.InternetGatewayRule] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkRack] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "InternetGatewayRule")
+            _json = self._serialize.body(body, "NetworkRack")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            internet_gateway_rule_name=internet_gateway_rule_name,
+            network_rack_name=network_rack_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
@@ -116,173 +112,161 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("InternetGatewayRule", pipeline_response)
+            deserialized = self._deserialize("NetworkRack", pipeline_response)
 
         if response.status_code == 201:
-            response_headers["Azure-AsyncOperation"] = self._deserialize(
-                "str", response.headers.get("Azure-AsyncOperation")
-            )
-
-            deserialized = self._deserialize("InternetGatewayRule", pipeline_response)
+            deserialized = self._deserialize("NetworkRack", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules/{internetGatewayRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
     }
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
-        internet_gateway_rule_name: str,
-        body: _models.InternetGatewayRule,
+        network_rack_name: str,
+        body: _models.NetworkRack,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.InternetGatewayRule]:
-        """Creates an Internet Gateway rule.
+    ) -> AsyncLROPoller[_models.NetworkRack]:
+        """Create Network Rack.
 
-        Creates an Internet Gateway rule resource.
+        Create Network Rack resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param internet_gateway_rule_name: Name of the Internet Gateway rule. Required.
-        :type internet_gateway_rule_name: str
+        :param network_rack_name: Name of the Network Rack. Required.
+        :type network_rack_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.InternetGatewayRule
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkRack
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either InternetGatewayRule or the result of
+        :return: An instance of AsyncLROPoller that returns either NetworkRack or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.InternetGatewayRule]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
-        internet_gateway_rule_name: str,
+        network_rack_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.InternetGatewayRule]:
-        """Creates an Internet Gateway rule.
+    ) -> AsyncLROPoller[_models.NetworkRack]:
+        """Create Network Rack.
 
-        Creates an Internet Gateway rule resource.
+        Create Network Rack resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param internet_gateway_rule_name: Name of the Internet Gateway rule. Required.
-        :type internet_gateway_rule_name: str
+        :param network_rack_name: Name of the Network Rack. Required.
+        :type network_rack_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either InternetGatewayRule or the result of
+        :return: An instance of AsyncLROPoller that returns either NetworkRack or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.InternetGatewayRule]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create(
-        self,
-        resource_group_name: str,
-        internet_gateway_rule_name: str,
-        body: Union[_models.InternetGatewayRule, IO],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.InternetGatewayRule]:
-        """Creates an Internet Gateway rule.
+        self, resource_group_name: str, network_rack_name: str, body: Union[_models.NetworkRack, IO], **kwargs: Any
+    ) -> AsyncLROPoller[_models.NetworkRack]:
+        """Create Network Rack.
 
-        Creates an Internet Gateway rule resource.
+        Create Network Rack resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param internet_gateway_rule_name: Name of the Internet Gateway rule. Required.
-        :type internet_gateway_rule_name: str
-        :param body: Request payload. Is either a InternetGatewayRule type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.InternetGatewayRule or IO
+        :param network_rack_name: Name of the Network Rack. Required.
+        :type network_rack_name: str
+        :param body: Request payload. Is either a NetworkRack type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkRack or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either InternetGatewayRule or the result of
+        :return: An instance of AsyncLROPoller that returns either NetworkRack or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.InternetGatewayRule]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.InternetGatewayRule] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkRack] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
                 resource_group_name=resource_group_name,
-                internet_gateway_rule_name=internet_gateway_rule_name,
+                network_rack_name=network_rack_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("InternetGatewayRule", pipeline_response)
+            deserialized = self._deserialize("NetworkRack", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
@@ -298,52 +282,50 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules/{internetGatewayRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
     }
 
     @distributed_trace_async
-    async def get(
-        self, resource_group_name: str, internet_gateway_rule_name: str, **kwargs: Any
-    ) -> _models.InternetGatewayRule:
-        """Gets an Internet Gateway Rule.
+    async def get(self, resource_group_name: str, network_rack_name: str, **kwargs: Any) -> _models.NetworkRack:
+        """Gets a Network Rack.
 
-        Gets an Internet Gateway Rule resource.
+        Get Network Rack resource details.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param internet_gateway_rule_name: Name of the Internet Gateway rule. Required.
-        :type internet_gateway_rule_name: str
+        :param network_rack_name: Name of the Network Rack. Required.
+        :type network_rack_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: InternetGatewayRule or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.InternetGatewayRule
+        :return: NetworkRack or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkRack
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.InternetGatewayRule] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkRack] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            internet_gateway_rule_name=internet_gateway_rule_name,
+            network_rack_name=network_rack_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -357,58 +339,54 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("InternetGatewayRule", pipeline_response)
+        deserialized = self._deserialize("NetworkRack", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules/{internetGatewayRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
     }
 
     async def _update_initial(
-        self,
-        resource_group_name: str,
-        internet_gateway_rule_name: str,
-        body: Union[_models.InternetGatewayRulePatch, IO],
-        **kwargs: Any
-    ) -> Optional[_models.InternetGatewayRule]:
+        self, resource_group_name: str, network_rack_name: str, body: Union[_models.NetworkRackPatch, IO], **kwargs: Any
+    ) -> Optional[_models.NetworkRack]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.InternetGatewayRule]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.NetworkRack]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "InternetGatewayRulePatch")
+            _json = self._serialize.body(body, "NetworkRackPatch")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            internet_gateway_rule_name=internet_gateway_rule_name,
+            network_rack_name=network_rack_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
@@ -428,168 +406,163 @@
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("InternetGatewayRule", pipeline_response)
+            deserialized = self._deserialize("NetworkRack", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules/{internetGatewayRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
     }
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
-        internet_gateway_rule_name: str,
-        body: _models.InternetGatewayRulePatch,
+        network_rack_name: str,
+        body: _models.NetworkRackPatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.InternetGatewayRule]:
-        """Updates an Internet Gateway Rule.
+    ) -> AsyncLROPoller[_models.NetworkRack]:
+        """Updates a Network Rack.
 
-        API to update certain properties of the Internet Gateway Rule resource.
+        Update certain properties of the Network Rack resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param internet_gateway_rule_name: Name of the Internet Gateway rule. Required.
-        :type internet_gateway_rule_name: str
-        :param body: Internet Gateway Rule properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.InternetGatewayRulePatch
+        :param network_rack_name: Name of the Network Rack. Required.
+        :type network_rack_name: str
+        :param body: Network Rack properties to update. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkRackPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either InternetGatewayRule or the result of
+        :return: An instance of AsyncLROPoller that returns either NetworkRack or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.InternetGatewayRule]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
-        internet_gateway_rule_name: str,
+        network_rack_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.InternetGatewayRule]:
-        """Updates an Internet Gateway Rule.
+    ) -> AsyncLROPoller[_models.NetworkRack]:
+        """Updates a Network Rack.
 
-        API to update certain properties of the Internet Gateway Rule resource.
+        Update certain properties of the Network Rack resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param internet_gateway_rule_name: Name of the Internet Gateway rule. Required.
-        :type internet_gateway_rule_name: str
-        :param body: Internet Gateway Rule properties to update. Required.
+        :param network_rack_name: Name of the Network Rack. Required.
+        :type network_rack_name: str
+        :param body: Network Rack properties to update. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either InternetGatewayRule or the result of
+        :return: An instance of AsyncLROPoller that returns either NetworkRack or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.InternetGatewayRule]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update(
-        self,
-        resource_group_name: str,
-        internet_gateway_rule_name: str,
-        body: Union[_models.InternetGatewayRulePatch, IO],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.InternetGatewayRule]:
-        """Updates an Internet Gateway Rule.
+        self, resource_group_name: str, network_rack_name: str, body: Union[_models.NetworkRackPatch, IO], **kwargs: Any
+    ) -> AsyncLROPoller[_models.NetworkRack]:
+        """Updates a Network Rack.
 
-        API to update certain properties of the Internet Gateway Rule resource.
+        Update certain properties of the Network Rack resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param internet_gateway_rule_name: Name of the Internet Gateway rule. Required.
-        :type internet_gateway_rule_name: str
-        :param body: Internet Gateway Rule properties to update. Is either a InternetGatewayRulePatch
-         type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.InternetGatewayRulePatch or IO
+        :param network_rack_name: Name of the Network Rack. Required.
+        :type network_rack_name: str
+        :param body: Network Rack properties to update. Is either a NetworkRackPatch type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkRackPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either InternetGatewayRule or the result of
+        :return: An instance of AsyncLROPoller that returns either NetworkRack or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.InternetGatewayRule]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.InternetGatewayRule] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkRack] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
                 resource_group_name=resource_group_name,
-                internet_gateway_rule_name=internet_gateway_rule_name,
+                network_rack_name=network_rack_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("InternetGatewayRule", pipeline_response)
+            deserialized = self._deserialize("NetworkRack", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
@@ -604,19 +577,19 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules/{internetGatewayRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
     }
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, internet_gateway_rule_name: str, **kwargs: Any
+        self, resource_group_name: str, network_rack_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -626,15 +599,15 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            internet_gateway_rule_name=internet_gateway_rule_name,
+            network_rack_name=network_rack_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -648,40 +621,34 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Azure-AsyncOperation"] = self._deserialize(
-                "str", response.headers.get("Azure-AsyncOperation")
-            )
-
         if cls:
-            return cls(pipeline_response, None, response_headers)
+            return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules/{internetGatewayRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
     }
 
     @distributed_trace_async
     async def begin_delete(
-        self, resource_group_name: str, internet_gateway_rule_name: str, **kwargs: Any
+        self, resource_group_name: str, network_rack_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
-        """Deletes an Internet Gateway Rule.
+        """Deletes a Network Rack.
 
-        Implements Internet Gateway Rules DELETE method.
+        Delete Network Rack resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param internet_gateway_rule_name: Name of the Internet Gateway rule. Required.
-        :type internet_gateway_rule_name: str
+        :param network_rack_name: Name of the Network Rack. Required.
+        :type network_rack_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
@@ -697,15 +664,15 @@
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                internet_gateway_rule_name=internet_gateway_rule_name,
+                network_rack_name=network_rack_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
@@ -728,39 +695,37 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules/{internetGatewayRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
     }
 
     @distributed_trace
-    def list_by_resource_group(
-        self, resource_group_name: str, **kwargs: Any
-    ) -> AsyncIterable["_models.InternetGatewayRule"]:
-        """List Internet Gateway Rules by resource group.
+    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.NetworkRack"]:
+        """List NetworkRacks by resource group.
 
-        Implements Internet Gateway Rules list by resource group GET method.
+        List all Network Rack resources in the given resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either InternetGatewayRule or the result of cls(response)
+        :return: An iterator like instance of either NetworkRack or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.InternetGatewayRule]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.InternetGatewayRulesListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkRacksListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -795,15 +760,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("InternetGatewayRulesListResult", pipeline_response)
+            deserialized = self._deserialize("NetworkRacksListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -820,34 +785,34 @@
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks"
     }
 
     @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.InternetGatewayRule"]:
-        """List Internet Gateway Rules by subscription.
+    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.NetworkRack"]:
+        """List NetworkRacks by subscription.
 
-        List all Internet Gateway rules in the given subscription.
+        List all Network Rack resources in the given subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either InternetGatewayRule or the result of cls(response)
+        :return: An iterator like instance of either NetworkRack or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.InternetGatewayRule]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.InternetGatewayRulesListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkRacksListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -881,15 +846,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("InternetGatewayRulesListResult", pipeline_response)
+            deserialized = self._deserialize("NetworkRacksListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -906,9 +871,9 @@
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules"
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkRacks"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_ip_prefixes_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_ip_prefixes_operations.py`

 * *Files 0% similar despite different names*

```diff
@@ -414,15 +414,17 @@
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("IpPrefix", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
@@ -619,15 +621,15 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 202:
             response_headers["Azure-AsyncOperation"] = self._deserialize(
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_racks_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_fabrics_operations.py`

 * *Files 16% similar despite different names*

```diff
@@ -27,75 +27,77 @@
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._network_racks_operations import (
+from ...operations._network_fabrics_operations import (
     build_create_request,
     build_delete_request,
+    build_deprovision_request,
     build_get_request,
     build_list_by_resource_group_request,
     build_list_by_subscription_request,
+    build_provision_request,
     build_update_request,
 )
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class NetworkRacksOperations:
+class NetworkFabricsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.managednetworkfabric.aio.ManagedNetworkFabricMgmtClient`'s
-        :attr:`network_racks` attribute.
+        :attr:`network_fabrics` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     async def _create_initial(
-        self, resource_group_name: str, network_rack_name: str, body: Union[_models.NetworkRack, IO], **kwargs: Any
-    ) -> _models.NetworkRack:
+        self, resource_group_name: str, network_fabric_name: str, body: Union[_models.NetworkFabric, IO], **kwargs: Any
+    ) -> _models.NetworkFabric:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkRack] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabric] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkRack")
+            _json = self._serialize.body(body, "NetworkFabric")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            network_rack_name=network_rack_name,
+            network_fabric_name=network_fabric_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
@@ -112,161 +114,169 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkRack", pipeline_response)
+            deserialized = self._deserialize("NetworkFabric", pipeline_response)
 
         if response.status_code == 201:
-            deserialized = self._deserialize("NetworkRack", pipeline_response)
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
+            deserialized = self._deserialize("NetworkFabric", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
     }
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
-        network_rack_name: str,
-        body: _models.NetworkRack,
+        network_fabric_name: str,
+        body: _models.NetworkFabric,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkRack]:
-        """Create Network Rack.
+    ) -> AsyncLROPoller[_models.NetworkFabric]:
+        """Create Network Fabric.
 
-        Create Network Rack resource.
+        Create Network Fabric resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_rack_name: Name of the Network Rack. Required.
-        :type network_rack_name: str
+        :param network_fabric_name: Name of the Network Fabric. Required.
+        :type network_fabric_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkRack
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabric
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkRack or the result of
+        :return: An instance of AsyncLROPoller that returns either NetworkFabric or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
+        :rtype:
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
-        network_rack_name: str,
+        network_fabric_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkRack]:
-        """Create Network Rack.
+    ) -> AsyncLROPoller[_models.NetworkFabric]:
+        """Create Network Fabric.
 
-        Create Network Rack resource.
+        Create Network Fabric resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_rack_name: Name of the Network Rack. Required.
-        :type network_rack_name: str
+        :param network_fabric_name: Name of the Network Fabric. Required.
+        :type network_fabric_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkRack or the result of
+        :return: An instance of AsyncLROPoller that returns either NetworkFabric or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
+        :rtype:
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create(
-        self, resource_group_name: str, network_rack_name: str, body: Union[_models.NetworkRack, IO], **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkRack]:
-        """Create Network Rack.
+        self, resource_group_name: str, network_fabric_name: str, body: Union[_models.NetworkFabric, IO], **kwargs: Any
+    ) -> AsyncLROPoller[_models.NetworkFabric]:
+        """Create Network Fabric.
 
-        Create Network Rack resource.
+        Create Network Fabric resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_rack_name: Name of the Network Rack. Required.
-        :type network_rack_name: str
-        :param body: Request payload. Is either a NetworkRack type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkRack or IO
+        :param network_fabric_name: Name of the Network Fabric. Required.
+        :type network_fabric_name: str
+        :param body: Request payload. Is either a NetworkFabric type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabric or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkRack or the result of
+        :return: An instance of AsyncLROPoller that returns either NetworkFabric or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
+        :rtype:
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkRack] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabric] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
                 resource_group_name=resource_group_name,
-                network_rack_name=network_rack_name,
+                network_fabric_name=network_fabric_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkRack", pipeline_response)
+            deserialized = self._deserialize("NetworkFabric", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
@@ -282,50 +292,50 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
     }
 
     @distributed_trace_async
-    async def get(self, resource_group_name: str, network_rack_name: str, **kwargs: Any) -> _models.NetworkRack:
-        """Gets a Network Rack.
+    async def get(self, resource_group_name: str, network_fabric_name: str, **kwargs: Any) -> _models.NetworkFabric:
+        """Gets a Network Fabric.
 
-        Get Network Rack resource details.
+        Get Network Fabric resource details.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_rack_name: Name of the Network Rack. Required.
-        :type network_rack_name: str
+        :param network_fabric_name: Name of the Network Fabric. Required.
+        :type network_fabric_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NetworkRack or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkRack
+        :return: NetworkFabric or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkFabric
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkRack] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabric] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            network_rack_name=network_rack_name,
+            network_fabric_name=network_fabric_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -339,54 +349,58 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("NetworkRack", pipeline_response)
+        deserialized = self._deserialize("NetworkFabric", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
     }
 
     async def _update_initial(
-        self, resource_group_name: str, network_rack_name: str, body: Union[_models.TagsUpdate, IO], **kwargs: Any
-    ) -> Optional[_models.NetworkRack]:
+        self,
+        resource_group_name: str,
+        network_fabric_name: str,
+        body: Union[_models.NetworkFabricPatchParameters, IO],
+        **kwargs: Any
+    ) -> Optional[_models.NetworkFabric]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.NetworkRack]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.NetworkFabric]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "TagsUpdate")
+            _json = self._serialize.body(body, "NetworkFabricPatchParameters")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            network_rack_name=network_rack_name,
+            network_fabric_name=network_fabric_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
@@ -406,161 +420,168 @@
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkRack", pipeline_response)
+            deserialized = self._deserialize("NetworkFabric", pipeline_response)
 
         if response.status_code == 202:
             response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
     }
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
-        network_rack_name: str,
-        body: _models.TagsUpdate,
+        network_fabric_name: str,
+        body: _models.NetworkFabricPatchParameters,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkRack]:
-        """Updates a Network Rack.
+    ) -> AsyncLROPoller[_models.NetworkFabric]:
+        """Updates a Network Fabric.
 
-        Update certain properties of the Network Rack resource.
+        Update certain properties of the Network Fabric resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_rack_name: Name of the Network Rack. Required.
-        :type network_rack_name: str
-        :param body: Network Rack properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.TagsUpdate
+        :param network_fabric_name: Name of the Network Fabric. Required.
+        :type network_fabric_name: str
+        :param body: Network Fabric properties to update. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricPatchParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkRack or the result of
+        :return: An instance of AsyncLROPoller that returns either NetworkFabric or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
+        :rtype:
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
-        network_rack_name: str,
+        network_fabric_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkRack]:
-        """Updates a Network Rack.
+    ) -> AsyncLROPoller[_models.NetworkFabric]:
+        """Updates a Network Fabric.
 
-        Update certain properties of the Network Rack resource.
+        Update certain properties of the Network Fabric resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_rack_name: Name of the Network Rack. Required.
-        :type network_rack_name: str
-        :param body: Network Rack properties to update. Required.
+        :param network_fabric_name: Name of the Network Fabric. Required.
+        :type network_fabric_name: str
+        :param body: Network Fabric properties to update. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkRack or the result of
+        :return: An instance of AsyncLROPoller that returns either NetworkFabric or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
+        :rtype:
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update(
-        self, resource_group_name: str, network_rack_name: str, body: Union[_models.TagsUpdate, IO], **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkRack]:
-        """Updates a Network Rack.
+        self,
+        resource_group_name: str,
+        network_fabric_name: str,
+        body: Union[_models.NetworkFabricPatchParameters, IO],
+        **kwargs: Any
+    ) -> AsyncLROPoller[_models.NetworkFabric]:
+        """Updates a Network Fabric.
 
-        Update certain properties of the Network Rack resource.
+        Update certain properties of the Network Fabric resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_rack_name: Name of the Network Rack. Required.
-        :type network_rack_name: str
-        :param body: Network Rack properties to update. Is either a TagsUpdate type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.TagsUpdate or IO
+        :param network_fabric_name: Name of the Network Fabric. Required.
+        :type network_fabric_name: str
+        :param body: Network Fabric properties to update. Is either a NetworkFabricPatchParameters type
+         or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricPatchParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkRack or the result of
+        :return: An instance of AsyncLROPoller that returns either NetworkFabric or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
+        :rtype:
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkRack] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabric] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
                 resource_group_name=resource_group_name,
-                network_rack_name=network_rack_name,
+                network_fabric_name=network_fabric_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkRack", pipeline_response)
+            deserialized = self._deserialize("NetworkFabric", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
@@ -575,19 +596,19 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
     }
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, network_rack_name: str, **kwargs: Any
+        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -597,15 +618,15 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            network_rack_name=network_rack_name,
+            network_fabric_name=network_fabric_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -614,39 +635,43 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
     }
 
     @distributed_trace_async
     async def begin_delete(
-        self, resource_group_name: str, network_rack_name: str, **kwargs: Any
+        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
-        """Deletes a Network Rack.
+        """Deletes a Network Fabric.
 
-        Delete Network Rack resource.
+        Delete Network Fabric resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_rack_name: Name of the Network Rack. Required.
-        :type network_rack_name: str
+        :param network_fabric_name: Name of the Network Fabric. Required.
+        :type network_fabric_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
@@ -662,15 +687,15 @@
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_rack_name=network_rack_name,
+                network_fabric_name=network_fabric_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
@@ -693,37 +718,37 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
     }
 
     @distributed_trace
-    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.NetworkRack"]:
-        """List Network Racks by resource group.
+    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.NetworkFabric"]:
+        """List NetworkFabrics by resource group.
 
-        List all Network Rack resources in the given resource group.
+        List all the Network Fabric resources in the given resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkRack or the result of cls(response)
+        :return: An iterator like instance of either NetworkFabric or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkRack]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkRacksListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabricsListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -758,15 +783,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkRacksListResult", pipeline_response)
+            deserialized = self._deserialize("NetworkFabricsListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -783,34 +808,34 @@
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics"
     }
 
     @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.NetworkRack"]:
-        """List Network Racks by subscription.
+    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.NetworkFabric"]:
+        """List NetworkFabrics by subscription.
 
-        List all Network Rack resources in the given subscription.
+        List all the Network Fabric resources in the given subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkRack or the result of cls(response)
+        :return: An iterator like instance of either NetworkFabric or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkRack]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkRacksListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabricsListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -844,15 +869,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkRacksListResult", pipeline_response)
+            deserialized = self._deserialize("NetworkFabricsListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -869,9 +894,251 @@
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkRacks"
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabrics"
+    }
+
+    async def _provision_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        request = build_provision_request(
+            resource_group_name=resource_group_name,
+            network_fabric_name=network_fabric_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            template_url=self._provision_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    _provision_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/provision"
+    }
+
+    @distributed_trace_async
+    async def begin_provision(
+        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
+
+        Provisions the underlying resources in the given Network Fabric instance.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param network_fabric_name: Name of the NetworkFabric. Required.
+        :type network_fabric_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = await self._provision_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                network_fabric_name=network_fabric_name,
+                api_version=api_version,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
+
+        if polling is True:
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_provision.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/provision"
+    }
+
+    async def _deprovision_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        request = build_deprovision_request(
+            resource_group_name=resource_group_name,
+            network_fabric_name=network_fabric_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            template_url=self._deprovision_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    _deprovision_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/deprovision"
+    }
+
+    @distributed_trace_async
+    async def begin_deprovision(
+        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
+
+        Deprovisions the underlying resources in the given Network Fabric instance.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param network_fabric_name: Name of the NetworkFabric. Required.
+        :type network_fabric_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = await self._deprovision_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                network_fabric_name=network_fabric_name,
+                api_version=api_version,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
+
+        if polling is True:
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_deprovision.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/deprovision"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_packet_brokers_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_ip_communities_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,615 +3,786 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 from io import IOBase
-from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
+from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
-from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
+from azure.core.pipeline.transport import HttpResponse
+from azure.core.polling import LROPoller, NoPolling, PollingMethod
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
-from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
+from azure.mgmt.core.polling.arm_polling import ARMPolling
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._network_packet_brokers_operations import (
-    build_create_request,
-    build_delete_request,
-    build_get_request,
-    build_list_by_resource_group_request,
-    build_list_by_subscription_request,
-    build_update_request,
-)
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request, _format_url_section
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_create_request(
+    resource_group_name: str, ip_community_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "ipCommunityName": _SERIALIZER.url("ip_community_name", ip_community_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_get_request(
+    resource_group_name: str, ip_community_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "ipCommunityName": _SERIALIZER.url("ip_community_name", ip_community_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_update_request(
+    resource_group_name: str, ip_community_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "ipCommunityName": _SERIALIZER.url("ip_community_name", ip_community_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_delete_request(
+    resource_group_name: str, ip_community_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "ipCommunityName": _SERIALIZER.url("ip_community_name", ip_community_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/ipCommunities"
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
 
-class NetworkPacketBrokersOperations:
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class IpCommunitiesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.managednetworkfabric.aio.ManagedNetworkFabricMgmtClient`'s
-        :attr:`network_packet_brokers` attribute.
+        :class:`~azure.mgmt.managednetworkfabric.ManagedNetworkFabricMgmtClient`'s
+        :attr:`ip_communities` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    async def _create_initial(
-        self,
-        resource_group_name: str,
-        network_packet_broker_name: str,
-        body: Union[_models.NetworkPacketBroker, IO],
-        **kwargs: Any
-    ) -> _models.NetworkPacketBroker:
+    def _create_initial(
+        self, resource_group_name: str, ip_community_name: str, body: Union[_models.IpCommunity, IO], **kwargs: Any
+    ) -> _models.IpCommunity:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkPacketBroker] = kwargs.pop("cls", None)
+        cls: ClsType[_models.IpCommunity] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkPacketBroker")
+            _json = self._serialize.body(body, "IpCommunity")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            network_packet_broker_name=network_packet_broker_name,
+            ip_community_name=ip_community_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkPacketBroker", pipeline_response)
+            deserialized = self._deserialize("IpCommunity", pipeline_response)
 
         if response.status_code == 201:
-            deserialized = self._deserialize("NetworkPacketBroker", pipeline_response)
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
+            deserialized = self._deserialize("IpCommunity", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers/{networkPacketBrokerName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}"
     }
 
     @overload
-    async def begin_create(
+    def begin_create(
         self,
         resource_group_name: str,
-        network_packet_broker_name: str,
-        body: _models.NetworkPacketBroker,
+        ip_community_name: str,
+        body: _models.IpCommunity,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkPacketBroker]:
-        """Create Network Packet Broker.
+    ) -> LROPoller[_models.IpCommunity]:
+        """Create an IP Community.
 
-        Creates a Network Packet Broker.
+        Implements an IP Community PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_packet_broker_name: Name of the Network Packet Broker. Required.
-        :type network_packet_broker_name: str
+        :param ip_community_name: Name of the IP Community. Required.
+        :type ip_community_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkPacketBroker
+        :type body: ~azure.mgmt.managednetworkfabric.models.IpCommunity
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkPacketBroker or the result of
+        :return: An instance of LROPoller that returns either IpCommunity or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkPacketBroker]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_create(
+    def begin_create(
         self,
         resource_group_name: str,
-        network_packet_broker_name: str,
+        ip_community_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkPacketBroker]:
-        """Create Network Packet Broker.
+    ) -> LROPoller[_models.IpCommunity]:
+        """Create an IP Community.
 
-        Creates a Network Packet Broker.
+        Implements an IP Community PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_packet_broker_name: Name of the Network Packet Broker. Required.
-        :type network_packet_broker_name: str
+        :param ip_community_name: Name of the IP Community. Required.
+        :type ip_community_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkPacketBroker or the result of
+        :return: An instance of LROPoller that returns either IpCommunity or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkPacketBroker]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_create(
-        self,
-        resource_group_name: str,
-        network_packet_broker_name: str,
-        body: Union[_models.NetworkPacketBroker, IO],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkPacketBroker]:
-        """Create Network Packet Broker.
+    @distributed_trace
+    def begin_create(
+        self, resource_group_name: str, ip_community_name: str, body: Union[_models.IpCommunity, IO], **kwargs: Any
+    ) -> LROPoller[_models.IpCommunity]:
+        """Create an IP Community.
 
-        Creates a Network Packet Broker.
+        Implements an IP Community PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_packet_broker_name: Name of the Network Packet Broker. Required.
-        :type network_packet_broker_name: str
-        :param body: Request payload. Is either a NetworkPacketBroker type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkPacketBroker or IO
+        :param ip_community_name: Name of the IP Community. Required.
+        :type ip_community_name: str
+        :param body: Request payload. Is either a IpCommunity type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.IpCommunity or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkPacketBroker or the result of
+        :return: An instance of LROPoller that returns either IpCommunity or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkPacketBroker]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkPacketBroker] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[_models.IpCommunity] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._create_initial(
+            raw_result = self._create_initial(
                 resource_group_name=resource_group_name,
-                network_packet_broker_name=network_packet_broker_name,
+                ip_community_name=ip_community_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkPacketBroker", pipeline_response)
+            deserialized = self._deserialize("IpCommunity", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers/{networkPacketBrokerName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}"
     }
 
-    @distributed_trace_async
-    async def get(
-        self, resource_group_name: str, network_packet_broker_name: str, **kwargs: Any
-    ) -> _models.NetworkPacketBroker:
-        """Gets a Network Packet Broker.
+    @distributed_trace
+    def get(self, resource_group_name: str, ip_community_name: str, **kwargs: Any) -> _models.IpCommunity:
+        """Gets an IP Community.
 
-        Retrieves details of this Network Packet Broker.
+        Implements an IP Community GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_packet_broker_name: Name of the Network Packet Broker. Required.
-        :type network_packet_broker_name: str
+        :param ip_community_name: Name of the IP Community. Required.
+        :type ip_community_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NetworkPacketBroker or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkPacketBroker
+        :return: IpCommunity or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.IpCommunity
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkPacketBroker] = kwargs.pop("cls", None)
+        cls: ClsType[_models.IpCommunity] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            network_packet_broker_name=network_packet_broker_name,
+            ip_community_name=ip_community_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("NetworkPacketBroker", pipeline_response)
+        deserialized = self._deserialize("IpCommunity", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers/{networkPacketBrokerName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}"
     }
 
-    async def _update_initial(
-        self,
-        resource_group_name: str,
-        network_packet_broker_name: str,
-        body: Union[_models.NetworkPacketBrokerPatch, IO],
-        **kwargs: Any
-    ) -> Optional[_models.NetworkPacketBroker]:
+    def _update_initial(
+        self, resource_group_name: str, ip_community_name: str, body: Union[_models.IpCommunityPatch, IO], **kwargs: Any
+    ) -> Optional[_models.IpCommunity]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.NetworkPacketBroker]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.IpCommunity]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkPacketBrokerPatch")
+            _json = self._serialize.body(body, "IpCommunityPatch")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            network_packet_broker_name=network_packet_broker_name,
+            ip_community_name=ip_community_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkPacketBroker", pipeline_response)
+            deserialized = self._deserialize("IpCommunity", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers/{networkPacketBrokerName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}"
     }
 
     @overload
-    async def begin_update(
+    def begin_update(
         self,
         resource_group_name: str,
-        network_packet_broker_name: str,
-        body: _models.NetworkPacketBrokerPatch,
+        ip_community_name: str,
+        body: _models.IpCommunityPatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkPacketBroker]:
-        """Updates the Network Packet Broker.
+    ) -> LROPoller[_models.IpCommunity]:
+        """Updates an IP Community.
 
-        API to update certain properties of the Network Packet Broker resource.
+        API to update certain properties of the IP Community resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_packet_broker_name: Name of the Network Packet Broker. Required.
-        :type network_packet_broker_name: str
-        :param body: Network Packet Broker properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkPacketBrokerPatch
+        :param ip_community_name: Name of the IP Community. Required.
+        :type ip_community_name: str
+        :param body: IP Community properties to update. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.IpCommunityPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkPacketBroker or the result of
+        :return: An instance of LROPoller that returns either IpCommunity or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkPacketBroker]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_update(
+    def begin_update(
         self,
         resource_group_name: str,
-        network_packet_broker_name: str,
+        ip_community_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkPacketBroker]:
-        """Updates the Network Packet Broker.
+    ) -> LROPoller[_models.IpCommunity]:
+        """Updates an IP Community.
 
-        API to update certain properties of the Network Packet Broker resource.
+        API to update certain properties of the IP Community resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_packet_broker_name: Name of the Network Packet Broker. Required.
-        :type network_packet_broker_name: str
-        :param body: Network Packet Broker properties to update. Required.
+        :param ip_community_name: Name of the IP Community. Required.
+        :type ip_community_name: str
+        :param body: IP Community properties to update. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkPacketBroker or the result of
+        :return: An instance of LROPoller that returns either IpCommunity or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkPacketBroker]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_update(
-        self,
-        resource_group_name: str,
-        network_packet_broker_name: str,
-        body: Union[_models.NetworkPacketBrokerPatch, IO],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkPacketBroker]:
-        """Updates the Network Packet Broker.
+    @distributed_trace
+    def begin_update(
+        self, resource_group_name: str, ip_community_name: str, body: Union[_models.IpCommunityPatch, IO], **kwargs: Any
+    ) -> LROPoller[_models.IpCommunity]:
+        """Updates an IP Community.
 
-        API to update certain properties of the Network Packet Broker resource.
+        API to update certain properties of the IP Community resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_packet_broker_name: Name of the Network Packet Broker. Required.
-        :type network_packet_broker_name: str
-        :param body: Network Packet Broker properties to update. Is either a NetworkPacketBrokerPatch
-         type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkPacketBrokerPatch or IO
+        :param ip_community_name: Name of the IP Community. Required.
+        :type ip_community_name: str
+        :param body: IP Community properties to update. Is either a IpCommunityPatch type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.IpCommunityPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkPacketBroker or the result of
+        :return: An instance of LROPoller that returns either IpCommunity or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkPacketBroker]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkPacketBroker] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[_models.IpCommunity] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_initial(
+            raw_result = self._update_initial(
                 resource_group_name=resource_group_name,
-                network_packet_broker_name=network_packet_broker_name,
+                ip_community_name=ip_community_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkPacketBroker", pipeline_response)
+            deserialized = self._deserialize("IpCommunity", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers/{networkPacketBrokerName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}"
     }
 
-    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, network_packet_broker_name: str, **kwargs: Any
+    def _delete_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, ip_community_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -621,135 +792,136 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            network_packet_broker_name=network_packet_broker_name,
+            ip_community_name=ip_community_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers/{networkPacketBrokerName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}"
     }
 
-    @distributed_trace_async
-    async def begin_delete(
-        self, resource_group_name: str, network_packet_broker_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[None]:
-        """Deletes a Network Packet Broker.
+    @distributed_trace
+    def begin_delete(self, resource_group_name: str, ip_community_name: str, **kwargs: Any) -> LROPoller[None]:
+        """Deletes an IP Community.
 
-        Deletes Network Packet Broker.
+        Implements IP Community DELETE method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_packet_broker_name: Name of the Network Packet Broker. Required.
-        :type network_packet_broker_name: str
+        :param ip_community_name: Name of the IP Community. Required.
+        :type ip_community_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._delete_initial(  # type: ignore
+            raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_packet_broker_name=network_packet_broker_name,
+                ip_community_name=ip_community_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers/{networkPacketBrokerName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}"
     }
 
     @distributed_trace
-    def list_by_resource_group(
-        self, resource_group_name: str, **kwargs: Any
-    ) -> AsyncIterable["_models.NetworkPacketBroker"]:
-        """List all Network Packet Brokers under resource group.
+    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.IpCommunity"]:
+        """List IpCommunities by resource group.
 
-        Displays NetworkPacketBrokers list by resource group GET method.
+        Implements IpCommunities list by resource group GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkPacketBroker or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkPacketBroker]
+        :return: An iterator like instance of either IpCommunity or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.IpCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkPacketBrokersListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.IpCommunitiesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -783,60 +955,59 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkPacketBrokersListResult", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("IpCommunitiesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
     list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities"
     }
 
     @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.NetworkPacketBroker"]:
-        """List Network Packet Brokers by subscription.
+    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.IpCommunity"]:
+        """List IpCommunities by subscription.
 
-        Displays Network Packet Brokers list by subscription GET method.
+        Implements IpCommunities list by subscription GET method.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkPacketBroker or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkPacketBroker]
+        :return: An iterator like instance of either IpCommunity or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.IpCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkPacketBrokersListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.IpCommunitiesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -869,35 +1040,35 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkPacketBrokersListResult", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("IpCommunitiesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
     list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers"
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/ipCommunities"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_to_network_interconnects_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_interfaces_operations.py`

 * *Files 20% similar despite different names*

```diff
@@ -27,82 +27,82 @@
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._network_to_network_interconnects_operations import (
+from ...operations._network_interfaces_operations import (
     build_create_request,
     build_delete_request,
     build_get_request,
-    build_list_by_network_fabric_request,
+    build_get_status_request,
+    build_list_request,
     build_update_administrative_state_request,
-    build_update_npb_static_route_bfd_administrative_state_request,
     build_update_request,
 )
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class NetworkToNetworkInterconnectsOperations:
+class NetworkInterfacesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.managednetworkfabric.aio.ManagedNetworkFabricMgmtClient`'s
-        :attr:`network_to_network_interconnects` attribute.
+        :attr:`network_interfaces` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     async def _create_initial(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
-        body: Union[_models.NetworkToNetworkInterconnect, IO],
+        network_device_name: str,
+        network_interface_name: str,
+        body: Union[_models.NetworkInterface, IO],
         **kwargs: Any
-    ) -> _models.NetworkToNetworkInterconnect:
+    ) -> _models.NetworkInterface:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkToNetworkInterconnect] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkInterface] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkToNetworkInterconnect")
+            _json = self._serialize.body(body, "NetworkInterface")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
-            network_to_network_interconnect_name=network_to_network_interconnect_name,
+            network_device_name=network_device_name,
+            network_interface_name=network_interface_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
@@ -120,181 +120,177 @@
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkToNetworkInterconnect", pipeline_response)
+            deserialized = self._deserialize("NetworkInterface", pipeline_response)
 
         if response.status_code == 201:
-            deserialized = self._deserialize("NetworkToNetworkInterconnect", pipeline_response)
+            deserialized = self._deserialize("NetworkInterface", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
     }
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
-        body: _models.NetworkToNetworkInterconnect,
+        network_device_name: str,
+        network_interface_name: str,
+        body: _models.NetworkInterface,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkToNetworkInterconnect]:
-        """Configuration used to setup CE-PE connectivity.
+    ) -> AsyncLROPoller[_models.NetworkInterface]:
+        """Create NetworkInterface.
 
-        Configuration used to setup CE-PE connectivity PUT Method.
+        Create a Network Interface resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param network_to_network_interconnect_name: Name of the Network to Network Interconnect.
-         Required.
-        :type network_to_network_interconnect_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterface. Required.
+        :type network_interface_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkInterface
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkToNetworkInterconnect or the
-         result of cls(response)
+        :return: An instance of AsyncLROPoller that returns either NetworkInterface or the result of
+         cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
+        network_device_name: str,
+        network_interface_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkToNetworkInterconnect]:
-        """Configuration used to setup CE-PE connectivity.
+    ) -> AsyncLROPoller[_models.NetworkInterface]:
+        """Create NetworkInterface.
 
-        Configuration used to setup CE-PE connectivity PUT Method.
+        Create a Network Interface resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param network_to_network_interconnect_name: Name of the Network to Network Interconnect.
-         Required.
-        :type network_to_network_interconnect_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterface. Required.
+        :type network_interface_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkToNetworkInterconnect or the
-         result of cls(response)
+        :return: An instance of AsyncLROPoller that returns either NetworkInterface or the result of
+         cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
-        body: Union[_models.NetworkToNetworkInterconnect, IO],
+        network_device_name: str,
+        network_interface_name: str,
+        body: Union[_models.NetworkInterface, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkToNetworkInterconnect]:
-        """Configuration used to setup CE-PE connectivity.
+    ) -> AsyncLROPoller[_models.NetworkInterface]:
+        """Create NetworkInterface.
 
-        Configuration used to setup CE-PE connectivity PUT Method.
+        Create a Network Interface resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param network_to_network_interconnect_name: Name of the Network to Network Interconnect.
-         Required.
-        :type network_to_network_interconnect_name: str
-        :param body: Request payload. Is either a NetworkToNetworkInterconnect type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect or IO
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterface. Required.
+        :type network_interface_name: str
+        :param body: Request payload. Is either a NetworkInterface type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkInterface or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkToNetworkInterconnect or the
-         result of cls(response)
+        :return: An instance of AsyncLROPoller that returns either NetworkInterface or the result of
+         cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkToNetworkInterconnect] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkInterface] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
-                network_to_network_interconnect_name=network_to_network_interconnect_name,
+                network_device_name=network_device_name,
+                network_interface_name=network_interface_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkToNetworkInterconnect", pipeline_response)
+            deserialized = self._deserialize("NetworkInterface", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
@@ -310,60 +306,55 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
     }
 
     @distributed_trace_async
     async def get(
-        self,
-        resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
-        **kwargs: Any
-    ) -> _models.NetworkToNetworkInterconnect:
-        """Configuration used to setup CE-PE connectivity.
+        self, resource_group_name: str, network_device_name: str, network_interface_name: str, **kwargs: Any
+    ) -> _models.NetworkInterface:
+        """Gets a NetworkInterface.
 
-        Implements NetworkToNetworkInterconnects GET method.
+        Get the Network Interface resource details.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param network_to_network_interconnect_name: Name of the Network to Network Interconnect.
-         Required.
-        :type network_to_network_interconnect_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterfaceName. Required.
+        :type network_interface_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NetworkToNetworkInterconnect or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect
+        :return: NetworkInterface or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkInterface
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkToNetworkInterconnect] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkInterface] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
-            network_to_network_interconnect_name=network_to_network_interconnect_name,
+            network_device_name=network_device_name,
+            network_interface_name=network_interface_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -377,60 +368,60 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("NetworkToNetworkInterconnect", pipeline_response)
+        deserialized = self._deserialize("NetworkInterface", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
     }
 
     async def _update_initial(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
-        body: Union[_models.NetworkToNetworkInterconnectPatch, IO],
+        network_device_name: str,
+        network_interface_name: str,
+        body: Union[_models.NetworkInterfacePatch, IO],
         **kwargs: Any
-    ) -> Optional[_models.NetworkToNetworkInterconnect]:
+    ) -> _models.NetworkInterface:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.NetworkToNetworkInterconnect]] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkInterface] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkToNetworkInterconnectPatch")
+            _json = self._serialize.body(body, "NetworkInterfacePatch")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
-            network_to_network_interconnect_name=network_to_network_interconnect_name,
+            network_device_name=network_device_name,
+            network_interface_name=network_interface_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
@@ -447,191 +438,187 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = None
-        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkToNetworkInterconnect", pipeline_response)
+            deserialized = self._deserialize("NetworkInterface", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            deserialized = self._deserialize("NetworkInterface", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
     }
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
-        body: _models.NetworkToNetworkInterconnectPatch,
+        network_device_name: str,
+        network_interface_name: str,
+        body: _models.NetworkInterfacePatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkToNetworkInterconnect]:
-        """Updates a Network To NetworkInterconnects.
+    ) -> AsyncLROPoller[_models.NetworkInterface]:
+        """Updates a NetworkInterface.
 
-        Update certain properties of the Network To NetworkInterconnects resource.
+        Update certain properties of the Network Interface resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param network_to_network_interconnect_name: Name of the Network to Network Interconnect.
-         Required.
-        :type network_to_network_interconnect_name: str
-        :param body: Network to Network Interconnect properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnectPatch
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterfaceName. Required.
+        :type network_interface_name: str
+        :param body: NetworkInterface properties to update. Only tags are supported. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkInterfacePatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkToNetworkInterconnect or the
-         result of cls(response)
+        :return: An instance of AsyncLROPoller that returns either NetworkInterface or the result of
+         cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
+        network_device_name: str,
+        network_interface_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkToNetworkInterconnect]:
-        """Updates a Network To NetworkInterconnects.
+    ) -> AsyncLROPoller[_models.NetworkInterface]:
+        """Updates a NetworkInterface.
 
-        Update certain properties of the Network To NetworkInterconnects resource.
+        Update certain properties of the Network Interface resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param network_to_network_interconnect_name: Name of the Network to Network Interconnect.
-         Required.
-        :type network_to_network_interconnect_name: str
-        :param body: Network to Network Interconnect properties to update. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterfaceName. Required.
+        :type network_interface_name: str
+        :param body: NetworkInterface properties to update. Only tags are supported. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkToNetworkInterconnect or the
-         result of cls(response)
+        :return: An instance of AsyncLROPoller that returns either NetworkInterface or the result of
+         cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
-        body: Union[_models.NetworkToNetworkInterconnectPatch, IO],
+        network_device_name: str,
+        network_interface_name: str,
+        body: Union[_models.NetworkInterfacePatch, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkToNetworkInterconnect]:
-        """Updates a Network To NetworkInterconnects.
+    ) -> AsyncLROPoller[_models.NetworkInterface]:
+        """Updates a NetworkInterface.
 
-        Update certain properties of the Network To NetworkInterconnects resource.
+        Update certain properties of the Network Interface resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param network_to_network_interconnect_name: Name of the Network to Network Interconnect.
-         Required.
-        :type network_to_network_interconnect_name: str
-        :param body: Network to Network Interconnect properties to update. Is either a
-         NetworkToNetworkInterconnectPatch type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnectPatch or IO
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterfaceName. Required.
+        :type network_interface_name: str
+        :param body: NetworkInterface properties to update. Only tags are supported. Is either a
+         NetworkInterfacePatch type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkInterfacePatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkToNetworkInterconnect or the
-         result of cls(response)
+        :return: An instance of AsyncLROPoller that returns either NetworkInterface or the result of
+         cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkToNetworkInterconnect] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkInterface] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
-                network_to_network_interconnect_name=network_to_network_interconnect_name,
+                network_device_name=network_device_name,
+                network_interface_name=network_interface_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkToNetworkInterconnect", pipeline_response)
+            deserialized = self._deserialize("NetworkInterface", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+                AsyncPollingMethod,
+                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
@@ -639,23 +626,19 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
     }
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self,
-        resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
-        **kwargs: Any
+        self, resource_group_name: str, network_device_name: str, network_interface_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -665,16 +648,16 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
-            network_to_network_interconnect_name=network_to_network_interconnect_name,
+            network_device_name=network_device_name,
+            network_interface_name=network_interface_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -683,46 +666,41 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
     }
 
     @distributed_trace_async
     async def begin_delete(
-        self,
-        resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
-        **kwargs: Any
+        self, resource_group_name: str, network_device_name: str, network_interface_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
-        """Deletes a NetworkToNetworkInterconnects.
+        """Deletes a NetworkInterface.
 
-        Implements NetworkToNetworkInterconnects DELETE method.
+        Delete the Network Interface resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param network_to_network_interconnect_name: Name of the Network to Network Interconnect.
-         Required.
-        :type network_to_network_interconnect_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterfaceName. Required.
+        :type network_interface_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
@@ -738,16 +716,16 @@
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
-                network_to_network_interconnect_name=network_to_network_interconnect_name,
+                network_device_name=network_device_name,
+                network_interface_name=network_interface_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
@@ -770,60 +748,59 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
     }
 
     @distributed_trace
-    def list_by_network_fabric(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> AsyncIterable["_models.NetworkToNetworkInterconnect"]:
-        """Executes list operation to display Network To Network Interconnects within a Network Fabric.
+    def list(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> AsyncIterable["_models.NetworkInterface"]:
+        """List all Network Interfaces that are available using an Network Device.
 
-        Implements Network To Network Interconnects list by Network Fabric GET method.
+        List all the Network Interface resources in a given resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkToNetworkInterconnect or the result of
-         cls(response)
+        :return: An iterator like instance of either NetworkInterface or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkToNetworkInterconnectsList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkInterfacesList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_by_network_fabric_request(
+                request = build_list_request(
                     resource_group_name=resource_group_name,
-                    network_fabric_name=network_fabric_name,
+                    network_device_name=network_device_name,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
-                    template_url=self.list_by_network_fabric.metadata["url"],
+                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
@@ -841,15 +818,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkToNetworkInterconnectsList", pipeline_response)
+            deserialized = self._deserialize("NetworkInterfacesList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -865,250 +842,132 @@
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list_by_network_fabric.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects"
+    list.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces"
     }
 
-    async def _update_npb_static_route_bfd_administrative_state_initial(
-        self,
-        resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
-        **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    async def _get_status_initial(
+        self, resource_group_name: str, network_device_name: str, network_interface_name: str, **kwargs: Any
+    ) -> _models.InterfaceStatus:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[_models.InterfaceStatus] = kwargs.pop("cls", None)
 
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "UpdateAdministrativeState")
-
-        request = build_update_npb_static_route_bfd_administrative_state_request(
+        request = build_get_status_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
-            network_to_network_interconnect_name=network_to_network_interconnect_name,
+            network_device_name=network_device_name,
+            network_interface_name=network_interface_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self._update_npb_static_route_bfd_administrative_state_initial.metadata["url"],
+            template_url=self._get_status_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        deserialized = self._deserialize("InterfaceStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)
 
-        return deserialized  # type: ignore
+        return deserialized
 
-    _update_npb_static_route_bfd_administrative_state_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}/updateNpbStaticRouteBfdAdministrativeState"
+    _get_status_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}/getStatus"
     }
 
-    @overload
-    async def begin_update_npb_static_route_bfd_administrative_state(
-        self,
-        resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
-        body: _models.UpdateAdministrativeState,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
-
-        Updates the NPB Static Route BFD Administrative State.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param network_to_network_interconnect_name: Name of the Network to Network Interconnect.
-         Required.
-        :type network_to_network_interconnect_name: str
-        :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    async def begin_update_npb_static_route_bfd_administrative_state(
-        self,
-        resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
-        body: IO,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
-
-        Updates the NPB Static Route BFD Administrative State.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param network_to_network_interconnect_name: Name of the Network to Network Interconnect.
-         Required.
-        :type network_to_network_interconnect_name: str
-        :param body: Request payload. Required.
-        :type body: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
     @distributed_trace_async
-    async def begin_update_npb_static_route_bfd_administrative_state(
-        self,
-        resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    async def begin_get_status(
+        self, resource_group_name: str, network_device_name: str, network_interface_name: str, **kwargs: Any
+    ) -> AsyncLROPoller[_models.InterfaceStatus]:
         """Implements the operation to the underlying resources.
 
-        Updates the NPB Static Route BFD Administrative State.
+        Get the running status of the Network Interface.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param network_to_network_interconnect_name: Name of the Network to Network Interconnect.
-         Required.
-        :type network_to_network_interconnect_name: str
-        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterface. Required.
+        :type network_interface_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
+        :return: An instance of AsyncLROPoller that returns either InterfaceStatus or the result of
+         cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.InterfaceStatus]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[_models.InterfaceStatus] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_npb_static_route_bfd_administrative_state_initial(
+            raw_result = await self._get_status_initial(
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
-                network_to_network_interconnect_name=network_to_network_interconnect_name,
-                body=body,
+                network_device_name=network_device_name,
+                network_interface_name=network_interface_name,
                 api_version=api_version,
-                content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+            response_headers = {}
+            response = pipeline_response.http_response
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+            deserialized = self._deserialize("InterfaceStatus", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})
+                return cls(pipeline_response, deserialized, response_headers)
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
@@ -1120,53 +979,53 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_update_npb_static_route_bfd_administrative_state.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}/updateNpbStaticRouteBfdAdministrativeState"
+    begin_get_status.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}/getStatus"
     }
 
-    async def _update_administrative_state_initial(
+    async def _update_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
+        network_device_name: str,
+        network_interface_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "UpdateAdministrativeState")
 
         request = build_update_administrative_state_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
-            network_to_network_interconnect_name=network_to_network_interconnect_name,
+            network_device_name=network_device_name,
+            network_interface_name=network_interface_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_administrative_state_initial.metadata["url"],
             headers=_headers,
@@ -1178,193 +1037,174 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
     _update_administrative_state_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}/updateAdministrativeState"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}/updateAdministrativeState"
     }
 
     @overload
     async def begin_update_administrative_state(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
+        network_device_name: str,
+        network_interface_name: str,
         body: _models.UpdateAdministrativeState,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    ) -> AsyncLROPoller[None]:
+        """Updates the admin state of the network interface.
 
-        Updates the Admin State.
+        Update the admin state of the Network Interface.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param network_to_network_interconnect_name: Name of the Network to Network Interconnect.
-         Required.
-        :type network_to_network_interconnect_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterface. Required.
+        :type network_interface_name: str
         :param body: Request payload. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update_administrative_state(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
+        network_device_name: str,
+        network_interface_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    ) -> AsyncLROPoller[None]:
+        """Updates the admin state of the network interface.
 
-        Updates the Admin State.
+        Update the admin state of the Network Interface.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param network_to_network_interconnect_name: Name of the Network to Network Interconnect.
-         Required.
-        :type network_to_network_interconnect_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterface. Required.
+        :type network_interface_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update_administrative_state(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        network_to_network_interconnect_name: str,
+        network_device_name: str,
+        network_interface_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    ) -> AsyncLROPoller[None]:
+        """Updates the admin state of the network interface.
 
-        Updates the Admin State.
+        Update the admin state of the Network Interface.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param network_to_network_interconnect_name: Name of the Network to Network Interconnect.
-         Required.
-        :type network_to_network_interconnect_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterface. Required.
+        :type network_interface_name: str
         :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
          Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_administrative_state_initial(
+            raw_result = await self._update_administrative_state_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
-                network_to_network_interconnect_name=network_to_network_interconnect_name,
+                network_device_name=network_device_name,
+                network_interface_name=network_interface_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
@@ -1376,9 +1216,9 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update_administrative_state.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}/updateAdministrativeState"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}/updateAdministrativeState"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_route_policies_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_route_policies_operations.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,74 +3,260 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 from io import IOBase
-from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
+from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
-from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
+from azure.core.pipeline.transport import HttpResponse
+from azure.core.polling import LROPoller, NoPolling, PollingMethod
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
-from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
+from azure.mgmt.core.polling.arm_polling import ARMPolling
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._route_policies_operations import (
-    build_commit_configuration_request,
-    build_create_request,
-    build_delete_request,
-    build_get_request,
-    build_list_by_resource_group_request,
-    build_list_by_subscription_request,
-    build_update_administrative_state_request,
-    build_update_request,
-    build_validate_configuration_request,
-)
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request, _format_url_section
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_create_request(
+    resource_group_name: str, route_policy_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "routePolicyName": _SERIALIZER.url("route_policy_name", route_policy_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_get_request(
+    resource_group_name: str, route_policy_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "routePolicyName": _SERIALIZER.url("route_policy_name", route_policy_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_update_request(
+    resource_group_name: str, route_policy_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "routePolicyName": _SERIALIZER.url("route_policy_name", route_policy_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_delete_request(
+    resource_group_name: str, route_policy_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "routePolicyName": _SERIALIZER.url("route_policy_name", route_policy_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/routePolicies"
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 class RoutePoliciesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.managednetworkfabric.aio.ManagedNetworkFabricMgmtClient`'s
+        :class:`~azure.mgmt.managednetworkfabric.ManagedNetworkFabricMgmtClient`'s
         :attr:`route_policies` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    async def _create_initial(
+    def _create_initial(
         self, resource_group_name: str, route_policy_name: str, body: Union[_models.RoutePolicy, IO], **kwargs: Any
     ) -> _models.RoutePolicy:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -104,15 +290,15 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -131,23 +317,23 @@
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
     }
 
     @overload
-    async def begin_create(
+    def begin_create(
         self,
         resource_group_name: str,
         route_policy_name: str,
         body: _models.RoutePolicy,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.RoutePolicy]:
+    ) -> LROPoller[_models.RoutePolicy]:
         """Create Route Policy.
 
         Implements Route Policy PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
@@ -156,36 +342,36 @@
         :param body: Request payload. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.RoutePolicy
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either RoutePolicy or the result of
+        :return: An instance of LROPoller that returns either RoutePolicy or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_create(
+    def begin_create(
         self,
         resource_group_name: str,
         route_policy_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.RoutePolicy]:
+    ) -> LROPoller[_models.RoutePolicy]:
         """Create Route Policy.
 
         Implements Route Policy PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
@@ -194,30 +380,30 @@
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either RoutePolicy or the result of
+        :return: An instance of LROPoller that returns either RoutePolicy or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_create(
+    @distributed_trace
+    def begin_create(
         self, resource_group_name: str, route_policy_name: str, body: Union[_models.RoutePolicy, IO], **kwargs: Any
-    ) -> AsyncLROPoller[_models.RoutePolicy]:
+    ) -> LROPoller[_models.RoutePolicy]:
         """Create Route Policy.
 
         Implements Route Policy PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
@@ -226,36 +412,36 @@
         :param body: Request payload. Is either a RoutePolicy type or a IO type. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.RoutePolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either RoutePolicy or the result of
+        :return: An instance of LROPoller that returns either RoutePolicy or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoutePolicy] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._create_initial(
+            raw_result = self._create_initial(
                 resource_group_name=resource_group_name,
                 route_policy_name=route_policy_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
@@ -267,37 +453,36 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("RoutePolicy", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
     }
 
-    @distributed_trace_async
-    async def get(self, resource_group_name: str, route_policy_name: str, **kwargs: Any) -> _models.RoutePolicy:
+    @distributed_trace
+    def get(self, resource_group_name: str, route_policy_name: str, **kwargs: Any) -> _models.RoutePolicy:
         """Gets a Route Policy.
 
         Implements Route Policy GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
@@ -331,15 +516,15 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -353,15 +538,15 @@
 
         return deserialized
 
     get.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
     }
 
-    async def _update_initial(
+    def _update_initial(
         self, resource_group_name: str, route_policy_name: str, body: Union[_models.RoutePolicyPatch, IO], **kwargs: Any
     ) -> Optional[_models.RoutePolicy]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -395,15 +580,15 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
@@ -412,35 +597,37 @@
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("RoutePolicy", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
     }
 
     @overload
-    async def begin_update(
+    def begin_update(
         self,
         resource_group_name: str,
         route_policy_name: str,
         body: _models.RoutePolicyPatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.RoutePolicy]:
+    ) -> LROPoller[_models.RoutePolicy]:
         """Updates a Route Policy.
 
         API to update certain properties of the Route Policy resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
@@ -449,36 +636,36 @@
         :param body: Route Policy properties to update. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.RoutePolicyPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either RoutePolicy or the result of
+        :return: An instance of LROPoller that returns either RoutePolicy or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_update(
+    def begin_update(
         self,
         resource_group_name: str,
         route_policy_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.RoutePolicy]:
+    ) -> LROPoller[_models.RoutePolicy]:
         """Updates a Route Policy.
 
         API to update certain properties of the Route Policy resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
@@ -487,30 +674,30 @@
         :param body: Route Policy properties to update. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either RoutePolicy or the result of
+        :return: An instance of LROPoller that returns either RoutePolicy or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_update(
+    @distributed_trace
+    def begin_update(
         self, resource_group_name: str, route_policy_name: str, body: Union[_models.RoutePolicyPatch, IO], **kwargs: Any
-    ) -> AsyncLROPoller[_models.RoutePolicy]:
+    ) -> LROPoller[_models.RoutePolicy]:
         """Updates a Route Policy.
 
         API to update certain properties of the Route Policy resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
@@ -520,36 +707,36 @@
          Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.RoutePolicyPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either RoutePolicy or the result of
+        :return: An instance of LROPoller that returns either RoutePolicy or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoutePolicy] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_initial(
+            raw_result = self._update_initial(
                 resource_group_name=resource_group_name,
                 route_policy_name=route_policy_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
@@ -561,35 +748,35 @@
         def get_long_running_output(pipeline_response):
             deserialized = self._deserialize("RoutePolicy", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
     }
 
-    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
+    def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self, resource_group_name: str, route_policy_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -611,67 +798,65 @@
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
     }
 
-    @distributed_trace_async
-    async def begin_delete(
-        self, resource_group_name: str, route_policy_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[None]:
+    @distributed_trace
+    def begin_delete(self, resource_group_name: str, route_policy_name: str, **kwargs: Any) -> LROPoller[None]:
         """Deletes a Route Policy.
 
         Implements Route Policy DELETE method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :param route_policy_name: Name of the Route Policy. Required.
         :type route_policy_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._delete_initial(  # type: ignore
+            raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 route_policy_name=route_policy_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
@@ -679,47 +864,46 @@
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
     }
 
     @distributed_trace
-    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.RoutePolicy"]:
+    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.RoutePolicy"]:
         """List RoutePolicies by resource group.
 
         Implements RoutePolicies list by resource group GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoutePolicy or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.RoutePoliciesListResult] = kwargs.pop("cls", None)
@@ -760,53 +944,52 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
+        def extract_data(pipeline_response):
             deserialized = self._deserialize("RoutePoliciesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
     list_by_resource_group.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies"
     }
 
     @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.RoutePolicy"]:
+    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.RoutePolicy"]:
         """List RoutePolicies by subscription.
 
         Implements RoutePolicies list by subscription GET method.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoutePolicy or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.RoutePoliciesListResult] = kwargs.pop("cls", None)
@@ -846,539 +1029,35 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
+        def extract_data(pipeline_response):
             deserialized = self._deserialize("RoutePoliciesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
     list_by_subscription.metadata = {
         "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/routePolicies"
     }
-
-    async def _update_administrative_state_initial(
-        self,
-        resource_group_name: str,
-        route_policy_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
-        **kwargs: Any
-    ) -> _models.CommonPostActionResponseForDeviceUpdate:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "UpdateAdministrativeState")
-
-        request = build_update_administrative_state_request(
-            resource_group_name=resource_group_name,
-            route_policy_name=route_policy_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self._update_administrative_state_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
-
-    _update_administrative_state_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/updateAdministrativeState"
-    }
-
-    @overload
-    async def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        route_policy_name: str,
-        body: _models.UpdateAdministrativeState,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """Executes enable operation to the underlying resources.
-
-        Updated the admin state for this Route Policy.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
-        :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForDeviceUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    async def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        route_policy_name: str,
-        body: IO,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """Executes enable operation to the underlying resources.
-
-        Updated the admin state for this Route Policy.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
-        :param body: Request payload. Required.
-        :type body: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForDeviceUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @distributed_trace_async
-    async def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        route_policy_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """Executes enable operation to the underlying resources.
-
-        Updated the admin state for this Route Policy.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
-        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForDeviceUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._update_administrative_state_initial(
-                resource_group_name=resource_group_name,
-                route_policy_name=route_policy_name,
-                body=body,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_update_administrative_state.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/updateAdministrativeState"
-    }
-
-    async def _validate_configuration_initial(
-        self, resource_group_name: str, route_policy_name: str, **kwargs: Any
-    ) -> _models.ValidateConfigurationResponse:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
-
-        request = build_validate_configuration_request(
-            resource_group_name=resource_group_name,
-            route_policy_name=route_policy_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            template_url=self._validate_configuration_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
-
-    _validate_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/validateConfiguration"
-    }
-
-    @distributed_trace_async
-    async def begin_validate_configuration(
-        self, resource_group_name: str, route_policy_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.ValidateConfigurationResponse]:
-        """Validates the configuration of the resources.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._validate_configuration_initial(
-                resource_group_name=resource_group_name,
-                route_policy_name=route_policy_name,
-                api_version=api_version,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_validate_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/validateConfiguration"
-    }
-
-    async def _commit_configuration_initial(
-        self, resource_group_name: str, route_policy_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-
-        request = build_commit_configuration_request(
-            resource_group_name=resource_group_name,
-            route_policy_name=route_policy_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            template_url=self._commit_configuration_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
-
-    _commit_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/commitConfiguration"
-    }
-
-    @distributed_trace_async
-    async def begin_commit_configuration(
-        self, resource_group_name: str, route_policy_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Execute the commit on the resources.
-
-        Commits the configuration of the given resources.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._commit_configuration_initial(
-                resource_group_name=resource_group_name,
-                route_policy_name=route_policy_name,
-                api_version=api_version,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_commit_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/commitConfiguration"
-    }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_internet_gateways_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_route_policies_operations.py`

 * *Files 16% similar despite different names*

```diff
@@ -27,79 +27,75 @@
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._internet_gateways_operations import (
+from ...operations._route_policies_operations import (
     build_create_request,
     build_delete_request,
     build_get_request,
     build_list_by_resource_group_request,
     build_list_by_subscription_request,
     build_update_request,
 )
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class InternetGatewaysOperations:
+class RoutePoliciesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.managednetworkfabric.aio.ManagedNetworkFabricMgmtClient`'s
-        :attr:`internet_gateways` attribute.
+        :attr:`route_policies` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     async def _create_initial(
-        self,
-        resource_group_name: str,
-        internet_gateway_name: str,
-        body: Union[_models.InternetGateway, IO],
-        **kwargs: Any
-    ) -> _models.InternetGateway:
+        self, resource_group_name: str, route_policy_name: str, body: Union[_models.RoutePolicy, IO], **kwargs: Any
+    ) -> _models.RoutePolicy:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.InternetGateway] = kwargs.pop("cls", None)
+        cls: ClsType[_models.RoutePolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "InternetGateway")
+            _json = self._serialize.body(body, "RoutePolicy")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            internet_gateway_name=internet_gateway_name,
+            route_policy_name=route_policy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
@@ -116,173 +112,161 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("InternetGateway", pipeline_response)
+            deserialized = self._deserialize("RoutePolicy", pipeline_response)
 
         if response.status_code == 201:
-            response_headers["Azure-AsyncOperation"] = self._deserialize(
-                "str", response.headers.get("Azure-AsyncOperation")
-            )
-
-            deserialized = self._deserialize("InternetGateway", pipeline_response)
+            deserialized = self._deserialize("RoutePolicy", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways/{internetGatewayName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
     }
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
-        internet_gateway_name: str,
-        body: _models.InternetGateway,
+        route_policy_name: str,
+        body: _models.RoutePolicy,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.InternetGateway]:
-        """Create a Network Fabric Service Internet Gateway.
+    ) -> AsyncLROPoller[_models.RoutePolicy]:
+        """Create Route Policy.
 
-        Creates a Network Fabric Service Internet Gateway resource instance.
+        Implements Route Policy PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param internet_gateway_name: Name of the Internet Gateway. Required.
-        :type internet_gateway_name: str
+        :param route_policy_name: Name of the Route Policy. Required.
+        :type route_policy_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.InternetGateway
+        :type body: ~azure.mgmt.managednetworkfabric.models.RoutePolicy
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either InternetGateway or the result of
+        :return: An instance of AsyncLROPoller that returns either RoutePolicy or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.InternetGateway]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
-        internet_gateway_name: str,
+        route_policy_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.InternetGateway]:
-        """Create a Network Fabric Service Internet Gateway.
+    ) -> AsyncLROPoller[_models.RoutePolicy]:
+        """Create Route Policy.
 
-        Creates a Network Fabric Service Internet Gateway resource instance.
+        Implements Route Policy PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param internet_gateway_name: Name of the Internet Gateway. Required.
-        :type internet_gateway_name: str
+        :param route_policy_name: Name of the Route Policy. Required.
+        :type route_policy_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either InternetGateway or the result of
+        :return: An instance of AsyncLROPoller that returns either RoutePolicy or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.InternetGateway]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create(
-        self,
-        resource_group_name: str,
-        internet_gateway_name: str,
-        body: Union[_models.InternetGateway, IO],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.InternetGateway]:
-        """Create a Network Fabric Service Internet Gateway.
+        self, resource_group_name: str, route_policy_name: str, body: Union[_models.RoutePolicy, IO], **kwargs: Any
+    ) -> AsyncLROPoller[_models.RoutePolicy]:
+        """Create Route Policy.
 
-        Creates a Network Fabric Service Internet Gateway resource instance.
+        Implements Route Policy PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param internet_gateway_name: Name of the Internet Gateway. Required.
-        :type internet_gateway_name: str
-        :param body: Request payload. Is either a InternetGateway type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.InternetGateway or IO
+        :param route_policy_name: Name of the Route Policy. Required.
+        :type route_policy_name: str
+        :param body: Request payload. Is either a RoutePolicy type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.RoutePolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either InternetGateway or the result of
+        :return: An instance of AsyncLROPoller that returns either RoutePolicy or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.InternetGateway]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.InternetGateway] = kwargs.pop("cls", None)
+        cls: ClsType[_models.RoutePolicy] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
                 resource_group_name=resource_group_name,
-                internet_gateway_name=internet_gateway_name,
+                route_policy_name=route_policy_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("InternetGateway", pipeline_response)
+            deserialized = self._deserialize("RoutePolicy", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
@@ -298,50 +282,50 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways/{internetGatewayName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
     }
 
     @distributed_trace_async
-    async def get(self, resource_group_name: str, internet_gateway_name: str, **kwargs: Any) -> _models.InternetGateway:
-        """Retrieves details of Network Fabric Service Internet Gateway.
+    async def get(self, resource_group_name: str, route_policy_name: str, **kwargs: Any) -> _models.RoutePolicy:
+        """Gets a Route Policy.
 
-        Implements Gateway GET method.
+        Implements Route Policy GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param internet_gateway_name: Name of the Internet Gateway. Required.
-        :type internet_gateway_name: str
+        :param route_policy_name: Name of the Route Policy. Required.
+        :type route_policy_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: InternetGateway or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.InternetGateway
+        :return: RoutePolicy or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.RoutePolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.InternetGateway] = kwargs.pop("cls", None)
+        cls: ClsType[_models.RoutePolicy] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            internet_gateway_name=internet_gateway_name,
+            route_policy_name=route_policy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -355,58 +339,54 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("InternetGateway", pipeline_response)
+        deserialized = self._deserialize("RoutePolicy", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways/{internetGatewayName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
     }
 
     async def _update_initial(
-        self,
-        resource_group_name: str,
-        internet_gateway_name: str,
-        body: Union[_models.InternetGatewayPatch, IO],
-        **kwargs: Any
-    ) -> Optional[_models.InternetGateway]:
+        self, resource_group_name: str, route_policy_name: str, body: Union[_models.RoutePolicyPatch, IO], **kwargs: Any
+    ) -> Optional[_models.RoutePolicy]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.InternetGateway]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.RoutePolicy]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "InternetGatewayPatch")
+            _json = self._serialize.body(body, "RoutePolicyPatch")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            internet_gateway_name=internet_gateway_name,
+            route_policy_name=route_policy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
@@ -426,168 +406,163 @@
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("InternetGateway", pipeline_response)
+            deserialized = self._deserialize("RoutePolicy", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways/{internetGatewayName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
     }
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
-        internet_gateway_name: str,
-        body: _models.InternetGatewayPatch,
+        route_policy_name: str,
+        body: _models.RoutePolicyPatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.InternetGateway]:
-        """Updates a Network Fabric Service Internet Gateway.
+    ) -> AsyncLROPoller[_models.RoutePolicy]:
+        """Updates a Route Policy.
 
-        Execute patch on Network Fabric Service Internet Gateway.
+        API to update certain properties of the Route Policy resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param internet_gateway_name: Name of the Internet Gateway. Required.
-        :type internet_gateway_name: str
-        :param body: API to update certain properties of the L2 Isolation Domain resource.. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.InternetGatewayPatch
+        :param route_policy_name: Name of the Route Policy. Required.
+        :type route_policy_name: str
+        :param body: Route Policy properties to update. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.RoutePolicyPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either InternetGateway or the result of
+        :return: An instance of AsyncLROPoller that returns either RoutePolicy or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.InternetGateway]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
-        internet_gateway_name: str,
+        route_policy_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.InternetGateway]:
-        """Updates a Network Fabric Service Internet Gateway.
+    ) -> AsyncLROPoller[_models.RoutePolicy]:
+        """Updates a Route Policy.
 
-        Execute patch on Network Fabric Service Internet Gateway.
+        API to update certain properties of the Route Policy resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param internet_gateway_name: Name of the Internet Gateway. Required.
-        :type internet_gateway_name: str
-        :param body: API to update certain properties of the L2 Isolation Domain resource.. Required.
+        :param route_policy_name: Name of the Route Policy. Required.
+        :type route_policy_name: str
+        :param body: Route Policy properties to update. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either InternetGateway or the result of
+        :return: An instance of AsyncLROPoller that returns either RoutePolicy or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.InternetGateway]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update(
-        self,
-        resource_group_name: str,
-        internet_gateway_name: str,
-        body: Union[_models.InternetGatewayPatch, IO],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.InternetGateway]:
-        """Updates a Network Fabric Service Internet Gateway.
+        self, resource_group_name: str, route_policy_name: str, body: Union[_models.RoutePolicyPatch, IO], **kwargs: Any
+    ) -> AsyncLROPoller[_models.RoutePolicy]:
+        """Updates a Route Policy.
 
-        Execute patch on Network Fabric Service Internet Gateway.
+        API to update certain properties of the Route Policy resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param internet_gateway_name: Name of the Internet Gateway. Required.
-        :type internet_gateway_name: str
-        :param body: API to update certain properties of the L2 Isolation Domain resource.. Is either a
-         InternetGatewayPatch type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.InternetGatewayPatch or IO
+        :param route_policy_name: Name of the Route Policy. Required.
+        :type route_policy_name: str
+        :param body: Route Policy properties to update. Is either a RoutePolicyPatch type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.RoutePolicyPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either InternetGateway or the result of
+        :return: An instance of AsyncLROPoller that returns either RoutePolicy or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.InternetGateway]
+        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.InternetGateway] = kwargs.pop("cls", None)
+        cls: ClsType[_models.RoutePolicy] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
                 resource_group_name=resource_group_name,
-                internet_gateway_name=internet_gateway_name,
+                route_policy_name=route_policy_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("InternetGateway", pipeline_response)
+            deserialized = self._deserialize("RoutePolicy", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
@@ -602,19 +577,19 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways/{internetGatewayName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
     }
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, internet_gateway_name: str, **kwargs: Any
+        self, resource_group_name: str, route_policy_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -624,15 +599,15 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            internet_gateway_name=internet_gateway_name,
+            route_policy_name=route_policy_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -641,39 +616,39 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways/{internetGatewayName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
     }
 
     @distributed_trace_async
     async def begin_delete(
-        self, resource_group_name: str, internet_gateway_name: str, **kwargs: Any
+        self, resource_group_name: str, route_policy_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
-        """Deletes a Network Fabric Service Internet Gateway.
+        """Deletes a Route Policy.
 
-        Execute a delete on Network Fabric Service Internet Gateway.
+        Implements Route Policy DELETE method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param internet_gateway_name: Name of the Internet Gateway. Required.
-        :type internet_gateway_name: str
+        :param route_policy_name: Name of the Route Policy. Required.
+        :type route_policy_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
@@ -689,15 +664,15 @@
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                internet_gateway_name=internet_gateway_name,
+                route_policy_name=route_policy_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
@@ -720,39 +695,37 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways/{internetGatewayName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
     }
 
     @distributed_trace
-    def list_by_resource_group(
-        self, resource_group_name: str, **kwargs: Any
-    ) -> AsyncIterable["_models.InternetGateway"]:
-        """List Internet Gateways by resource group.
+    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.RoutePolicy"]:
+        """List RoutePolicies by resource group.
 
-        Displays Internet Gateways list by resource group GET method.
+        Implements RoutePolicies list by resource group GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either InternetGateway or the result of cls(response)
+        :return: An iterator like instance of either RoutePolicy or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.InternetGateway]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.InternetGatewaysListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.RoutePoliciesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -787,15 +760,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("InternetGatewaysListResult", pipeline_response)
+            deserialized = self._deserialize("RoutePoliciesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -812,34 +785,34 @@
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies"
     }
 
     @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.InternetGateway"]:
-        """List Internet Gateways by subscription.
+    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.RoutePolicy"]:
+        """List RoutePolicies by subscription.
 
-        Displays Internet Gateways list by subscription GET method.
+        Implements RoutePolicies list by subscription GET method.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either InternetGateway or the result of cls(response)
+        :return: An iterator like instance of either RoutePolicy or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.InternetGateway]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.InternetGatewaysListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.RoutePoliciesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -873,15 +846,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("InternetGatewaysListResult", pipeline_response)
+            deserialized = self._deserialize("RoutePoliciesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -898,9 +871,9 @@
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/internetGateways"
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/routePolicies"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_tap_rules_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_fabric_controllers_operations.py`

 * *Files 16% similar despite different names*

```diff
@@ -27,82 +27,81 @@
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._network_tap_rules_operations import (
+from ...operations._network_fabric_controllers_operations import (
     build_create_request,
     build_delete_request,
+    build_disable_workload_management_network_request,
+    build_enable_workload_management_network_request,
     build_get_request,
     build_list_by_resource_group_request,
     build_list_by_subscription_request,
-    build_resync_request,
-    build_update_administrative_state_request,
     build_update_request,
-    build_validate_configuration_request,
 )
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class NetworkTapRulesOperations:
+class NetworkFabricControllersOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.managednetworkfabric.aio.ManagedNetworkFabricMgmtClient`'s
-        :attr:`network_tap_rules` attribute.
+        :attr:`network_fabric_controllers` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     async def _create_initial(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
-        body: Union[_models.NetworkTapRule, IO],
+        network_fabric_controller_name: str,
+        body: Union[_models.NetworkFabricController, IO],
         **kwargs: Any
-    ) -> _models.NetworkTapRule:
+    ) -> _models.NetworkFabricController:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkTapRule] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabricController] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkTapRule")
+            _json = self._serialize.body(body, "NetworkFabricController")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            network_tap_rule_name=network_tap_rule_name,
+            network_fabric_controller_name=network_fabric_controller_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
@@ -119,173 +118,168 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkTapRule", pipeline_response)
+            deserialized = self._deserialize("NetworkFabricController", pipeline_response)
 
         if response.status_code == 201:
-            response_headers["Azure-AsyncOperation"] = self._deserialize(
-                "str", response.headers.get("Azure-AsyncOperation")
-            )
-
-            deserialized = self._deserialize("NetworkTapRule", pipeline_response)
+            deserialized = self._deserialize("NetworkFabricController", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
     }
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
-        body: _models.NetworkTapRule,
+        network_fabric_controller_name: str,
+        body: _models.NetworkFabricController,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkTapRule]:
-        """Create Network Tap Rule.
+    ) -> AsyncLROPoller[_models.NetworkFabricController]:
+        """Create Network fabric controller.
 
-        Create Network Tap Rule resource.
+        Creates a Network Fabric Controller.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
+        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
+        :type network_fabric_controller_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkTapRule
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricController
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkTapRule or the result of
-         cls(response)
+        :return: An instance of AsyncLROPoller that returns either NetworkFabricController or the
+         result of cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
+        network_fabric_controller_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkTapRule]:
-        """Create Network Tap Rule.
+    ) -> AsyncLROPoller[_models.NetworkFabricController]:
+        """Create Network fabric controller.
 
-        Create Network Tap Rule resource.
+        Creates a Network Fabric Controller.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
+        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
+        :type network_fabric_controller_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkTapRule or the result of
-         cls(response)
+        :return: An instance of AsyncLROPoller that returns either NetworkFabricController or the
+         result of cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
-        body: Union[_models.NetworkTapRule, IO],
+        network_fabric_controller_name: str,
+        body: Union[_models.NetworkFabricController, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkTapRule]:
-        """Create Network Tap Rule.
+    ) -> AsyncLROPoller[_models.NetworkFabricController]:
+        """Create Network fabric controller.
 
-        Create Network Tap Rule resource.
+        Creates a Network Fabric Controller.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
-        :param body: Request payload. Is either a NetworkTapRule type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkTapRule or IO
+        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
+        :type network_fabric_controller_name: str
+        :param body: Request payload. Is either a NetworkFabricController type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricController or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkTapRule or the result of
-         cls(response)
+        :return: An instance of AsyncLROPoller that returns either NetworkFabricController or the
+         result of cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkTapRule] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabricController] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
                 resource_group_name=resource_group_name,
-                network_tap_rule_name=network_tap_rule_name,
+                network_fabric_controller_name=network_fabric_controller_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkTapRule", pipeline_response)
+            deserialized = self._deserialize("NetworkFabricController", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
@@ -301,50 +295,52 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
     }
 
     @distributed_trace_async
-    async def get(self, resource_group_name: str, network_tap_rule_name: str, **kwargs: Any) -> _models.NetworkTapRule:
-        """Gets a Network Tap Rule.
+    async def get(
+        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
+    ) -> _models.NetworkFabricController:
+        """Gets a Network Fabric Controller.
 
-        Get Network Tap Rule resource details.
+        Shows the provisioning status of Network Fabric Controller.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
+        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
+        :type network_fabric_controller_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NetworkTapRule or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkTapRule
+        :return: NetworkFabricController or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkFabricController
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkTapRule] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabricController] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            network_tap_rule_name=network_tap_rule_name,
+            network_fabric_controller_name=network_fabric_controller_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -358,58 +354,58 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("NetworkTapRule", pipeline_response)
+        deserialized = self._deserialize("NetworkFabricController", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
     }
 
     async def _update_initial(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
-        body: Union[_models.NetworkTapRulePatch, IO],
+        network_fabric_controller_name: str,
+        body: Union[_models.NetworkFabricControllerPatch, IO],
         **kwargs: Any
-    ) -> Optional[_models.NetworkTapRule]:
+    ) -> Optional[_models.NetworkFabricController]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.NetworkTapRule]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.NetworkFabricController]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkTapRulePatch")
+            _json = self._serialize.body(body, "NetworkFabricControllerPatch")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            network_tap_rule_name=network_tap_rule_name,
+            network_fabric_controller_name=network_fabric_controller_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
@@ -429,168 +425,168 @@
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkTapRule", pipeline_response)
+            deserialized = self._deserialize("NetworkFabricController", pipeline_response)
 
         if response.status_code == 202:
             response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
     }
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
-        body: _models.NetworkTapRulePatch,
+        network_fabric_controller_name: str,
+        body: _models.NetworkFabricControllerPatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkTapRule]:
-        """Updates a Network Tap Rule.
+    ) -> AsyncLROPoller[_models.NetworkFabricController]:
+        """Updates a Network Fabric Controller.
 
-        Update certain properties of the Network Tap Rule resource.
+        Updates are currently not supported for the Network Fabric Controller resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
-        :param body: Network Tap Rule properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkTapRulePatch
+        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
+        :type network_fabric_controller_name: str
+        :param body: Network Fabric Controller properties to update. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricControllerPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkTapRule or the result of
-         cls(response)
+        :return: An instance of AsyncLROPoller that returns either NetworkFabricController or the
+         result of cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
+        network_fabric_controller_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkTapRule]:
-        """Updates a Network Tap Rule.
+    ) -> AsyncLROPoller[_models.NetworkFabricController]:
+        """Updates a Network Fabric Controller.
 
-        Update certain properties of the Network Tap Rule resource.
+        Updates are currently not supported for the Network Fabric Controller resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
-        :param body: Network Tap Rule properties to update. Required.
+        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
+        :type network_fabric_controller_name: str
+        :param body: Network Fabric Controller properties to update. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkTapRule or the result of
-         cls(response)
+        :return: An instance of AsyncLROPoller that returns either NetworkFabricController or the
+         result of cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
-        body: Union[_models.NetworkTapRulePatch, IO],
+        network_fabric_controller_name: str,
+        body: Union[_models.NetworkFabricControllerPatch, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkTapRule]:
-        """Updates a Network Tap Rule.
+    ) -> AsyncLROPoller[_models.NetworkFabricController]:
+        """Updates a Network Fabric Controller.
 
-        Update certain properties of the Network Tap Rule resource.
+        Updates are currently not supported for the Network Fabric Controller resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
-        :param body: Network Tap Rule properties to update. Is either a NetworkTapRulePatch type or a
-         IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkTapRulePatch or IO
+        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
+        :type network_fabric_controller_name: str
+        :param body: Network Fabric Controller properties to update. Is either a
+         NetworkFabricControllerPatch type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricControllerPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkTapRule or the result of
-         cls(response)
+        :return: An instance of AsyncLROPoller that returns either NetworkFabricController or the
+         result of cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkTapRule] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabricController] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
                 resource_group_name=resource_group_name,
-                network_tap_rule_name=network_tap_rule_name,
+                network_fabric_controller_name=network_fabric_controller_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkTapRule", pipeline_response)
+            deserialized = self._deserialize("NetworkFabricController", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
@@ -605,19 +601,19 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
     }
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, network_tap_rule_name: str, **kwargs: Any
+        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -627,15 +623,15 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            network_tap_rule_name=network_tap_rule_name,
+            network_fabric_controller_name=network_fabric_controller_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -644,43 +640,43 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 202:
             response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
     }
 
     @distributed_trace_async
     async def begin_delete(
-        self, resource_group_name: str, network_tap_rule_name: str, **kwargs: Any
+        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
-        """Deletes a Network Tap Rule.
+        """Deletes a Network Fabric Controller.
 
-        Delete Network Tap Rule resource.
+        Deletes the Network Fabric Controller resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
+        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
+        :type network_fabric_controller_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
@@ -696,15 +692,15 @@
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_tap_rule_name=network_tap_rule_name,
+                network_fabric_controller_name=network_fabric_controller_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
@@ -727,39 +723,40 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
     }
 
     @distributed_trace
     def list_by_resource_group(
         self, resource_group_name: str, **kwargs: Any
-    ) -> AsyncIterable["_models.NetworkTapRule"]:
-        """List Network Tap Rules by resource group.
+    ) -> AsyncIterable["_models.NetworkFabricController"]:
+        """List NetworkFabricControllers by resource group.
 
-        List all the Network Tap Rule resources in the given resource group.
+        Lists all the NetworkFabricControllers thats available in the resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkTapRule or the result of cls(response)
+        :return: An iterator like instance of either NetworkFabricController or the result of
+         cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkTapRulesListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabricControllersListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -794,15 +791,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkTapRulesListResult", pipeline_response)
+            deserialized = self._deserialize("NetworkFabricControllersListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -819,34 +816,35 @@
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers"
     }
 
     @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.NetworkTapRule"]:
-        """List NetworkTapRules by subscription.
+    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.NetworkFabricController"]:
+        """List NetworkFabricControllers by subscription.
 
-        List all the Network Tap Rule resources in the given subscription.
+        Lists all the NetworkFabricControllers by subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkTapRule or the result of cls(response)
+        :return: An iterator like instance of either NetworkFabricController or the result of
+         cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkTapRulesListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabricControllersListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -880,15 +878,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkTapRulesListResult", pipeline_response)
+            deserialized = self._deserialize("NetworkFabricControllersListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -905,368 +903,116 @@
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkTapRules"
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers"
     }
 
-    async def _update_administrative_state_initial(
-        self,
-        resource_group_name: str,
-        network_tap_rule_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
-        **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "UpdateAdministrativeState")
-
-        request = build_update_administrative_state_request(
-            resource_group_name=resource_group_name,
-            network_tap_rule_name=network_tap_rule_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self._update_administrative_state_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
-
-    _update_administrative_state_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/updateAdministrativeState"
-    }
-
-    @overload
-    async def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        network_tap_rule_name: str,
-        body: _models.UpdateAdministrativeState,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Updates administrative state of  Network Tap Rules.
-
-        Implements the operation to the underlying resources.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
-        :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    async def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        network_tap_rule_name: str,
-        body: IO,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Updates administrative state of  Network Tap Rules.
-
-        Implements the operation to the underlying resources.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
-        :param body: Request payload. Required.
-        :type body: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @distributed_trace_async
-    async def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        network_tap_rule_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Updates administrative state of  Network Tap Rules.
-
-        Implements the operation to the underlying resources.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
-        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._update_administrative_state_initial(
-                resource_group_name=resource_group_name,
-                network_tap_rule_name=network_tap_rule_name,
-                body=body,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_update_administrative_state.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/updateAdministrativeState"
-    }
-
-    async def _resync_initial(
-        self, resource_group_name: str, network_tap_rule_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    async def _enable_workload_management_network_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_resync_request(
+        request = build_enable_workload_management_network_request(
             resource_group_name=resource_group_name,
-            network_tap_rule_name=network_tap_rule_name,
+            network_fabric_controller_name=network_fabric_controller_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._resync_initial.metadata["url"],
+            template_url=self._enable_workload_management_network_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _resync_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/resync"
+    _enable_workload_management_network_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}/enableWorkloadManagementNetwork"
     }
 
     @distributed_trace_async
-    async def begin_resync(
-        self, resource_group_name: str, network_tap_rule_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Resync the Network Tap Rule.
+    async def begin_enable_workload_management_network(
+        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        Implements the operation to the underlying resources.
+        Enables the workloadManagementNetwork (Tenant Network).
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
+        :param network_fabric_controller_name: Name of the networkFabricController. Required.
+        :type network_fabric_controller_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._resync_initial(
+            raw_result = await self._enable_workload_management_network_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_tap_rule_name=network_tap_rule_name,
+                network_fabric_controller_name=network_fabric_controller_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
@@ -1277,129 +1023,117 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_resync.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/resync"
+    begin_enable_workload_management_network.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}/enableWorkloadManagementNetwork"
     }
 
-    async def _validate_configuration_initial(
-        self, resource_group_name: str, network_tap_rule_name: str, **kwargs: Any
-    ) -> _models.ValidateConfigurationResponse:
+    async def _disable_workload_management_network_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_validate_configuration_request(
+        request = build_disable_workload_management_network_request(
             resource_group_name=resource_group_name,
-            network_tap_rule_name=network_tap_rule_name,
+            network_fabric_controller_name=network_fabric_controller_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._validate_configuration_initial.metadata["url"],
+            template_url=self._disable_workload_management_network_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _validate_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/validateConfiguration"
+    _disable_workload_management_network_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}/disableWorkloadManagementNetwork"
     }
 
     @distributed_trace_async
-    async def begin_validate_configuration(
-        self, resource_group_name: str, network_tap_rule_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.ValidateConfigurationResponse]:
-        """Validates the configuration of the Network Tap Rule.
+    async def begin_disable_workload_management_network(
+        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        Implements the operation to the underlying resources.
+        Disables the workloadManagementNetwork (Tenant Network).
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
+        :param network_fabric_controller_name: Name of the networkFabricController. Required.
+        :type network_fabric_controller_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._validate_configuration_initial(
+            raw_result = await self._disable_workload_management_network_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_tap_rule_name=network_tap_rule_name,
+                network_fabric_controller_name=network_fabric_controller_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
@@ -1410,10 +1144,10 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_validate_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/validateConfiguration"
+    begin_disable_workload_management_network.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}/disableWorkloadManagementNetwork"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_taps_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_ip_extended_communities_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,593 +3,810 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 from io import IOBase
-from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
+from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
-from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
+from azure.core.pipeline.transport import HttpResponse
+from azure.core.polling import LROPoller, NoPolling, PollingMethod
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
-from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
+from azure.mgmt.core.polling.arm_polling import ARMPolling
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._network_taps_operations import (
-    build_create_request,
-    build_delete_request,
-    build_get_request,
-    build_list_by_resource_group_request,
-    build_list_by_subscription_request,
-    build_resync_request,
-    build_update_administrative_state_request,
-    build_update_request,
-)
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request, _format_url_section
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_create_request(
+    resource_group_name: str, ip_extended_community_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "ipExtendedCommunityName": _SERIALIZER.url("ip_extended_community_name", ip_extended_community_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_get_request(
+    resource_group_name: str, ip_extended_community_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "ipExtendedCommunityName": _SERIALIZER.url("ip_extended_community_name", ip_extended_community_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-class NetworkTapsOperations:
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_update_request(
+    resource_group_name: str, ip_extended_community_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "ipExtendedCommunityName": _SERIALIZER.url("ip_extended_community_name", ip_extended_community_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_delete_request(
+    resource_group_name: str, ip_extended_community_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "ipExtendedCommunityName": _SERIALIZER.url("ip_extended_community_name", ip_extended_community_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities"
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class IpExtendedCommunitiesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.managednetworkfabric.aio.ManagedNetworkFabricMgmtClient`'s
-        :attr:`network_taps` attribute.
+        :class:`~azure.mgmt.managednetworkfabric.ManagedNetworkFabricMgmtClient`'s
+        :attr:`ip_extended_communities` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    async def _create_initial(
-        self, resource_group_name: str, network_tap_name: str, body: Union[_models.NetworkTap, IO], **kwargs: Any
-    ) -> _models.NetworkTap:
+    def _create_initial(
+        self,
+        resource_group_name: str,
+        ip_extended_community_name: str,
+        body: Union[_models.IpExtendedCommunity, IO],
+        **kwargs: Any
+    ) -> _models.IpExtendedCommunity:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkTap] = kwargs.pop("cls", None)
+        cls: ClsType[_models.IpExtendedCommunity] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkTap")
+            _json = self._serialize.body(body, "IpExtendedCommunity")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            network_tap_name=network_tap_name,
+            ip_extended_community_name=ip_extended_community_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkTap", pipeline_response)
+            deserialized = self._deserialize("IpExtendedCommunity", pipeline_response)
 
         if response.status_code == 201:
-            deserialized = self._deserialize("NetworkTap", pipeline_response)
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
+            deserialized = self._deserialize("IpExtendedCommunity", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}"
     }
 
     @overload
-    async def begin_create(
+    def begin_create(
         self,
         resource_group_name: str,
-        network_tap_name: str,
-        body: _models.NetworkTap,
+        ip_extended_community_name: str,
+        body: _models.IpExtendedCommunity,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkTap]:
-        """Create Network Tap.
+    ) -> LROPoller[_models.IpExtendedCommunity]:
+        """Create an IP Extended Community.
 
-        Creates a Network Tap.
+        Implements IP Extended Community PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_name: Name of the Network Tap. Required.
-        :type network_tap_name: str
+        :param ip_extended_community_name: Name of the IP Extended Community. Required.
+        :type ip_extended_community_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkTap
+        :type body: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkTap or the result of
+        :return: An instance of LROPoller that returns either IpExtendedCommunity or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTap]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_create(
+    def begin_create(
         self,
         resource_group_name: str,
-        network_tap_name: str,
+        ip_extended_community_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkTap]:
-        """Create Network Tap.
+    ) -> LROPoller[_models.IpExtendedCommunity]:
+        """Create an IP Extended Community.
 
-        Creates a Network Tap.
+        Implements IP Extended Community PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_name: Name of the Network Tap. Required.
-        :type network_tap_name: str
+        :param ip_extended_community_name: Name of the IP Extended Community. Required.
+        :type ip_extended_community_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkTap or the result of
+        :return: An instance of LROPoller that returns either IpExtendedCommunity or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTap]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_create(
-        self, resource_group_name: str, network_tap_name: str, body: Union[_models.NetworkTap, IO], **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkTap]:
-        """Create Network Tap.
+    @distributed_trace
+    def begin_create(
+        self,
+        resource_group_name: str,
+        ip_extended_community_name: str,
+        body: Union[_models.IpExtendedCommunity, IO],
+        **kwargs: Any
+    ) -> LROPoller[_models.IpExtendedCommunity]:
+        """Create an IP Extended Community.
 
-        Creates a Network Tap.
+        Implements IP Extended Community PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_name: Name of the Network Tap. Required.
-        :type network_tap_name: str
-        :param body: Request payload. Is either a NetworkTap type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkTap or IO
+        :param ip_extended_community_name: Name of the IP Extended Community. Required.
+        :type ip_extended_community_name: str
+        :param body: Request payload. Is either a IpExtendedCommunity type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkTap or the result of
+        :return: An instance of LROPoller that returns either IpExtendedCommunity or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTap]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkTap] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[_models.IpExtendedCommunity] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._create_initial(
+            raw_result = self._create_initial(
                 resource_group_name=resource_group_name,
-                network_tap_name=network_tap_name,
+                ip_extended_community_name=ip_extended_community_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkTap", pipeline_response)
+            deserialized = self._deserialize("IpExtendedCommunity", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}"
     }
 
-    @distributed_trace_async
-    async def get(self, resource_group_name: str, network_tap_name: str, **kwargs: Any) -> _models.NetworkTap:
-        """Gets a Network Tap.
+    @distributed_trace
+    def get(
+        self, resource_group_name: str, ip_extended_community_name: str, **kwargs: Any
+    ) -> _models.IpExtendedCommunity:
+        """Gets an IP Extended Community.
 
-        Retrieves details of this Network Tap.
+        Implements IP Extended Community GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_name: Name of the Network Tap. Required.
-        :type network_tap_name: str
+        :param ip_extended_community_name: Name of the IP Extended Community. Required.
+        :type ip_extended_community_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NetworkTap or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkTap
+        :return: IpExtendedCommunity or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkTap] = kwargs.pop("cls", None)
+        cls: ClsType[_models.IpExtendedCommunity] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            network_tap_name=network_tap_name,
+            ip_extended_community_name=ip_extended_community_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("NetworkTap", pipeline_response)
+        deserialized = self._deserialize("IpExtendedCommunity", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}"
     }
 
-    async def _update_initial(
-        self, resource_group_name: str, network_tap_name: str, body: Union[_models.NetworkTapPatch, IO], **kwargs: Any
-    ) -> Optional[_models.NetworkTap]:
+    def _update_initial(
+        self,
+        resource_group_name: str,
+        ip_extended_community_name: str,
+        body: Union[_models.IpExtendedCommunityPatch, IO],
+        **kwargs: Any
+    ) -> Optional[_models.IpExtendedCommunity]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.NetworkTap]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.IpExtendedCommunity]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkTapPatch")
+            _json = self._serialize.body(body, "IpExtendedCommunityPatch")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            network_tap_name=network_tap_name,
+            ip_extended_community_name=ip_extended_community_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkTap", pipeline_response)
+            deserialized = self._deserialize("IpExtendedCommunity", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}"
     }
 
     @overload
-    async def begin_update(
+    def begin_update(
         self,
         resource_group_name: str,
-        network_tap_name: str,
-        body: _models.NetworkTapPatch,
+        ip_extended_community_name: str,
+        body: _models.IpExtendedCommunityPatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkTap]:
-        """Updates the Network Taps.
+    ) -> LROPoller[_models.IpExtendedCommunity]:
+        """Updates the IP Extended Community.
 
-        API to update certain properties of the Network Tap resource.
+        API to update certain properties of the IP Extended Community resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_name: Name of the Network Tap. Required.
-        :type network_tap_name: str
-        :param body: Network Tap properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkTapPatch
+        :param ip_extended_community_name: Name of the IP Extended Community. Required.
+        :type ip_extended_community_name: str
+        :param body: IP Extended Community properties to update. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkTap or the result of
+        :return: An instance of LROPoller that returns either IpExtendedCommunity or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTap]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_update(
+    def begin_update(
         self,
         resource_group_name: str,
-        network_tap_name: str,
+        ip_extended_community_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkTap]:
-        """Updates the Network Taps.
+    ) -> LROPoller[_models.IpExtendedCommunity]:
+        """Updates the IP Extended Community.
 
-        API to update certain properties of the Network Tap resource.
+        API to update certain properties of the IP Extended Community resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_name: Name of the Network Tap. Required.
-        :type network_tap_name: str
-        :param body: Network Tap properties to update. Required.
+        :param ip_extended_community_name: Name of the IP Extended Community. Required.
+        :type ip_extended_community_name: str
+        :param body: IP Extended Community properties to update. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkTap or the result of
+        :return: An instance of LROPoller that returns either IpExtendedCommunity or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTap]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_update(
-        self, resource_group_name: str, network_tap_name: str, body: Union[_models.NetworkTapPatch, IO], **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkTap]:
-        """Updates the Network Taps.
+    @distributed_trace
+    def begin_update(
+        self,
+        resource_group_name: str,
+        ip_extended_community_name: str,
+        body: Union[_models.IpExtendedCommunityPatch, IO],
+        **kwargs: Any
+    ) -> LROPoller[_models.IpExtendedCommunity]:
+        """Updates the IP Extended Community.
 
-        API to update certain properties of the Network Tap resource.
+        API to update certain properties of the IP Extended Community resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_name: Name of the Network Tap. Required.
-        :type network_tap_name: str
-        :param body: Network Tap properties to update. Is either a NetworkTapPatch type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkTapPatch or IO
+        :param ip_extended_community_name: Name of the IP Extended Community. Required.
+        :type ip_extended_community_name: str
+        :param body: IP Extended Community properties to update. Is either a IpExtendedCommunityPatch
+         type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkTap or the result of
+        :return: An instance of LROPoller that returns either IpExtendedCommunity or the result of
          cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTap]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkTap] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[_models.IpExtendedCommunity] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_initial(
+            raw_result = self._update_initial(
                 resource_group_name=resource_group_name,
-                network_tap_name=network_tap_name,
+                ip_extended_community_name=ip_extended_community_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkTap", pipeline_response)
+            deserialized = self._deserialize("IpExtendedCommunity", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}"
     }
 
-    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, network_tap_name: str, **kwargs: Any
+    def _delete_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, ip_extended_community_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -599,133 +816,139 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            network_tap_name=network_tap_name,
+            ip_extended_community_name=ip_extended_community_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}"
     }
 
-    @distributed_trace_async
-    async def begin_delete(
-        self, resource_group_name: str, network_tap_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[None]:
-        """Deletes a Network Tap.
+    @distributed_trace
+    def begin_delete(self, resource_group_name: str, ip_extended_community_name: str, **kwargs: Any) -> LROPoller[None]:
+        """Deletes the IP Extended Community.
 
-        Deletes Network Tap.
+        Implements IP Extended Community DELETE method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_name: Name of the Network Tap. Required.
-        :type network_tap_name: str
+        :param ip_extended_community_name: Name of the IP Extended Community. Required.
+        :type ip_extended_community_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._delete_initial(  # type: ignore
+            raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_tap_name=network_tap_name,
+                ip_extended_community_name=ip_extended_community_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}"
     }
 
     @distributed_trace
-    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.NetworkTap"]:
-        """List Network Taps by resource group.
+    def list_by_resource_group(
+        self, resource_group_name: str, **kwargs: Any
+    ) -> Iterable["_models.IpExtendedCommunity"]:
+        """List IpExtendedCommunities by resource group.
 
-        Displays Network Taps list by resource group GET method.
+        Implements IpExtendedCommunities list by resource group GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkTap or the result of cls(response)
+        :return: An iterator like instance of either IpExtendedCommunity or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkTap]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkTapsListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.IpExtendedCommunityListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -759,60 +982,60 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkTapsListResult", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("IpExtendedCommunityListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
     list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities"
     }
 
     @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.NetworkTap"]:
-        """List Network Taps by subscription.
+    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.IpExtendedCommunity"]:
+        """List IpExtendedCommunities by subscription.
 
-        Displays Network Taps list by subscription GET method.
+        Implements IpExtendedCommunities list by subscription GET method.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkTap or the result of cls(response)
+        :return: An iterator like instance of either IpExtendedCommunity or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkTap]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkTapsListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.IpExtendedCommunityListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -845,408 +1068,35 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkTapsListResult", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("IpExtendedCommunityListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
     list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkTaps"
-    }
-
-    async def _update_administrative_state_initial(
-        self,
-        resource_group_name: str,
-        network_tap_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
-        **kwargs: Any
-    ) -> _models.CommonPostActionResponseForDeviceUpdate:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "UpdateAdministrativeState")
-
-        request = build_update_administrative_state_request(
-            resource_group_name=resource_group_name,
-            network_tap_name=network_tap_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self._update_administrative_state_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
-
-    _update_administrative_state_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}/updateAdministrativeState"
-    }
-
-    @overload
-    async def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        network_tap_name: str,
-        body: _models.UpdateAdministrativeState,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """Updates administrative state of  Network Tap.
-
-        Implements the operation to the underlying resources.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_tap_name: Name of the Network Tap. Required.
-        :type network_tap_name: str
-        :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForDeviceUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    async def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        network_tap_name: str,
-        body: IO,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """Updates administrative state of  Network Tap.
-
-        Implements the operation to the underlying resources.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_tap_name: Name of the Network Tap. Required.
-        :type network_tap_name: str
-        :param body: Request payload. Required.
-        :type body: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForDeviceUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @distributed_trace_async
-    async def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        network_tap_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """Updates administrative state of  Network Tap.
-
-        Implements the operation to the underlying resources.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_tap_name: Name of the Network Tap. Required.
-        :type network_tap_name: str
-        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForDeviceUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._update_administrative_state_initial(
-                resource_group_name=resource_group_name,
-                network_tap_name=network_tap_name,
-                body=body,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_update_administrative_state.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}/updateAdministrativeState"
-    }
-
-    async def _resync_initial(
-        self, resource_group_name: str, network_tap_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-
-        request = build_resync_request(
-            resource_group_name=resource_group_name,
-            network_tap_name=network_tap_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            template_url=self._resync_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
-
-    _resync_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}/resync"
-    }
-
-    @distributed_trace_async
-    async def begin_resync(
-        self, resource_group_name: str, network_tap_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Resync operation on the Network Tap.
-
-        Implements the operation to the underlying resources.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_tap_name: Name of the Network Tap. Required.
-        :type network_tap_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._resync_initial(
-                resource_group_name=resource_group_name,
-                network_tap_name=network_tap_name,
-                api_version=api_version,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_resync.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}/resync"
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_fabric_skus_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_fabric_skus_operations.py`

 * *Files 1% similar despite different names*

```diff
@@ -53,17 +53,17 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace_async
     async def get(self, network_fabric_sku_name: str, **kwargs: Any) -> _models.NetworkFabricSku:
         """Gets a Network Fabric Sku.
 
-        Implements Network Fabric SKU GET method.
+        Implements Network Fabric Sku GET method.
 
-        :param network_fabric_sku_name: Name of the Network Fabric SKU. Required.
+        :param network_fabric_sku_name: Name of the Network Fabric Sku. Required.
         :type network_fabric_sku_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: NetworkFabricSku or the result of cls(response)
         :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkFabricSku
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
@@ -112,17 +112,17 @@
 
     get.metadata = {
         "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabricSkus/{networkFabricSkuName}"
     }
 
     @distributed_trace
     def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.NetworkFabricSku"]:
-        """List Network Fabric SKUs by subscription.
+        """List NetworkFabricSkus by subscription.
 
-        Implements Network Fabric SKUs list by subscription GET method.
+        Implements NetworkFabricSkus list by subscription GET method.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either NetworkFabricSku or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkFabricSku]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_patch.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_external_networks_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_external_networks_operations.py`

 * *Files 23% similar despite different names*

```diff
@@ -28,21 +28,24 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._external_networks_operations import (
+    build_clear_arp_entries_request,
+    build_clear_ipv6_neighbors_request,
     build_create_request,
     build_delete_request,
     build_get_request,
-    build_list_by_l3_isolation_domain_request,
+    build_list_request,
     build_update_administrative_state_request,
+    build_update_bfd_for_bgp_administrative_state_request,
+    build_update_bgp_administrative_state_request,
     build_update_request,
-    build_update_static_route_bfd_administrative_state_request,
 )
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ExternalNetworksOperations:
@@ -153,17 +156,17 @@
         services.
 
         Creates ExternalNetwork PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param external_network_name: Name of the External Network. Required.
+        :param external_network_name: Name of the ExternalNetwork. Required.
         :type external_network_name: str
         :param body: Request payload. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.ExternalNetwork
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -196,17 +199,17 @@
         services.
 
         Creates ExternalNetwork PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param external_network_name: Name of the External Network. Required.
+        :param external_network_name: Name of the ExternalNetwork. Required.
         :type external_network_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -237,17 +240,17 @@
         services.
 
         Creates ExternalNetwork PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param external_network_name: Name of the External Network. Required.
+        :param external_network_name: Name of the ExternalNetwork. Required.
         :type external_network_name: str
         :param body: Request payload. Is either a ExternalNetwork type or a IO type. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.ExternalNetwork or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -323,17 +326,17 @@
         """Retrieves details of ExternalNetwork.
 
         Implements ExternalNetworks GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param external_network_name: Name of the External Network. Required.
+        :param external_network_name: Name of the ExternalNetwork. Required.
         :type external_network_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ExternalNetwork or the result of cls(response)
         :rtype: ~azure.mgmt.managednetworkfabric.models.ExternalNetwork
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
@@ -389,29 +392,29 @@
     async def _update_initial(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         external_network_name: str,
         body: Union[_models.ExternalNetworkPatch, IO],
         **kwargs: Any
-    ) -> Optional[_models.ExternalNetwork]:
+    ) -> _models.ExternalNetwork:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.ExternalNetwork]] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ExternalNetwork] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
@@ -441,26 +444,24 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = None
-        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("ExternalNetwork", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            deserialized = self._deserialize("ExternalNetwork", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
     _update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}"
     }
 
     @overload
     async def begin_update(
@@ -469,24 +470,24 @@
         l3_isolation_domain_name: str,
         external_network_name: str,
         body: _models.ExternalNetworkPatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.ExternalNetwork]:
-        """Updates a External Networks.
+        """Updates a ExternalNetworks.
 
         API to update certain properties of the ExternalNetworks resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param external_network_name: Name of the External Network. Required.
+        :param external_network_name: Name of the ExternalNetwork. Required.
         :type external_network_name: str
         :param body: ExternalNetwork properties to update. Only annotations are supported. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.ExternalNetworkPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -511,24 +512,24 @@
         l3_isolation_domain_name: str,
         external_network_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> AsyncLROPoller[_models.ExternalNetwork]:
-        """Updates a External Networks.
+        """Updates a ExternalNetworks.
 
         API to update certain properties of the ExternalNetworks resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param external_network_name: Name of the External Network. Required.
+        :param external_network_name: Name of the ExternalNetwork. Required.
         :type external_network_name: str
         :param body: ExternalNetwork properties to update. Only annotations are supported. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -551,24 +552,24 @@
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         external_network_name: str,
         body: Union[_models.ExternalNetworkPatch, IO],
         **kwargs: Any
     ) -> AsyncLROPoller[_models.ExternalNetwork]:
-        """Updates a External Networks.
+        """Updates a ExternalNetworks.
 
         API to update certain properties of the ExternalNetworks resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param external_network_name: Name of the External Network. Required.
+        :param external_network_name: Name of the ExternalNetwork. Required.
         :type external_network_name: str
         :param body: ExternalNetwork properties to update. Only annotations are supported. Is either a
          ExternalNetworkPatch type or a IO type. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.ExternalNetworkPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
@@ -614,15 +615,16 @@
             deserialized = self._deserialize("ExternalNetwork", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+                AsyncPollingMethod,
+                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
@@ -670,15 +672,15 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
@@ -693,17 +695,17 @@
         """Deletes a ExternalNetworks.
 
         Implements ExternalNetworks DELETE method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param external_network_name: Name of the External Network. Required.
+        :param external_network_name: Name of the ExternalNetwork. Required.
         :type external_network_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
@@ -756,25 +758,25 @@
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}"
     }
 
     @distributed_trace
-    def list_by_l3_isolation_domain(
+    def list(
         self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
     ) -> AsyncIterable["_models.ExternalNetwork"]:
         """Executes list operation to display External Networks within an isolation domain.
 
         Implements External Networks list by resource group GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ExternalNetwork or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.ExternalNetwork]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -791,20 +793,20 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_by_l3_isolation_domain_request(
+                request = build_list_request(
                     resource_group_name=resource_group_name,
                     l3_isolation_domain_name=l3_isolation_domain_name,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
-                    template_url=self.list_by_l3_isolation_domain.metadata["url"],
+                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
@@ -846,40 +848,40 @@
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list_by_l3_isolation_domain.metadata = {
+    list.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks"
     }
 
-    async def _update_administrative_state_initial(
+    async def _update_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         external_network_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
@@ -904,32 +906,24 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
     _update_administrative_state_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateAdministrativeState"
     }
 
     @overload
     async def begin_update_administrative_state(
@@ -937,107 +931,103 @@
         resource_group_name: str,
         l3_isolation_domain_name: str,
         external_network_name: str,
         body: _models.UpdateAdministrativeState,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> AsyncLROPoller[None]:
         """Implements the operation to the underlying resources.
 
         Executes update operation to enable or disable administrative State for externalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param external_network_name: Name of the External Network. Required.
+        :param external_network_name: Name of the ExternalNetwork. Required.
         :type external_network_name: str
         :param body: Request payload. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update_administrative_state(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         external_network_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> AsyncLROPoller[None]:
         """Implements the operation to the underlying resources.
 
         Executes update operation to enable or disable administrative State for externalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param external_network_name: Name of the External Network. Required.
+        :param external_network_name: Name of the ExternalNetwork. Required.
         :type external_network_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update_administrative_state(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         external_network_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> AsyncLROPoller[None]:
         """Implements the operation to the underlying resources.
 
         Executes update operation to enable or disable administrative State for externalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param external_network_name: Name of the External Network. Required.
+        :param external_network_name: Name of the ExternalNetwork. Required.
         :type external_network_name: str
         :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
          Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
@@ -1045,49 +1035,45 @@
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_administrative_state_initial(
+            raw_result = await self._update_administrative_state_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 l3_isolation_domain_name=l3_isolation_domain_name,
                 external_network_name=external_network_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
@@ -1102,194 +1088,418 @@
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update_administrative_state.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateAdministrativeState"
     }
 
-    async def _update_static_route_bfd_administrative_state_initial(
+    async def _update_bgp_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         external_network_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "UpdateAdministrativeState")
 
-        request = build_update_static_route_bfd_administrative_state_request(
+        request = build_update_bgp_administrative_state_request(
             resource_group_name=resource_group_name,
             l3_isolation_domain_name=l3_isolation_domain_name,
             external_network_name=external_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._update_static_route_bfd_administrative_state_initial.metadata["url"],
+            template_url=self._update_bgp_administrative_state_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        if cls:
+            return cls(pipeline_response, None, response_headers)
 
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+    _update_bgp_administrative_state_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateBgpAdministrativeState"
+    }
 
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+    @overload
+    async def begin_update_bgp_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: _models.UpdateAdministrativeState,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Executes BGP state update operation to the underlying resources.
 
-        return deserialized  # type: ignore
+        Update BGP for externalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    async def begin_update_bgp_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Executes BGP state update operation to the underlying resources.
+
+        Update BGP for externalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @distributed_trace_async
+    async def begin_update_bgp_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Executes BGP state update operation to the underlying resources.
+
+        Update BGP for externalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = await self._update_bgp_administrative_state_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                external_network_name=external_network_name,
+                body=body,
+                api_version=api_version,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
 
-    _update_static_route_bfd_administrative_state_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateStaticRouteBfdAdministrativeState"
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
+
+        if polling is True:
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_update_bgp_administrative_state.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateBgpAdministrativeState"
+    }
+
+    async def _update_bfd_for_bgp_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "UpdateAdministrativeState")
+
+        request = build_update_bfd_for_bgp_administrative_state_request(
+            resource_group_name=resource_group_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            external_network_name=external_network_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._update_bfd_for_bgp_administrative_state_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    _update_bfd_for_bgp_administrative_state_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateBfdForBgpAdministrativeState"
     }
 
     @overload
-    async def begin_update_static_route_bfd_administrative_state(
+    async def begin_update_bfd_for_bgp_administrative_state(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         external_network_name: str,
         body: _models.UpdateAdministrativeState,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Executes Static Route BFD state update operation to the underlying resources.
+    ) -> AsyncLROPoller[None]:
+        """Execute BfdForBgp update operation to the underlying resources.
 
-        Update Static Route BFD for external Network.
+        Update BfdForBgp for externalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param external_network_name: Name of the External Network. Required.
+        :param external_network_name: Name of the ExternalNetwork. Required.
         :type external_network_name: str
         :param body: Request payload. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_update_static_route_bfd_administrative_state(
+    async def begin_update_bfd_for_bgp_administrative_state(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         external_network_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Executes Static Route BFD state update operation to the underlying resources.
+    ) -> AsyncLROPoller[None]:
+        """Execute BfdForBgp update operation to the underlying resources.
 
-        Update Static Route BFD for external Network.
+        Update BfdForBgp for externalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param external_network_name: Name of the External Network. Required.
+        :param external_network_name: Name of the ExternalNetwork. Required.
         :type external_network_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
-    async def begin_update_static_route_bfd_administrative_state(
+    async def begin_update_bfd_for_bgp_administrative_state(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         external_network_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Executes Static Route BFD state update operation to the underlying resources.
+    ) -> AsyncLROPoller[None]:
+        """Execute BfdForBgp update operation to the underlying resources.
 
-        Update Static Route BFD for external Network.
+        Update BfdForBgp for externalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param external_network_name: Name of the External Network. Required.
+        :param external_network_name: Name of the ExternalNetwork. Required.
         :type external_network_name: str
         :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
          Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
@@ -1297,49 +1507,515 @@
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_static_route_bfd_administrative_state_initial(
+            raw_result = await self._update_bfd_for_bgp_administrative_state_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 l3_isolation_domain_name=l3_isolation_domain_name,
                 external_network_name=external_network_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
+
+        if polling is True:
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_update_bfd_for_bgp_administrative_state.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateBfdForBgpAdministrativeState"
+    }
+
+    async def _clear_ipv6_neighbors_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "EnableDisableOnResources")
+
+        request = build_clear_ipv6_neighbors_request(
+            resource_group_name=resource_group_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            external_network_name=external_network_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._clear_ipv6_neighbors_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    _clear_ipv6_neighbors_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/clearIpv6Neighbors"
+    }
+
+    @overload
+    async def begin_clear_ipv6_neighbors(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: _models.EnableDisableOnResources,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Executes clearIpv6Neighbors table operation to the underlying resources.
+
+        clearIpv6Neighbors for externalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    async def begin_clear_ipv6_neighbors(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Executes clearIpv6Neighbors table operation to the underlying resources.
+
+        clearIpv6Neighbors for externalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @distributed_trace_async
+    async def begin_clear_ipv6_neighbors(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Executes clearIpv6Neighbors table operation to the underlying resources.
+
+        clearIpv6Neighbors for externalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Is either a EnableDisableOnResources type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = await self._clear_ipv6_neighbors_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                external_network_name=external_network_name,
+                body=body,
+                api_version=api_version,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
+
+        if polling is True:
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_clear_ipv6_neighbors.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/clearIpv6Neighbors"
+    }
+
+    async def _clear_arp_entries_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "EnableDisableOnResources")
+
+        request = build_clear_arp_entries_request(
+            resource_group_name=resource_group_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            external_network_name=external_network_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._clear_arp_entries_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    _clear_arp_entries_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/clearArpEntries"
+    }
+
+    @overload
+    async def begin_clear_arp_entries(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: _models.EnableDisableOnResources,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
+
+        clearArpEntries for externalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    async def begin_clear_arp_entries(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
+
+        clearArpEntries for externalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @distributed_trace_async
+    async def begin_clear_arp_entries(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
+
+        clearArpEntries for externalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Is either a EnableDisableOnResources type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = await self._clear_arp_entries_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                external_network_name=external_network_name,
+                body=body,
+                api_version=api_version,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
@@ -1350,10 +2026,10 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_update_static_route_bfd_administrative_state.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateStaticRouteBfdAdministrativeState"
+    begin_clear_arp_entries.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/clearArpEntries"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_operations.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_device_skus_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_network_device_skus_operations.py`

 * *Files 1% similar despite different names*

```diff
@@ -53,17 +53,17 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace_async
     async def get(self, network_device_sku_name: str, **kwargs: Any) -> _models.NetworkDeviceSku:
         """Gets a Network Device Sku.
 
-        Get a Network Device SKU details.
+        Get Network Device SKU details.
 
-        :param network_device_sku_name: Name of the Network Device SKU. Required.
+        :param network_device_sku_name: Name of the Network Device Sku. Required.
         :type network_device_sku_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: NetworkDeviceSku or the result of cls(response)
         :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkDeviceSku
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
@@ -112,15 +112,15 @@
 
     get.metadata = {
         "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkDeviceSkus/{networkDeviceSkuName}"
     }
 
     @distributed_trace
     def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.NetworkDeviceSku"]:
-        """List Network Device SKUs by subscription.
+        """List NetworkDeviceSkus by subscription.
 
         List Network Device SKUs for the given subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either NetworkDeviceSku or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkDeviceSku]
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_l2_isolation_domains_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_l3_isolation_domains_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -27,82 +27,83 @@
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._l2_isolation_domains_operations import (
-    build_commit_configuration_request,
+from ...operations._l3_isolation_domains_operations import (
+    build_clear_arp_table_request,
+    build_clear_neighbor_table_request,
     build_create_request,
     build_delete_request,
     build_get_request,
     build_list_by_resource_group_request,
     build_list_by_subscription_request,
     build_update_administrative_state_request,
+    build_update_option_b_administrative_state_request,
     build_update_request,
-    build_validate_configuration_request,
 )
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class L2IsolationDomainsOperations:
+class L3IsolationDomainsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.managednetworkfabric.aio.ManagedNetworkFabricMgmtClient`'s
-        :attr:`l2_isolation_domains` attribute.
+        :attr:`l3_isolation_domains` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     async def _create_initial(
         self,
         resource_group_name: str,
-        l2_isolation_domain_name: str,
-        body: Union[_models.L2IsolationDomain, IO],
+        l3_isolation_domain_name: str,
+        body: Union[_models.L3IsolationDomain, IO],
         **kwargs: Any
-    ) -> _models.L2IsolationDomain:
+    ) -> _models.L3IsolationDomain:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.L2IsolationDomain] = kwargs.pop("cls", None)
+        cls: ClsType[_models.L3IsolationDomain] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "L2IsolationDomain")
+            _json = self._serialize.body(body, "L3IsolationDomain")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            l2_isolation_domain_name=l2_isolation_domain_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
@@ -120,170 +121,173 @@
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
-            deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
+            deserialized = self._deserialize("L3IsolationDomain", pipeline_response)
 
         if response.status_code == 201:
-            deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
+            deserialized = self._deserialize("L3IsolationDomain", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}"
     }
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
-        l2_isolation_domain_name: str,
-        body: _models.L2IsolationDomain,
+        l3_isolation_domain_name: str,
+        body: _models.L3IsolationDomain,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.L2IsolationDomain]:
-        """Create L2 Isolation Domain.
+    ) -> AsyncLROPoller[_models.L3IsolationDomain]:
+        """Create L3 Isolation Domain.
 
-        Creates layer 2 network connectivity between compute nodes within a rack and across racks.The
-        configuration is applied on the devices only after the isolation domain is enabled.
+        Create isolation domain resources for layer 3 connectivity between compute nodes and for
+        communication with external services .This configuration is applied on the devices only after
+        the creation of networks is completed and isolation domain is enabled.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
-        :type l2_isolation_domain_name: str
+        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :type l3_isolation_domain_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.L2IsolationDomain
+        :type body: ~azure.mgmt.managednetworkfabric.models.L3IsolationDomain
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either L2IsolationDomain or the result of
+        :return: An instance of AsyncLROPoller that returns either L3IsolationDomain or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_create(
         self,
         resource_group_name: str,
-        l2_isolation_domain_name: str,
+        l3_isolation_domain_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.L2IsolationDomain]:
-        """Create L2 Isolation Domain.
+    ) -> AsyncLROPoller[_models.L3IsolationDomain]:
+        """Create L3 Isolation Domain.
 
-        Creates layer 2 network connectivity between compute nodes within a rack and across racks.The
-        configuration is applied on the devices only after the isolation domain is enabled.
+        Create isolation domain resources for layer 3 connectivity between compute nodes and for
+        communication with external services .This configuration is applied on the devices only after
+        the creation of networks is completed and isolation domain is enabled.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
-        :type l2_isolation_domain_name: str
+        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :type l3_isolation_domain_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either L2IsolationDomain or the result of
+        :return: An instance of AsyncLROPoller that returns either L3IsolationDomain or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_create(
         self,
         resource_group_name: str,
-        l2_isolation_domain_name: str,
-        body: Union[_models.L2IsolationDomain, IO],
+        l3_isolation_domain_name: str,
+        body: Union[_models.L3IsolationDomain, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.L2IsolationDomain]:
-        """Create L2 Isolation Domain.
+    ) -> AsyncLROPoller[_models.L3IsolationDomain]:
+        """Create L3 Isolation Domain.
 
-        Creates layer 2 network connectivity between compute nodes within a rack and across racks.The
-        configuration is applied on the devices only after the isolation domain is enabled.
+        Create isolation domain resources for layer 3 connectivity between compute nodes and for
+        communication with external services .This configuration is applied on the devices only after
+        the creation of networks is completed and isolation domain is enabled.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
-        :type l2_isolation_domain_name: str
-        :param body: Request payload. Is either a L2IsolationDomain type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.L2IsolationDomain or IO
+        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Is either a L3IsolationDomain type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.L3IsolationDomain or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either L2IsolationDomain or the result of
+        :return: An instance of AsyncLROPoller that returns either L3IsolationDomain or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.L2IsolationDomain] = kwargs.pop("cls", None)
+        cls: ClsType[_models.L3IsolationDomain] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
                 resource_group_name=resource_group_name,
-                l2_isolation_domain_name=l2_isolation_domain_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
+            deserialized = self._deserialize("L3IsolationDomain", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod,
@@ -299,52 +303,52 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}"
     }
 
     @distributed_trace_async
     async def get(
-        self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any
-    ) -> _models.L2IsolationDomain:
-        """Retrieves details of this L2 Isolation Domain.
+        self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
+    ) -> _models.L3IsolationDomain:
+        """Gets a L3 Isolation Domain.
 
-        Implements L2 Isolation Domain GET method.
+        Retrieves details of this L3 Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
-        :type l2_isolation_domain_name: str
+        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :type l3_isolation_domain_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: L2IsolationDomain or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.L2IsolationDomain
+        :return: L3IsolationDomain or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.L3IsolationDomain
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.L2IsolationDomain] = kwargs.pop("cls", None)
+        cls: ClsType[_models.L3IsolationDomain] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            l2_isolation_domain_name=l2_isolation_domain_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -358,58 +362,58 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
+        deserialized = self._deserialize("L3IsolationDomain", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}"
     }
 
     async def _update_initial(
         self,
         resource_group_name: str,
-        l2_isolation_domain_name: str,
-        body: Union[_models.L2IsolationDomainPatch, IO],
+        l3_isolation_domain_name: str,
+        body: Union[_models.L3IsolationDomainPatch, IO],
         **kwargs: Any
-    ) -> Optional[_models.L2IsolationDomain]:
+    ) -> Optional[_models.L3IsolationDomain]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.L2IsolationDomain]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.L3IsolationDomain]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "L2IsolationDomainPatch")
+            _json = self._serialize.body(body, "L3IsolationDomainPatch")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            l2_isolation_domain_name=l2_isolation_domain_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
@@ -429,168 +433,170 @@
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
+            deserialized = self._deserialize("L3IsolationDomain", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}"
     }
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
-        l2_isolation_domain_name: str,
-        body: _models.L2IsolationDomainPatch,
+        l3_isolation_domain_name: str,
+        body: _models.L3IsolationDomainPatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.L2IsolationDomain]:
-        """Updates the L2 Isolation Domain.
+    ) -> AsyncLROPoller[_models.L3IsolationDomain]:
+        """Updates a L3 Isolation Domain.
 
-        API to update certain properties of the L2 Isolation Domain resource.
+        API to update certain properties of the L3 Isolation Domain resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
-        :type l2_isolation_domain_name: str
-        :param body: API to update certain properties of the L2 Isolation Domain resource.. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.L2IsolationDomainPatch
+        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: API to update certain properties of the L3 Isolation Domain resource. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.L3IsolationDomainPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either L2IsolationDomain or the result of
+        :return: An instance of AsyncLROPoller that returns either L3IsolationDomain or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update(
         self,
         resource_group_name: str,
-        l2_isolation_domain_name: str,
+        l3_isolation_domain_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.L2IsolationDomain]:
-        """Updates the L2 Isolation Domain.
+    ) -> AsyncLROPoller[_models.L3IsolationDomain]:
+        """Updates a L3 Isolation Domain.
 
-        API to update certain properties of the L2 Isolation Domain resource.
+        API to update certain properties of the L3 Isolation Domain resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
-        :type l2_isolation_domain_name: str
-        :param body: API to update certain properties of the L2 Isolation Domain resource.. Required.
+        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: API to update certain properties of the L3 Isolation Domain resource. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either L2IsolationDomain or the result of
+        :return: An instance of AsyncLROPoller that returns either L3IsolationDomain or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update(
         self,
         resource_group_name: str,
-        l2_isolation_domain_name: str,
-        body: Union[_models.L2IsolationDomainPatch, IO],
+        l3_isolation_domain_name: str,
+        body: Union[_models.L3IsolationDomainPatch, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.L2IsolationDomain]:
-        """Updates the L2 Isolation Domain.
+    ) -> AsyncLROPoller[_models.L3IsolationDomain]:
+        """Updates a L3 Isolation Domain.
 
-        API to update certain properties of the L2 Isolation Domain resource.
+        API to update certain properties of the L3 Isolation Domain resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
-        :type l2_isolation_domain_name: str
-        :param body: API to update certain properties of the L2 Isolation Domain resource.. Is either a
-         L2IsolationDomainPatch type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.L2IsolationDomainPatch or IO
+        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: API to update certain properties of the L3 Isolation Domain resource. Is either a
+         L3IsolationDomainPatch type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.L3IsolationDomainPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either L2IsolationDomain or the result of
+        :return: An instance of AsyncLROPoller that returns either L3IsolationDomain or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.L2IsolationDomain] = kwargs.pop("cls", None)
+        cls: ClsType[_models.L3IsolationDomain] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(
                 resource_group_name=resource_group_name,
-                l2_isolation_domain_name=l2_isolation_domain_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
+            deserialized = self._deserialize("L3IsolationDomain", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
@@ -605,19 +611,19 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}"
     }
 
     async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any
+        self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -627,15 +633,15 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            l2_isolation_domain_name=l2_isolation_domain_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -644,39 +650,39 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}"
     }
 
     @distributed_trace_async
     async def begin_delete(
-        self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any
+        self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
     ) -> AsyncLROPoller[None]:
-        """Deletes the L2 Isolation Domain.
+        """Deletes a L3 Isolation Domain.
 
-        Deletes layer 2 connectivity between compute nodes by managed by named L2 Isolation name.
+        Deletes layer 3 connectivity between compute nodes by managed by named L3 Isolation name.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
-        :type l2_isolation_domain_name: str
+        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :type l3_isolation_domain_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
@@ -692,15 +698,15 @@
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                l2_isolation_domain_name=l2_isolation_domain_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
@@ -723,50 +729,228 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}"
+    }
+
+    @distributed_trace
+    def list_by_resource_group(
+        self, resource_group_name: str, **kwargs: Any
+    ) -> AsyncIterable["_models.L3IsolationDomain"]:
+        """List L3IsolationDomains by resource group.
+
+        Displays L3IsolationDomains list by resource group GET method.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either L3IsolationDomain or the result of cls(response)
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.L3IsolationDomainsListResult] = kwargs.pop("cls", None)
+
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        def prepare_request(next_link=None):
+            if not next_link:
+
+                request = build_list_by_resource_group_request(
+                    resource_group_name=resource_group_name,
+                    subscription_id=self._config.subscription_id,
+                    api_version=api_version,
+                    template_url=self.list_by_resource_group.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("L3IsolationDomainsListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, AsyncList(list_of_elem)
+
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+            return pipeline_response
+
+        return AsyncItemPaged(get_next, extract_data)
+
+    list_by_resource_group.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains"
     }
 
-    async def _update_administrative_state_initial(
+    @distributed_trace
+    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.L3IsolationDomain"]:
+        """List L3IsolationDomains by subscription.
+
+        Displays L3IsolationDomains list by subscription GET method.
+
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either L3IsolationDomain or the result of cls(response)
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.L3IsolationDomain]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.L3IsolationDomainsListResult] = kwargs.pop("cls", None)
+
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        def prepare_request(next_link=None):
+            if not next_link:
+
+                request = build_list_by_subscription_request(
+                    subscription_id=self._config.subscription_id,
+                    api_version=api_version,
+                    template_url=self.list_by_subscription.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("L3IsolationDomainsListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, AsyncList(list_of_elem)
+
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+            return pipeline_response
+
+        return AsyncItemPaged(get_next, extract_data)
+
+    list_by_subscription.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains"
+    }
+
+    async def _update_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
-        l2_isolation_domain_name: str,
+        l3_isolation_domain_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForDeviceUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "UpdateAdministrativeState")
 
         request = build_update_administrative_state_request(
             resource_group_name=resource_group_name,
-            l2_isolation_domain_name=l2_isolation_domain_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_administrative_state_initial.metadata["url"],
             headers=_headers,
@@ -778,180 +962,164 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
     _update_administrative_state_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/updateAdministrativeState"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/updateAdministrativeState"
     }
 
     @overload
     async def begin_update_administrative_state(
         self,
         resource_group_name: str,
-        l2_isolation_domain_name: str,
+        l3_isolation_domain_name: str,
         body: _models.UpdateAdministrativeState,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """Implements the operation to the underlying resources.
+    ) -> AsyncLROPoller[None]:
+        """executes enable operation to the underlying resources.
 
-        Enables isolation domain across the fabric or on specified racks.
+        Enables racks for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
-        :type l2_isolation_domain_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
         :param body: Request payload. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForDeviceUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update_administrative_state(
         self,
         resource_group_name: str,
-        l2_isolation_domain_name: str,
+        l3_isolation_domain_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """Implements the operation to the underlying resources.
+    ) -> AsyncLROPoller[None]:
+        """executes enable operation to the underlying resources.
 
-        Enables isolation domain across the fabric or on specified racks.
+        Enables racks for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
-        :type l2_isolation_domain_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForDeviceUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update_administrative_state(
         self,
         resource_group_name: str,
-        l2_isolation_domain_name: str,
+        l3_isolation_domain_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """Implements the operation to the underlying resources.
+    ) -> AsyncLROPoller[None]:
+        """executes enable operation to the underlying resources.
 
-        Enables isolation domain across the fabric or on specified racks.
+        Enables racks for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
-        :type l2_isolation_domain_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
         :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
          Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForDeviceUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_administrative_state_initial(
+            raw_result = await self._update_administrative_state_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                l2_isolation_domain_name=l2_isolation_domain_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
@@ -963,126 +1131,222 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update_administrative_state.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/updateAdministrativeState"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/updateAdministrativeState"
     }
 
-    async def _validate_configuration_initial(
-        self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any
-    ) -> _models.ValidateConfigurationResponse:
+    async def _update_option_b_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_validate_configuration_request(
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "UpdateAdministrativeState")
+
+        request = build_update_option_b_administrative_state_request(
             resource_group_name=resource_group_name,
-            l2_isolation_domain_name=l2_isolation_domain_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._validate_configuration_initial.metadata["url"],
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._update_option_b_administrative_state_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        if cls:
+            return cls(pipeline_response, None, response_headers)
 
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+    _update_option_b_administrative_state_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/updateOptionBAdministrativeState"
+    }
 
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+    @overload
+    async def begin_update_option_b_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: _models.UpdateAdministrativeState,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Update route targets on CE devices. List the CE network device ARM resource IDs in the request
+        body payload.
 
-        return deserialized  # type: ignore
+        Update administrative state of option B on CE devices.
 
-    _validate_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/validateConfiguration"
-    }
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    async def begin_update_option_b_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Update route targets on CE devices. List the CE network device ARM resource IDs in the request
+        body payload.
+
+        Update administrative state of option B on CE devices.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
 
     @distributed_trace_async
-    async def begin_validate_configuration(
-        self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.ValidateConfigurationResponse]:
-        """Validates the configuration of the resources.
+    async def begin_update_option_b_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Update route targets on CE devices. List the CE network device ARM resource IDs in the request
+        body payload.
+
+        Update administrative state of option B on CE devices.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
-        :type l2_isolation_domain_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._validate_configuration_initial(
+            raw_result = await self._update_option_b_administrative_state_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                l2_isolation_domain_name=l2_isolation_domain_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                body=body,
                 api_version=api_version,
+                content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
@@ -1093,129 +1357,219 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_validate_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/validateConfiguration"
+    begin_update_option_b_administrative_state.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/updateOptionBAdministrativeState"
     }
 
-    async def _commit_configuration_initial(
-        self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    async def _clear_arp_table_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "EnableDisableOnResources")
 
-        request = build_commit_configuration_request(
+        request = build_clear_arp_table_request(
             resource_group_name=resource_group_name,
-            l2_isolation_domain_name=l2_isolation_domain_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._commit_configuration_initial.metadata["url"],
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._clear_arp_table_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        if cls:
+            return cls(pipeline_response, None, response_headers)
 
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+    _clear_arp_table_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/clearArpTable"
+    }
 
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+    @overload
+    async def begin_clear_arp_table(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: _models.EnableDisableOnResources,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """executes clear ARP operation to the underlying resources.
 
-        return deserialized  # type: ignore
+        Clears ARP tables for this Isolation Domain.
 
-    _commit_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/commitConfiguration"
-    }
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    async def begin_clear_arp_table(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """executes clear ARP operation to the underlying resources.
+
+        Clears ARP tables for this Isolation Domain.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
 
     @distributed_trace_async
-    async def begin_commit_configuration(
-        self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Execute the commit on the resources.
+    async def begin_clear_arp_table(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """executes clear ARP operation to the underlying resources.
 
-        Commits the configuration of the given resources.
+        Clears ARP tables for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
-        :type l2_isolation_domain_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Is either a EnableDisableOnResources type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._commit_configuration_initial(
+            raw_result = await self._clear_arp_table_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                l2_isolation_domain_name=l2_isolation_domain_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                body=body,
                 api_version=api_version,
+                content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
@@ -1226,188 +1580,233 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_commit_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/commitConfiguration"
+    begin_clear_arp_table.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/clearArpTable"
     }
 
-    @distributed_trace
-    def list_by_resource_group(
-        self, resource_group_name: str, **kwargs: Any
-    ) -> AsyncIterable["_models.L2IsolationDomain"]:
-        """List L2IsolationDomains by resource group.
-
-        Displays L2IsolationDomains list by resource group GET method.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either L2IsolationDomain or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.L2IsolationDomainsListResult] = kwargs.pop("cls", None)
-
+    async def _clear_neighbor_table_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        def prepare_request(next_link=None):
-            if not next_link:
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-                request = build_list_by_resource_group_request(
-                    resource_group_name=resource_group_name,
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    template_url=self.list_by_resource_group.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "EnableDisableOnResources")
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("L2IsolationDomainsListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+        request = build_clear_neighbor_table_request(
+            resource_group_name=resource_group_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._clear_neighbor_table_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
-        async def get_next(next_link=None):
-            request = prepare_request(next_link)
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
 
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
-            )
-            response = pipeline_response.http_response
+        response = pipeline_response.http_response
 
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-            return pipeline_response
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        return AsyncItemPaged(get_next, extract_data)
+        if cls:
+            return cls(pipeline_response, None, response_headers)
 
-    list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains"
+    _clear_neighbor_table_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/clearNeighborTable"
     }
 
-    @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.L2IsolationDomain"]:
-        """List L2IsolationDomains by subscription.
+    @overload
+    async def begin_clear_neighbor_table(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: _models.EnableDisableOnResources,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """executes ipv6 clear neighbor tables operation to the underlying resources.
 
-        Displays L2IsolationDomains list by subscription GET method.
+        Clears IPv6 neighbor tables for this Isolation Domain.
 
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either L2IsolationDomain or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.L2IsolationDomainsListResult] = kwargs.pop("cls", None)
+    @overload
+    async def begin_clear_neighbor_table(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """executes ipv6 clear neighbor tables operation to the underlying resources.
 
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
+        Clears IPv6 neighbor tables for this Isolation Domain.
 
-        def prepare_request(next_link=None):
-            if not next_link:
-
-                request = build_list_by_subscription_request(
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    template_url=self.list_by_subscription.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
 
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+    @distributed_trace_async
+    async def begin_clear_neighbor_table(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """executes ipv6 clear neighbor tables operation to the underlying resources.
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("L2IsolationDomainsListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+        Clears IPv6 neighbor tables for this Isolation Domain.
 
-        async def get_next(next_link=None):
-            request = prepare_request(next_link)
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Is either a EnableDisableOnResources type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-            _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = await self._clear_neighbor_table_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                body=body,
+                api_version=api_version,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
             )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+        kwargs.pop("error_map", None)
 
-            return pipeline_response
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
 
-        return AsyncItemPaged(get_next, extract_data)
+        if polling is True:
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains"
+    begin_clear_neighbor_table.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/clearNeighborTable"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_internal_networks_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/_internal_networks_operations.py`

 * *Files 16% similar despite different names*

```diff
@@ -28,22 +28,25 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._internal_networks_operations import (
+    build_clear_arp_entries_request,
+    build_clear_ipv6_neighbors_request,
     build_create_request,
     build_delete_request,
     build_get_request,
-    build_list_by_l3_isolation_domain_request,
+    build_list_request,
     build_update_administrative_state_request,
+    build_update_bfd_for_bgp_administrative_state_request,
+    build_update_bfd_for_static_route_administrative_state_request,
     build_update_bgp_administrative_state_request,
     build_update_request,
-    build_update_static_route_bfd_administrative_state_request,
 )
 
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class InternalNetworksOperations:
@@ -154,17 +157,17 @@
         across racks.
 
         Creates InternalNetwork PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :param body: Request payload. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.InternalNetwork
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -197,17 +200,17 @@
         across racks.
 
         Creates InternalNetwork PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -238,17 +241,17 @@
         across racks.
 
         Creates InternalNetwork PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :param body: Request payload. Is either a InternalNetwork type or a IO type. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.InternalNetwork or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -324,17 +327,17 @@
         """Retrieves details of InternalNetworks using GET method.
 
         Gets a InternalNetworks.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: InternalNetwork or the result of cls(response)
         :rtype: ~azure.mgmt.managednetworkfabric.models.InternalNetwork
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
@@ -390,29 +393,29 @@
     async def _update_initial(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         internal_network_name: str,
         body: Union[_models.InternalNetworkPatch, IO],
         **kwargs: Any
-    ) -> Optional[_models.InternalNetwork]:
+    ) -> _models.InternalNetwork:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.InternalNetwork]] = kwargs.pop("cls", None)
+        cls: ClsType[_models.InternalNetwork] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
@@ -442,26 +445,24 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = None
-        response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("InternalNetwork", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            deserialized = self._deserialize("InternalNetwork", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
     _update_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}"
     }
 
     @overload
     async def begin_update(
@@ -477,17 +478,17 @@
         """API to update certain properties of the InternalNetworks resources.
 
         Updates a InternalNetworks.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :param body: InternalNetwork properties to update. Only annotations are supported. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.InternalNetworkPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -519,17 +520,17 @@
         """API to update certain properties of the InternalNetworks resources.
 
         Updates a InternalNetworks.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :param body: InternalNetwork properties to update. Only annotations are supported. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
@@ -559,17 +560,17 @@
         """API to update certain properties of the InternalNetworks resources.
 
         Updates a InternalNetworks.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :param body: InternalNetwork properties to update. Only annotations are supported. Is either a
          InternalNetworkPatch type or a IO type. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.InternalNetworkPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
@@ -615,15 +616,16 @@
             deserialized = self._deserialize("InternalNetwork", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+                AsyncPollingMethod,
+                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
         else:
             polling_method = polling
         if cont_token:
             return AsyncLROPoller.from_continuation_token(
@@ -671,15 +673,15 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
@@ -694,17 +696,17 @@
         """Deletes a InternalNetworks.
 
         Implements InternalNetworks DELETE method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
@@ -757,25 +759,25 @@
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}"
     }
 
     @distributed_trace
-    def list_by_l3_isolation_domain(
+    def list(
         self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
     ) -> AsyncIterable["_models.InternalNetwork"]:
         """Executes list operation to display list of all internal networks.
 
         Displays InternalNetworks list by resource group GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either InternalNetwork or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.InternalNetwork]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
@@ -792,20 +794,20 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_by_l3_isolation_domain_request(
+                request = build_list_request(
                     resource_group_name=resource_group_name,
                     l3_isolation_domain_name=l3_isolation_domain_name,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
-                    template_url=self.list_by_l3_isolation_domain.metadata["url"],
+                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
@@ -847,40 +849,40 @@
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list_by_l3_isolation_domain.metadata = {
+    list.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks"
     }
 
-    async def _update_administrative_state_initial(
+    async def _update_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         internal_network_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
@@ -905,32 +907,24 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
     _update_administrative_state_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateAdministrativeState"
     }
 
     @overload
     async def begin_update_administrative_state(
@@ -938,107 +932,103 @@
         resource_group_name: str,
         l3_isolation_domain_name: str,
         internal_network_name: str,
         body: _models.UpdateAdministrativeState,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> AsyncLROPoller[None]:
         """Executes the operation to the underlying resources.
 
         Update Administrative state of  InternalNetworks on resources referred by their resource ids.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :param body: Request payload. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update_administrative_state(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         internal_network_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> AsyncLROPoller[None]:
         """Executes the operation to the underlying resources.
 
         Update Administrative state of  InternalNetworks on resources referred by their resource ids.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update_administrative_state(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         internal_network_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> AsyncLROPoller[None]:
         """Executes the operation to the underlying resources.
 
         Update Administrative state of  InternalNetworks on resources referred by their resource ids.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
          Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
@@ -1046,49 +1036,45 @@
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_administrative_state_initial(
+            raw_result = await self._update_administrative_state_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 l3_isolation_domain_name=l3_isolation_domain_name,
                 internal_network_name=internal_network_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
@@ -1103,36 +1089,36 @@
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update_administrative_state.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateAdministrativeState"
     }
 
-    async def _update_bgp_administrative_state_initial(
+    async def _update_bgp_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         internal_network_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
@@ -1157,32 +1143,24 @@
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
     _update_bgp_administrative_state_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBgpAdministrativeState"
     }
 
     @overload
     async def begin_update_bgp_administrative_state(
@@ -1190,107 +1168,103 @@
         resource_group_name: str,
         l3_isolation_domain_name: str,
         internal_network_name: str,
         body: _models.UpdateAdministrativeState,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> AsyncLROPoller[None]:
         """Executes the operation to the underlying resources for updating BGP state on edge devices.
 
         Update BGP state for internalNetwork. Allowed only on edge devices.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :param body: Request payload. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def begin_update_bgp_administrative_state(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         internal_network_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> AsyncLROPoller[None]:
         """Executes the operation to the underlying resources for updating BGP state on edge devices.
 
         Update BGP state for internalNetwork. Allowed only on edge devices.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def begin_update_bgp_administrative_state(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         internal_network_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> AsyncLROPoller[None]:
         """Executes the operation to the underlying resources for updating BGP state on edge devices.
 
         Update BGP state for internalNetwork. Allowed only on edge devices.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
          Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
@@ -1298,49 +1272,45 @@
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_bgp_administrative_state_initial(
+            raw_result = await self._update_bgp_administrative_state_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 l3_isolation_domain_name=l3_isolation_domain_name,
                 internal_network_name=internal_network_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
@@ -1355,194 +1325,182 @@
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update_bgp_administrative_state.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBgpAdministrativeState"
     }
 
-    async def _update_static_route_bfd_administrative_state_initial(
+    async def _update_bfd_for_bgp_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         internal_network_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "UpdateAdministrativeState")
 
-        request = build_update_static_route_bfd_administrative_state_request(
+        request = build_update_bfd_for_bgp_administrative_state_request(
             resource_group_name=resource_group_name,
             l3_isolation_domain_name=l3_isolation_domain_name,
             internal_network_name=internal_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._update_static_route_bfd_administrative_state_initial.metadata["url"],
+            template_url=self._update_bfd_for_bgp_administrative_state_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _update_static_route_bfd_administrative_state_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateStaticRouteBfdAdministrativeState"
+    _update_bfd_for_bgp_administrative_state_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBfdForBgpAdministrativeState"
     }
 
     @overload
-    async def begin_update_static_route_bfd_administrative_state(
+    async def begin_update_bfd_for_bgp_administrative_state(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         internal_network_name: str,
         body: _models.UpdateAdministrativeState,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> AsyncLROPoller[None]:
         """Implements the operation to the underlying resources.
 
-        Update Static Route BFD administrative state for internalNetwork.
+        Update BfdForBgp for internalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :param body: Request payload. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_update_static_route_bfd_administrative_state(
+    async def begin_update_bfd_for_bgp_administrative_state(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         internal_network_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> AsyncLROPoller[None]:
         """Implements the operation to the underlying resources.
 
-        Update Static Route BFD administrative state for internalNetwork.
+        Update BfdForBgp for internalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
-    async def begin_update_static_route_bfd_administrative_state(
+    async def begin_update_bfd_for_bgp_administrative_state(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         internal_network_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> AsyncLROPoller[None]:
         """Implements the operation to the underlying resources.
 
-        Update Static Route BFD administrative state for internalNetwork.
+        Update BfdForBgp for internalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
-        :param internal_network_name: Name of the Internal Network. Required.
+        :param internal_network_name: Name of the InternalNetwork. Required.
         :type internal_network_name: str
         :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
          Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
@@ -1550,49 +1508,751 @@
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
          this operation to not poll, or pass in your own initialized polling object for a personal
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_static_route_bfd_administrative_state_initial(
+            raw_result = await self._update_bfd_for_bgp_administrative_state_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 l3_isolation_domain_name=l3_isolation_domain_name,
                 internal_network_name=internal_network_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
+
+        if polling is True:
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_update_bfd_for_bgp_administrative_state.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBfdForBgpAdministrativeState"
+    }
+
+    async def _clear_ipv6_neighbors_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "EnableDisableOnResources")
+
+        request = build_clear_ipv6_neighbors_request(
+            resource_group_name=resource_group_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            internal_network_name=internal_network_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._clear_ipv6_neighbors_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    _clear_ipv6_neighbors_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/clearIpv6Neighbors"
+    }
+
+    @overload
+    async def begin_clear_ipv6_neighbors(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: _models.EnableDisableOnResources,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
+
+        clearIpv6Neighbors for internalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    async def begin_clear_ipv6_neighbors(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
+
+        clearIpv6Neighbors for internalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @distributed_trace_async
+    async def begin_clear_ipv6_neighbors(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Implements the operation to the underlying resources.
+
+        clearIpv6Neighbors for internalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Is either a EnableDisableOnResources type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = await self._clear_ipv6_neighbors_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                internal_network_name=internal_network_name,
+                body=body,
+                api_version=api_version,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
+
+        if polling is True:
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_clear_ipv6_neighbors.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/clearIpv6Neighbors"
+    }
+
+    async def _clear_arp_entries_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "EnableDisableOnResources")
+
+        request = build_clear_arp_entries_request(
+            resource_group_name=resource_group_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            internal_network_name=internal_network_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._clear_arp_entries_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    _clear_arp_entries_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/clearArpEntries"
+    }
+
+    @overload
+    async def begin_clear_arp_entries(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: _models.EnableDisableOnResources,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Executes clearArpEntries operation to the underlying resources.
+
+        clearArpEntries for internalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    async def begin_clear_arp_entries(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Executes clearArpEntries operation to the underlying resources.
+
+        clearArpEntries for internalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @distributed_trace_async
+    async def begin_clear_arp_entries(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Executes clearArpEntries operation to the underlying resources.
+
+        clearArpEntries for internalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Is either a EnableDisableOnResources type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = await self._clear_arp_entries_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                internal_network_name=internal_network_name,
+                body=body,
+                api_version=api_version,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
+
+        if polling is True:
+            polling_method: AsyncPollingMethod = cast(
+                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return AsyncLROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_clear_arp_entries.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/clearArpEntries"
+    }
+
+    async def _update_bfd_for_static_route_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "UpdateAdministrativeState")
+
+        request = build_update_bfd_for_static_route_administrative_state_request(
+            resource_group_name=resource_group_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            internal_network_name=internal_network_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._update_bfd_for_static_route_administrative_state_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    _update_bfd_for_static_route_administrative_state_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBfdForStaticRouteAdministrativeState"
+    }
+
+    @overload
+    async def begin_update_bfd_for_static_route_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: _models.UpdateAdministrativeState,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Executes update BfdForStaticRoutes operation to the underlying resources.
+
+        Update BfdForStaticRoutes for internalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    async def begin_update_bfd_for_static_route_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Executes update BfdForStaticRoutes operation to the underlying resources.
+
+        Update BfdForStaticRoutes for internalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @distributed_trace_async
+    async def begin_update_bfd_for_static_route_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        internal_network_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> AsyncLROPoller[None]:
+        """Executes update BfdForStaticRoutes operation to the underlying resources.
+
+        Update BfdForStaticRoutes for internalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param internal_network_name: Name of the InternalNetwork. Required.
+        :type internal_network_name: str
+        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
+         this operation to not poll, or pass in your own initialized polling object for a personal
+         polling strategy.
+        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = await self._update_bfd_for_static_route_administrative_state_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                internal_network_name=internal_network_name,
+                body=body,
+                api_version=api_version,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: AsyncPollingMethod = cast(
                 AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
@@ -1603,10 +2263,10 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_update_static_route_bfd_administrative_state.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateStaticRouteBfdAdministrativeState"
+    begin_update_bfd_for_static_route_administrative_state.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBfdForStaticRouteAdministrativeState"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_interfaces_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_ip_prefixes_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -3,642 +3,780 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 from io import IOBase
-from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
+from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
-from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
+from azure.core.pipeline.transport import HttpResponse
+from azure.core.polling import LROPoller, NoPolling, PollingMethod
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
-from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
+from azure.mgmt.core.polling.arm_polling import ARMPolling
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._network_interfaces_operations import (
-    build_create_request,
-    build_delete_request,
-    build_get_request,
-    build_list_by_network_device_request,
-    build_update_administrative_state_request,
-    build_update_request,
-)
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request, _format_url_section
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_create_request(
+    resource_group_name: str, ip_prefix_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "ipPrefixName": _SERIALIZER.url("ip_prefix_name", ip_prefix_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_get_request(
+    resource_group_name: str, ip_prefix_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "ipPrefixName": _SERIALIZER.url("ip_prefix_name", ip_prefix_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_update_request(
+    resource_group_name: str, ip_prefix_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "ipPrefixName": _SERIALIZER.url("ip_prefix_name", ip_prefix_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_delete_request(
+    resource_group_name: str, ip_prefix_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "ipPrefixName": _SERIALIZER.url("ip_prefix_name", ip_prefix_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes"
+    )
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
 
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
-class NetworkInterfacesOperations:
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class IpPrefixesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.managednetworkfabric.aio.ManagedNetworkFabricMgmtClient`'s
-        :attr:`network_interfaces` attribute.
+        :class:`~azure.mgmt.managednetworkfabric.ManagedNetworkFabricMgmtClient`'s
+        :attr:`ip_prefixes` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
-    async def _create_initial(
-        self,
-        resource_group_name: str,
-        network_device_name: str,
-        network_interface_name: str,
-        body: Union[_models.NetworkInterface, IO],
-        **kwargs: Any
-    ) -> _models.NetworkInterface:
+    def _create_initial(
+        self, resource_group_name: str, ip_prefix_name: str, body: Union[_models.IpPrefix, IO], **kwargs: Any
+    ) -> _models.IpPrefix:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkInterface] = kwargs.pop("cls", None)
+        cls: ClsType[_models.IpPrefix] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkInterface")
+            _json = self._serialize.body(body, "IpPrefix")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            network_device_name=network_device_name,
-            network_interface_name=network_interface_name,
+            ip_prefix_name=ip_prefix_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkInterface", pipeline_response)
+            deserialized = self._deserialize("IpPrefix", pipeline_response)
 
         if response.status_code == 201:
-            deserialized = self._deserialize("NetworkInterface", pipeline_response)
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
+            deserialized = self._deserialize("IpPrefix", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}"
     }
 
     @overload
-    async def begin_create(
+    def begin_create(
         self,
         resource_group_name: str,
-        network_device_name: str,
-        network_interface_name: str,
-        body: _models.NetworkInterface,
+        ip_prefix_name: str,
+        body: _models.IpPrefix,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkInterface]:
-        """Create NetworkInterface.
+    ) -> LROPoller[_models.IpPrefix]:
+        """Create an IP Prefix.
 
-        Create a Network Interface resource.
+        Implements IP Prefix PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param network_interface_name: Name of the Network Interface. Required.
-        :type network_interface_name: str
+        :param ip_prefix_name: Name of the IP Prefix. Required.
+        :type ip_prefix_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkInterface
+        :type body: ~azure.mgmt.managednetworkfabric.models.IpPrefix
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkInterface or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
+        :return: An instance of LROPoller that returns either IpPrefix or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpPrefix]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_create(
+    def begin_create(
         self,
         resource_group_name: str,
-        network_device_name: str,
-        network_interface_name: str,
+        ip_prefix_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkInterface]:
-        """Create NetworkInterface.
+    ) -> LROPoller[_models.IpPrefix]:
+        """Create an IP Prefix.
 
-        Create a Network Interface resource.
+        Implements IP Prefix PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param network_interface_name: Name of the Network Interface. Required.
-        :type network_interface_name: str
+        :param ip_prefix_name: Name of the IP Prefix. Required.
+        :type ip_prefix_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkInterface or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
+        :return: An instance of LROPoller that returns either IpPrefix or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpPrefix]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_create(
-        self,
-        resource_group_name: str,
-        network_device_name: str,
-        network_interface_name: str,
-        body: Union[_models.NetworkInterface, IO],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkInterface]:
-        """Create NetworkInterface.
+    @distributed_trace
+    def begin_create(
+        self, resource_group_name: str, ip_prefix_name: str, body: Union[_models.IpPrefix, IO], **kwargs: Any
+    ) -> LROPoller[_models.IpPrefix]:
+        """Create an IP Prefix.
 
-        Create a Network Interface resource.
+        Implements IP Prefix PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param network_interface_name: Name of the Network Interface. Required.
-        :type network_interface_name: str
-        :param body: Request payload. Is either a NetworkInterface type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkInterface or IO
+        :param ip_prefix_name: Name of the IP Prefix. Required.
+        :type ip_prefix_name: str
+        :param body: Request payload. Is either a IpPrefix type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.IpPrefix or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkInterface or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
+        :return: An instance of LROPoller that returns either IpPrefix or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpPrefix]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkInterface] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[_models.IpPrefix] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._create_initial(
+            raw_result = self._create_initial(
                 resource_group_name=resource_group_name,
-                network_device_name=network_device_name,
-                network_interface_name=network_interface_name,
+                ip_prefix_name=ip_prefix_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkInterface", pipeline_response)
+            deserialized = self._deserialize("IpPrefix", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}"
     }
 
-    @distributed_trace_async
-    async def get(
-        self, resource_group_name: str, network_device_name: str, network_interface_name: str, **kwargs: Any
-    ) -> _models.NetworkInterface:
-        """Gets a NetworkInterface.
+    @distributed_trace
+    def get(self, resource_group_name: str, ip_prefix_name: str, **kwargs: Any) -> _models.IpPrefix:
+        """Gets an IP Prefix.
 
-        Get the Network Interface resource details.
+        Implements IP Prefix GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param network_interface_name: Name of the Network Interface. Required.
-        :type network_interface_name: str
+        :param ip_prefix_name: Name of the IP Prefix. Required.
+        :type ip_prefix_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NetworkInterface or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkInterface
+        :return: IpPrefix or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.IpPrefix
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkInterface] = kwargs.pop("cls", None)
+        cls: ClsType[_models.IpPrefix] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            network_device_name=network_device_name,
-            network_interface_name=network_interface_name,
+            ip_prefix_name=ip_prefix_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("NetworkInterface", pipeline_response)
+        deserialized = self._deserialize("IpPrefix", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}"
     }
 
-    async def _update_initial(
-        self,
-        resource_group_name: str,
-        network_device_name: str,
-        network_interface_name: str,
-        body: Union[_models.NetworkInterfacePatch, IO],
-        **kwargs: Any
-    ) -> Optional[_models.NetworkInterface]:
+    def _update_initial(
+        self, resource_group_name: str, ip_prefix_name: str, body: Union[_models.IpPrefixPatch, IO], **kwargs: Any
+    ) -> Optional[_models.IpPrefix]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.NetworkInterface]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.IpPrefix]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkInterfacePatch")
+            _json = self._serialize.body(body, "IpPrefixPatch")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            network_device_name=network_device_name,
-            network_interface_name=network_interface_name,
+            ip_prefix_name=ip_prefix_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkInterface", pipeline_response)
+            deserialized = self._deserialize("IpPrefix", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}"
     }
 
     @overload
-    async def begin_update(
+    def begin_update(
         self,
         resource_group_name: str,
-        network_device_name: str,
-        network_interface_name: str,
-        body: _models.NetworkInterfacePatch,
+        ip_prefix_name: str,
+        body: _models.IpPrefixPatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkInterface]:
-        """Updates a NetworkInterface.
+    ) -> LROPoller[_models.IpPrefix]:
+        """Updates the IP Prefix.
 
-        Update certain properties of the Network Interface resource.
+        API to update certain properties of the IP Prefix resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param network_interface_name: Name of the Network Interface. Required.
-        :type network_interface_name: str
-        :param body: NetworkInterface properties to update. Only tags are supported. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkInterfacePatch
+        :param ip_prefix_name: Name of the IP Prefix. Required.
+        :type ip_prefix_name: str
+        :param body: IP Prefix properties to update. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.IpPrefixPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkInterface or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
+        :return: An instance of LROPoller that returns either IpPrefix or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpPrefix]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_update(
+    def begin_update(
         self,
         resource_group_name: str,
-        network_device_name: str,
-        network_interface_name: str,
+        ip_prefix_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkInterface]:
-        """Updates a NetworkInterface.
+    ) -> LROPoller[_models.IpPrefix]:
+        """Updates the IP Prefix.
 
-        Update certain properties of the Network Interface resource.
+        API to update certain properties of the IP Prefix resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param network_interface_name: Name of the Network Interface. Required.
-        :type network_interface_name: str
-        :param body: NetworkInterface properties to update. Only tags are supported. Required.
+        :param ip_prefix_name: Name of the IP Prefix. Required.
+        :type ip_prefix_name: str
+        :param body: IP Prefix properties to update. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkInterface or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
+        :return: An instance of LROPoller that returns either IpPrefix or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpPrefix]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_update(
-        self,
-        resource_group_name: str,
-        network_device_name: str,
-        network_interface_name: str,
-        body: Union[_models.NetworkInterfacePatch, IO],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkInterface]:
-        """Updates a NetworkInterface.
+    @distributed_trace
+    def begin_update(
+        self, resource_group_name: str, ip_prefix_name: str, body: Union[_models.IpPrefixPatch, IO], **kwargs: Any
+    ) -> LROPoller[_models.IpPrefix]:
+        """Updates the IP Prefix.
 
-        Update certain properties of the Network Interface resource.
+        API to update certain properties of the IP Prefix resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param network_interface_name: Name of the Network Interface. Required.
-        :type network_interface_name: str
-        :param body: NetworkInterface properties to update. Only tags are supported. Is either a
-         NetworkInterfacePatch type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkInterfacePatch or IO
+        :param ip_prefix_name: Name of the IP Prefix. Required.
+        :type ip_prefix_name: str
+        :param body: IP Prefix properties to update. Is either a IpPrefixPatch type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.IpPrefixPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkInterface or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
+        :return: An instance of LROPoller that returns either IpPrefix or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpPrefix]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkInterface] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        cls: ClsType[_models.IpPrefix] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._update_initial(
+            raw_result = self._update_initial(
                 resource_group_name=resource_group_name,
-                network_device_name=network_device_name,
-                network_interface_name=network_interface_name,
+                ip_prefix_name=ip_prefix_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkInterface", pipeline_response)
+            deserialized = self._deserialize("IpPrefix", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}"
     }
 
-    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, network_device_name: str, network_interface_name: str, **kwargs: Any
+    def _delete_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, ip_prefix_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -648,159 +786,153 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            network_device_name=network_device_name,
-            network_interface_name=network_interface_name,
+            ip_prefix_name=ip_prefix_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        response_headers = {}
+        if response.status_code == 202:
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
+
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}"
     }
 
-    @distributed_trace_async
-    async def begin_delete(
-        self, resource_group_name: str, network_device_name: str, network_interface_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[None]:
-        """Deletes a NetworkInterface.
+    @distributed_trace
+    def begin_delete(self, resource_group_name: str, ip_prefix_name: str, **kwargs: Any) -> LROPoller[None]:
+        """Deletes the IP Prefix.
 
-        Delete the Network Interface resource.
+        Implements IP Prefix DELETE method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param network_interface_name: Name of the Network Interface. Required.
-        :type network_interface_name: str
+        :param ip_prefix_name: Name of the IP Prefix. Required.
+        :type ip_prefix_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = await self._delete_initial(  # type: ignore
+            raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_device_name=network_device_name,
-                network_interface_name=network_interface_name,
+                ip_prefix_name=ip_prefix_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
+            polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
-            return AsyncLROPoller.from_continuation_token(
+            return LROPoller.from_continuation_token(
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}"
     }
 
     @distributed_trace
-    def list_by_network_device(
-        self, resource_group_name: str, network_device_name: str, **kwargs: Any
-    ) -> AsyncIterable["_models.NetworkInterface"]:
-        """List all Network Interfaces that are available using an Network Device.
+    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.IpPrefix"]:
+        """List IpPrefixes by resource group.
 
-        List all the Network Interface resources in a given resource group.
+        Implements IpPrefixes list by resource group GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkInterface or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
+        :return: An iterator like instance of either IpPrefix or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.IpPrefix]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkInterfacesList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.IpPrefixesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_by_network_device_request(
+                request = build_list_by_resource_group_request(
                     resource_group_name=resource_group_name,
-                    network_device_name=network_device_name,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
-                    template_url=self.list_by_network_device.metadata["url"],
+                    template_url=self.list_by_resource_group.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
@@ -817,287 +949,120 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkInterfacesList", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("IpPrefixesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
-    list_by_network_device.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces"
+    list_by_resource_group.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes"
     }
 
-    async def _update_administrative_state_initial(
-        self,
-        resource_group_name: str,
-        network_device_name: str,
-        network_interface_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
-        **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    @distributed_trace
+    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.IpPrefix"]:
+        """List IpPrefixes by subscription.
+
+        Implements IpPrefixes list by subscription GET method.
+
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either IpPrefix or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.IpPrefix]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.IpPrefixesListResult] = kwargs.pop("cls", None)
+
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "UpdateAdministrativeState")
-
-        request = build_update_administrative_state_request(
-            resource_group_name=resource_group_name,
-            network_device_name=network_device_name,
-            network_interface_name=network_interface_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self._update_administrative_state_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
-
-    _update_administrative_state_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}/updateAdministrativeState"
-    }
-
-    @overload
-    async def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        network_device_name: str,
-        network_interface_name: str,
-        body: _models.UpdateAdministrativeState,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Updates the admin state of the network interface.
-
-        Update the admin state of the Network Interface.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param network_interface_name: Name of the Network Interface. Required.
-        :type network_interface_name: str
-        :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    async def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        network_device_name: str,
-        network_interface_name: str,
-        body: IO,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Updates the admin state of the network interface.
-
-        Update the admin state of the Network Interface.
+        def prepare_request(next_link=None):
+            if not next_link:
 
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param network_interface_name: Name of the Network Interface. Required.
-        :type network_interface_name: str
-        :param body: Request payload. Required.
-        :type body: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
+                request = build_list_by_subscription_request(
+                    subscription_id=self._config.subscription_id,
+                    api_version=api_version,
+                    template_url=self.list_by_subscription.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
-    @distributed_trace_async
-    async def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        network_device_name: str,
-        network_interface_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
-        **kwargs: Any
-    ) -> AsyncLROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Updates the admin state of the network interface.
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
-        Update the admin state of the Network Interface.
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("IpPrefixesListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param network_interface_name: Name of the Network Interface. Required.
-        :type network_interface_name: str
-        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either
-         CommonPostActionResponseForStateUpdate or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+        def get_next(next_link=None):
+            request = prepare_request(next_link)
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._update_administrative_state_initial(
-                resource_group_name=resource_group_name,
-                network_device_name=network_device_name,
-                network_interface_name=network_interface_name,
-                body=body,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
-        kwargs.pop("error_map", None)
+            response = pipeline_response.http_response
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+            return pipeline_response
+
+        return ItemPaged(get_next, extract_data)
 
-    begin_update_administrative_state.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}/updateAdministrativeState"
+    list_by_subscription.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/aio/operations/_network_fabric_controllers_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_access_control_lists_operations.py`

 * *Files 23% similar despite different names*

```diff
@@ -3,758 +3,701 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 from io import IOBase
-from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
+from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
-from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
-from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
-from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._network_fabric_controllers_operations import (
-    build_create_request,
-    build_delete_request,
-    build_get_request,
-    build_list_by_resource_group_request,
-    build_list_by_subscription_request,
-    build_update_request,
-)
+from .. import models as _models
+from .._serialization import Serializer
+from .._vendor import _convert_request, _format_url_section
 
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
 
-class NetworkFabricControllersOperations:
-    """
-    .. warning::
-        **DO NOT** instantiate this class directly.
 
-        Instead, you should access the following operations through
-        :class:`~azure.mgmt.managednetworkfabric.aio.ManagedNetworkFabricMgmtClient`'s
-        :attr:`network_fabric_controllers` attribute.
-    """
+def build_create_request(
+    resource_group_name: str, access_control_list_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "accessControlListName": _SERIALIZER.url("access_control_list_name", access_control_list_name, "str"),
+    }
 
-    models = _models
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
-    def __init__(self, *args, **kwargs) -> None:
-        input_args = list(args)
-        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
-        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
-        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
-        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
-    async def _create_initial(
-        self,
-        resource_group_name: str,
-        network_fabric_controller_name: str,
-        body: Union[_models.NetworkFabricController, IO],
-        **kwargs: Any
-    ) -> _models.NetworkFabricController:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_get_request(
+    resource_group_name: str, access_control_list_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "accessControlListName": _SERIALIZER.url("access_control_list_name", access_control_list_name, "str"),
+    }
 
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkFabricController] = kwargs.pop("cls", None)
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "NetworkFabricController")
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-        request = build_create_request(
-            resource_group_name=resource_group_name,
-            network_fabric_controller_name=network_fabric_controller_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self._create_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_update_request(
+    resource_group_name: str, access_control_list_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "accessControlListName": _SERIALIZER.url("access_control_list_name", access_control_list_name, "str"),
+    }
 
-        _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
-        response = pipeline_response.http_response
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
-        if response.status_code not in [200, 201]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_delete_request(
+    resource_group_name: str, access_control_list_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "accessControlListName": _SERIALIZER.url("access_control_list_name", access_control_list_name, "str"),
+    }
 
-        if response.status_code == 200:
-            deserialized = self._deserialize("NetworkFabricController", pipeline_response)
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
-        if response.status_code == 201:
-            deserialized = self._deserialize("NetworkFabricController", pipeline_response)
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
-        if cls:
-            return cls(pipeline_response, deserialized, {})  # type: ignore
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+    }
 
-        return deserialized  # type: ignore
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
-    _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/accessControlLists"
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class AccessControlListsOperations:
+    """
+    .. warning::
+        **DO NOT** instantiate this class directly.
+
+        Instead, you should access the following operations through
+        :class:`~azure.mgmt.managednetworkfabric.ManagedNetworkFabricMgmtClient`'s
+        :attr:`access_control_lists` attribute.
+    """
+
+    models = _models
+
+    def __init__(self, *args, **kwargs):
+        input_args = list(args)
+        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
+        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
+        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
+        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+
     @overload
-    async def begin_create(
+    def create(
         self,
         resource_group_name: str,
-        network_fabric_controller_name: str,
-        body: _models.NetworkFabricController,
+        access_control_list_name: str,
+        body: _models.AccessControlList,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkFabricController]:
-        """Create Network fabric controller.
+    ) -> _models.AccessControlList:
+        """Create Access Control List.
 
-        Creates a Network Fabric Controller.
+        Implements Access Control List PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
-        :type network_fabric_controller_name: str
+        :param access_control_list_name: Name of the Access Control List. Required.
+        :type access_control_list_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricController
+        :type body: ~azure.mgmt.managednetworkfabric.models.AccessControlList
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkFabricController or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
+        :return: AccessControlList or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.AccessControlList
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_create(
+    def create(
         self,
         resource_group_name: str,
-        network_fabric_controller_name: str,
+        access_control_list_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkFabricController]:
-        """Create Network fabric controller.
+    ) -> _models.AccessControlList:
+        """Create Access Control List.
 
-        Creates a Network Fabric Controller.
+        Implements Access Control List PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
-        :type network_fabric_controller_name: str
+        :param access_control_list_name: Name of the Access Control List. Required.
+        :type access_control_list_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkFabricController or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
+        :return: AccessControlList or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.AccessControlList
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_create(
+    @distributed_trace
+    def create(
         self,
         resource_group_name: str,
-        network_fabric_controller_name: str,
-        body: Union[_models.NetworkFabricController, IO],
+        access_control_list_name: str,
+        body: Union[_models.AccessControlList, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkFabricController]:
-        """Create Network fabric controller.
+    ) -> _models.AccessControlList:
+        """Create Access Control List.
 
-        Creates a Network Fabric Controller.
+        Implements Access Control List PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
-        :type network_fabric_controller_name: str
-        :param body: Request payload. Is either a NetworkFabricController type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricController or IO
+        :param access_control_list_name: Name of the Access Control List. Required.
+        :type access_control_list_name: str
+        :param body: Request payload. Is either a AccessControlList type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.AccessControlList or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkFabricController or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkFabricController] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._create_initial(
-                resource_group_name=resource_group_name,
-                network_fabric_controller_name=network_fabric_controller_name,
-                body=body,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkFabricController", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod,
-                AsyncARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs),
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
-    }
-
-    @distributed_trace_async
-    async def get(
-        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
-    ) -> _models.NetworkFabricController:
-        """Gets a Network Fabric Controller.
-
-        Shows the provisioning status of Network Fabric Controller.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
-        :type network_fabric_controller_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NetworkFabricController or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkFabricController
+        :return: AccessControlList or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.AccessControlList
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkFabricController] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.AccessControlList] = kwargs.pop("cls", None)
 
-        request = build_get_request(
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "AccessControlList")
+
+        request = build_create_request(
             resource_group_name=resource_group_name,
-            network_fabric_controller_name=network_fabric_controller_name,
+            access_control_list_name=access_control_list_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self.get.metadata["url"],
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("NetworkFabricController", pipeline_response)
+        deserialized = self._deserialize("AccessControlList", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
+    create.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
     }
 
-    async def _update_initial(
-        self,
-        resource_group_name: str,
-        network_fabric_controller_name: str,
-        body: Union[_models.NetworkFabricControllerPatch, IO],
-        **kwargs: Any
-    ) -> Optional[_models.NetworkFabricController]:
+    @distributed_trace
+    def get(self, resource_group_name: str, access_control_list_name: str, **kwargs: Any) -> _models.AccessControlList:
+        """Gets a Access Control List.
+
+        Implements Access Control List GET method.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param access_control_list_name: Name of the Access Control List. Required.
+        :type access_control_list_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: AccessControlList or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.AccessControlList
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.NetworkFabricController]] = kwargs.pop("cls", None)
+        cls: ClsType[_models.AccessControlList] = kwargs.pop("cls", None)
 
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "NetworkFabricControllerPatch")
-
-        request = build_update_request(
+        request = build_get_request(
             resource_group_name=resource_group_name,
-            network_fabric_controller_name=network_fabric_controller_name,
+            access_control_list_name=access_control_list_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self._update_initial.metadata["url"],
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = None
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("NetworkFabricController", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        deserialized = self._deserialize("AccessControlList", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)
+            return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
     }
 
     @overload
-    async def begin_update(
+    def update(
         self,
         resource_group_name: str,
-        network_fabric_controller_name: str,
-        body: _models.NetworkFabricControllerPatch,
+        access_control_list_name: str,
+        body: _models.AccessControlListPatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkFabricController]:
-        """Updates a Network Fabric Controller.
+    ) -> _models.AccessControlList:
+        """Updates a Access Control List.
 
-        Updates are currently not supported for the Network Fabric Controller resource.
+        API to update certain properties of the Access Control List resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
-        :type network_fabric_controller_name: str
-        :param body: Network Fabric Controller properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricControllerPatch
+        :param access_control_list_name: Name of the Access Control List. Required.
+        :type access_control_list_name: str
+        :param body: Access Control List properties to update. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.AccessControlListPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkFabricController or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
+        :return: AccessControlList or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.AccessControlList
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    async def begin_update(
+    def update(
         self,
         resource_group_name: str,
-        network_fabric_controller_name: str,
+        access_control_list_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkFabricController]:
-        """Updates a Network Fabric Controller.
+    ) -> _models.AccessControlList:
+        """Updates a Access Control List.
 
-        Updates are currently not supported for the Network Fabric Controller resource.
+        API to update certain properties of the Access Control List resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
-        :type network_fabric_controller_name: str
-        :param body: Network Fabric Controller properties to update. Required.
+        :param access_control_list_name: Name of the Access Control List. Required.
+        :type access_control_list_name: str
+        :param body: Access Control List properties to update. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkFabricController or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
+        :return: AccessControlList or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.AccessControlList
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
-    @distributed_trace_async
-    async def begin_update(
+    @distributed_trace
+    def update(
         self,
         resource_group_name: str,
-        network_fabric_controller_name: str,
-        body: Union[_models.NetworkFabricControllerPatch, IO],
+        access_control_list_name: str,
+        body: Union[_models.AccessControlListPatch, IO],
         **kwargs: Any
-    ) -> AsyncLROPoller[_models.NetworkFabricController]:
-        """Updates a Network Fabric Controller.
+    ) -> _models.AccessControlList:
+        """Updates a Access Control List.
 
-        Updates are currently not supported for the Network Fabric Controller resource.
+        API to update certain properties of the Access Control List resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
-        :type network_fabric_controller_name: str
-        :param body: Network Fabric Controller properties to update. Is either a
-         NetworkFabricControllerPatch type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricControllerPatch or IO
+        :param access_control_list_name: Name of the Access Control List. Required.
+        :type access_control_list_name: str
+        :param body: Access Control List properties to update. Is either a AccessControlListPatch type
+         or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.AccessControlListPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either NetworkFabricController or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
+        :return: AccessControlList or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.AccessControlList
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkFabricController] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._update_initial(
-                resource_group_name=resource_group_name,
-                network_fabric_controller_name=network_fabric_controller_name,
-                body=body,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkFabricController", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
-    }
-
-    async def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
-    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.AccessControlList] = kwargs.pop("cls", None)
 
-        request = build_delete_request(
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "AccessControlListPatch")
+
+        request = build_update_request(
             resource_group_name=resource_group_name,
-            network_fabric_controller_name=network_fabric_controller_name,
+            access_control_list_name=access_control_list_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._delete_initial.metadata["url"],
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        deserialized = self._deserialize("AccessControlList", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, None, response_headers)
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-    _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
+    update.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
     }
 
-    @distributed_trace_async
-    async def begin_delete(
-        self, resource_group_name: str, network_fabric_controller_name: str, **kwargs: Any
-    ) -> AsyncLROPoller[None]:
-        """Deletes a Network Fabric Controller.
+    @distributed_trace
+    def delete(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, access_control_list_name: str, **kwargs: Any
+    ) -> None:
+        """Deletes a Access Control List.
 
-        Deletes the Network Fabric Controller resource.
+        Implements Access Control List DELETE method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_controller_name: Name of the Network Fabric Controller. Required.
-        :type network_fabric_controller_name: str
+        :param access_control_list_name: Name of the Access Control List. Required.
+        :type access_control_list_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
-         this operation to not poll, or pass in your own initialized polling object for a personal
-         polling strategy.
-        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
-        :rtype: ~azure.core.polling.AsyncLROPoller[None]
+        :return: None or the result of cls(response)
+        :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
-        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = await self._delete_initial(  # type: ignore
-                resource_group_name=resource_group_name,
-                network_fabric_controller_name=network_fabric_controller_name,
-                api_version=api_version,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
-            if cls:
-                return cls(pipeline_response, None, {})
+        request = build_delete_request(
+            resource_group_name=resource_group_name,
+            access_control_list_name=access_control_list_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            template_url=self.delete.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
-        if polling is True:
-            polling_method: AsyncPollingMethod = cast(
-                AsyncPollingMethod, AsyncARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return AsyncLROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200, 204]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        if cls:
+            return cls(pipeline_response, None, {})
 
-    begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}"
+    delete.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
     }
 
     @distributed_trace
-    def list_by_resource_group(
-        self, resource_group_name: str, **kwargs: Any
-    ) -> AsyncIterable["_models.NetworkFabricController"]:
-        """List NetworkFabricControllers by resource group.
+    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.AccessControlList"]:
+        """List AccessControlLists by resource group.
 
-        Lists all the NetworkFabricControllers thats available in the resource group.
+        Implements AccessControlLists list by resource group GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkFabricController or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
+        :return: An iterator like instance of either AccessControlList or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.AccessControlList]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkFabricControllersListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.AccessControlListsListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -788,61 +731,59 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkFabricControllersListResult", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("AccessControlListsListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
     list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists"
     }
 
     @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> AsyncIterable["_models.NetworkFabricController"]:
-        """List NetworkFabricControllers by subscription.
+    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.AccessControlList"]:
+        """List AccessControlLists by subscription.
 
-        Lists all the NetworkFabricControllers by subscription.
+        Implements AccessControlLists list by subscription GET method.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkFabricController or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkFabricController]
+        :return: An iterator like instance of either AccessControlList or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.AccessControlList]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkFabricControllersListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.AccessControlListsListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -875,35 +816,35 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkFabricControllersListResult", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("AccessControlListsListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
             _stream = False
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
                 request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
     list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers"
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/accessControlLists"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_access_control_lists_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_fabrics_operations.py`

 * *Files 19% similar despite different names*

```diff
@@ -36,34 +36,34 @@
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_request(
-    resource_group_name: str, access_control_list_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "accessControlListName": _SERIALIZER.url("access_control_list_name", access_control_list_name, "str"),
+        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -72,67 +72,67 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(
-    resource_group_name: str, access_control_list_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "accessControlListName": _SERIALIZER.url("access_control_list_name", access_control_list_name, "str"),
+        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_request(
-    resource_group_name: str, access_control_list_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "accessControlListName": _SERIALIZER.url("access_control_list_name", access_control_list_name, "str"),
+        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -141,33 +141,33 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(
-    resource_group_name: str, access_control_list_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "accessControlListName": _SERIALIZER.url("access_control_list_name", access_control_list_name, "str"),
+        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -177,24 +177,24 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
@@ -207,190 +207,150 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
-        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/accessControlLists"
+        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabrics"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_update_administrative_state_request(
-    resource_group_name: str, access_control_list_name: str, subscription_id: str, **kwargs: Any
+def build_provision_request(
+    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/updateAdministrativeState",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/provision",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "accessControlListName": _SERIALIZER.url("access_control_list_name", access_control_list_name, "str"),
+        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_resync_request(
-    resource_group_name: str, access_control_list_name: str, subscription_id: str, **kwargs: Any
+def build_deprovision_request(
+    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/resync",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/deprovision",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "accessControlListName": _SERIALIZER.url("access_control_list_name", access_control_list_name, "str"),
+        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_validate_configuration_request(
-    resource_group_name: str, access_control_list_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/validateConfiguration",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "accessControlListName": _SERIALIZER.url("access_control_list_name", access_control_list_name, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-class AccessControlListsOperations:
+class NetworkFabricsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.managednetworkfabric.ManagedNetworkFabricMgmtClient`'s
-        :attr:`access_control_lists` attribute.
+        :attr:`network_fabrics` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     def _create_initial(
-        self,
-        resource_group_name: str,
-        access_control_list_name: str,
-        body: Union[_models.AccessControlList, IO],
-        **kwargs: Any
-    ) -> _models.AccessControlList:
+        self, resource_group_name: str, network_fabric_name: str, body: Union[_models.NetworkFabric, IO], **kwargs: Any
+    ) -> _models.NetworkFabric:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.AccessControlList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabric] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "AccessControlList")
+            _json = self._serialize.body(body, "NetworkFabric")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            access_control_list_name=access_control_list_name,
+            network_fabric_name=network_fabric_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
@@ -409,171 +369,164 @@
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("AccessControlList", pipeline_response)
+            deserialized = self._deserialize("NetworkFabric", pipeline_response)
 
         if response.status_code == 201:
             response_headers["Azure-AsyncOperation"] = self._deserialize(
                 "str", response.headers.get("Azure-AsyncOperation")
             )
 
-            deserialized = self._deserialize("AccessControlList", pipeline_response)
+            deserialized = self._deserialize("NetworkFabric", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
     }
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
-        access_control_list_name: str,
-        body: _models.AccessControlList,
+        network_fabric_name: str,
+        body: _models.NetworkFabric,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.AccessControlList]:
-        """Creates Access Control List.
+    ) -> LROPoller[_models.NetworkFabric]:
+        """Create Network Fabric.
 
-        Implements Access Control List PUT method.
+        Create Network Fabric resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
+        :param network_fabric_name: Name of the Network Fabric. Required.
+        :type network_fabric_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.AccessControlList
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabric
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either AccessControlList or the result of
+        :return: An instance of LROPoller that returns either NetworkFabric or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.AccessControlList]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
-        access_control_list_name: str,
+        network_fabric_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.AccessControlList]:
-        """Creates Access Control List.
+    ) -> LROPoller[_models.NetworkFabric]:
+        """Create Network Fabric.
 
-        Implements Access Control List PUT method.
+        Create Network Fabric resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
+        :param network_fabric_name: Name of the Network Fabric. Required.
+        :type network_fabric_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either AccessControlList or the result of
+        :return: An instance of LROPoller that returns either NetworkFabric or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.AccessControlList]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
-        self,
-        resource_group_name: str,
-        access_control_list_name: str,
-        body: Union[_models.AccessControlList, IO],
-        **kwargs: Any
-    ) -> LROPoller[_models.AccessControlList]:
-        """Creates Access Control List.
+        self, resource_group_name: str, network_fabric_name: str, body: Union[_models.NetworkFabric, IO], **kwargs: Any
+    ) -> LROPoller[_models.NetworkFabric]:
+        """Create Network Fabric.
 
-        Implements Access Control List PUT method.
+        Create Network Fabric resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
-        :param body: Request payload. Is either a AccessControlList type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.AccessControlList or IO
+        :param network_fabric_name: Name of the Network Fabric. Required.
+        :type network_fabric_name: str
+        :param body: Request payload. Is either a NetworkFabric type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabric or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either AccessControlList or the result of
+        :return: An instance of LROPoller that returns either NetworkFabric or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.AccessControlList]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.AccessControlList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabric] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
                 resource_group_name=resource_group_name,
-                access_control_list_name=access_control_list_name,
+                network_fabric_name=network_fabric_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("AccessControlList", pipeline_response)
+            deserialized = self._deserialize("NetworkFabric", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
@@ -588,50 +541,50 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
     }
 
     @distributed_trace
-    def get(self, resource_group_name: str, access_control_list_name: str, **kwargs: Any) -> _models.AccessControlList:
-        """Gets a Access Control List.
+    def get(self, resource_group_name: str, network_fabric_name: str, **kwargs: Any) -> _models.NetworkFabric:
+        """Gets a Network Fabric.
 
-        Implements Access Control List GET method.
+        Get Network Fabric resource details.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
+        :param network_fabric_name: Name of the Network Fabric. Required.
+        :type network_fabric_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessControlList or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.AccessControlList
+        :return: NetworkFabric or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkFabric
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.AccessControlList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabric] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            access_control_list_name=access_control_list_name,
+            network_fabric_name=network_fabric_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -645,58 +598,58 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("AccessControlList", pipeline_response)
+        deserialized = self._deserialize("NetworkFabric", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
     }
 
     def _update_initial(
         self,
         resource_group_name: str,
-        access_control_list_name: str,
-        body: Union[_models.AccessControlListPatch, IO],
+        network_fabric_name: str,
+        body: Union[_models.NetworkFabricPatchParameters, IO],
         **kwargs: Any
-    ) -> Optional[_models.AccessControlList]:
+    ) -> Optional[_models.NetworkFabric]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.AccessControlList]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.NetworkFabric]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "AccessControlListPatch")
+            _json = self._serialize.body(body, "NetworkFabricPatchParameters")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            access_control_list_name=access_control_list_name,
+            network_fabric_name=network_fabric_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
@@ -716,168 +669,165 @@
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("AccessControlList", pipeline_response)
+            deserialized = self._deserialize("NetworkFabric", pipeline_response)
 
         if response.status_code == 202:
             response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
     }
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
-        access_control_list_name: str,
-        body: _models.AccessControlListPatch,
+        network_fabric_name: str,
+        body: _models.NetworkFabricPatchParameters,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.AccessControlList]:
-        """Updates the Access Control List.
+    ) -> LROPoller[_models.NetworkFabric]:
+        """Updates a Network Fabric.
 
-        API to update certain properties of the Access Control List resource.
+        Update certain properties of the Network Fabric resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
-        :param body: Access Control List properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.AccessControlListPatch
+        :param network_fabric_name: Name of the Network Fabric. Required.
+        :type network_fabric_name: str
+        :param body: Network Fabric properties to update. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricPatchParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either AccessControlList or the result of
+        :return: An instance of LROPoller that returns either NetworkFabric or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.AccessControlList]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
-        access_control_list_name: str,
+        network_fabric_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.AccessControlList]:
-        """Updates the Access Control List.
+    ) -> LROPoller[_models.NetworkFabric]:
+        """Updates a Network Fabric.
 
-        API to update certain properties of the Access Control List resource.
+        Update certain properties of the Network Fabric resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
-        :param body: Access Control List properties to update. Required.
+        :param network_fabric_name: Name of the Network Fabric. Required.
+        :type network_fabric_name: str
+        :param body: Network Fabric properties to update. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either AccessControlList or the result of
+        :return: An instance of LROPoller that returns either NetworkFabric or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.AccessControlList]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
-        access_control_list_name: str,
-        body: Union[_models.AccessControlListPatch, IO],
+        network_fabric_name: str,
+        body: Union[_models.NetworkFabricPatchParameters, IO],
         **kwargs: Any
-    ) -> LROPoller[_models.AccessControlList]:
-        """Updates the Access Control List.
+    ) -> LROPoller[_models.NetworkFabric]:
+        """Updates a Network Fabric.
 
-        API to update certain properties of the Access Control List resource.
+        Update certain properties of the Network Fabric resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
-        :param body: Access Control List properties to update. Is either a AccessControlListPatch type
+        :param network_fabric_name: Name of the Network Fabric. Required.
+        :type network_fabric_name: str
+        :param body: Network Fabric properties to update. Is either a NetworkFabricPatchParameters type
          or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.AccessControlListPatch or IO
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricPatchParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either AccessControlList or the result of
+        :return: An instance of LROPoller that returns either NetworkFabric or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.AccessControlList]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.AccessControlList] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabric] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
                 resource_group_name=resource_group_name,
-                access_control_list_name=access_control_list_name,
+                network_fabric_name=network_fabric_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("AccessControlList", pipeline_response)
+            deserialized = self._deserialize("NetworkFabric", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
@@ -892,19 +842,19 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
     }
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, access_control_list_name: str, **kwargs: Any
+        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -914,15 +864,15 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            access_control_list_name=access_control_list_name,
+            network_fabric_name=network_fabric_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -931,41 +881,41 @@
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
         if response.status_code == 202:
             response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
             return cls(pipeline_response, None, response_headers)
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
     }
 
     @distributed_trace
-    def begin_delete(self, resource_group_name: str, access_control_list_name: str, **kwargs: Any) -> LROPoller[None]:
-        """Deletes a Access Control List.
+    def begin_delete(self, resource_group_name: str, network_fabric_name: str, **kwargs: Any) -> LROPoller[None]:
+        """Deletes a Network Fabric.
 
-        Implements Access Control List DELETE method.
+        Delete Network Fabric resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
+        :param network_fabric_name: Name of the Network Fabric. Required.
+        :type network_fabric_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
@@ -981,30 +931,30 @@
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                access_control_list_name=access_control_list_name,
+                network_fabric_name=network_fabric_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
                 return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
@@ -1012,36 +962,36 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
     }
 
     @distributed_trace
-    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.AccessControlList"]:
-        """List AccessControlLists by resource group.
+    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.NetworkFabric"]:
+        """List NetworkFabrics by resource group.
 
-        Implements AccessControlLists list by resource group GET method.
+        List all the Network Fabric resources in the given resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessControlList or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.AccessControlList]
+        :return: An iterator like instance of either NetworkFabric or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.AccessControlListsListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabricsListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1076,15 +1026,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessControlListsListResult", pipeline_response)
+            deserialized = self._deserialize("NetworkFabricsListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -1101,33 +1051,33 @@
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics"
     }
 
     @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.AccessControlList"]:
-        """List AccessControlLists by subscription.
+    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.NetworkFabric"]:
+        """List NetworkFabrics by subscription.
 
-        Implements AccessControlLists list by subscription GET method.
+        List all the Network Fabric resources in the given subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessControlList or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.AccessControlList]
+        :return: An iterator like instance of either NetworkFabric or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.AccessControlListsListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkFabricsListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1161,15 +1111,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessControlListsListResult", pipeline_response)
+            deserialized = self._deserialize("NetworkFabricsListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -1186,368 +1136,114 @@
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/accessControlLists"
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabrics"
     }
 
-    def _update_administrative_state_initial(
-        self,
-        resource_group_name: str,
-        access_control_list_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
-        **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "UpdateAdministrativeState")
-
-        request = build_update_administrative_state_request(
-            resource_group_name=resource_group_name,
-            access_control_list_name=access_control_list_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self._update_administrative_state_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
-
-    _update_administrative_state_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/updateAdministrativeState"
-    }
-
-    @overload
-    def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        access_control_list_name: str,
-        body: _models.UpdateAdministrativeState,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Updates administrative state of Access Control Lists.
-
-        Implements the operation to the underlying resources.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
-        :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        access_control_list_name: str,
-        body: IO,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Updates administrative state of Access Control Lists.
-
-        Implements the operation to the underlying resources.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
-        :param body: Request payload. Required.
-        :type body: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @distributed_trace
-    def begin_update_administrative_state(
-        self,
-        resource_group_name: str,
-        access_control_list_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
-        **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Updates administrative state of Access Control Lists.
-
-        Implements the operation to the underlying resources.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
-        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = self._update_administrative_state_initial(
-                resource_group_name=resource_group_name,
-                access_control_list_name=access_control_list_name,
-                body=body,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return LROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_update_administrative_state.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/updateAdministrativeState"
-    }
-
-    def _resync_initial(
-        self, resource_group_name: str, access_control_list_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    def _provision_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_resync_request(
+        request = build_provision_request(
             resource_group_name=resource_group_name,
-            access_control_list_name=access_control_list_name,
+            network_fabric_name=network_fabric_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._resync_initial.metadata["url"],
+            template_url=self._provision_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _resync_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/resync"
+    _provision_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/provision"
     }
 
     @distributed_trace
-    def begin_resync(
-        self, resource_group_name: str, access_control_list_name: str, **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Resync operation on the Access Control Lists.
+    def begin_provision(self, resource_group_name: str, network_fabric_name: str, **kwargs: Any) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        Implements the operation to the underlying resources.
+        Provisions the underlying resources in the given Network Fabric instance.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
+        :param network_fabric_name: Name of the NetworkFabric. Required.
+        :type network_fabric_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._resync_initial(
+            raw_result = self._provision_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                access_control_list_name=access_control_list_name,
+                network_fabric_name=network_fabric_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
@@ -1558,129 +1254,115 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_resync.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/resync"
+    begin_provision.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/provision"
     }
 
-    def _validate_configuration_initial(
-        self, resource_group_name: str, access_control_list_name: str, **kwargs: Any
-    ) -> _models.ValidateConfigurationResponse:
+    def _deprovision_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_validate_configuration_request(
+        request = build_deprovision_request(
             resource_group_name=resource_group_name,
-            access_control_list_name=access_control_list_name,
+            network_fabric_name=network_fabric_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._validate_configuration_initial.metadata["url"],
+            template_url=self._deprovision_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _validate_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/validateConfiguration"
+    _deprovision_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/deprovision"
     }
 
     @distributed_trace
-    def begin_validate_configuration(
-        self, resource_group_name: str, access_control_list_name: str, **kwargs: Any
-    ) -> LROPoller[_models.ValidateConfigurationResponse]:
-        """Validates the configuration of the Access Control Lists.
+    def begin_deprovision(self, resource_group_name: str, network_fabric_name: str, **kwargs: Any) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        Implements the operation to the underlying resources.
+        Deprovisions the underlying resources in the given Network Fabric instance.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param access_control_list_name: Name of the Access Control List. Required.
-        :type access_control_list_name: str
+        :param network_fabric_name: Name of the NetworkFabric. Required.
+        :type network_fabric_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._validate_configuration_initial(
+            raw_result = self._deprovision_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                access_control_list_name=access_control_list_name,
+                network_fabric_name=network_fabric_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
@@ -1691,10 +1373,10 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_validate_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/validateConfiguration"
+    begin_deprovision.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/deprovision"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_l3_isolation_domains_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_l3_isolation_domains_operations.py`

 * *Files 13% similar despite different names*

```diff
@@ -41,25 +41,25 @@
 
 def build_create_request(
     resource_group_name: str, l3_isolation_domain_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
@@ -77,24 +77,24 @@
 
 def build_get_request(
     resource_group_name: str, l3_isolation_domain_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
@@ -110,25 +110,25 @@
 
 def build_update_request(
     resource_group_name: str, l3_isolation_domain_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
@@ -146,24 +146,24 @@
 
 def build_delete_request(
     resource_group_name: str, l3_isolation_domain_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
@@ -177,24 +177,24 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
@@ -207,23 +207,23 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -235,25 +235,25 @@
 
 def build_update_administrative_state_request(
     resource_group_name: str, l3_isolation_domain_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/updateAdministrativeState",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
@@ -265,75 +265,117 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_validate_configuration_request(
+def build_update_option_b_administrative_state_request(
     resource_group_name: str, l3_isolation_domain_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/validateConfiguration",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/updateOptionBAdministrativeState",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_commit_configuration_request(
+def build_clear_arp_table_request(
     resource_group_name: str, l3_isolation_domain_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/commitConfiguration",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/clearArpTable",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_clear_neighbor_table_request(
+    resource_group_name: str, l3_isolation_domain_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/clearNeighborTable",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 class L3IsolationDomainsOperations:
     """
@@ -720,15 +762,17 @@
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
             deserialized = self._deserialize("L3IsolationDomain", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
@@ -932,15 +976,15 @@
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
@@ -1186,35 +1230,35 @@
 
         return ItemPaged(get_next, extract_data)
 
     list_by_subscription.metadata = {
         "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains"
     }
 
-    def _update_administrative_state_initial(
+    def _update_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForDeviceUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
@@ -1238,131 +1282,119 @@
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
     _update_administrative_state_initial.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/updateAdministrativeState"
     }
 
     @overload
     def begin_update_administrative_state(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         body: _models.UpdateAdministrativeState,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
+    ) -> LROPoller[None]:
         """executes enable operation to the underlying resources.
 
         Enables racks for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
         :param body: Request payload. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForDeviceUpdate
-         or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update_administrative_state(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
+    ) -> LROPoller[None]:
         """executes enable operation to the underlying resources.
 
         Enables racks for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForDeviceUpdate
-         or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update_administrative_state(
         self,
         resource_group_name: str,
         l3_isolation_domain_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
+    ) -> LROPoller[None]:
         """executes enable operation to the underlying resources.
 
         Enables racks for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
         :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
          Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
@@ -1370,48 +1402,44 @@
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForDeviceUpdate
-         or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._update_administrative_state_initial(
+            raw_result = self._update_administrative_state_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 l3_isolation_domain_name=l3_isolation_domain_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
@@ -1426,123 +1454,219 @@
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update_administrative_state.metadata = {
         "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/updateAdministrativeState"
     }
 
-    def _validate_configuration_initial(
-        self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
-    ) -> _models.ValidateConfigurationResponse:
+    def _update_option_b_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_validate_configuration_request(
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "UpdateAdministrativeState")
+
+        request = build_update_option_b_administrative_state_request(
             resource_group_name=resource_group_name,
             l3_isolation_domain_name=l3_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._validate_configuration_initial.metadata["url"],
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._update_option_b_administrative_state_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        if cls:
+            return cls(pipeline_response, None, response_headers)
 
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+    _update_option_b_administrative_state_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/updateOptionBAdministrativeState"
+    }
 
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+    @overload
+    def begin_update_option_b_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: _models.UpdateAdministrativeState,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Update route targets on CE devices. List the CE network device ARM resource IDs in the request
+        body payload.
 
-        return deserialized  # type: ignore
+        Update administrative state of option B on CE devices.
 
-    _validate_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/validateConfiguration"
-    }
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    def begin_update_option_b_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Update route targets on CE devices. List the CE network device ARM resource IDs in the request
+        body payload.
+
+        Update administrative state of option B on CE devices.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
 
     @distributed_trace
-    def begin_validate_configuration(
-        self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
-    ) -> LROPoller[_models.ValidateConfigurationResponse]:
-        """Validates the configuration of the resources.
+    def begin_update_option_b_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Update route targets on CE devices. List the CE network device ARM resource IDs in the request
+        body payload.
+
+        Update administrative state of option B on CE devices.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
+        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._validate_configuration_initial(
+            raw_result = self._update_option_b_administrative_state_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 l3_isolation_domain_name=l3_isolation_domain_name,
+                body=body,
                 api_version=api_version,
+                content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
@@ -1553,129 +1677,442 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_validate_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/validateConfiguration"
+    begin_update_option_b_administrative_state.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/updateOptionBAdministrativeState"
     }
 
-    def _commit_configuration_initial(
-        self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    def _clear_arp_table_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "EnableDisableOnResources")
 
-        request = build_commit_configuration_request(
+        request = build_clear_arp_table_request(
             resource_group_name=resource_group_name,
             l3_isolation_domain_name=l3_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._commit_configuration_initial.metadata["url"],
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._clear_arp_table_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        if cls:
+            return cls(pipeline_response, None, response_headers)
 
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+    _clear_arp_table_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/clearArpTable"
+    }
 
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+    @overload
+    def begin_clear_arp_table(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: _models.EnableDisableOnResources,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """executes clear ARP operation to the underlying resources.
 
-        return deserialized  # type: ignore
+        Clears ARP tables for this Isolation Domain.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
 
-    _commit_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/commitConfiguration"
+    @overload
+    def begin_clear_arp_table(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """executes clear ARP operation to the underlying resources.
+
+        Clears ARP tables for this Isolation Domain.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @distributed_trace
+    def begin_clear_arp_table(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """executes clear ARP operation to the underlying resources.
+
+        Clears ARP tables for this Isolation Domain.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Is either a EnableDisableOnResources type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = self._clear_arp_table_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                body=body,
+                api_version=api_version,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
+
+        if polling is True:
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(PollingMethod, NoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return LROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_clear_arp_table.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/clearArpTable"
     }
 
+    def _clear_neighbor_table_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "EnableDisableOnResources")
+
+        request = build_clear_neighbor_table_request(
+            resource_group_name=resource_group_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._clear_neighbor_table_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    _clear_neighbor_table_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/clearNeighborTable"
+    }
+
+    @overload
+    def begin_clear_neighbor_table(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: _models.EnableDisableOnResources,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """executes ipv6 clear neighbor tables operation to the underlying resources.
+
+        Clears IPv6 neighbor tables for this Isolation Domain.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    def begin_clear_neighbor_table(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """executes ipv6 clear neighbor tables operation to the underlying resources.
+
+        Clears IPv6 neighbor tables for this Isolation Domain.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
     @distributed_trace
-    def begin_commit_configuration(
-        self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Execute the commit on the resources.
+    def begin_clear_neighbor_table(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """executes ipv6 clear neighbor tables operation to the underlying resources.
 
-        Commits the configuration of the given resources.
+        Clears IPv6 neighbor tables for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param l3_isolation_domain_name: Name of the L3 Isolation Domain. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
         :type l3_isolation_domain_name: str
+        :param body: Request payload. Is either a EnableDisableOnResources type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._commit_configuration_initial(
+            raw_result = self._clear_neighbor_table_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 l3_isolation_domain_name=l3_isolation_domain_name,
+                body=body,
                 api_version=api_version,
+                content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
@@ -1686,10 +2123,10 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_commit_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/commitConfiguration"
+    begin_clear_neighbor_table.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/clearNeighborTable"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_ip_extended_communities_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_racks_operations.py`

 * *Files 18% similar despite different names*

```diff
@@ -36,34 +36,34 @@
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_request(
-    resource_group_name: str, ip_extended_community_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_rack_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "ipExtendedCommunityName": _SERIALIZER.url("ip_extended_community_name", ip_extended_community_name, "str"),
+        "networkRackName": _SERIALIZER.url("network_rack_name", network_rack_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -72,67 +72,67 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(
-    resource_group_name: str, ip_extended_community_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_rack_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "ipExtendedCommunityName": _SERIALIZER.url("ip_extended_community_name", ip_extended_community_name, "str"),
+        "networkRackName": _SERIALIZER.url("network_rack_name", network_rack_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_request(
-    resource_group_name: str, ip_extended_community_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_rack_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "ipExtendedCommunityName": _SERIALIZER.url("ip_extended_community_name", ip_extended_community_name, "str"),
+        "networkRackName": _SERIALIZER.url("network_rack_name", network_rack_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -141,33 +141,33 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(
-    resource_group_name: str, ip_extended_community_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_rack_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "ipExtendedCommunityName": _SERIALIZER.url("ip_extended_community_name", ip_extended_community_name, "str"),
+        "networkRackName": _SERIALIZER.url("network_rack_name", network_rack_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -177,24 +177,24 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
@@ -207,88 +207,84 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
-        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities"
+        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkRacks"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class IpExtendedCommunitiesOperations:
+class NetworkRacksOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.managednetworkfabric.ManagedNetworkFabricMgmtClient`'s
-        :attr:`ip_extended_communities` attribute.
+        :attr:`network_racks` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     def _create_initial(
-        self,
-        resource_group_name: str,
-        ip_extended_community_name: str,
-        body: Union[_models.IpExtendedCommunity, IO],
-        **kwargs: Any
-    ) -> _models.IpExtendedCommunity:
+        self, resource_group_name: str, network_rack_name: str, body: Union[_models.NetworkRack, IO], **kwargs: Any
+    ) -> _models.NetworkRack:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.IpExtendedCommunity] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkRack] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "IpExtendedCommunity")
+            _json = self._serialize.body(body, "NetworkRack")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            ip_extended_community_name=ip_extended_community_name,
+            network_rack_name=network_rack_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
@@ -305,173 +301,161 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("IpExtendedCommunity", pipeline_response)
+            deserialized = self._deserialize("NetworkRack", pipeline_response)
 
         if response.status_code == 201:
-            response_headers["Azure-AsyncOperation"] = self._deserialize(
-                "str", response.headers.get("Azure-AsyncOperation")
-            )
-
-            deserialized = self._deserialize("IpExtendedCommunity", pipeline_response)
+            deserialized = self._deserialize("NetworkRack", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
     }
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
-        ip_extended_community_name: str,
-        body: _models.IpExtendedCommunity,
+        network_rack_name: str,
+        body: _models.NetworkRack,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.IpExtendedCommunity]:
-        """Create an IP Extended Community.
+    ) -> LROPoller[_models.NetworkRack]:
+        """Create Network Rack.
 
-        Implements IP Extended Community PUT method.
+        Create Network Rack resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param ip_extended_community_name: Name of the IP Extended Community. Required.
-        :type ip_extended_community_name: str
+        :param network_rack_name: Name of the Network Rack. Required.
+        :type network_rack_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkRack
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either IpExtendedCommunity or the result of
+        :return: An instance of LROPoller that returns either NetworkRack or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
-        ip_extended_community_name: str,
+        network_rack_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.IpExtendedCommunity]:
-        """Create an IP Extended Community.
+    ) -> LROPoller[_models.NetworkRack]:
+        """Create Network Rack.
 
-        Implements IP Extended Community PUT method.
+        Create Network Rack resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param ip_extended_community_name: Name of the IP Extended Community. Required.
-        :type ip_extended_community_name: str
+        :param network_rack_name: Name of the Network Rack. Required.
+        :type network_rack_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either IpExtendedCommunity or the result of
+        :return: An instance of LROPoller that returns either NetworkRack or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
-        self,
-        resource_group_name: str,
-        ip_extended_community_name: str,
-        body: Union[_models.IpExtendedCommunity, IO],
-        **kwargs: Any
-    ) -> LROPoller[_models.IpExtendedCommunity]:
-        """Create an IP Extended Community.
+        self, resource_group_name: str, network_rack_name: str, body: Union[_models.NetworkRack, IO], **kwargs: Any
+    ) -> LROPoller[_models.NetworkRack]:
+        """Create Network Rack.
 
-        Implements IP Extended Community PUT method.
+        Create Network Rack resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param ip_extended_community_name: Name of the IP Extended Community. Required.
-        :type ip_extended_community_name: str
-        :param body: Request payload. Is either a IpExtendedCommunity type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity or IO
+        :param network_rack_name: Name of the Network Rack. Required.
+        :type network_rack_name: str
+        :param body: Request payload. Is either a NetworkRack type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkRack or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either IpExtendedCommunity or the result of
+        :return: An instance of LROPoller that returns either NetworkRack or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.IpExtendedCommunity] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkRack] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
                 resource_group_name=resource_group_name,
-                ip_extended_community_name=ip_extended_community_name,
+                network_rack_name=network_rack_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("IpExtendedCommunity", pipeline_response)
+            deserialized = self._deserialize("NetworkRack", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
@@ -486,52 +470,50 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
     }
 
     @distributed_trace
-    def get(
-        self, resource_group_name: str, ip_extended_community_name: str, **kwargs: Any
-    ) -> _models.IpExtendedCommunity:
-        """Gets an IP Extended Community.
+    def get(self, resource_group_name: str, network_rack_name: str, **kwargs: Any) -> _models.NetworkRack:
+        """Gets a Network Rack.
 
-        Implements IP Extended Community GET method.
+        Get Network Rack resource details.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param ip_extended_community_name: Name of the IP Extended Community. Required.
-        :type ip_extended_community_name: str
+        :param network_rack_name: Name of the Network Rack. Required.
+        :type network_rack_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: IpExtendedCommunity or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity
+        :return: NetworkRack or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkRack
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.IpExtendedCommunity] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkRack] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            ip_extended_community_name=ip_extended_community_name,
+            network_rack_name=network_rack_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -545,58 +527,54 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("IpExtendedCommunity", pipeline_response)
+        deserialized = self._deserialize("NetworkRack", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
     }
 
     def _update_initial(
-        self,
-        resource_group_name: str,
-        ip_extended_community_name: str,
-        body: Union[_models.IpExtendedCommunityPatch, IO],
-        **kwargs: Any
-    ) -> Optional[_models.IpExtendedCommunity]:
+        self, resource_group_name: str, network_rack_name: str, body: Union[_models.NetworkRackPatch, IO], **kwargs: Any
+    ) -> Optional[_models.NetworkRack]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.IpExtendedCommunity]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.NetworkRack]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "IpExtendedCommunityPatch")
+            _json = self._serialize.body(body, "NetworkRackPatch")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            ip_extended_community_name=ip_extended_community_name,
+            network_rack_name=network_rack_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
@@ -616,168 +594,163 @@
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("IpExtendedCommunity", pipeline_response)
+            deserialized = self._deserialize("NetworkRack", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
     }
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
-        ip_extended_community_name: str,
-        body: _models.IpExtendedCommunityPatch,
+        network_rack_name: str,
+        body: _models.NetworkRackPatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.IpExtendedCommunity]:
-        """Updates the IP Extended Community.
+    ) -> LROPoller[_models.NetworkRack]:
+        """Updates a Network Rack.
 
-        API to update certain properties of the IP Extended Community resource.
+        Update certain properties of the Network Rack resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param ip_extended_community_name: Name of the IP Extended Community. Required.
-        :type ip_extended_community_name: str
-        :param body: IP Extended Community properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityPatch
+        :param network_rack_name: Name of the Network Rack. Required.
+        :type network_rack_name: str
+        :param body: Network Rack properties to update. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkRackPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either IpExtendedCommunity or the result of
+        :return: An instance of LROPoller that returns either NetworkRack or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
-        ip_extended_community_name: str,
+        network_rack_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.IpExtendedCommunity]:
-        """Updates the IP Extended Community.
+    ) -> LROPoller[_models.NetworkRack]:
+        """Updates a Network Rack.
 
-        API to update certain properties of the IP Extended Community resource.
+        Update certain properties of the Network Rack resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param ip_extended_community_name: Name of the IP Extended Community. Required.
-        :type ip_extended_community_name: str
-        :param body: IP Extended Community properties to update. Required.
+        :param network_rack_name: Name of the Network Rack. Required.
+        :type network_rack_name: str
+        :param body: Network Rack properties to update. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either IpExtendedCommunity or the result of
+        :return: An instance of LROPoller that returns either NetworkRack or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
-        self,
-        resource_group_name: str,
-        ip_extended_community_name: str,
-        body: Union[_models.IpExtendedCommunityPatch, IO],
-        **kwargs: Any
-    ) -> LROPoller[_models.IpExtendedCommunity]:
-        """Updates the IP Extended Community.
+        self, resource_group_name: str, network_rack_name: str, body: Union[_models.NetworkRackPatch, IO], **kwargs: Any
+    ) -> LROPoller[_models.NetworkRack]:
+        """Updates a Network Rack.
 
-        API to update certain properties of the IP Extended Community resource.
+        Update certain properties of the Network Rack resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param ip_extended_community_name: Name of the IP Extended Community. Required.
-        :type ip_extended_community_name: str
-        :param body: IP Extended Community properties to update. Is either a IpExtendedCommunityPatch
-         type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.IpExtendedCommunityPatch or IO
+        :param network_rack_name: Name of the Network Rack. Required.
+        :type network_rack_name: str
+        :param body: Network Rack properties to update. Is either a NetworkRackPatch type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkRackPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either IpExtendedCommunity or the result of
+        :return: An instance of LROPoller that returns either NetworkRack or the result of
          cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.IpExtendedCommunity] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkRack] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
                 resource_group_name=resource_group_name,
-                ip_extended_community_name=ip_extended_community_name,
+                network_rack_name=network_rack_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("IpExtendedCommunity", pipeline_response)
+            deserialized = self._deserialize("NetworkRack", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
@@ -792,19 +765,19 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
     }
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, ip_extended_community_name: str, **kwargs: Any
+        self, resource_group_name: str, network_rack_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -814,15 +787,15 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            ip_extended_community_name=ip_extended_community_name,
+            network_rack_name=network_rack_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -836,38 +809,32 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Azure-AsyncOperation"] = self._deserialize(
-                "str", response.headers.get("Azure-AsyncOperation")
-            )
-
         if cls:
-            return cls(pipeline_response, None, response_headers)
+            return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
     }
 
     @distributed_trace
-    def begin_delete(self, resource_group_name: str, ip_extended_community_name: str, **kwargs: Any) -> LROPoller[None]:
-        """Deletes the IP Extended Community.
+    def begin_delete(self, resource_group_name: str, network_rack_name: str, **kwargs: Any) -> LROPoller[None]:
+        """Deletes a Network Rack.
 
-        Implements IP Extended Community DELETE method.
+        Delete Network Rack resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param ip_extended_community_name: Name of the IP Extended Community. Required.
-        :type ip_extended_community_name: str
+        :param network_rack_name: Name of the Network Rack. Required.
+        :type network_rack_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
@@ -883,15 +850,15 @@
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                ip_extended_community_name=ip_extended_community_name,
+                network_rack_name=network_rack_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
@@ -914,39 +881,36 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}"
     }
 
     @distributed_trace
-    def list_by_resource_group(
-        self, resource_group_name: str, **kwargs: Any
-    ) -> Iterable["_models.IpExtendedCommunity"]:
-        """List IpExtendedCommunities by resource group.
+    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.NetworkRack"]:
+        """List NetworkRacks by resource group.
 
-        Implements IpExtendedCommunities list by resource group GET method.
+        List all Network Rack resources in the given resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either IpExtendedCommunity or the result of cls(response)
-        :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
+        :return: An iterator like instance of either NetworkRack or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.IpExtendedCommunityListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkRacksListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -981,15 +945,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("IpExtendedCommunityListResult", pipeline_response)
+            deserialized = self._deserialize("NetworkRacksListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -1006,34 +970,33 @@
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks"
     }
 
     @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.IpExtendedCommunity"]:
-        """List IpExtendedCommunities by subscription.
+    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.NetworkRack"]:
+        """List NetworkRacks by subscription.
 
-        Implements IpExtendedCommunities list by subscription GET method.
+        List all Network Rack resources in the given subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either IpExtendedCommunity or the result of cls(response)
-        :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.IpExtendedCommunity]
+        :return: An iterator like instance of either NetworkRack or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkRack]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.IpExtendedCommunityListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkRacksListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1067,15 +1030,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("IpExtendedCommunityListResult", pipeline_response)
+            deserialized = self._deserialize("NetworkRacksListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -1092,9 +1055,9 @@
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities"
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkRacks"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_fabrics_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_devices_operations.py`

 * *Files 15% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 from io import IOBase
-from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
+from typing import Any, Callable, Dict, IO, Iterable, List, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -36,34 +36,34 @@
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_request(
-    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
+        "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -72,67 +72,67 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(
-    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
+        "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_request(
-    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
+        "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -141,33 +141,33 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(
-    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
+        "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -177,24 +177,24 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
@@ -207,123 +207,123 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
-        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabrics"
+        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkDevices"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_provision_request(
-    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
+def build_reboot_request(
+    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/provision",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/reboot",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
+        "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_deprovision_request(
-    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
+def build_restore_config_request(
+    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/deprovision",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/restoreConfig",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
+        "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_upgrade_request(
-    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
+def build_update_version_request(
+    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/upgrade",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updateVersion",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
+        "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -331,68 +331,68 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_refresh_configuration_request(
-    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
+def build_generate_support_package_request(
+    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/refreshConfiguration",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/generateSupportPackage",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
+        "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_update_workload_management_bfd_configuration_request(
-    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
+def build_update_power_cycle_request(
+    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/updateWorkloadManagementBfdConfiguration",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updatePowerCycle",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
+        "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -400,200 +400,161 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_update_infra_management_bfd_configuration_request(
-    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
+def build_get_status_request(
+    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/updateInfraManagementBfdConfiguration",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/getStatus",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
+        "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_validate_configuration_request(
-    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
+def build_get_static_interface_maps_request(
+    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/validateConfiguration",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/getStaticInterfaceMaps",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
+        "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_get_topology_request(
-    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
+def build_get_dynamic_interface_maps_request(
+    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/getTopology",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/getDynamicInterfaceMaps",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
+        "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_commit_configuration_request(
-    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/commitConfiguration",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-class NetworkFabricsOperations:  # pylint: disable=too-many-public-methods
+class NetworkDevicesOperations:  # pylint: disable=too-many-public-methods
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.managednetworkfabric.ManagedNetworkFabricMgmtClient`'s
-        :attr:`network_fabrics` attribute.
+        :attr:`network_devices` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     def _create_initial(
-        self, resource_group_name: str, network_fabric_name: str, body: Union[_models.NetworkFabric, IO], **kwargs: Any
-    ) -> _models.NetworkFabric:
+        self, resource_group_name: str, network_device_name: str, body: Union[_models.NetworkDevice, IO], **kwargs: Any
+    ) -> _models.NetworkDevice:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkFabric] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkDevice] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkFabric")
+            _json = self._serialize.body(body, "NetworkDevice")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            network_device_name=network_device_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
@@ -610,166 +571,161 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkFabric", pipeline_response)
+            deserialized = self._deserialize("NetworkDevice", pipeline_response)
 
         if response.status_code == 201:
-            response_headers["Azure-AsyncOperation"] = self._deserialize(
-                "str", response.headers.get("Azure-AsyncOperation")
-            )
-
-            deserialized = self._deserialize("NetworkFabric", pipeline_response)
+            deserialized = self._deserialize("NetworkDevice", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}"
     }
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: _models.NetworkFabric,
+        network_device_name: str,
+        body: _models.NetworkDevice,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.NetworkFabric]:
-        """Create Network Fabric.
+    ) -> LROPoller[_models.NetworkDevice]:
+        """Create Network Device.
 
-        Create Network Fabric resource.
+        Create a Network Device resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param network_device_name: Name of the Network Device. Required.
+        :type network_device_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabric
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkDevice
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkFabric or the result of
+        :return: An instance of LROPoller that returns either NetworkDevice or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkDevice]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
+        network_device_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.NetworkFabric]:
-        """Create Network Fabric.
+    ) -> LROPoller[_models.NetworkDevice]:
+        """Create Network Device.
 
-        Create Network Fabric resource.
+        Create a Network Device resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param network_device_name: Name of the Network Device. Required.
+        :type network_device_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkFabric or the result of
+        :return: An instance of LROPoller that returns either NetworkDevice or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkDevice]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
-        self, resource_group_name: str, network_fabric_name: str, body: Union[_models.NetworkFabric, IO], **kwargs: Any
-    ) -> LROPoller[_models.NetworkFabric]:
-        """Create Network Fabric.
+        self, resource_group_name: str, network_device_name: str, body: Union[_models.NetworkDevice, IO], **kwargs: Any
+    ) -> LROPoller[_models.NetworkDevice]:
+        """Create Network Device.
 
-        Create Network Fabric resource.
+        Create a Network Device resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Request payload. Is either a NetworkFabric type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabric or IO
+        :param network_device_name: Name of the Network Device. Required.
+        :type network_device_name: str
+        :param body: Request payload. Is either a NetworkDevice type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkDevice or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkFabric or the result of
+        :return: An instance of LROPoller that returns either NetworkDevice or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkDevice]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkFabric] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkDevice] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                network_device_name=network_device_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkFabric", pipeline_response)
+            deserialized = self._deserialize("NetworkDevice", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
@@ -784,50 +740,50 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}"
     }
 
     @distributed_trace
-    def get(self, resource_group_name: str, network_fabric_name: str, **kwargs: Any) -> _models.NetworkFabric:
-        """Gets a Network Fabric.
+    def get(self, resource_group_name: str, network_device_name: str, **kwargs: Any) -> _models.NetworkDevice:
+        """Gets a Network Device.
 
-        Get Network Fabric resource details.
+        Get the Network Device resource details.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param network_device_name: Name of the Network Device. Required.
+        :type network_device_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NetworkFabric or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkFabric
+        :return: NetworkDevice or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkDevice
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkFabric] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkDevice] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            network_device_name=network_device_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -841,58 +797,58 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("NetworkFabric", pipeline_response)
+        deserialized = self._deserialize("NetworkDevice", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}"
     }
 
     def _update_initial(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: Union[_models.NetworkFabricPatch, IO],
+        network_device_name: str,
+        body: Union[_models.NetworkDevicePatchParameters, IO],
         **kwargs: Any
-    ) -> Optional[_models.NetworkFabric]:
+    ) -> Optional[_models.NetworkDevice]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.NetworkFabric]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.NetworkDevice]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkFabricPatch")
+            _json = self._serialize.body(body, "NetworkDevicePatchParameters")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            network_device_name=network_device_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
@@ -912,165 +868,167 @@
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkFabric", pipeline_response)
+            deserialized = self._deserialize("NetworkDevice", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}"
     }
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: _models.NetworkFabricPatch,
+        network_device_name: str,
+        body: _models.NetworkDevicePatchParameters,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.NetworkFabric]:
-        """Updates a Network Fabric.
+    ) -> LROPoller[_models.NetworkDevice]:
+        """Updates a Network Device.
 
-        Update certain properties of the Network Fabric resource.
+        Update certain properties of the Network Device resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Network Fabric properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricPatch
+        :param network_device_name: Name of the Network Device. Required.
+        :type network_device_name: str
+        :param body: Network Device properties to update. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkDevicePatchParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkFabric or the result of
+        :return: An instance of LROPoller that returns either NetworkDevice or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkDevice]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
+        network_device_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.NetworkFabric]:
-        """Updates a Network Fabric.
+    ) -> LROPoller[_models.NetworkDevice]:
+        """Updates a Network Device.
 
-        Update certain properties of the Network Fabric resource.
+        Update certain properties of the Network Device resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Network Fabric properties to update. Required.
+        :param network_device_name: Name of the Network Device. Required.
+        :type network_device_name: str
+        :param body: Network Device properties to update. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkFabric or the result of
+        :return: An instance of LROPoller that returns either NetworkDevice or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkDevice]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: Union[_models.NetworkFabricPatch, IO],
+        network_device_name: str,
+        body: Union[_models.NetworkDevicePatchParameters, IO],
         **kwargs: Any
-    ) -> LROPoller[_models.NetworkFabric]:
-        """Updates a Network Fabric.
+    ) -> LROPoller[_models.NetworkDevice]:
+        """Updates a Network Device.
 
-        Update certain properties of the Network Fabric resource.
+        Update certain properties of the Network Device resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Network Fabric properties to update. Is either a NetworkFabricPatch type or a IO
-         type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkFabricPatch or IO
+        :param network_device_name: Name of the Network Device. Required.
+        :type network_device_name: str
+        :param body: Network Device properties to update. Is either a NetworkDevicePatchParameters type
+         or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkDevicePatchParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkFabric or the result of
+        :return: An instance of LROPoller that returns either NetworkDevice or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkDevice]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkFabric] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkDevice] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                network_device_name=network_device_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkFabric", pipeline_response)
+            deserialized = self._deserialize("NetworkDevice", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
@@ -1085,19 +1043,19 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}"
     }
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1107,15 +1065,15 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            network_device_name=network_device_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -1124,41 +1082,37 @@
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
         if cls:
-            return cls(pipeline_response, None, response_headers)
+            return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}"
     }
 
     @distributed_trace
-    def begin_delete(self, resource_group_name: str, network_fabric_name: str, **kwargs: Any) -> LROPoller[None]:
-        """Deletes a Network Fabric.
+    def begin_delete(self, resource_group_name: str, network_device_name: str, **kwargs: Any) -> LROPoller[None]:
+        """Deletes a Network Device.
 
-        Delete Network Fabric resource.
+        Delete the Network Device resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param network_device_name: Name of the Network Device. Required.
+        :type network_device_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
@@ -1174,15 +1128,15 @@
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                network_device_name=network_device_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
@@ -1205,36 +1159,36 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}"
     }
 
     @distributed_trace
-    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.NetworkFabric"]:
-        """List Network Fabrics by resource group.
+    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.NetworkDevice"]:
+        """List NetworkDevices by resource group.
 
-        List all the Network Fabric resources in the given resource group.
+        List all the Network Device resources in a given resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkFabric or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
+        :return: An iterator like instance of either NetworkDevice or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkDevice]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkFabricsListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkDevicesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1269,15 +1223,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkFabricsListResult", pipeline_response)
+            deserialized = self._deserialize("NetworkDevicesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -1294,33 +1248,33 @@
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices"
     }
 
     @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.NetworkFabric"]:
-        """List Network Fabrics by subscription.
+    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.NetworkDevice"]:
+        """List NetworkDevices by subscription.
 
-        List all the Network Fabric resources in the given subscription.
+        List all the Network Device resources in a given subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkFabric or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkFabric]
+        :return: An iterator like instance of either NetworkDevice or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkDevice]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkFabricsListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkDevicesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -1354,15 +1308,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkFabricsListResult", pipeline_response)
+            deserialized = self._deserialize("NetworkDevicesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -1379,128 +1333,114 @@
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabrics"
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkDevices"
     }
 
-    def _provision_initial(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForDeviceUpdate:
+    def _reboot_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_provision_request(
+        request = build_reboot_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            network_device_name=network_device_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._provision_initial.metadata["url"],
+            template_url=self._reboot_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _provision_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/provision"
+    _reboot_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/reboot"
     }
 
     @distributed_trace
-    def begin_provision(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
+    def begin_reboot(self, resource_group_name: str, network_device_name: str, **kwargs: Any) -> LROPoller[None]:
         """Implements the operation to the underlying resources.
 
-        Provisions the underlying resources in the given Network Fabric instance.
+        Reboot the Network Device.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForDeviceUpdate
-         or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._provision_initial(
+            raw_result = self._reboot_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                network_device_name=network_device_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
@@ -1511,129 +1451,117 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_provision.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/provision"
+    begin_reboot.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/reboot"
     }
 
-    def _deprovision_initial(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForDeviceUpdate:
+    def _restore_config_initial(  # pylint: disable=inconsistent-return-statements
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_deprovision_request(
+        request = build_restore_config_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            network_device_name=network_device_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._deprovision_initial.metadata["url"],
+            template_url=self._restore_config_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _deprovision_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/deprovision"
+    _restore_config_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/restoreConfig"
     }
 
     @distributed_trace
-    def begin_deprovision(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """Implements the operation to the underlying resources.
+    def begin_restore_config(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> LROPoller[None]:
+        """Restores the configuration to last applied good configuration from Azure.
 
-        Deprovisions the underlying resources in the given Network Fabric instance.
+        Restore the configuration of the Network Device resource to last known good configuration.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForDeviceUpdate
-         or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._deprovision_initial(
+            raw_result = self._restore_config_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                network_device_name=network_device_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
@@ -1644,228 +1572,219 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_deprovision.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/deprovision"
+    begin_restore_config.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/restoreConfig"
     }
 
-    def _upgrade_initial(
-        self, resource_group_name: str, network_fabric_name: str, body: Union[_models.UpdateVersion, IO], **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    def _update_version_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        network_device_name: str,
+        body: Union[_models.UpdateVersionProperties, IO],
+        **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "UpdateVersion")
+            _json = self._serialize.body(body, "UpdateVersionProperties")
 
-        request = build_upgrade_request(
+        request = build_update_version_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            network_device_name=network_device_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._upgrade_initial.metadata["url"],
+            template_url=self._update_version_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _upgrade_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/upgrade"
+    _update_version_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updateVersion"
     }
 
     @overload
-    def begin_upgrade(
+    def begin_update_version(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: _models.UpdateVersion,
+        network_device_name: str,
+        body: _models.UpdateVersionProperties,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    ) -> LROPoller[None]:
+        """Implements SKU version upgrade of network device.
 
-        Upgrades the version of the underlying resources in the given Network Fabric instance.
+        Update the SKU version of the Network Device resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Network Fabric properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateVersion
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateVersionProperties
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def begin_upgrade(
+    def begin_update_version(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
+        network_device_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    ) -> LROPoller[None]:
+        """Implements SKU version upgrade of network device.
 
-        Upgrades the version of the underlying resources in the given Network Fabric instance.
+        Update the SKU version of the Network Device resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Network Fabric properties to update. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
-    def begin_upgrade(
-        self, resource_group_name: str, network_fabric_name: str, body: Union[_models.UpdateVersion, IO], **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    def begin_update_version(
+        self,
+        resource_group_name: str,
+        network_device_name: str,
+        body: Union[_models.UpdateVersionProperties, IO],
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Implements SKU version upgrade of network device.
 
-        Upgrades the version of the underlying resources in the given Network Fabric instance.
+        Update the SKU version of the Network Device resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Network Fabric properties to update. Is either a UpdateVersion type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateVersion or IO
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :param body: Request payload. Is either a UpdateVersionProperties type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateVersionProperties or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._upgrade_initial(
+            raw_result = self._update_version_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                network_device_name=network_device_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
@@ -1876,371 +1795,128 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_upgrade.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/upgrade"
+    begin_update_version.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updateVersion"
     }
 
-    def _refresh_configuration_initial(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    def _generate_support_package_initial(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> _models.SupportPackageProperties:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[_models.SupportPackageProperties] = kwargs.pop("cls", None)
 
-        request = build_refresh_configuration_request(
+        request = build_generate_support_package_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            network_device_name=network_device_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._refresh_configuration_initial.metadata["url"],
+            template_url=self._generate_support_package_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        deserialized = self._deserialize("SupportPackageProperties", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)
 
-        return deserialized  # type: ignore
+        return deserialized
 
-    _refresh_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/refreshConfiguration"
+    _generate_support_package_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/generateSupportPackage"
     }
 
     @distributed_trace
-    def begin_refresh_configuration(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    def begin_generate_support_package(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> LROPoller[_models.SupportPackageProperties]:
         """Implements the operation to the underlying resources.
 
-        Refreshes the configuration of the underlying resources in the given Network Fabric instance.
+        Generate Support Package for the given Network Device.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
+        :return: An instance of LROPoller that returns either SupportPackageProperties or the result of
+         cls(response)
         :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.SupportPackageProperties]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[_models.SupportPackageProperties] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._refresh_configuration_initial(
+            raw_result = self._generate_support_package_initial(
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                network_device_name=network_device_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return LROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_refresh_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/refreshConfiguration"
-    }
-
-    def _update_workload_management_bfd_configuration_initial(
-        self,
-        resource_group_name: str,
-        network_fabric_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
-        **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "UpdateAdministrativeState")
-
-        request = build_update_workload_management_bfd_configuration_request(
-            resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self._update_workload_management_bfd_configuration_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
+            response_headers = {}
+            response = pipeline_response.http_response
             response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
-
-    _update_workload_management_bfd_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/updateWorkloadManagementBfdConfiguration"
-    }
-
-    @overload
-    def begin_update_workload_management_bfd_configuration(
-        self,
-        resource_group_name: str,
-        network_fabric_name: str,
-        body: _models.UpdateAdministrativeState,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
-
-        Updates the Workload Management BFD Configuration of the underlying resources in the given
-        Network Fabric instance.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    def begin_update_workload_management_bfd_configuration(
-        self,
-        resource_group_name: str,
-        network_fabric_name: str,
-        body: IO,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
-
-        Updates the Workload Management BFD Configuration of the underlying resources in the given
-        Network Fabric instance.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Request payload. Required.
-        :type body: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @distributed_trace
-    def begin_update_workload_management_bfd_configuration(
-        self,
-        resource_group_name: str,
-        network_fabric_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
-        **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
-
-        Updates the Workload Management BFD Configuration of the underlying resources in the given
-        Network Fabric instance.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = self._update_workload_management_bfd_configuration_initial(
-                resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
-                body=body,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+            deserialized = self._deserialize("SupportPackageProperties", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})
+                return cls(pipeline_response, deserialized, response_headers)
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
@@ -2252,239 +1928,220 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_update_workload_management_bfd_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/updateWorkloadManagementBfdConfiguration"
+    begin_generate_support_package.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/generateSupportPackage"
     }
 
-    def _update_infra_management_bfd_configuration_initial(
+    def _update_power_cycle_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
+        network_device_name: str,
+        body: Union[_models.UpdatePowerCycleProperties, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "UpdateAdministrativeState")
+            _json = self._serialize.body(body, "UpdatePowerCycleProperties")
 
-        request = build_update_infra_management_bfd_configuration_request(
+        request = build_update_power_cycle_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            network_device_name=network_device_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._update_infra_management_bfd_configuration_initial.metadata["url"],
+            template_url=self._update_power_cycle_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _update_infra_management_bfd_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/updateInfraManagementBfdConfiguration"
+    _update_power_cycle_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updatePowerCycle"
     }
 
     @overload
-    def begin_update_infra_management_bfd_configuration(
+    def begin_update_power_cycle(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: _models.UpdateAdministrativeState,
+        network_device_name: str,
+        body: _models.UpdatePowerCycleProperties,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> LROPoller[None]:
         """Implements the operation to the underlying resources.
 
-        Updates the Infra Management BFD Configuration of the underlying resources in the given Network
-        Fabric instance.
+        Update PDU power cycle of the Network Device.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdatePowerCycleProperties
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def begin_update_infra_management_bfd_configuration(
+    def begin_update_power_cycle(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
+        network_device_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> LROPoller[None]:
         """Implements the operation to the underlying resources.
 
-        Updates the Infra Management BFD Configuration of the underlying resources in the given Network
-        Fabric instance.
+        Update PDU power cycle of the Network Device.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
-    def begin_update_infra_management_bfd_configuration(
+    def begin_update_power_cycle(
         self,
         resource_group_name: str,
-        network_fabric_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
+        network_device_name: str,
+        body: Union[_models.UpdatePowerCycleProperties, IO],
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    ) -> LROPoller[None]:
         """Implements the operation to the underlying resources.
 
-        Updates the Infra Management BFD Configuration of the underlying resources in the given Network
-        Fabric instance.
+        Update PDU power cycle of the Network Device.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
+        :param body: Request payload. Is either a UpdatePowerCycleProperties type or a IO type.
          Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdatePowerCycleProperties or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._update_infra_management_bfd_configuration_initial(
+            raw_result = self._update_power_cycle_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                network_device_name=network_device_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
@@ -2495,235 +2152,128 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_update_infra_management_bfd_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/updateInfraManagementBfdConfiguration"
+    begin_update_power_cycle.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updatePowerCycle"
     }
 
-    def _validate_configuration_initial(
-        self,
-        resource_group_name: str,
-        network_fabric_name: str,
-        body: Union[_models.ValidateConfigurationProperties, IO],
-        **kwargs: Any
-    ) -> _models.ValidateConfigurationResponse:
+    def _get_status_initial(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> _models.GetDeviceStatusProperties:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        cls: ClsType[_models.GetDeviceStatusProperties] = kwargs.pop("cls", None)
 
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "ValidateConfigurationProperties")
-
-        request = build_validate_configuration_request(
+        request = build_get_status_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            network_device_name=network_device_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self._validate_configuration_initial.metadata["url"],
+            template_url=self._get_status_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        deserialized = self._deserialize("GetDeviceStatusProperties", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)
 
-        return deserialized  # type: ignore
+        return deserialized
 
-    _validate_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/validateConfiguration"
+    _get_status_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/getStatus"
     }
 
-    @overload
-    def begin_validate_configuration(
-        self,
-        resource_group_name: str,
-        network_fabric_name: str,
-        body: _models.ValidateConfigurationProperties,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> LROPoller[_models.ValidateConfigurationResponse]:
-        """Implements the operation to the underlying resources.
-
-        Validates the configuration of the underlying resources in the given Network Fabric instance.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Validate configuration properties. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.ValidateConfigurationProperties
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    def begin_validate_configuration(
-        self,
-        resource_group_name: str,
-        network_fabric_name: str,
-        body: IO,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> LROPoller[_models.ValidateConfigurationResponse]:
-        """Implements the operation to the underlying resources.
-
-        Validates the configuration of the underlying resources in the given Network Fabric instance.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Validate configuration properties. Required.
-        :type body: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
     @distributed_trace
-    def begin_validate_configuration(
-        self,
-        resource_group_name: str,
-        network_fabric_name: str,
-        body: Union[_models.ValidateConfigurationProperties, IO],
-        **kwargs: Any
-    ) -> LROPoller[_models.ValidateConfigurationResponse]:
-        """Implements the operation to the underlying resources.
+    def begin_get_status(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> LROPoller[_models.GetDeviceStatusProperties]:
+        """Gets the running status of the network device.
 
-        Validates the configuration of the underlying resources in the given Network Fabric instance.
+        Get the running status of the Network Device.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
-        :param body: Validate configuration properties. Is either a ValidateConfigurationProperties
-         type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.ValidateConfigurationProperties or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
+        :return: An instance of LROPoller that returns either GetDeviceStatusProperties or the result
+         of cls(response)
         :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.GetDeviceStatusProperties]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        cls: ClsType[_models.GetDeviceStatusProperties] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._validate_configuration_initial(
+            raw_result = self._get_status_initial(
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
-                body=body,
+                network_device_name=network_device_name,
                 api_version=api_version,
-                content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+            response_headers = {}
+            response = pipeline_response.http_response
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+            deserialized = self._deserialize("GetDeviceStatusProperties", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})
+                return cls(pipeline_response, deserialized, response_headers)
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
@@ -2735,128 +2285,128 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_validate_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/validateConfiguration"
+    begin_get_status.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/getStatus"
     }
 
-    def _get_topology_initial(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> _models.ValidateConfigurationResponse:
+    def _get_static_interface_maps_initial(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> List[_models.GetStaticInterfaceMapsPropertiesItem]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        cls: ClsType[List[_models.GetStaticInterfaceMapsPropertiesItem]] = kwargs.pop("cls", None)
 
-        request = build_get_topology_request(
+        request = build_get_static_interface_maps_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            network_device_name=network_device_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._get_topology_initial.metadata["url"],
+            template_url=self._get_static_interface_maps_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        deserialized = self._deserialize("[GetStaticInterfaceMapsPropertiesItem]", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)
 
-        return deserialized  # type: ignore
+        return deserialized
 
-    _get_topology_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/getTopology"
+    _get_static_interface_maps_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/getStaticInterfaceMaps"
     }
 
     @distributed_trace
-    def begin_get_topology(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> LROPoller[_models.ValidateConfigurationResponse]:
-        """Implements the operation to the underlying resources.
+    def begin_get_static_interface_maps(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> LROPoller[List[_models.GetStaticInterfaceMapsPropertiesItem]]:
+        """Show the interface maps as per the topology.
 
-        Gets Topology of the underlying resources in the given Network Fabric instance.
+        Get the static interface maps for the given Network Device.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
+        :return: An instance of LROPoller that returns either list of
+         GetStaticInterfaceMapsPropertiesItem or the result of cls(response)
         :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
+         ~azure.core.polling.LROPoller[list[~azure.mgmt.managednetworkfabric.models.GetStaticInterfaceMapsPropertiesItem]]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        cls: ClsType[List[_models.GetStaticInterfaceMapsPropertiesItem]] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._get_topology_initial(
+            raw_result = self._get_static_interface_maps_initial(
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                network_device_name=network_device_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+            response_headers = {}
+            response = pipeline_response.http_response
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+            deserialized = self._deserialize("[GetStaticInterfaceMapsPropertiesItem]", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})
+                return cls(pipeline_response, deserialized, response_headers)
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
@@ -2868,129 +2418,128 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_get_topology.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/getTopology"
+    begin_get_static_interface_maps.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/getStaticInterfaceMaps"
     }
 
-    def _commit_configuration_initial(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    def _get_dynamic_interface_maps_initial(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> List[_models.GetDynamicInterfaceMapsPropertiesItem]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[List[_models.GetDynamicInterfaceMapsPropertiesItem]] = kwargs.pop("cls", None)
 
-        request = build_commit_configuration_request(
+        request = build_get_dynamic_interface_maps_request(
             resource_group_name=resource_group_name,
-            network_fabric_name=network_fabric_name,
+            network_device_name=network_device_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._commit_configuration_initial.metadata["url"],
+            template_url=self._get_dynamic_interface_maps_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        deserialized = self._deserialize("[GetDynamicInterfaceMapsPropertiesItem]", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)
 
-        return deserialized  # type: ignore
+        return deserialized
 
-    _commit_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/commitConfiguration"
+    _get_dynamic_interface_maps_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/getDynamicInterfaceMaps"
     }
 
     @distributed_trace
-    def begin_commit_configuration(
-        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    def begin_get_dynamic_interface_maps(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> LROPoller[List[_models.GetDynamicInterfaceMapsPropertiesItem]]:
         """Implements the operation to the underlying resources.
 
-        Atomic update of the given Network Fabric instance. Sync update of NFA resources at Fabric
-        level.
+        Get the dynamic interface maps for the given Network Device.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_fabric_name: Name of the Network Fabric. Required.
-        :type network_fabric_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
+        :return: An instance of LROPoller that returns either list of
+         GetDynamicInterfaceMapsPropertiesItem or the result of cls(response)
         :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+         ~azure.core.polling.LROPoller[list[~azure.mgmt.managednetworkfabric.models.GetDynamicInterfaceMapsPropertiesItem]]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[List[_models.GetDynamicInterfaceMapsPropertiesItem]] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._commit_configuration_initial(
+            raw_result = self._get_dynamic_interface_maps_initial(
                 resource_group_name=resource_group_name,
-                network_fabric_name=network_fabric_name,
+                network_device_name=network_device_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+            response_headers = {}
+            response = pipeline_response.http_response
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+            deserialized = self._deserialize("[GetDynamicInterfaceMapsPropertiesItem]", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})
+                return cls(pipeline_response, deserialized, response_headers)
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
@@ -3002,10 +2551,10 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_commit_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/commitConfiguration"
+    begin_get_dynamic_interface_maps.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/getDynamicInterfaceMaps"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/__init__.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/aio/operations/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,63 +3,53 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._access_control_lists_operations import AccessControlListsOperations
-from ._internet_gateways_operations import InternetGatewaysOperations
-from ._internet_gateway_rules_operations import InternetGatewayRulesOperations
 from ._ip_communities_operations import IpCommunitiesOperations
 from ._ip_extended_communities_operations import IpExtendedCommunitiesOperations
 from ._ip_prefixes_operations import IpPrefixesOperations
 from ._l2_isolation_domains_operations import L2IsolationDomainsOperations
 from ._l3_isolation_domains_operations import L3IsolationDomainsOperations
 from ._internal_networks_operations import InternalNetworksOperations
 from ._external_networks_operations import ExternalNetworksOperations
-from ._neighbor_groups_operations import NeighborGroupsOperations
 from ._network_device_skus_operations import NetworkDeviceSkusOperations
 from ._network_devices_operations import NetworkDevicesOperations
 from ._network_interfaces_operations import NetworkInterfacesOperations
 from ._network_fabric_controllers_operations import NetworkFabricControllersOperations
 from ._network_fabric_skus_operations import NetworkFabricSkusOperations
 from ._network_fabrics_operations import NetworkFabricsOperations
 from ._network_to_network_interconnects_operations import NetworkToNetworkInterconnectsOperations
-from ._network_packet_brokers_operations import NetworkPacketBrokersOperations
+from ._network_rack_skus_operations import NetworkRackSkusOperations
 from ._network_racks_operations import NetworkRacksOperations
-from ._network_tap_rules_operations import NetworkTapRulesOperations
-from ._network_taps_operations import NetworkTapsOperations
 from ._operations import Operations
 from ._route_policies_operations import RoutePoliciesOperations
 
 from ._patch import __all__ as _patch_all
 from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "AccessControlListsOperations",
-    "InternetGatewaysOperations",
-    "InternetGatewayRulesOperations",
     "IpCommunitiesOperations",
     "IpExtendedCommunitiesOperations",
     "IpPrefixesOperations",
     "L2IsolationDomainsOperations",
     "L3IsolationDomainsOperations",
     "InternalNetworksOperations",
     "ExternalNetworksOperations",
-    "NeighborGroupsOperations",
     "NetworkDeviceSkusOperations",
     "NetworkDevicesOperations",
     "NetworkInterfacesOperations",
     "NetworkFabricControllersOperations",
     "NetworkFabricSkusOperations",
     "NetworkFabricsOperations",
     "NetworkToNetworkInterconnectsOperations",
-    "NetworkPacketBrokersOperations",
+    "NetworkRackSkusOperations",
     "NetworkRacksOperations",
-    "NetworkTapRulesOperations",
-    "NetworkTapsOperations",
     "Operations",
     "RoutePoliciesOperations",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_ip_communities_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_to_network_interconnects_operations.py`

 * *Files 27% similar despite different names*

```diff
@@ -36,34 +36,41 @@
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_request(
-    resource_group_name: str, ip_community_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str,
+    network_fabric_name: str,
+    network_to_network_interconnect_name: str,
+    subscription_id: str,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "ipCommunityName": _SERIALIZER.url("ip_community_name", ip_community_name, "str"),
+        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
+        "networkToNetworkInterconnectName": _SERIALIZER.url(
+            "network_to_network_interconnect_name", network_to_network_interconnect_name, "str"
+        ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -72,219 +79,180 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(
-    resource_group_name: str, ip_community_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str,
+    network_fabric_name: str,
+    network_to_network_interconnect_name: str,
+    subscription_id: str,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "ipCommunityName": _SERIALIZER.url("ip_community_name", ip_community_name, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_update_request(
-    resource_group_name: str, ip_community_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
+        "networkToNetworkInterconnectName": _SERIALIZER.url(
+            "network_to_network_interconnect_name", network_to_network_interconnect_name, "str"
         ),
-        "ipCommunityName": _SERIALIZER.url("ip_community_name", ip_community_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(
-    resource_group_name: str, ip_community_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str,
+    network_fabric_name: str,
+    network_to_network_interconnect_name: str,
+    subscription_id: str,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "ipCommunityName": _SERIALIZER.url("ip_community_name", ip_community_name, "str"),
+        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
+        "networkToNetworkInterconnectName": _SERIALIZER.url(
+            "network_to_network_interconnect_name", network_to_network_interconnect_name, "str"
+        ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_list_request(
+    resource_group_name: str, network_fabric_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
+        "networkFabricName": _SERIALIZER.url("network_fabric_name", network_fabric_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/ipCommunities"
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-class IpCommunitiesOperations:
+class NetworkToNetworkInterconnectsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.managednetworkfabric.ManagedNetworkFabricMgmtClient`'s
-        :attr:`ip_communities` attribute.
+        :attr:`network_to_network_interconnects` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     def _create_initial(
-        self, resource_group_name: str, ip_community_name: str, body: Union[_models.IpCommunity, IO], **kwargs: Any
-    ) -> _models.IpCommunity:
+        self,
+        resource_group_name: str,
+        network_fabric_name: str,
+        network_to_network_interconnect_name: str,
+        body: Union[_models.NetworkToNetworkInterconnect, IO],
+        **kwargs: Any
+    ) -> _models.NetworkToNetworkInterconnect:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.IpCommunity] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkToNetworkInterconnect] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "IpCommunity")
+            _json = self._serialize.body(body, "NetworkToNetworkInterconnect")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            ip_community_name=ip_community_name,
+            network_fabric_name=network_fabric_name,
+            network_to_network_interconnect_name=network_to_network_interconnect_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
@@ -301,166 +269,182 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("IpCommunity", pipeline_response)
+            deserialized = self._deserialize("NetworkToNetworkInterconnect", pipeline_response)
 
         if response.status_code == 201:
-            response_headers["Azure-AsyncOperation"] = self._deserialize(
-                "str", response.headers.get("Azure-AsyncOperation")
-            )
-
-            deserialized = self._deserialize("IpCommunity", pipeline_response)
+            deserialized = self._deserialize("NetworkToNetworkInterconnect", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}"
     }
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
-        ip_community_name: str,
-        body: _models.IpCommunity,
+        network_fabric_name: str,
+        network_to_network_interconnect_name: str,
+        body: _models.NetworkToNetworkInterconnect,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.IpCommunity]:
-        """Create an IP Community.
+    ) -> LROPoller[_models.NetworkToNetworkInterconnect]:
+        """Configuration used to setup CE-PE connectivity.
 
-        Implements an IP Community PUT method.
+        Configuration used to setup CE-PE connectivity PUT Method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param ip_community_name: Name of the IP Community. Required.
-        :type ip_community_name: str
+        :param network_fabric_name: Name of the NetworkFabric. Required.
+        :type network_fabric_name: str
+        :param network_to_network_interconnect_name: Name of the NetworkToNetworkInterconnectName.
+         Required.
+        :type network_to_network_interconnect_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.IpCommunity
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either IpCommunity or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpCommunity]
+        :return: An instance of LROPoller that returns either NetworkToNetworkInterconnect or the
+         result of cls(response)
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
-        ip_community_name: str,
+        network_fabric_name: str,
+        network_to_network_interconnect_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.IpCommunity]:
-        """Create an IP Community.
+    ) -> LROPoller[_models.NetworkToNetworkInterconnect]:
+        """Configuration used to setup CE-PE connectivity.
 
-        Implements an IP Community PUT method.
+        Configuration used to setup CE-PE connectivity PUT Method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param ip_community_name: Name of the IP Community. Required.
-        :type ip_community_name: str
+        :param network_fabric_name: Name of the NetworkFabric. Required.
+        :type network_fabric_name: str
+        :param network_to_network_interconnect_name: Name of the NetworkToNetworkInterconnectName.
+         Required.
+        :type network_to_network_interconnect_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either IpCommunity or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpCommunity]
+        :return: An instance of LROPoller that returns either NetworkToNetworkInterconnect or the
+         result of cls(response)
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
-        self, resource_group_name: str, ip_community_name: str, body: Union[_models.IpCommunity, IO], **kwargs: Any
-    ) -> LROPoller[_models.IpCommunity]:
-        """Create an IP Community.
+        self,
+        resource_group_name: str,
+        network_fabric_name: str,
+        network_to_network_interconnect_name: str,
+        body: Union[_models.NetworkToNetworkInterconnect, IO],
+        **kwargs: Any
+    ) -> LROPoller[_models.NetworkToNetworkInterconnect]:
+        """Configuration used to setup CE-PE connectivity.
 
-        Implements an IP Community PUT method.
+        Configuration used to setup CE-PE connectivity PUT Method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param ip_community_name: Name of the IP Community. Required.
-        :type ip_community_name: str
-        :param body: Request payload. Is either a IpCommunity type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.IpCommunity or IO
+        :param network_fabric_name: Name of the NetworkFabric. Required.
+        :type network_fabric_name: str
+        :param network_to_network_interconnect_name: Name of the NetworkToNetworkInterconnectName.
+         Required.
+        :type network_to_network_interconnect_name: str
+        :param body: Request payload. Is either a NetworkToNetworkInterconnect type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either IpCommunity or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpCommunity]
+        :return: An instance of LROPoller that returns either NetworkToNetworkInterconnect or the
+         result of cls(response)
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.IpCommunity] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkToNetworkInterconnect] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
                 resource_group_name=resource_group_name,
-                ip_community_name=ip_community_name,
+                network_fabric_name=network_fabric_name,
+                network_to_network_interconnect_name=network_to_network_interconnect_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("IpCommunity", pipeline_response)
+            deserialized = self._deserialize("NetworkToNetworkInterconnect", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
@@ -475,50 +459,60 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}"
     }
 
     @distributed_trace
-    def get(self, resource_group_name: str, ip_community_name: str, **kwargs: Any) -> _models.IpCommunity:
-        """Gets an IP Community.
+    def get(
+        self,
+        resource_group_name: str,
+        network_fabric_name: str,
+        network_to_network_interconnect_name: str,
+        **kwargs: Any
+    ) -> _models.NetworkToNetworkInterconnect:
+        """Configuration used to setup CE-PE connectivity.
 
-        Implements an IP Community GET method.
+        Implements NetworkToNetworkInterconnects GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param ip_community_name: Name of the IP Community. Required.
-        :type ip_community_name: str
+        :param network_fabric_name: Name of the NetworkFabric. Required.
+        :type network_fabric_name: str
+        :param network_to_network_interconnect_name: Name of the NetworkToNetworkInterconnect.
+         Required.
+        :type network_to_network_interconnect_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: IpCommunity or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.IpCommunity
+        :return: NetworkToNetworkInterconnect or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.IpCommunity] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkToNetworkInterconnect] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            ip_community_name=ip_community_name,
+            network_fabric_name=network_fabric_name,
+            network_to_network_interconnect_name=network_to_network_interconnect_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -532,255 +526,31 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("IpCommunity", pipeline_response)
+        deserialized = self._deserialize("NetworkToNetworkInterconnect", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}"
     }
 
-    def _update_initial(
-        self, resource_group_name: str, ip_community_name: str, body: Union[_models.IpCommunityPatch, IO], **kwargs: Any
-    ) -> Optional[_models.IpCommunity]:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.IpCommunity]] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "IpCommunityPatch")
-
-        request = build_update_request(
-            resource_group_name=resource_group_name,
-            ip_community_name=ip_community_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self._update_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        deserialized = None
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("IpCommunity", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)
-
-        return deserialized
-
-    _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}"
-    }
-
-    @overload
-    def begin_update(
-        self,
-        resource_group_name: str,
-        ip_community_name: str,
-        body: _models.IpCommunityPatch,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> LROPoller[_models.IpCommunity]:
-        """Updates an IP Community.
-
-        API to update certain properties of the IP Community resource.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param ip_community_name: Name of the IP Community. Required.
-        :type ip_community_name: str
-        :param body: IP Community properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.IpCommunityPatch
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either IpCommunity or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpCommunity]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    def begin_update(
+    def _delete_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
-        ip_community_name: str,
-        body: IO,
-        *,
-        content_type: str = "application/json",
+        network_fabric_name: str,
+        network_to_network_interconnect_name: str,
         **kwargs: Any
-    ) -> LROPoller[_models.IpCommunity]:
-        """Updates an IP Community.
-
-        API to update certain properties of the IP Community resource.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param ip_community_name: Name of the IP Community. Required.
-        :type ip_community_name: str
-        :param body: IP Community properties to update. Required.
-        :type body: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either IpCommunity or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpCommunity]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @distributed_trace
-    def begin_update(
-        self, resource_group_name: str, ip_community_name: str, body: Union[_models.IpCommunityPatch, IO], **kwargs: Any
-    ) -> LROPoller[_models.IpCommunity]:
-        """Updates an IP Community.
-
-        API to update certain properties of the IP Community resource.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param ip_community_name: Name of the IP Community. Required.
-        :type ip_community_name: str
-        :param body: IP Community properties to update. Is either a IpCommunityPatch type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.IpCommunityPatch or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either IpCommunity or the result of
-         cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.IpCommunity]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.IpCommunity] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = self._update_initial(
-                resource_group_name=resource_group_name,
-                ip_community_name=ip_community_name,
-                body=body,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("IpCommunity", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return LROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}"
-    }
-
-    def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, ip_community_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -790,15 +560,16 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            ip_community_name=ip_community_name,
+            network_fabric_name=network_fabric_name,
+            network_to_network_interconnect_name=network_to_network_interconnect_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -807,43 +578,46 @@
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Azure-AsyncOperation"] = self._deserialize(
-                "str", response.headers.get("Azure-AsyncOperation")
-            )
-
         if cls:
-            return cls(pipeline_response, None, response_headers)
+            return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}"
     }
 
     @distributed_trace
-    def begin_delete(self, resource_group_name: str, ip_community_name: str, **kwargs: Any) -> LROPoller[None]:
-        """Deletes an IP Community.
+    def begin_delete(
+        self,
+        resource_group_name: str,
+        network_fabric_name: str,
+        network_to_network_interconnect_name: str,
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Deletes a NetworkToNetworkInterconnects.
 
-        Implements IP Community DELETE method.
+        Implements NetworkToNetworkInterconnects DELETE method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param ip_community_name: Name of the IP Community. Required.
-        :type ip_community_name: str
+        :param network_fabric_name: Name of the NetworkFabric. Required.
+        :type network_fabric_name: str
+        :param network_to_network_interconnect_name: Name of the NetworkToNetworkInterconnectName.
+         Required.
+        :type network_to_network_interconnect_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
@@ -859,15 +633,16 @@
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                ip_community_name=ip_community_name,
+                network_fabric_name=network_fabric_name,
+                network_to_network_interconnect_name=network_to_network_interconnect_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
@@ -890,138 +665,60 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}"
     }
 
     @distributed_trace
-    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.IpCommunity"]:
-        """List IP Communities by resource group.
+    def list(
+        self, resource_group_name: str, network_fabric_name: str, **kwargs: Any
+    ) -> Iterable["_models.NetworkToNetworkInterconnect"]:
+        """Executes list operation to display Network To Network Interconnects within a Network Fabric.
 
-        Implements IP Communities list by resource group GET method.
+        Implements Network To Network Interconnects list by Network Fabric GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
+        :param network_fabric_name: Name of the NetworkFabric. Required.
+        :type network_fabric_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either IpCommunity or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.IpCommunity]
+        :return: An iterator like instance of either NetworkToNetworkInterconnect or the result of
+         cls(response)
+        :rtype:
+         ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkToNetworkInterconnect]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.IpCommunitiesListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkToNetworkInterconnectsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_by_resource_group_request(
+                request = build_list_request(
                     resource_group_name=resource_group_name,
+                    network_fabric_name=network_fabric_name,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
-                    template_url=self.list_by_resource_group.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
-
-        def extract_data(pipeline_response):
-            deserialized = self._deserialize("IpCommunitiesListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
-
-        def get_next(next_link=None):
-            request = prepare_request(next_link)
-
-            _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
-            )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-            return pipeline_response
-
-        return ItemPaged(get_next, extract_data)
-
-    list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities"
-    }
-
-    @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.IpCommunity"]:
-        """List IP Communities by subscription.
-
-        Implements IP Communities list by subscription GET method.
-
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either IpCommunity or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.IpCommunity]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.IpCommunitiesListResult] = kwargs.pop("cls", None)
-
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        def prepare_request(next_link=None):
-            if not next_link:
-
-                request = build_list_by_subscription_request(
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    template_url=self.list_by_subscription.metadata["url"],
+                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
@@ -1039,15 +736,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("IpCommunitiesListResult", pipeline_response)
+            deserialized = self._deserialize("NetworkToNetworkInterconnectsList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -1063,10 +760,10 @@
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/ipCommunities"
+    list.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_devices_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_interfaces_operations.py`

 * *Files 17% similar despite different names*

```diff
@@ -36,34 +36,35 @@
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_request(
-    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_device_name: str, network_interface_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
+        "networkInterfaceName": _SERIALIZER.url("network_interface_name", network_interface_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -72,67 +73,69 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(
-    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_device_name: str, network_interface_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
+        "networkInterfaceName": _SERIALIZER.url("network_interface_name", network_interface_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_request(
-    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_device_name: str, network_interface_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
+        "networkInterfaceName": _SERIALIZER.url("network_interface_name", network_interface_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -141,192 +144,136 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(
-    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_device_name: str, network_interface_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
+        "networkInterfaceName": _SERIALIZER.url("network_interface_name", network_interface_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkDevices"
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_reboot_request(
+def build_list_request(
     resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/reboot",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_refresh_configuration_request(
-    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
+def build_get_status_request(
+    resource_group_name: str, network_device_name: str, network_interface_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/refreshConfiguration",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}/getStatus",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
+        "networkInterfaceName": _SERIALIZER.url("network_interface_name", network_interface_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_administrative_state_request(
-    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, network_device_name: str, network_interface_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updateAdministrativeState",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}/updateAdministrativeState",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
         "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
+        "networkInterfaceName": _SERIALIZER.url("network_interface_name", network_interface_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -334,98 +281,68 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_upgrade_request(
-    resource_group_name: str, network_device_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/upgrade",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-        "resourceGroupName": _SERIALIZER.url(
-            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
-        ),
-        "networkDeviceName": _SERIALIZER.url("network_device_name", network_device_name, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-class NetworkDevicesOperations:
+class NetworkInterfacesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.managednetworkfabric.ManagedNetworkFabricMgmtClient`'s
-        :attr:`network_devices` attribute.
+        :attr:`network_interfaces` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     def _create_initial(
-        self, resource_group_name: str, network_device_name: str, body: Union[_models.NetworkDevice, IO], **kwargs: Any
-    ) -> _models.NetworkDevice:
+        self,
+        resource_group_name: str,
+        network_device_name: str,
+        network_interface_name: str,
+        body: Union[_models.NetworkInterface, IO],
+        **kwargs: Any
+    ) -> _models.NetworkInterface:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkDevice] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkInterface] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkDevice")
+            _json = self._serialize.body(body, "NetworkInterface")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
             network_device_name=network_device_name,
+            network_interface_name=network_interface_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
@@ -443,160 +360,174 @@
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkDevice", pipeline_response)
+            deserialized = self._deserialize("NetworkInterface", pipeline_response)
 
         if response.status_code == 201:
-            deserialized = self._deserialize("NetworkDevice", pipeline_response)
+            deserialized = self._deserialize("NetworkInterface", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
     }
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
         network_device_name: str,
-        body: _models.NetworkDevice,
+        network_interface_name: str,
+        body: _models.NetworkInterface,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.NetworkDevice]:
-        """Create Network Device.
+    ) -> LROPoller[_models.NetworkInterface]:
+        """Create NetworkInterface.
 
-        Create a Network Device resource.
+        Create a Network Interface resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterface. Required.
+        :type network_interface_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkDevice
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkInterface
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkDevice or the result of
+        :return: An instance of LROPoller that returns either NetworkInterface or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkDevice]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
         network_device_name: str,
+        network_interface_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.NetworkDevice]:
-        """Create Network Device.
+    ) -> LROPoller[_models.NetworkInterface]:
+        """Create NetworkInterface.
 
-        Create a Network Device resource.
+        Create a Network Interface resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterface. Required.
+        :type network_interface_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkDevice or the result of
+        :return: An instance of LROPoller that returns either NetworkInterface or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkDevice]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
-        self, resource_group_name: str, network_device_name: str, body: Union[_models.NetworkDevice, IO], **kwargs: Any
-    ) -> LROPoller[_models.NetworkDevice]:
-        """Create Network Device.
+        self,
+        resource_group_name: str,
+        network_device_name: str,
+        network_interface_name: str,
+        body: Union[_models.NetworkInterface, IO],
+        **kwargs: Any
+    ) -> LROPoller[_models.NetworkInterface]:
+        """Create NetworkInterface.
 
-        Create a Network Device resource.
+        Create a Network Interface resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
-        :param body: Request payload. Is either a NetworkDevice type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkDevice or IO
+        :param network_interface_name: Name of the NetworkInterface. Required.
+        :type network_interface_name: str
+        :param body: Request payload. Is either a NetworkInterface type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkInterface or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkDevice or the result of
+        :return: An instance of LROPoller that returns either NetworkInterface or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkDevice]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkDevice] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkInterface] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
                 resource_group_name=resource_group_name,
                 network_device_name=network_device_name,
+                network_interface_name=network_interface_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkDevice", pipeline_response)
+            deserialized = self._deserialize("NetworkInterface", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
@@ -611,50 +542,55 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
     }
 
     @distributed_trace
-    def get(self, resource_group_name: str, network_device_name: str, **kwargs: Any) -> _models.NetworkDevice:
-        """Gets a Network Device.
+    def get(
+        self, resource_group_name: str, network_device_name: str, network_interface_name: str, **kwargs: Any
+    ) -> _models.NetworkInterface:
+        """Gets a NetworkInterface.
 
-        Gets the Network Device resource details.
+        Get the Network Interface resource details.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterfaceName. Required.
+        :type network_interface_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NetworkDevice or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkDevice
+        :return: NetworkInterface or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkInterface
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkDevice] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkInterface] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             network_device_name=network_device_name,
+            network_interface_name=network_interface_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -668,58 +604,60 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("NetworkDevice", pipeline_response)
+        deserialized = self._deserialize("NetworkInterface", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
     }
 
     def _update_initial(
         self,
         resource_group_name: str,
         network_device_name: str,
-        body: Union[_models.NetworkDevicePatchParameters, IO],
+        network_interface_name: str,
+        body: Union[_models.NetworkInterfacePatch, IO],
         **kwargs: Any
-    ) -> Optional[_models.NetworkDevice]:
+    ) -> _models.NetworkInterface:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.NetworkDevice]] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkInterface] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkDevicePatchParameters")
+            _json = self._serialize.body(body, "NetworkInterfacePatch")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             network_device_name=network_device_name,
+            network_interface_name=network_interface_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
@@ -736,175 +674,183 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = None
-        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkDevice", pipeline_response)
+            deserialized = self._deserialize("NetworkInterface", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            deserialized = self._deserialize("NetworkInterface", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
     }
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
         network_device_name: str,
-        body: _models.NetworkDevicePatchParameters,
+        network_interface_name: str,
+        body: _models.NetworkInterfacePatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.NetworkDevice]:
-        """Updates a Network Device.
+    ) -> LROPoller[_models.NetworkInterface]:
+        """Updates a NetworkInterface.
 
-        Update certain properties of the Network Device resource.
+        Update certain properties of the Network Interface resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
-        :param body: Network Device properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkDevicePatchParameters
+        :param network_interface_name: Name of the NetworkInterfaceName. Required.
+        :type network_interface_name: str
+        :param body: NetworkInterface properties to update. Only tags are supported. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkInterfacePatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkDevice or the result of
+        :return: An instance of LROPoller that returns either NetworkInterface or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkDevice]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
         network_device_name: str,
+        network_interface_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.NetworkDevice]:
-        """Updates a Network Device.
+    ) -> LROPoller[_models.NetworkInterface]:
+        """Updates a NetworkInterface.
 
-        Update certain properties of the Network Device resource.
+        Update certain properties of the Network Interface resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
-        :param body: Network Device properties to update. Required.
+        :param network_interface_name: Name of the NetworkInterfaceName. Required.
+        :type network_interface_name: str
+        :param body: NetworkInterface properties to update. Only tags are supported. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkDevice or the result of
+        :return: An instance of LROPoller that returns either NetworkInterface or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkDevice]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
         network_device_name: str,
-        body: Union[_models.NetworkDevicePatchParameters, IO],
+        network_interface_name: str,
+        body: Union[_models.NetworkInterfacePatch, IO],
         **kwargs: Any
-    ) -> LROPoller[_models.NetworkDevice]:
-        """Updates a Network Device.
+    ) -> LROPoller[_models.NetworkInterface]:
+        """Updates a NetworkInterface.
 
-        Update certain properties of the Network Device resource.
+        Update certain properties of the Network Interface resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
-        :param body: Network Device properties to update. Is either a NetworkDevicePatchParameters type
-         or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkDevicePatchParameters or IO
+        :param network_interface_name: Name of the NetworkInterfaceName. Required.
+        :type network_interface_name: str
+        :param body: NetworkInterface properties to update. Only tags are supported. Is either a
+         NetworkInterfacePatch type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkInterfacePatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkDevice or the result of
+        :return: An instance of LROPoller that returns either NetworkInterface or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkDevice]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkDevice] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkInterface] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
                 resource_group_name=resource_group_name,
                 network_device_name=network_device_name,
+                network_interface_name=network_interface_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkDevice", pipeline_response)
+            deserialized = self._deserialize("NetworkInterface", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
@@ -912,19 +858,19 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
     }
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+        self, resource_group_name: str, network_device_name: str, network_interface_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -935,14 +881,15 @@
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             network_device_name=network_device_name,
+            network_interface_name=network_interface_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -951,37 +898,41 @@
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
     }
 
     @distributed_trace
-    def begin_delete(self, resource_group_name: str, network_device_name: str, **kwargs: Any) -> LROPoller[None]:
-        """Deletes a Network Device.
+    def begin_delete(
+        self, resource_group_name: str, network_device_name: str, network_interface_name: str, **kwargs: Any
+    ) -> LROPoller[None]:
+        """Deletes a NetworkInterface.
 
-        Delete the Network Device resource.
+        Delete the Network Interface resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterfaceName. Required.
+        :type network_interface_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
@@ -998,14 +949,15 @@
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 network_device_name=network_device_name,
+                network_interface_name=network_interface_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
@@ -1028,53 +980,58 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}"
     }
 
     @distributed_trace
-    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.NetworkDevice"]:
-        """List NetworkDevices by resource group.
+    def list(
+        self, resource_group_name: str, network_device_name: str, **kwargs: Any
+    ) -> Iterable["_models.NetworkInterface"]:
+        """List all Network Interfaces that are available using an Network Device.
 
-        List all the Network Device resources in a given resource group.
+        List all the Network Interface resources in a given resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
+        :param network_device_name: Name of the NetworkDevice. Required.
+        :type network_device_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkDevice or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkDevice]
+        :return: An iterator like instance of either NetworkInterface or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkInterface]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkDevicesListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.NetworkInterfacesList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_by_resource_group_request(
+                request = build_list_request(
                     resource_group_name=resource_group_name,
+                    network_device_name=network_device_name,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
-                    template_url=self.list_by_resource_group.metadata["url"],
+                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
@@ -1092,15 +1049,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkDevicesListResult", pipeline_response)
+            deserialized = self._deserialize("NetworkInterfacesList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -1116,452 +1073,131 @@
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices"
-    }
-
-    @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.NetworkDevice"]:
-        """List NetworkDevices by subscription.
-
-        List all the Network Device resources in a given subscription.
-
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkDevice or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkDevice]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkDevicesListResult] = kwargs.pop("cls", None)
-
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        def prepare_request(next_link=None):
-            if not next_link:
-
-                request = build_list_by_subscription_request(
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    template_url=self.list_by_subscription.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
-
-        def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkDevicesListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
-
-        def get_next(next_link=None):
-            request = prepare_request(next_link)
-
-            _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
-            )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-            return pipeline_response
-
-        return ItemPaged(get_next, extract_data)
-
-    list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkDevices"
-    }
-
-    def _reboot_initial(
-        self,
-        resource_group_name: str,
-        network_device_name: str,
-        body: Union[_models.RebootProperties, IO],
-        **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "RebootProperties")
-
-        request = build_reboot_request(
-            resource_group_name=resource_group_name,
-            network_device_name=network_device_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self._reboot_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
-
-    _reboot_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/reboot"
-    }
-
-    @overload
-    def begin_reboot(
-        self,
-        resource_group_name: str,
-        network_device_name: str,
-        body: _models.RebootProperties,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
-
-        Reboot the Network Device.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.RebootProperties
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    def begin_reboot(
-        self,
-        resource_group_name: str,
-        network_device_name: str,
-        body: IO,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
-
-        Reboot the Network Device.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param body: Request payload. Required.
-        :type body: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @distributed_trace
-    def begin_reboot(
-        self,
-        resource_group_name: str,
-        network_device_name: str,
-        body: Union[_models.RebootProperties, IO],
-        **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
-
-        Reboot the Network Device.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param body: Request payload. Is either a RebootProperties type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.RebootProperties or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = self._reboot_initial(
-                resource_group_name=resource_group_name,
-                network_device_name=network_device_name,
-                body=body,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return LROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_reboot.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/reboot"
+    list.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces"
     }
 
-    def _refresh_configuration_initial(
-        self, resource_group_name: str, network_device_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    def _get_status_initial(
+        self, resource_group_name: str, network_device_name: str, network_interface_name: str, **kwargs: Any
+    ) -> _models.InterfaceStatus:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[_models.InterfaceStatus] = kwargs.pop("cls", None)
 
-        request = build_refresh_configuration_request(
+        request = build_get_status_request(
             resource_group_name=resource_group_name,
             network_device_name=network_device_name,
+            network_interface_name=network_interface_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._refresh_configuration_initial.metadata["url"],
+            template_url=self._get_status_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        deserialized = self._deserialize("InterfaceStatus", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)
 
-        return deserialized  # type: ignore
+        return deserialized
 
-    _refresh_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/refreshConfiguration"
+    _get_status_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}/getStatus"
     }
 
     @distributed_trace
-    def begin_refresh_configuration(
-        self, resource_group_name: str, network_device_name: str, **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
+    def begin_get_status(
+        self, resource_group_name: str, network_device_name: str, network_interface_name: str, **kwargs: Any
+    ) -> LROPoller[_models.InterfaceStatus]:
         """Implements the operation to the underlying resources.
 
-        Refreshes the configuration the Network Device.
+        Get the running status of the Network Interface.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterface. Required.
+        :type network_interface_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either InterfaceStatus or the result of
+         cls(response)
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.InterfaceStatus]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[_models.InterfaceStatus] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._refresh_configuration_initial(
+            raw_result = self._get_status_initial(
                 resource_group_name=resource_group_name,
                 network_device_name=network_device_name,
+                network_interface_name=network_interface_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+            response_headers = {}
+            response = pipeline_response.http_response
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+            deserialized = self._deserialize("InterfaceStatus", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})
+                return cls(pipeline_response, deserialized, response_headers)
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
@@ -1573,51 +1209,53 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_refresh_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/refreshConfiguration"
+    begin_get_status.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}/getStatus"
     }
 
-    def _update_administrative_state_initial(
+    def _update_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
         network_device_name: str,
-        body: Union[_models.UpdateDeviceAdministrativeState, IO],
+        network_interface_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "UpdateDeviceAdministrativeState")
+            _json = self._serialize.body(body, "UpdateAdministrativeState")
 
         request = build_update_administrative_state_request(
             resource_group_name=resource_group_name,
             network_device_name=network_device_name,
+            network_interface_name=network_interface_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_administrative_state_initial.metadata["url"],
             headers=_headers,
@@ -1629,180 +1267,174 @@
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
     _update_administrative_state_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updateAdministrativeState"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}/updateAdministrativeState"
     }
 
     @overload
     def begin_update_administrative_state(
         self,
         resource_group_name: str,
         network_device_name: str,
-        body: _models.UpdateDeviceAdministrativeState,
+        network_interface_name: str,
+        body: _models.UpdateAdministrativeState,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    ) -> LROPoller[None]:
+        """Updates the admin state of the network interface.
 
-        Updates the Administrative state of the Network Device.
+        Update the admin state of the Network Interface.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterface. Required.
+        :type network_interface_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateDeviceAdministrativeState
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update_administrative_state(
         self,
         resource_group_name: str,
         network_device_name: str,
+        network_interface_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    ) -> LROPoller[None]:
+        """Updates the admin state of the network interface.
 
-        Updates the Administrative state of the Network Device.
+        Update the admin state of the Network Interface.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
+        :param network_interface_name: Name of the NetworkInterface. Required.
+        :type network_interface_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update_administrative_state(
         self,
         resource_group_name: str,
         network_device_name: str,
-        body: Union[_models.UpdateDeviceAdministrativeState, IO],
+        network_interface_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
+    ) -> LROPoller[None]:
+        """Updates the admin state of the network interface.
 
-        Updates the Administrative state of the Network Device.
+        Update the admin state of the Network Interface.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
+        :param network_device_name: Name of the NetworkDevice. Required.
         :type network_device_name: str
-        :param body: Request payload. Is either a UpdateDeviceAdministrativeState type or a IO type.
+        :param network_interface_name: Name of the NetworkInterface. Required.
+        :type network_interface_name: str
+        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
          Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateDeviceAdministrativeState or IO
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._update_administrative_state_initial(
+            raw_result = self._update_administrative_state_initial(  # type: ignore
                 resource_group_name=resource_group_name,
                 network_device_name=network_device_name,
+                network_interface_name=network_interface_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
@@ -1814,240 +1446,9 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update_administrative_state.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updateAdministrativeState"
-    }
-
-    def _upgrade_initial(
-        self, resource_group_name: str, network_device_name: str, body: Union[_models.UpdateVersion, IO], **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(body, (IOBase, bytes)):
-            _content = body
-        else:
-            _json = self._serialize.body(body, "UpdateVersion")
-
-        request = build_upgrade_request(
-            resource_group_name=resource_group_name,
-            network_device_name=network_device_name,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self._upgrade_initial.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        _stream = False
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=_stream, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200, 202]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
-
-    _upgrade_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/upgrade"
-    }
-
-    @overload
-    def begin_upgrade(
-        self,
-        resource_group_name: str,
-        network_device_name: str,
-        body: _models.UpdateVersion,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
-
-        Upgrades the version of the Network Device.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateVersion
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    def begin_upgrade(
-        self,
-        resource_group_name: str,
-        network_device_name: str,
-        body: IO,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
-
-        Upgrades the version of the Network Device.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param body: Request payload. Required.
-        :type body: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @distributed_trace
-    def begin_upgrade(
-        self, resource_group_name: str, network_device_name: str, body: Union[_models.UpdateVersion, IO], **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Implements the operation to the underlying resources.
-
-        Upgrades the version of the Network Device.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :param network_device_name: Name of the Network Device. Required.
-        :type network_device_name: str
-        :param body: Request payload. Is either a UpdateVersion type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateVersion or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
-        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
-         operation to not poll, or pass in your own initialized polling object for a personal polling
-         strategy.
-        :paramtype polling: bool or ~azure.core.polling.PollingMethod
-        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-         Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
-        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
-        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
-        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
-        if cont_token is None:
-            raw_result = self._upgrade_initial(
-                resource_group_name=resource_group_name,
-                network_device_name=network_device_name,
-                body=body,
-                api_version=api_version,
-                content_type=content_type,
-                cls=lambda x, y, z: x,
-                headers=_headers,
-                params=_params,
-                **kwargs
-            )
-        kwargs.pop("error_map", None)
-
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-            if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
-
-        if polling is True:
-            polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
-            )
-        elif polling is False:
-            polling_method = cast(PollingMethod, NoPolling())
-        else:
-            polling_method = polling
-        if cont_token:
-            return LROPoller.from_continuation_token(
-                polling_method=polling_method,
-                continuation_token=cont_token,
-                client=self._client,
-                deserialization_callback=get_long_running_output,
-            )
-        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
-
-    begin_upgrade.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/upgrade"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}/updateAdministrativeState"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_route_policies_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_l2_isolation_domains_operations.py`

 * *Files 18% similar despite different names*

```diff
@@ -36,34 +36,34 @@
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_request(
-    resource_group_name: str, route_policy_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, l2_isolation_domain_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "routePolicyName": _SERIALIZER.url("route_policy_name", route_policy_name, "str"),
+        "l2IsolationDomainName": _SERIALIZER.url("l2_isolation_domain_name", l2_isolation_domain_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -72,67 +72,67 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(
-    resource_group_name: str, route_policy_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, l2_isolation_domain_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "routePolicyName": _SERIALIZER.url("route_policy_name", route_policy_name, "str"),
+        "l2IsolationDomainName": _SERIALIZER.url("l2_isolation_domain_name", l2_isolation_domain_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_request(
-    resource_group_name: str, route_policy_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, l2_isolation_domain_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "routePolicyName": _SERIALIZER.url("route_policy_name", route_policy_name, "str"),
+        "l2IsolationDomainName": _SERIALIZER.url("l2_isolation_domain_name", l2_isolation_domain_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -141,123 +141,139 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(
-    resource_group_name: str, route_policy_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str, l2_isolation_domain_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "routePolicyName": _SERIALIZER.url("route_policy_name", route_policy_name, "str"),
+        "l2IsolationDomainName": _SERIALIZER.url("l2_isolation_domain_name", l2_isolation_domain_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_update_administrative_state_request(
+    resource_group_name: str, l2_isolation_domain_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/updateAdministrativeState",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
+        "l2IsolationDomainName": _SERIALIZER.url("l2_isolation_domain_name", l2_isolation_domain_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_clear_arp_table_request(
+    resource_group_name: str, l2_isolation_domain_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
-        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/routePolicies"
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/clearArpTable",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "l2IsolationDomainName": _SERIALIZER.url("l2_isolation_domain_name", l2_isolation_domain_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_update_administrative_state_request(
-    resource_group_name: str, route_policy_name: str, subscription_id: str, **kwargs: Any
+def build_clear_neighbor_table_request(
+    resource_group_name: str, l2_isolation_domain_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/updateAdministrativeState",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/clearNeighborTable",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "routePolicyName": _SERIALIZER.url("route_policy_name", route_policy_name, "str"),
+        "l2IsolationDomainName": _SERIALIZER.url("l2_isolation_domain_name", l2_isolation_domain_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -265,128 +281,155 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_validate_configuration_request(
-    resource_group_name: str, route_policy_name: str, subscription_id: str, **kwargs: Any
+def build_get_arp_entries_request(
+    resource_group_name: str, l2_isolation_domain_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/validateConfiguration",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/getArpEntries",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "routePolicyName": _SERIALIZER.url("route_policy_name", route_policy_name, "str"),
+        "l2IsolationDomainName": _SERIALIZER.url("l2_isolation_domain_name", l2_isolation_domain_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_commit_configuration_request(
-    resource_group_name: str, route_policy_name: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
+def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/commitConfiguration",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "routePolicyName": _SERIALIZER.url("route_policy_name", route_policy_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class RoutePoliciesOperations:
+def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains"
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class L2IsolationDomainsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.managednetworkfabric.ManagedNetworkFabricMgmtClient`'s
-        :attr:`route_policies` attribute.
+        :attr:`l2_isolation_domains` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     def _create_initial(
-        self, resource_group_name: str, route_policy_name: str, body: Union[_models.RoutePolicy, IO], **kwargs: Any
-    ) -> _models.RoutePolicy:
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: Union[_models.L2IsolationDomain, IO],
+        **kwargs: Any
+    ) -> _models.L2IsolationDomain:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.RoutePolicy] = kwargs.pop("cls", None)
+        cls: ClsType[_models.L2IsolationDomain] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "RoutePolicy")
+            _json = self._serialize.body(body, "L2IsolationDomain")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            route_policy_name=route_policy_name,
+            l2_isolation_domain_name=l2_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
@@ -404,160 +447,170 @@
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if response.status_code == 200:
-            deserialized = self._deserialize("RoutePolicy", pipeline_response)
+            deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
 
         if response.status_code == 201:
-            deserialized = self._deserialize("RoutePolicy", pipeline_response)
+            deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
     }
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
-        route_policy_name: str,
-        body: _models.RoutePolicy,
+        l2_isolation_domain_name: str,
+        body: _models.L2IsolationDomain,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.RoutePolicy]:
-        """Create Route Policy.
+    ) -> LROPoller[_models.L2IsolationDomain]:
+        """Create L2 Isolation Domain.
 
-        Implements Route Policy PUT method.
+        Creates layer 2 network connectivity between compute nodes within a rack and across racks.The
+        configuration is applied on the devices only after the isolation domain is enabled.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
+        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
+        :type l2_isolation_domain_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.RoutePolicy
+        :type body: ~azure.mgmt.managednetworkfabric.models.L2IsolationDomain
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either RoutePolicy or the result of
+        :return: An instance of LROPoller that returns either L2IsolationDomain or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
-        route_policy_name: str,
+        l2_isolation_domain_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.RoutePolicy]:
-        """Create Route Policy.
+    ) -> LROPoller[_models.L2IsolationDomain]:
+        """Create L2 Isolation Domain.
 
-        Implements Route Policy PUT method.
+        Creates layer 2 network connectivity between compute nodes within a rack and across racks.The
+        configuration is applied on the devices only after the isolation domain is enabled.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
+        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
+        :type l2_isolation_domain_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either RoutePolicy or the result of
+        :return: An instance of LROPoller that returns either L2IsolationDomain or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
-        self, resource_group_name: str, route_policy_name: str, body: Union[_models.RoutePolicy, IO], **kwargs: Any
-    ) -> LROPoller[_models.RoutePolicy]:
-        """Create Route Policy.
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: Union[_models.L2IsolationDomain, IO],
+        **kwargs: Any
+    ) -> LROPoller[_models.L2IsolationDomain]:
+        """Create L2 Isolation Domain.
 
-        Implements Route Policy PUT method.
+        Creates layer 2 network connectivity between compute nodes within a rack and across racks.The
+        configuration is applied on the devices only after the isolation domain is enabled.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
-        :param body: Request payload. Is either a RoutePolicy type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.RoutePolicy or IO
+        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: Request payload. Is either a L2IsolationDomain type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.L2IsolationDomain or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either RoutePolicy or the result of
+        :return: An instance of LROPoller that returns either L2IsolationDomain or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.RoutePolicy] = kwargs.pop("cls", None)
+        cls: ClsType[_models.L2IsolationDomain] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
                 resource_group_name=resource_group_name,
-                route_policy_name=route_policy_name,
+                l2_isolation_domain_name=l2_isolation_domain_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("RoutePolicy", pipeline_response)
+            deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
@@ -572,50 +625,50 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
     }
 
     @distributed_trace
-    def get(self, resource_group_name: str, route_policy_name: str, **kwargs: Any) -> _models.RoutePolicy:
-        """Gets a Route Policy.
+    def get(self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any) -> _models.L2IsolationDomain:
+        """Retrieves details of this L2 Isolation Domain.
 
-        Implements Route Policy GET method.
+        Implements L2 Isolation Domain GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
+        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
+        :type l2_isolation_domain_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: RoutePolicy or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.RoutePolicy
+        :return: L2IsolationDomain or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.L2IsolationDomain
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.RoutePolicy] = kwargs.pop("cls", None)
+        cls: ClsType[_models.L2IsolationDomain] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            route_policy_name=route_policy_name,
+            l2_isolation_domain_name=l2_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -629,54 +682,58 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("RoutePolicy", pipeline_response)
+        deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
     }
 
     def _update_initial(
-        self, resource_group_name: str, route_policy_name: str, body: Union[_models.RoutePolicyPatch, IO], **kwargs: Any
-    ) -> Optional[_models.RoutePolicy]:
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: Union[_models.L2IsolationDomainPatch, IO],
+        **kwargs: Any
+    ) -> Optional[_models.L2IsolationDomain]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.RoutePolicy]] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.L2IsolationDomain]] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "RoutePolicyPatch")
+            _json = self._serialize.body(body, "L2IsolationDomainPatch")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            route_policy_name=route_policy_name,
+            l2_isolation_domain_name=l2_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
@@ -696,161 +753,170 @@
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         deserialized = None
         response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("RoutePolicy", pipeline_response)
+            deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            response_headers["Azure-AsyncOperation"] = self._deserialize(
+                "str", response.headers.get("Azure-AsyncOperation")
+            )
 
         if cls:
             return cls(pipeline_response, deserialized, response_headers)
 
         return deserialized
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
     }
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
-        route_policy_name: str,
-        body: _models.RoutePolicyPatch,
+        l2_isolation_domain_name: str,
+        body: _models.L2IsolationDomainPatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.RoutePolicy]:
-        """Updates a Route Policy.
+    ) -> LROPoller[_models.L2IsolationDomain]:
+        """Updates a L2 Isolation Domain.
 
-        API to update certain properties of the Route Policy resource.
+        API to update certain properties of the L2 Isolation Domain resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
-        :param body: Route Policy properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.RoutePolicyPatch
+        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: API to update certain properties of the L2 Isolation Domain resource.. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.L2IsolationDomainPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either RoutePolicy or the result of
+        :return: An instance of LROPoller that returns either L2IsolationDomain or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
-        route_policy_name: str,
+        l2_isolation_domain_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.RoutePolicy]:
-        """Updates a Route Policy.
+    ) -> LROPoller[_models.L2IsolationDomain]:
+        """Updates a L2 Isolation Domain.
 
-        API to update certain properties of the Route Policy resource.
+        API to update certain properties of the L2 Isolation Domain resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
-        :param body: Route Policy properties to update. Required.
+        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: API to update certain properties of the L2 Isolation Domain resource.. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either RoutePolicy or the result of
+        :return: An instance of LROPoller that returns either L2IsolationDomain or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
-        self, resource_group_name: str, route_policy_name: str, body: Union[_models.RoutePolicyPatch, IO], **kwargs: Any
-    ) -> LROPoller[_models.RoutePolicy]:
-        """Updates a Route Policy.
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: Union[_models.L2IsolationDomainPatch, IO],
+        **kwargs: Any
+    ) -> LROPoller[_models.L2IsolationDomain]:
+        """Updates a L2 Isolation Domain.
 
-        API to update certain properties of the Route Policy resource.
+        API to update certain properties of the L2 Isolation Domain resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
-        :param body: Route Policy properties to update. Is either a RoutePolicyPatch type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.RoutePolicyPatch or IO
+        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: API to update certain properties of the L2 Isolation Domain resource.. Is either a
+         L2IsolationDomainPatch type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.L2IsolationDomainPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either RoutePolicy or the result of
+        :return: An instance of LROPoller that returns either L2IsolationDomain or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
+        :rtype:
+         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.RoutePolicy] = kwargs.pop("cls", None)
+        cls: ClsType[_models.L2IsolationDomain] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
                 resource_group_name=resource_group_name,
-                route_policy_name=route_policy_name,
+                l2_isolation_domain_name=l2_isolation_domain_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("RoutePolicy", pipeline_response)
+            deserialized = self._deserialize("L2IsolationDomain", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
@@ -865,19 +931,19 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
     }
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, route_policy_name: str, **kwargs: Any
+        self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -887,15 +953,15 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            route_policy_name=route_policy_name,
+            l2_isolation_domain_name=l2_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -904,37 +970,37 @@
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
     }
 
     @distributed_trace
-    def begin_delete(self, resource_group_name: str, route_policy_name: str, **kwargs: Any) -> LROPoller[None]:
-        """Deletes a Route Policy.
+    def begin_delete(self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any) -> LROPoller[None]:
+        """Deletes named L2 Isolation Domain.
 
-        Implements Route Policy DELETE method.
+        Deletes layer 2 connectivity between compute nodes by managed by named L2 Isolation name.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
+        :param l2_isolation_domain_name: Name of the L2 Isolation Domain. Required.
+        :type l2_isolation_domain_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
@@ -950,15 +1016,15 @@
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                route_policy_name=route_policy_name,
+                l2_isolation_domain_name=l2_isolation_domain_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
@@ -981,409 +1047,442 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}"
     }
 
-    @distributed_trace
-    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.RoutePolicy"]:
-        """List RoutePolicies by resource group.
-
-        Implements RoutePolicies list by resource group GET method.
-
-        :param resource_group_name: The name of the resource group. The name is case insensitive.
-         Required.
-        :type resource_group_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either RoutePolicy or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.RoutePoliciesListResult] = kwargs.pop("cls", None)
-
+    def _update_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        def prepare_request(next_link=None):
-            if not next_link:
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-                request = build_list_by_resource_group_request(
-                    resource_group_name=resource_group_name,
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    template_url=self.list_by_resource_group.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "UpdateAdministrativeState")
 
-        def extract_data(pipeline_response):
-            deserialized = self._deserialize("RoutePoliciesListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
+        request = build_update_administrative_state_request(
+            resource_group_name=resource_group_name,
+            l2_isolation_domain_name=l2_isolation_domain_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._update_administrative_state_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
-        def get_next(next_link=None):
-            request = prepare_request(next_link)
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
 
-            _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
-            )
-            response = pipeline_response.http_response
+        response = pipeline_response.http_response
 
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-            return pipeline_response
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        return ItemPaged(get_next, extract_data)
+        if cls:
+            return cls(pipeline_response, None, response_headers)
 
-    list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies"
+    _update_administrative_state_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/updateAdministrativeState"
     }
 
-    @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.RoutePolicy"]:
-        """List RoutePolicies by subscription.
+    @overload
+    def begin_update_administrative_state(
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: _models.UpdateAdministrativeState,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        Implements RoutePolicies list by subscription GET method.
+        Enables isolation domain across the fabric or on specified racks.
 
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either RoutePolicy or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.RoutePolicy]
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.RoutePoliciesListResult] = kwargs.pop("cls", None)
 
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
+    @overload
+    def begin_update_administrative_state(
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        def prepare_request(next_link=None):
-            if not next_link:
+        Enables isolation domain across the fabric or on specified racks.
 
-                request = build_list_by_subscription_request(
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    template_url=self.list_by_subscription.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
 
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+    @distributed_trace
+    def begin_update_administrative_state(
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        def extract_data(pipeline_response):
-            deserialized = self._deserialize("RoutePoliciesListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
+        Enables isolation domain across the fabric or on specified racks.
 
-        def get_next(next_link=None):
-            request = prepare_request(next_link)
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-            _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = self._update_administrative_state_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                l2_isolation_domain_name=l2_isolation_domain_name,
+                body=body,
+                api_version=api_version,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
             )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+        kwargs.pop("error_map", None)
 
-            return pipeline_response
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
 
-        return ItemPaged(get_next, extract_data)
+        if polling is True:
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(PollingMethod, NoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return LROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/routePolicies"
+    begin_update_administrative_state.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/updateAdministrativeState"
     }
 
-    def _update_administrative_state_initial(
+    def _clear_arp_table_initial(  # pylint: disable=inconsistent-return-statements
         self,
         resource_group_name: str,
-        route_policy_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
+        l2_isolation_domain_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForDeviceUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "UpdateAdministrativeState")
+            _json = self._serialize.body(body, "EnableDisableOnResources")
 
-        request = build_update_administrative_state_request(
+        request = build_clear_arp_table_request(
             resource_group_name=resource_group_name,
-            route_policy_name=route_policy_name,
+            l2_isolation_domain_name=l2_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._update_administrative_state_initial.metadata["url"],
+            template_url=self._clear_arp_table_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _update_administrative_state_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/updateAdministrativeState"
+    _clear_arp_table_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/clearArpTable"
     }
 
     @overload
-    def begin_update_administrative_state(
+    def begin_clear_arp_table(
         self,
         resource_group_name: str,
-        route_policy_name: str,
-        body: _models.UpdateAdministrativeState,
+        l2_isolation_domain_name: str,
+        body: _models.EnableDisableOnResources,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """Executes enable operation to the underlying resources.
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        Updated the admin state for this Route Policy.
+        Clears ARP tables for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForDeviceUpdate
-         or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def begin_update_administrative_state(
+    def begin_clear_arp_table(
         self,
         resource_group_name: str,
-        route_policy_name: str,
+        l2_isolation_domain_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """Executes enable operation to the underlying resources.
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        Updated the admin state for this Route Policy.
+        Clears ARP tables for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForDeviceUpdate
-         or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
-    def begin_update_administrative_state(
+    def begin_clear_arp_table(
         self,
         resource_group_name: str,
-        route_policy_name: str,
-        body: Union[_models.UpdateAdministrativeState, IO],
+        l2_isolation_domain_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForDeviceUpdate]:
-        """Executes enable operation to the underlying resources.
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        Updated the admin state for this Route Policy.
+        Clears ARP tables for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
-        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
-         Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: Request payload. Is either a EnableDisableOnResources type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForDeviceUpdate
-         or the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForDeviceUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForDeviceUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._update_administrative_state_initial(
+            raw_result = self._clear_arp_table_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                route_policy_name=route_policy_name,
+                l2_isolation_domain_name=l2_isolation_domain_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForDeviceUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
@@ -1394,127 +1493,219 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_update_administrative_state.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/updateAdministrativeState"
+    begin_clear_arp_table.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/clearArpTable"
     }
 
-    def _validate_configuration_initial(
-        self, resource_group_name: str, route_policy_name: str, **kwargs: Any
-    ) -> _models.ValidateConfigurationResponse:
+    def _clear_neighbor_table_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "EnableDisableOnResources")
 
-        request = build_validate_configuration_request(
+        request = build_clear_neighbor_table_request(
             resource_group_name=resource_group_name,
-            route_policy_name=route_policy_name,
+            l2_isolation_domain_name=l2_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._validate_configuration_initial.metadata["url"],
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._clear_neighbor_table_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        if cls:
+            return cls(pipeline_response, None, response_headers)
 
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+    _clear_neighbor_table_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/clearNeighborTable"
+    }
 
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+    @overload
+    def begin_clear_neighbor_table(
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: _models.EnableDisableOnResources,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        return deserialized  # type: ignore
+        Clears IPv6 neighbors for this Isolation Domain.
 
-    _validate_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/validateConfiguration"
-    }
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    def begin_clear_neighbor_table(
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
+
+        Clears IPv6 neighbors for this Isolation Domain.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
 
     @distributed_trace
-    def begin_validate_configuration(
-        self, resource_group_name: str, route_policy_name: str, **kwargs: Any
-    ) -> LROPoller[_models.ValidateConfigurationResponse]:
-        """Validates the configuration of the resources.
+    def begin_clear_neighbor_table(
+        self,
+        resource_group_name: str,
+        l2_isolation_domain_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
+
+        Clears IPv6 neighbors for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
+        :param body: Request payload. Is either a EnableDisableOnResources type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._validate_configuration_initial(
+            raw_result = self._clear_neighbor_table_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                route_policy_name=route_policy_name,
+                l2_isolation_domain_name=l2_isolation_domain_name,
+                body=body,
                 api_version=api_version,
+                content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
@@ -1525,128 +1716,128 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_validate_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/validateConfiguration"
+    begin_clear_neighbor_table.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/clearNeighborTable"
     }
 
-    def _commit_configuration_initial(
-        self, resource_group_name: str, route_policy_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    def _get_arp_entries_initial(
+        self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any
+    ) -> Dict[str, _models.ARPProperties]:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[Dict[str, _models.ARPProperties]] = kwargs.pop("cls", None)
 
-        request = build_commit_configuration_request(
+        request = build_get_arp_entries_request(
             resource_group_name=resource_group_name,
-            route_policy_name=route_policy_name,
+            l2_isolation_domain_name=l2_isolation_domain_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._commit_configuration_initial.metadata["url"],
+            template_url=self._get_arp_entries_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        deserialized = self._deserialize("{ARPProperties}", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, response_headers)
 
-        return deserialized  # type: ignore
+        return deserialized
 
-    _commit_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/commitConfiguration"
+    _get_arp_entries_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/getArpEntries"
     }
 
     @distributed_trace
-    def begin_commit_configuration(
-        self, resource_group_name: str, route_policy_name: str, **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Execute the commit on the resources.
+    def begin_get_arp_entries(
+        self, resource_group_name: str, l2_isolation_domain_name: str, **kwargs: Any
+    ) -> LROPoller[Dict[str, _models.ARPProperties]]:
+        """Implements the operation to the underlying resources.
 
-        Commits the configuration of the given resources.
+        Clears IPv6 neighbors for this Isolation Domain.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param route_policy_name: Name of the Route Policy. Required.
-        :type route_policy_name: str
+        :param l2_isolation_domain_name: Name of the L2IsolationDomain. Required.
+        :type l2_isolation_domain_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either dict mapping str to ARPProperties or the
+         result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[dict[str,
+         ~azure.mgmt.managednetworkfabric.models.ARPProperties]]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[Dict[str, _models.ARPProperties]] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._commit_configuration_initial(
+            raw_result = self._get_arp_entries_initial(
                 resource_group_name=resource_group_name,
-                route_policy_name=route_policy_name,
+                l2_isolation_domain_name=l2_isolation_domain_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+            response_headers = {}
+            response = pipeline_response.http_response
+            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+            deserialized = self._deserialize("{ARPProperties}", pipeline_response)
             if cls:
-                return cls(pipeline_response, deserialized, {})
+                return cls(pipeline_response, deserialized, response_headers)
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
@@ -1658,10 +1849,184 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_commit_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/commitConfiguration"
+    begin_get_arp_entries.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/getArpEntries"
+    }
+
+    @distributed_trace
+    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.L2IsolationDomain"]:
+        """List L2IsolationDomains by resource group.
+
+        Displays L2IsolationDomains list by resource group GET method.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either L2IsolationDomain or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.L2IsolationDomainsListResult] = kwargs.pop("cls", None)
+
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        def prepare_request(next_link=None):
+            if not next_link:
+
+                request = build_list_by_resource_group_request(
+                    resource_group_name=resource_group_name,
+                    subscription_id=self._config.subscription_id,
+                    api_version=api_version,
+                    template_url=self.list_by_resource_group.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("L2IsolationDomainsListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, iter(list_of_elem)
+
+        def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+            return pipeline_response
+
+        return ItemPaged(get_next, extract_data)
+
+    list_by_resource_group.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains"
+    }
+
+    @distributed_trace
+    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.L2IsolationDomain"]:
+        """List L2IsolationDomains by subscription.
+
+        Displays L2IsolationDomains list by subscription GET method.
+
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: An iterator like instance of either L2IsolationDomain or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.L2IsolationDomain]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        cls: ClsType[_models.L2IsolationDomainsListResult] = kwargs.pop("cls", None)
+
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        def prepare_request(next_link=None):
+            if not next_link:
+
+                request = build_list_by_subscription_request(
+                    subscription_id=self._config.subscription_id,
+                    api_version=api_version,
+                    template_url=self.list_by_subscription.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("L2IsolationDomainsListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, iter(list_of_elem)
+
+        def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+            return pipeline_response
+
+        return ItemPaged(get_next, extract_data)
+
+    list_by_subscription.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_tap_rules_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_external_networks_operations.py`

 * *Files 25% similar despite different names*

```diff
@@ -36,34 +36,39 @@
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_request(
-    resource_group_name: str, network_tap_rule_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    external_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkTapRuleName": _SERIALIZER.url("network_tap_rule_name", network_tap_rule_name, "str"),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "externalNetworkName": _SERIALIZER.url("external_network_name", external_network_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -72,67 +77,77 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(
-    resource_group_name: str, network_tap_rule_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    external_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkTapRuleName": _SERIALIZER.url("network_tap_rule_name", network_tap_rule_name, "str"),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "externalNetworkName": _SERIALIZER.url("external_network_name", external_network_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_request(
-    resource_group_name: str, network_tap_rule_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    external_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkTapRuleName": _SERIALIZER.url("network_tap_rule_name", network_tap_rule_name, "str"),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "externalNetworkName": _SERIALIZER.url("external_network_name", external_network_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -141,123 +156,151 @@
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(
-    resource_group_name: str, network_tap_rule_name: str, subscription_id: str, **kwargs: Any
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    external_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkTapRuleName": _SERIALIZER.url("network_tap_rule_name", network_tap_rule_name, "str"),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "externalNetworkName": _SERIALIZER.url("external_network_name", external_network_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_list_request(
+    resource_group_name: str, l3_isolation_domain_name: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_update_administrative_state_request(
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    external_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
-        "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkTapRules"
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateAdministrativeState",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "externalNetworkName": _SERIALIZER.url("external_network_name", external_network_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_update_administrative_state_request(
-    resource_group_name: str, network_tap_rule_name: str, subscription_id: str, **kwargs: Any
+def build_update_bgp_administrative_state_request(
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    external_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/updateAdministrativeState",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateBgpAdministrativeState",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkTapRuleName": _SERIALIZER.url("network_tap_rule_name", network_tap_rule_name, "str"),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "externalNetworkName": _SERIALIZER.url("external_network_name", external_network_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -265,132 +308,191 @@
     if content_type is not None:
         _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_resync_request(
-    resource_group_name: str, network_tap_rule_name: str, subscription_id: str, **kwargs: Any
+def build_update_bfd_for_bgp_administrative_state_request(
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    external_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/resync",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateBfdForBgpAdministrativeState",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkTapRuleName": _SERIALIZER.url("network_tap_rule_name", network_tap_rule_name, "str"),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "externalNetworkName": _SERIALIZER.url("external_network_name", external_network_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_validate_configuration_request(
-    resource_group_name: str, network_tap_rule_name: str, subscription_id: str, **kwargs: Any
+def build_clear_ipv6_neighbors_request(
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    external_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/validateConfiguration",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/clearIpv6Neighbors",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "networkTapRuleName": _SERIALIZER.url("network_tap_rule_name", network_tap_rule_name, "str"),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "externalNetworkName": _SERIALIZER.url("external_network_name", external_network_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class NetworkTapRulesOperations:
+def build_clear_arp_entries_request(
+    resource_group_name: str,
+    l3_isolation_domain_name: str,
+    external_network_name: str,
+    subscription_id: str,
+    **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/clearArpEntries",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
+        "resourceGroupName": _SERIALIZER.url(
+            "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
+        ),
+        "l3IsolationDomainName": _SERIALIZER.url("l3_isolation_domain_name", l3_isolation_domain_name, "str"),
+        "externalNetworkName": _SERIALIZER.url("external_network_name", external_network_name, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class ExternalNetworksOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.managednetworkfabric.ManagedNetworkFabricMgmtClient`'s
-        :attr:`network_tap_rules` attribute.
+        :attr:`external_networks` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     def _create_initial(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
-        body: Union[_models.NetworkTapRule, IO],
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.ExternalNetwork, IO],
         **kwargs: Any
-    ) -> _models.NetworkTapRule:
+    ) -> _models.ExternalNetwork:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkTapRule] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ExternalNetwork] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkTapRule")
+            _json = self._serialize.body(body, "ExternalNetwork")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
-            network_tap_rule_name=network_tap_rule_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            external_network_name=external_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
@@ -407,170 +509,178 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkTapRule", pipeline_response)
+            deserialized = self._deserialize("ExternalNetwork", pipeline_response)
 
         if response.status_code == 201:
-            response_headers["Azure-AsyncOperation"] = self._deserialize(
-                "str", response.headers.get("Azure-AsyncOperation")
-            )
-
-            deserialized = self._deserialize("NetworkTapRule", pipeline_response)
+            deserialized = self._deserialize("ExternalNetwork", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
         return deserialized  # type: ignore
 
     _create_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}"
     }
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
-        body: _models.NetworkTapRule,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: _models.ExternalNetwork,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.NetworkTapRule]:
-        """Create Network Tap Rule.
+    ) -> LROPoller[_models.ExternalNetwork]:
+        """Creates ExternalNetwork for Layer3 Isolation Domain for communication of computes with external
+        services.
 
-        Create Network Tap Rule resource.
+        Creates ExternalNetwork PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
         :param body: Request payload. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkTapRule
+        :type body: ~azure.mgmt.managednetworkfabric.models.ExternalNetwork
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkTapRule or the result of
+        :return: An instance of LROPoller that returns either ExternalNetwork or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.ExternalNetwork]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_create(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.NetworkTapRule]:
-        """Create Network Tap Rule.
+    ) -> LROPoller[_models.ExternalNetwork]:
+        """Creates ExternalNetwork for Layer3 Isolation Domain for communication of computes with external
+        services.
 
-        Create Network Tap Rule resource.
+        Creates ExternalNetwork PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkTapRule or the result of
+        :return: An instance of LROPoller that returns either ExternalNetwork or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.ExternalNetwork]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_create(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
-        body: Union[_models.NetworkTapRule, IO],
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.ExternalNetwork, IO],
         **kwargs: Any
-    ) -> LROPoller[_models.NetworkTapRule]:
-        """Create Network Tap Rule.
+    ) -> LROPoller[_models.ExternalNetwork]:
+        """Creates ExternalNetwork for Layer3 Isolation Domain for communication of computes with external
+        services.
 
-        Create Network Tap Rule resource.
+        Creates ExternalNetwork PUT method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
-        :param body: Request payload. Is either a NetworkTapRule type or a IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkTapRule or IO
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Is either a ExternalNetwork type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.ExternalNetwork or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkTapRule or the result of
+        :return: An instance of LROPoller that returns either ExternalNetwork or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.ExternalNetwork]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkTapRule] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ExternalNetwork] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
                 resource_group_name=resource_group_name,
-                network_tap_rule_name=network_tap_rule_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                external_network_name=external_network_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkTapRule", pipeline_response)
+            deserialized = self._deserialize("ExternalNetwork", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
@@ -585,50 +695,55 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_create.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}"
     }
 
     @distributed_trace
-    def get(self, resource_group_name: str, network_tap_rule_name: str, **kwargs: Any) -> _models.NetworkTapRule:
-        """Gets a Network Tap Rule.
+    def get(
+        self, resource_group_name: str, l3_isolation_domain_name: str, external_network_name: str, **kwargs: Any
+    ) -> _models.ExternalNetwork:
+        """Retrieves details of ExternalNetwork.
 
-        Get Network Tap Rule resource details.
+        Implements ExternalNetworks GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: NetworkTapRule or the result of cls(response)
-        :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkTapRule
+        :return: ExternalNetwork or the result of cls(response)
+        :rtype: ~azure.mgmt.managednetworkfabric.models.ExternalNetwork
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkTapRule] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ExternalNetwork] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
-            network_tap_rule_name=network_tap_rule_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            external_network_name=external_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -642,58 +757,60 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("NetworkTapRule", pipeline_response)
+        deserialized = self._deserialize("ExternalNetwork", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}"
     }
 
     def _update_initial(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
-        body: Union[_models.NetworkTapRulePatch, IO],
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.ExternalNetworkPatch, IO],
         **kwargs: Any
-    ) -> Optional[_models.NetworkTapRule]:
+    ) -> _models.ExternalNetwork:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[Optional[_models.NetworkTapRule]] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ExternalNetwork] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
-            _json = self._serialize.body(body, "NetworkTapRulePatch")
+            _json = self._serialize.body(body, "ExternalNetworkPatch")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
-            network_tap_rule_name=network_tap_rule_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            external_network_name=external_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
@@ -710,175 +827,183 @@
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = None
-        response_headers = {}
         if response.status_code == 200:
-            deserialized = self._deserialize("NetworkTapRule", pipeline_response)
+            deserialized = self._deserialize("ExternalNetwork", pipeline_response)
 
         if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+            deserialized = self._deserialize("ExternalNetwork", pipeline_response)
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)
+            return cls(pipeline_response, deserialized, {})  # type: ignore
 
-        return deserialized
+        return deserialized  # type: ignore
 
     _update_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}"
     }
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
-        body: _models.NetworkTapRulePatch,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: _models.ExternalNetworkPatch,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.NetworkTapRule]:
-        """Updates a Network Tap Rule.
+    ) -> LROPoller[_models.ExternalNetwork]:
+        """Updates a ExternalNetworks.
 
-        Update certain properties of the Network Tap Rule resource.
+        API to update certain properties of the ExternalNetworks resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
-        :param body: Network Tap Rule properties to update. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkTapRulePatch
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: ExternalNetwork properties to update. Only annotations are supported. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.ExternalNetworkPatch
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkTapRule or the result of
+        :return: An instance of LROPoller that returns either ExternalNetwork or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.ExternalNetwork]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def begin_update(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.NetworkTapRule]:
-        """Updates a Network Tap Rule.
+    ) -> LROPoller[_models.ExternalNetwork]:
+        """Updates a ExternalNetworks.
 
-        Update certain properties of the Network Tap Rule resource.
+        API to update certain properties of the ExternalNetworks resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
-        :param body: Network Tap Rule properties to update. Required.
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: ExternalNetwork properties to update. Only annotations are supported. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkTapRule or the result of
+        :return: An instance of LROPoller that returns either ExternalNetwork or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.ExternalNetwork]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def begin_update(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
-        body: Union[_models.NetworkTapRulePatch, IO],
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.ExternalNetworkPatch, IO],
         **kwargs: Any
-    ) -> LROPoller[_models.NetworkTapRule]:
-        """Updates a Network Tap Rule.
+    ) -> LROPoller[_models.ExternalNetwork]:
+        """Updates a ExternalNetworks.
 
-        Update certain properties of the Network Tap Rule resource.
+        API to update certain properties of the ExternalNetworks resource.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
-        :param body: Network Tap Rule properties to update. Is either a NetworkTapRulePatch type or a
-         IO type. Required.
-        :type body: ~azure.mgmt.managednetworkfabric.models.NetworkTapRulePatch or IO
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: ExternalNetwork properties to update. Only annotations are supported. Is either a
+         ExternalNetworkPatch type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.ExternalNetworkPatch or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either NetworkTapRule or the result of
+        :return: An instance of LROPoller that returns either ExternalNetwork or the result of
          cls(response)
-        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+        :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.ExternalNetwork]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.NetworkTapRule] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ExternalNetwork] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(
                 resource_group_name=resource_group_name,
-                network_tap_rule_name=network_tap_rule_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                external_network_name=external_network_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
         def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("NetworkTapRule", pipeline_response)
+            deserialized = self._deserialize("ExternalNetwork", pipeline_response)
             if cls:
                 return cls(pipeline_response, deserialized, {})
             return deserialized
 
         if polling is True:
             polling_method: PollingMethod = cast(
-                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "azure-async-operation"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
         else:
             polling_method = polling
         if cont_token:
             return LROPoller.from_continuation_token(
@@ -886,19 +1011,19 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_update.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}"
     }
 
     def _delete_initial(  # pylint: disable=inconsistent-return-statements
-        self, resource_group_name: str, network_tap_rule_name: str, **kwargs: Any
+        self, resource_group_name: str, l3_isolation_domain_name: str, external_network_name: str, **kwargs: Any
     ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -908,15 +1033,16 @@
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
-            network_tap_rule_name=network_tap_rule_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            external_network_name=external_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
@@ -925,41 +1051,41 @@
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [202, 204]:
+        if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        response_headers = {}
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
         if cls:
-            return cls(pipeline_response, None, response_headers)
+            return cls(pipeline_response, None, {})
 
     _delete_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}"
     }
 
     @distributed_trace
-    def begin_delete(self, resource_group_name: str, network_tap_rule_name: str, **kwargs: Any) -> LROPoller[None]:
-        """Deletes a Network Tap Rule.
+    def begin_delete(
+        self, resource_group_name: str, l3_isolation_domain_name: str, external_network_name: str, **kwargs: Any
+    ) -> LROPoller[None]:
+        """Deletes a ExternalNetworks.
 
-        Delete Network Tap Rule resource.
+        Implements ExternalNetworks DELETE method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
@@ -975,15 +1101,16 @@
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_tap_rule_name=network_tap_rule_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                external_network_name=external_network_name,
                 api_version=api_version,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
@@ -1006,53 +1133,58 @@
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
     begin_delete.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}"
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}"
     }
 
     @distributed_trace
-    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.NetworkTapRule"]:
-        """List Network Tap Rules by resource group.
+    def list(
+        self, resource_group_name: str, l3_isolation_domain_name: str, **kwargs: Any
+    ) -> Iterable["_models.ExternalNetwork"]:
+        """Executes list operation to display External Networks within an isolation domain.
 
-        List all the Network Tap Rule resources in the given resource group.
+        Implements External Networks list by resource group GET method.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkTapRule or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+        :return: An iterator like instance of either ExternalNetwork or the result of cls(response)
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.ExternalNetwork]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkTapRulesListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.ExternalNetworksList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_by_resource_group_request(
+                request = build_list_request(
                     resource_group_name=resource_group_name,
+                    l3_isolation_domain_name=l3_isolation_domain_name,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
-                    template_url=self.list_by_resource_group.metadata["url"],
+                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
@@ -1070,15 +1202,15 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkTapRulesListResult", pipeline_response)
+            deserialized = self._deserialize("ExternalNetworksList", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
@@ -1094,321 +1226,704 @@
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list_by_resource_group.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules"
+    list.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks"
+    }
+
+    def _update_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> None:
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "UpdateAdministrativeState")
+
+        request = build_update_administrative_state_request(
+            resource_group_name=resource_group_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            external_network_name=external_network_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._update_administrative_state_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+
+        if cls:
+            return cls(pipeline_response, None, response_headers)
+
+    _update_administrative_state_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateAdministrativeState"
     }
 
+    @overload
+    def begin_update_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: _models.UpdateAdministrativeState,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
+
+        Executes update operation to enable or disable administrative State for externalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    def begin_update_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
+
+        Executes update operation to enable or disable administrative State for externalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
     @distributed_trace
-    def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.NetworkTapRule"]:
-        """List NetworkTapRules by subscription.
+    def begin_update_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        List all the Network Tap Rule resources in the given subscription.
+        Executes update operation to enable or disable administrative State for externalNetwork.
 
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either NetworkTapRule or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkTapRule]
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.NetworkTapRulesListResult] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = self._update_administrative_state_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                external_network_name=external_network_name,
+                body=body,
+                api_version=api_version,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
 
+        if polling is True:
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(PollingMethod, NoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return LROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_update_administrative_state.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateAdministrativeState"
+    }
+
+    def _update_bgp_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        def prepare_request(next_link=None):
-            if not next_link:
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-                request = build_list_by_subscription_request(
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    template_url=self.list_by_subscription.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "UpdateAdministrativeState")
 
-        def extract_data(pipeline_response):
-            deserialized = self._deserialize("NetworkTapRulesListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
+        request = build_update_bgp_administrative_state_request(
+            resource_group_name=resource_group_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            external_network_name=external_network_name,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._update_bgp_administrative_state_initial.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
-        def get_next(next_link=None):
-            request = prepare_request(next_link)
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
 
-            _stream = False
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=_stream, **kwargs
-            )
-            response = pipeline_response.http_response
+        response = pipeline_response.http_response
 
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+        if response.status_code not in [202]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-            return pipeline_response
+        response_headers = {}
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        return ItemPaged(get_next, extract_data)
+        if cls:
+            return cls(pipeline_response, None, response_headers)
 
-    list_by_subscription.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkTapRules"
+    _update_bgp_administrative_state_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateBgpAdministrativeState"
     }
 
-    def _update_administrative_state_initial(
+    @overload
+    def begin_update_bgp_administrative_state(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: _models.UpdateAdministrativeState,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Executes BGP state update operation to the underlying resources.
+
+        Update BGP for externalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    def begin_update_bgp_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Executes BGP state update operation to the underlying resources.
+
+        Update BGP for externalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @distributed_trace
+    def begin_update_bgp_administrative_state(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.UpdateAdministrativeState, IO],
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Executes BGP state update operation to the underlying resources.
+
+        Update BGP for externalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
+         Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
+        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
+        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
+        if cont_token is None:
+            raw_result = self._update_bgp_administrative_state_initial(  # type: ignore
+                resource_group_name=resource_group_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                external_network_name=external_network_name,
+                body=body,
+                api_version=api_version,
+                content_type=content_type,
+                cls=lambda x, y, z: x,
+                headers=_headers,
+                params=_params,
+                **kwargs
+            )
+        kwargs.pop("error_map", None)
+
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
+            if cls:
+                return cls(pipeline_response, None, {})
+
+        if polling is True:
+            polling_method: PollingMethod = cast(
+                PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
+            )
+        elif polling is False:
+            polling_method = cast(PollingMethod, NoPolling())
+        else:
+            polling_method = polling
+        if cont_token:
+            return LROPoller.from_continuation_token(
+                polling_method=polling_method,
+                continuation_token=cont_token,
+                client=self._client,
+                deserialization_callback=get_long_running_output,
+            )
+        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
+
+    begin_update_bgp_administrative_state.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateBgpAdministrativeState"
+    }
+
+    def _update_bfd_for_bgp_administrative_state_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
         if isinstance(body, (IOBase, bytes)):
             _content = body
         else:
             _json = self._serialize.body(body, "UpdateAdministrativeState")
 
-        request = build_update_administrative_state_request(
+        request = build_update_bfd_for_bgp_administrative_state_request(
             resource_group_name=resource_group_name,
-            network_tap_rule_name=network_tap_rule_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            external_network_name=external_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
-            template_url=self._update_administrative_state_initial.metadata["url"],
+            template_url=self._update_bfd_for_bgp_administrative_state_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
-
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
-
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
         if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
-
-        return deserialized  # type: ignore
+            return cls(pipeline_response, None, response_headers)
 
-    _update_administrative_state_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/updateAdministrativeState"
+    _update_bfd_for_bgp_administrative_state_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateBfdForBgpAdministrativeState"
     }
 
     @overload
-    def begin_update_administrative_state(
+    def begin_update_bfd_for_bgp_administrative_state(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
         body: _models.UpdateAdministrativeState,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Updates administrative state of  Network Tap Rules.
+    ) -> LROPoller[None]:
+        """Execute BfdForBgp update operation to the underlying resources.
 
-        Implements the operation to the underlying resources.
+        Update BfdForBgp for externalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
         :param body: Request payload. Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
-    def begin_update_administrative_state(
+    def begin_update_bfd_for_bgp_administrative_state(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
         body: IO,
         *,
         content_type: str = "application/json",
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Updates administrative state of  Network Tap Rules.
+    ) -> LROPoller[None]:
+        """Execute BfdForBgp update operation to the underlying resources.
 
-        Implements the operation to the underlying resources.
+        Update BfdForBgp for externalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
         :param body: Request payload. Required.
         :type body: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
-    def begin_update_administrative_state(
+    def begin_update_bfd_for_bgp_administrative_state(
         self,
         resource_group_name: str,
-        network_tap_rule_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
         body: Union[_models.UpdateAdministrativeState, IO],
         **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Updates administrative state of  Network Tap Rules.
+    ) -> LROPoller[None]:
+        """Execute BfdForBgp update operation to the underlying resources.
 
-        Implements the operation to the underlying resources.
+        Update BfdForBgp for externalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
         :param body: Request payload. Is either a UpdateAdministrativeState type or a IO type.
          Required.
         :type body: ~azure.mgmt.managednetworkfabric.models.UpdateAdministrativeState or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._update_administrative_state_initial(
+            raw_result = self._update_bfd_for_bgp_administrative_state_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_tap_rule_name=network_tap_rule_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                external_network_name=external_network_name,
                 body=body,
                 api_version=api_version,
                 content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
@@ -1419,129 +1934,231 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_update_administrative_state.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/updateAdministrativeState"
+    begin_update_bfd_for_bgp_administrative_state.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateBfdForBgpAdministrativeState"
     }
 
-    def _resync_initial(
-        self, resource_group_name: str, network_tap_rule_name: str, **kwargs: Any
-    ) -> _models.CommonPostActionResponseForStateUpdate:
+    def _clear_ipv6_neighbors_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
 
-        request = build_resync_request(
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "EnableDisableOnResources")
+
+        request = build_clear_ipv6_neighbors_request(
             resource_group_name=resource_group_name,
-            network_tap_rule_name=network_tap_rule_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            external_network_name=external_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._resync_initial.metadata["url"],
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._clear_ipv6_neighbors_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        if cls:
+            return cls(pipeline_response, None, response_headers)
 
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+    _clear_ipv6_neighbors_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/clearIpv6Neighbors"
+    }
 
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+    @overload
+    def begin_clear_ipv6_neighbors(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: _models.EnableDisableOnResources,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Executes clearIpv6Neighbors table operation to the underlying resources.
 
-        return deserialized  # type: ignore
+        clearIpv6Neighbors for externalNetwork.
 
-    _resync_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/resync"
-    }
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    def begin_clear_ipv6_neighbors(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Executes clearIpv6Neighbors table operation to the underlying resources.
+
+        clearIpv6Neighbors for externalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
 
     @distributed_trace
-    def begin_resync(
-        self, resource_group_name: str, network_tap_rule_name: str, **kwargs: Any
-    ) -> LROPoller[_models.CommonPostActionResponseForStateUpdate]:
-        """Resync the Network Tap Rule.
+    def begin_clear_ipv6_neighbors(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Executes clearIpv6Neighbors table operation to the underlying resources.
 
-        Implements the operation to the underlying resources.
+        clearIpv6Neighbors for externalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Is either a EnableDisableOnResources type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either CommonPostActionResponseForStateUpdate or
-         the result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.CommonPostActionResponseForStateUpdate]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.CommonPostActionResponseForStateUpdate] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._resync_initial(
+            raw_result = self._clear_ipv6_neighbors_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_tap_rule_name=network_tap_rule_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                external_network_name=external_network_name,
+                body=body,
                 api_version=api_version,
+                content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("CommonPostActionResponseForStateUpdate", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
@@ -1552,129 +2169,231 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_resync.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/resync"
+    begin_clear_ipv6_neighbors.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/clearIpv6Neighbors"
     }
 
-    def _validate_configuration_initial(
-        self, resource_group_name: str, network_tap_rule_name: str, **kwargs: Any
-    ) -> _models.ValidateConfigurationResponse:
+    def _clear_arp_entries_initial(  # pylint: disable=inconsistent-return-statements
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> None:
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(body, (IOBase, bytes)):
+            _content = body
+        else:
+            _json = self._serialize.body(body, "EnableDisableOnResources")
 
-        request = build_validate_configuration_request(
+        request = build_clear_arp_entries_request(
             resource_group_name=resource_group_name,
-            network_tap_rule_name=network_tap_rule_name,
+            l3_isolation_domain_name=l3_isolation_domain_name,
+            external_network_name=external_network_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            template_url=self._validate_configuration_initial.metadata["url"],
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self._clear_arp_entries_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
         _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
             request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [200, 202]:
+        if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
         response_headers = {}
-        if response.status_code == 200:
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
 
-        if response.status_code == 202:
-            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))
+        if cls:
+            return cls(pipeline_response, None, response_headers)
 
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+    _clear_arp_entries_initial.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/clearArpEntries"
+    }
 
-        if cls:
-            return cls(pipeline_response, deserialized, response_headers)  # type: ignore
+    @overload
+    def begin_clear_arp_entries(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: _models.EnableDisableOnResources,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        return deserialized  # type: ignore
+        clearArpEntries for externalNetwork.
 
-    _validate_configuration_initial.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/validateConfiguration"
-    }
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    def begin_clear_arp_entries(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
+
+        clearArpEntries for externalNetwork.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Required.
+        :type body: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
+        :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
+         operation to not poll, or pass in your own initialized polling object for a personal polling
+         strategy.
+        :paramtype polling: bool or ~azure.core.polling.PollingMethod
+        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
+         Retry-After header is present.
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
 
     @distributed_trace
-    def begin_validate_configuration(
-        self, resource_group_name: str, network_tap_rule_name: str, **kwargs: Any
-    ) -> LROPoller[_models.ValidateConfigurationResponse]:
-        """Validates the configuration of the Network Tap Rule.
+    def begin_clear_arp_entries(
+        self,
+        resource_group_name: str,
+        l3_isolation_domain_name: str,
+        external_network_name: str,
+        body: Union[_models.EnableDisableOnResources, IO],
+        **kwargs: Any
+    ) -> LROPoller[None]:
+        """Implements the operation to the underlying resources.
 
-        Implements the operation to the underlying resources.
+        clearArpEntries for externalNetwork.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
-        :param network_tap_rule_name: Name of the Network Tap Rule. Required.
-        :type network_tap_rule_name: str
+        :param l3_isolation_domain_name: Name of the L3IsolationDomain. Required.
+        :type l3_isolation_domain_name: str
+        :param external_network_name: Name of the ExternalNetwork. Required.
+        :type external_network_name: str
+        :param body: Request payload. Is either a EnableDisableOnResources type or a IO type. Required.
+        :type body: ~azure.mgmt.managednetworkfabric.models.EnableDisableOnResources or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
          operation to not poll, or pass in your own initialized polling object for a personal polling
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
-        :return: An instance of LROPoller that returns either ValidateConfigurationResponse or the
-         result of cls(response)
-        :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.managednetworkfabric.models.ValidateConfigurationResponse]
+        :return: An instance of LROPoller that returns either None or the result of cls(response)
+        :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
         api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
-        cls: ClsType[_models.ValidateConfigurationResponse] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
-            raw_result = self._validate_configuration_initial(
+            raw_result = self._clear_arp_entries_initial(  # type: ignore
                 resource_group_name=resource_group_name,
-                network_tap_rule_name=network_tap_rule_name,
+                l3_isolation_domain_name=l3_isolation_domain_name,
+                external_network_name=external_network_name,
+                body=body,
                 api_version=api_version,
+                content_type=content_type,
                 cls=lambda x, y, z: x,
                 headers=_headers,
                 params=_params,
                 **kwargs
             )
         kwargs.pop("error_map", None)
 
-        def get_long_running_output(pipeline_response):
-            deserialized = self._deserialize("ValidateConfigurationResponse", pipeline_response)
+        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
             if cls:
-                return cls(pipeline_response, deserialized, {})
-            return deserialized
+                return cls(pipeline_response, None, {})
 
         if polling is True:
             polling_method: PollingMethod = cast(
                 PollingMethod, ARMPolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
             )
         elif polling is False:
             polling_method = cast(PollingMethod, NoPolling())
@@ -1685,10 +2404,10 @@
                 polling_method=polling_method,
                 continuation_token=cont_token,
                 client=self._client,
                 deserialization_callback=get_long_running_output,
             )
         return LROPoller(self._client, raw_result, get_long_running_output, polling_method)  # type: ignore
 
-    begin_validate_configuration.metadata = {
-        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/validateConfiguration"
+    begin_clear_arp_entries.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/clearArpEntries"
     }
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_fabric_skus_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_fabric_skus_operations.py`

 * *Files 1% similar despite different names*

```diff
@@ -36,24 +36,24 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(network_fabric_sku_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabricSkus/{networkFabricSkuName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "networkFabricSkuName": _SERIALIZER.url("network_fabric_sku_name", network_fabric_sku_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -64,23 +64,23 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabricSkus"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -109,17 +109,17 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def get(self, network_fabric_sku_name: str, **kwargs: Any) -> _models.NetworkFabricSku:
         """Gets a Network Fabric Sku.
 
-        Implements Network Fabric SKU GET method.
+        Implements Network Fabric Sku GET method.
 
-        :param network_fabric_sku_name: Name of the Network Fabric SKU. Required.
+        :param network_fabric_sku_name: Name of the Network Fabric Sku. Required.
         :type network_fabric_sku_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: NetworkFabricSku or the result of cls(response)
         :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkFabricSku
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
@@ -168,17 +168,17 @@
 
     get.metadata = {
         "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabricSkus/{networkFabricSkuName}"
     }
 
     @distributed_trace
     def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.NetworkFabricSku"]:
-        """List Network Fabric SKUs by subscription.
+        """List NetworkFabricSkus by subscription.
 
-        Implements Network Fabric SKUs list by subscription GET method.
+        Implements NetworkFabricSkus list by subscription GET method.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either NetworkFabricSku or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkFabricSku]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_patch.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_operations.py`

 * *Files 1% similar despite different names*

```diff
@@ -36,15 +36,15 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.ManagedNetworkFabric/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure/mgmt/managednetworkfabric/operations/_network_device_skus_operations.py` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure/mgmt/managednetworkfabric/operations/_network_device_skus_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -36,24 +36,24 @@
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(network_device_sku_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkDeviceSkus/{networkDeviceSkuName}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
         "networkDeviceSkuName": _SERIALIZER.url("network_device_sku_name", network_device_sku_name, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -64,23 +64,23 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-06-15"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-02-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkDeviceSkus"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -109,17 +109,17 @@
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
 
     @distributed_trace
     def get(self, network_device_sku_name: str, **kwargs: Any) -> _models.NetworkDeviceSku:
         """Gets a Network Device Sku.
 
-        Get a Network Device SKU details.
+        Get Network Device SKU details.
 
-        :param network_device_sku_name: Name of the Network Device SKU. Required.
+        :param network_device_sku_name: Name of the Network Device Sku. Required.
         :type network_device_sku_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: NetworkDeviceSku or the result of cls(response)
         :rtype: ~azure.mgmt.managednetworkfabric.models.NetworkDeviceSku
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
@@ -168,15 +168,15 @@
 
     get.metadata = {
         "url": "/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkDeviceSkus/{networkDeviceSkuName}"
     }
 
     @distributed_trace
     def list_by_subscription(self, **kwargs: Any) -> Iterable["_models.NetworkDeviceSku"]:
-        """List Network Device SKUs by subscription.
+        """List NetworkDeviceSkus by subscription.
 
         List Network Device SKUs for the given subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either NetworkDeviceSku or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.managednetworkfabric.models.NetworkDeviceSku]
         :raises ~azure.core.exceptions.HttpResponseError:
```

## Comparing `azure-mgmt-managednetworkfabric-1.0.0/azure_mgmt_managednetworkfabric.egg-info/SOURCES.txt` & `azure-mgmt-managednetworkfabric-1.0.0b1/azure_mgmt_managednetworkfabric.egg-info/SOURCES.txt`

 * *Files 8% similar despite different names*

```diff
@@ -18,62 +18,52 @@
 azure/mgmt/managednetworkfabric/aio/_configuration.py
 azure/mgmt/managednetworkfabric/aio/_managed_network_fabric_mgmt_client.py
 azure/mgmt/managednetworkfabric/aio/_patch.py
 azure/mgmt/managednetworkfabric/aio/operations/__init__.py
 azure/mgmt/managednetworkfabric/aio/operations/_access_control_lists_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_external_networks_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_internal_networks_operations.py
-azure/mgmt/managednetworkfabric/aio/operations/_internet_gateway_rules_operations.py
-azure/mgmt/managednetworkfabric/aio/operations/_internet_gateways_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_ip_communities_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_ip_extended_communities_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_ip_prefixes_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_l2_isolation_domains_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_l3_isolation_domains_operations.py
-azure/mgmt/managednetworkfabric/aio/operations/_neighbor_groups_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_network_device_skus_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_network_devices_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_network_fabric_controllers_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_network_fabric_skus_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_network_fabrics_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_network_interfaces_operations.py
-azure/mgmt/managednetworkfabric/aio/operations/_network_packet_brokers_operations.py
+azure/mgmt/managednetworkfabric/aio/operations/_network_rack_skus_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_network_racks_operations.py
-azure/mgmt/managednetworkfabric/aio/operations/_network_tap_rules_operations.py
-azure/mgmt/managednetworkfabric/aio/operations/_network_taps_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_network_to_network_interconnects_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_operations.py
 azure/mgmt/managednetworkfabric/aio/operations/_patch.py
 azure/mgmt/managednetworkfabric/aio/operations/_route_policies_operations.py
 azure/mgmt/managednetworkfabric/models/__init__.py
 azure/mgmt/managednetworkfabric/models/_managed_network_fabric_mgmt_client_enums.py
 azure/mgmt/managednetworkfabric/models/_models_py3.py
 azure/mgmt/managednetworkfabric/models/_patch.py
 azure/mgmt/managednetworkfabric/operations/__init__.py
 azure/mgmt/managednetworkfabric/operations/_access_control_lists_operations.py
 azure/mgmt/managednetworkfabric/operations/_external_networks_operations.py
 azure/mgmt/managednetworkfabric/operations/_internal_networks_operations.py
-azure/mgmt/managednetworkfabric/operations/_internet_gateway_rules_operations.py
-azure/mgmt/managednetworkfabric/operations/_internet_gateways_operations.py
 azure/mgmt/managednetworkfabric/operations/_ip_communities_operations.py
 azure/mgmt/managednetworkfabric/operations/_ip_extended_communities_operations.py
 azure/mgmt/managednetworkfabric/operations/_ip_prefixes_operations.py
 azure/mgmt/managednetworkfabric/operations/_l2_isolation_domains_operations.py
 azure/mgmt/managednetworkfabric/operations/_l3_isolation_domains_operations.py
-azure/mgmt/managednetworkfabric/operations/_neighbor_groups_operations.py
 azure/mgmt/managednetworkfabric/operations/_network_device_skus_operations.py
 azure/mgmt/managednetworkfabric/operations/_network_devices_operations.py
 azure/mgmt/managednetworkfabric/operations/_network_fabric_controllers_operations.py
 azure/mgmt/managednetworkfabric/operations/_network_fabric_skus_operations.py
 azure/mgmt/managednetworkfabric/operations/_network_fabrics_operations.py
 azure/mgmt/managednetworkfabric/operations/_network_interfaces_operations.py
-azure/mgmt/managednetworkfabric/operations/_network_packet_brokers_operations.py
+azure/mgmt/managednetworkfabric/operations/_network_rack_skus_operations.py
 azure/mgmt/managednetworkfabric/operations/_network_racks_operations.py
-azure/mgmt/managednetworkfabric/operations/_network_tap_rules_operations.py
-azure/mgmt/managednetworkfabric/operations/_network_taps_operations.py
 azure/mgmt/managednetworkfabric/operations/_network_to_network_interconnects_operations.py
 azure/mgmt/managednetworkfabric/operations/_operations.py
 azure/mgmt/managednetworkfabric/operations/_patch.py
 azure/mgmt/managednetworkfabric/operations/_route_policies_operations.py
 azure_mgmt_managednetworkfabric.egg-info/PKG-INFO
 azure_mgmt_managednetworkfabric.egg-info/SOURCES.txt
 azure_mgmt_managednetworkfabric.egg-info/dependency_links.txt
```

