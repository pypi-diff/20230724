# Comparing `tmp/azure-mgmt-hdinsight-9.0.0b1.zip` & `tmp/azure-mgmt-hdinsight-9.0.0b2.zip`

## zipinfo {}

```diff
@@ -1,69 +1,69 @@
-Zip file size: 160625 bytes, number of entries: 67
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/azure_mgmt_hdinsight.egg-info/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/azure/
--rw-rw-r--  2.0 unx     1074 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/LICENSE
--rw-rw-r--  2.0 unx     2837 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/setup.py
--rw-rw-r--  2.0 unx       38 b- defN 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/setup.cfg
--rw-rw-r--  2.0 unx      626 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/_meta.json
--rw-rw-r--  2.0 unx      215 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/MANIFEST.in
--rw-rw-r--  2.0 unx    10506 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/CHANGELOG.md
--rw-rw-r--  2.0 unx     1425 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/README.md
--rw-rw-r--  2.0 unx    12837 b- defN 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/PKG-INFO
--rw-rw-r--  2.0 unx        1 b- defN 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/azure_mgmt_hdinsight.egg-info/not-zip-safe
--rw-rw-r--  2.0 unx        1 b- defN 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/azure_mgmt_hdinsight.egg-info/dependency_links.txt
--rw-rw-r--  2.0 unx     2609 b- defN 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/azure_mgmt_hdinsight.egg-info/SOURCES.txt
--rw-rw-r--  2.0 unx      116 b- defN 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/azure_mgmt_hdinsight.egg-info/requires.txt
--rw-rw-r--  2.0 unx        6 b- defN 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/azure_mgmt_hdinsight.egg-info/top_level.txt
--rw-rw-r--  2.0 unx    12837 b- defN 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/azure_mgmt_hdinsight.egg-info/PKG-INFO
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/
--rw-rw-r--  2.0 unx       65 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/
--rw-rw-r--  2.0 unx       65 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/models/
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/
--rw-rw-r--  2.0 unx       26 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/py.typed
--rw-rw-r--  2.0 unx     3865 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_configuration.py
--rw-rw-r--  2.0 unx     1169 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_vendor.py
--rw-rw-r--  2.0 unx    77872 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_serialization.py
--rw-rw-r--  2.0 unx      916 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/__init__.py
--rw-rw-r--  2.0 unx      488 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_version.py
--rw-rw-r--  2.0 unx     7318 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_hd_insight_management_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_patch.py
--rw-rw-r--  2.0 unx    12426 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_script_execution_history_operations.py
--rw-rw-r--  2.0 unx    11058 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_private_link_resources_operations.py
--rw-rw-r--  2.0 unx    22369 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_virtual_machines_operations.py
--rw-rw-r--  2.0 unx     6741 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_operations.py
--rw-rw-r--  2.0 unx     1766 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/__init__.py
--rw-rw-r--  2.0 unx    31669 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_locations_operations.py
--rw-rw-r--  2.0 unx    77051 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_extensions_operations.py
--rw-rw-r--  2.0 unx    23568 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_configurations_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_patch.py
--rw-rw-r--  2.0 unx    37222 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_applications_operations.py
--rw-rw-r--  2.0 unx   124321 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_clusters_operations.py
--rw-rw-r--  2.0 unx    34231 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_private_endpoint_connections_operations.py
--rw-rw-r--  2.0 unx    21376 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_script_actions_operations.py
--rw-rw-r--  2.0 unx   198624 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/models/_models_py3.py
--rw-rw-r--  2.0 unx     4460 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/models/_hd_insight_management_client_enums.py
--rw-rw-r--  2.0 unx    10409 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/models/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 22-Nov-21 05:54 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/
--rw-rw-r--  2.0 unx     3913 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/_configuration.py
--rw-rw-r--  2.0 unx      863 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/__init__.py
--rw-rw-r--  2.0 unx     7494 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/_hd_insight_management_client.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/_patch.py
--rw-rw-r--  2.0 unx     9697 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_script_execution_history_operations.py
--rw-rw-r--  2.0 unx     8186 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_private_link_resources_operations.py
--rw-rw-r--  2.0 unx    18192 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_virtual_machines_operations.py
--rw-rw-r--  2.0 unx     6022 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_operations.py
--rw-rw-r--  2.0 unx     1766 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/__init__.py
--rw-rw-r--  2.0 unx    24256 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_locations_operations.py
--rw-rw-r--  2.0 unx    63140 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_extensions_operations.py
--rw-rw-r--  2.0 unx    19220 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_configurations_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    30050 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_applications_operations.py
--rw-rw-r--  2.0 unx   105380 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_clusters_operations.py
--rw-rw-r--  2.0 unx    28346 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_private_endpoint_connections_operations.py
--rw-rw-r--  2.0 unx    15784 b- defN 22-Nov-21 05:52 azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_script_actions_operations.py
-67 files, 1099882 bytes uncompressed, 146105 bytes compressed:  86.7%
+Zip file size: 160733 bytes, number of entries: 67
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/azure/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/azure_mgmt_hdinsight.egg-info/
+-rw-rw-r--  2.0 unx     1074 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/LICENSE
+-rw-rw-r--  2.0 unx    13897 b- defN 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/PKG-INFO
+-rw-rw-r--  2.0 unx      626 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/_meta.json
+-rw-rw-r--  2.0 unx      215 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/MANIFEST.in
+-rw-rw-r--  2.0 unx       38 b- defN 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/setup.cfg
+-rw-rw-r--  2.0 unx    10846 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/CHANGELOG.md
+-rw-rw-r--  2.0 unx     2158 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/README.md
+-rw-rw-r--  2.0 unx     2844 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/setup.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/
+-rw-rw-r--  2.0 unx       26 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/py.typed
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_patch.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_vendor.py
+-rw-rw-r--  2.0 unx      488 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_version.py
+-rw-rw-r--  2.0 unx      916 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/__init__.py
+-rw-rw-r--  2.0 unx    78836 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_serialization.py
+-rw-rw-r--  2.0 unx     3632 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_configuration.py
+-rw-rw-r--  2.0 unx     7350 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_hd_insight_management_client.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/models/_patch.py
+-rw-rw-r--  2.0 unx    10409 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/models/__init__.py
+-rw-rw-r--  2.0 unx   200964 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/models/_models_py3.py
+-rw-rw-r--  2.0 unx     4460 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/models/_hd_insight_management_client_enums.py
+-rw-rw-r--  2.0 unx    31411 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_locations_operations.py
+-rw-rw-r--  2.0 unx    36828 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_applications_operations.py
+-rw-rw-r--  2.0 unx    23267 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_configurations_operations.py
+-rw-rw-r--  2.0 unx    76412 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_extensions_operations.py
+-rw-rw-r--  2.0 unx    33875 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_private_endpoint_connections_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_patch.py
+-rw-rw-r--  2.0 unx     1766 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/__init__.py
+-rw-rw-r--  2.0 unx    22054 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_virtual_machines_operations.py
+-rw-rw-r--  2.0 unx     6491 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_operations.py
+-rw-rw-r--  2.0 unx    12152 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_script_execution_history_operations.py
+-rw-rw-r--  2.0 unx    10780 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_private_link_resources_operations.py
+-rw-rw-r--  2.0 unx   123739 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_clusters_operations.py
+-rw-rw-r--  2.0 unx    21054 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_script_actions_operations.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/_patch.py
+-rw-rw-r--  2.0 unx      863 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/__init__.py
+-rw-rw-r--  2.0 unx     3680 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/_configuration.py
+-rw-rw-r--  2.0 unx     7531 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/_hd_insight_management_client.py
+-rw-rw-r--  2.0 unx    24058 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_locations_operations.py
+-rw-rw-r--  2.0 unx    29706 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_applications_operations.py
+-rw-rw-r--  2.0 unx    18949 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_configurations_operations.py
+-rw-rw-r--  2.0 unx    62601 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_extensions_operations.py
+-rw-rw-r--  2.0 unx    28030 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_private_endpoint_connections_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx     1766 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    17907 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_virtual_machines_operations.py
+-rw-rw-r--  2.0 unx     5782 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_operations.py
+-rw-rw-r--  2.0 unx     9443 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_script_execution_history_operations.py
+-rw-rw-r--  2.0 unx     7928 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_private_link_resources_operations.py
+-rw-rw-r--  2.0 unx   104938 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_clusters_operations.py
+-rw-rw-r--  2.0 unx    15502 b- defN 23-Jul-24 07:33 azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_script_actions_operations.py
+-rw-rw-r--  2.0 unx    13897 b- defN 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/azure_mgmt_hdinsight.egg-info/PKG-INFO
+-rw-rw-r--  2.0 unx        1 b- defN 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/azure_mgmt_hdinsight.egg-info/not-zip-safe
+-rw-rw-r--  2.0 unx      124 b- defN 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/azure_mgmt_hdinsight.egg-info/requires.txt
+-rw-rw-r--  2.0 unx     2609 b- defN 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/azure_mgmt_hdinsight.egg-info/SOURCES.txt
+-rw-rw-r--  2.0 unx        6 b- defN 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/azure_mgmt_hdinsight.egg-info/top_level.txt
+-rw-rw-r--  2.0 unx        1 b- defN 23-Jul-24 07:34 azure-mgmt-hdinsight-9.0.0b2/azure_mgmt_hdinsight.egg-info/dependency_links.txt
+67 files, 1098732 bytes uncompressed, 146213 bytes compressed:  86.7%
```

## zipnote {}

```diff
@@ -1,202 +1,202 @@
-Filename: azure-mgmt-hdinsight-9.0.0b1/
+Filename: azure-mgmt-hdinsight-9.0.0b2/
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure_mgmt_hdinsight.egg-info/
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure_mgmt_hdinsight.egg-info/
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/LICENSE
+Filename: azure-mgmt-hdinsight-9.0.0b2/LICENSE
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/setup.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/setup.cfg
+Filename: azure-mgmt-hdinsight-9.0.0b2/_meta.json
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/_meta.json
+Filename: azure-mgmt-hdinsight-9.0.0b2/MANIFEST.in
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/MANIFEST.in
+Filename: azure-mgmt-hdinsight-9.0.0b2/setup.cfg
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/CHANGELOG.md
+Filename: azure-mgmt-hdinsight-9.0.0b2/CHANGELOG.md
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/README.md
+Filename: azure-mgmt-hdinsight-9.0.0b2/README.md
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/PKG-INFO
+Filename: azure-mgmt-hdinsight-9.0.0b2/setup.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure_mgmt_hdinsight.egg-info/not-zip-safe
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure_mgmt_hdinsight.egg-info/dependency_links.txt
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/__init__.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure_mgmt_hdinsight.egg-info/SOURCES.txt
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure_mgmt_hdinsight.egg-info/requires.txt
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/__init__.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure_mgmt_hdinsight.egg-info/top_level.txt
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/models/
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure_mgmt_hdinsight.egg-info/PKG-INFO
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/__init__.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/py.typed
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_patch.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/__init__.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_version.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/models/
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/__init__.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_serialization.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/py.typed
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_configuration.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_hd_insight_management_client.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_vendor.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_serialization.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/__init__.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_version.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/models/_hd_insight_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_hd_insight_management_client.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_locations_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_patch.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_applications_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_script_execution_history_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_configurations_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_private_link_resources_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_extensions_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_virtual_machines_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_private_endpoint_connections_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/__init__.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_locations_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_virtual_machines_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_extensions_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_configurations_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_script_execution_history_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_patch.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_private_link_resources_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_applications_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_clusters_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_clusters_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_script_actions_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_private_endpoint_connections_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_script_actions_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/models/_models_py3.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/models/_hd_insight_management_client_enums.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/models/__init__.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/_hd_insight_management_client.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/models/_patch.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_locations_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_applications_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/_configuration.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_configurations_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/__init__.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_extensions_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/_hd_insight_management_client.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_private_endpoint_connections_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/_patch.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_script_execution_history_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_private_link_resources_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_virtual_machines_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_virtual_machines_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_script_execution_history_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/__init__.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_private_link_resources_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_locations_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_clusters_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_extensions_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_script_actions_operations.py
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_configurations_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure_mgmt_hdinsight.egg-info/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_patch.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure_mgmt_hdinsight.egg-info/not-zip-safe
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_applications_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure_mgmt_hdinsight.egg-info/requires.txt
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_clusters_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure_mgmt_hdinsight.egg-info/SOURCES.txt
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_private_endpoint_connections_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure_mgmt_hdinsight.egg-info/top_level.txt
 Comment: 
 
-Filename: azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_script_actions_operations.py
+Filename: azure-mgmt-hdinsight-9.0.0b2/azure_mgmt_hdinsight.egg-info/dependency_links.txt
 Comment: 
 
 Zip file comment:
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/LICENSE` & `azure-mgmt-hdinsight-9.0.0b2/LICENSE`

 * *Files identical despite different names*

## Comparing `azure-mgmt-hdinsight-9.0.0b1/setup.py` & `azure-mgmt-hdinsight-9.0.0b2/setup.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,79 +1,83 @@
 #!/usr/bin/env python
 
-#-------------------------------------------------------------------------
+# -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
-#--------------------------------------------------------------------------
+# --------------------------------------------------------------------------
 
 import re
 import os.path
 from io import open
 from setuptools import find_packages, setup
 
 # Change the PACKAGE_NAME only to change folder and different name
 PACKAGE_NAME = "azure-mgmt-hdinsight"
 PACKAGE_PPRINT_NAME = "HDInsight Management"
 
 # a-b-c => a/b/c
-package_folder_path = PACKAGE_NAME.replace('-', '/')
+package_folder_path = PACKAGE_NAME.replace("-", "/")
 # a-b-c => a.b.c
-namespace_name = PACKAGE_NAME.replace('-', '.')
+namespace_name = PACKAGE_NAME.replace("-", ".")
 
 # Version extraction inspired from 'requests'
-with open(os.path.join(package_folder_path, 'version.py')
-          if os.path.exists(os.path.join(package_folder_path, 'version.py'))
-          else os.path.join(package_folder_path, '_version.py'), 'r') as fd:
-    version = re.search(r'^VERSION\s*=\s*[\'"]([^\'"]*)[\'"]',
-                        fd.read(), re.MULTILINE).group(1)
+with open(
+    os.path.join(package_folder_path, "version.py")
+    if os.path.exists(os.path.join(package_folder_path, "version.py"))
+    else os.path.join(package_folder_path, "_version.py"),
+    "r",
+) as fd:
+    version = re.search(r'^VERSION\s*=\s*[\'"]([^\'"]*)[\'"]', fd.read(), re.MULTILINE).group(1)
 
 if not version:
-    raise RuntimeError('Cannot find version information')
+    raise RuntimeError("Cannot find version information")
 
-with open('README.md', encoding='utf-8') as f:
+with open("README.md", encoding="utf-8") as f:
     readme = f.read()
-with open('CHANGELOG.md', encoding='utf-8') as f:
+with open("CHANGELOG.md", encoding="utf-8") as f:
     changelog = f.read()
 
 setup(
     name=PACKAGE_NAME,
     version=version,
-    description='Microsoft Azure {} Client Library for Python'.format(PACKAGE_PPRINT_NAME),
-    long_description=readme + '\n\n' + changelog,
-    long_description_content_type='text/markdown',
-    license='MIT License',
-    author='Microsoft Corporation',
-    author_email='azpysdkhelp@microsoft.com',
-    url='https://github.com/Azure/azure-sdk-for-python',
+    description="Microsoft Azure {} Client Library for Python".format(PACKAGE_PPRINT_NAME),
+    long_description=readme + "\n\n" + changelog,
+    long_description_content_type="text/markdown",
+    license="MIT License",
+    author="Microsoft Corporation",
+    author_email="azpysdkhelp@microsoft.com",
+    url="https://github.com/Azure/azure-sdk-for-python",
     keywords="azure, azure sdk",  # update with search keywords relevant to the azure service / product
     classifiers=[
-        'Development Status :: 5 - Production/Stable',
-        'Programming Language :: Python',
-        'Programming Language :: Python :: 3 :: Only',
-        'Programming Language :: Python :: 3',
-        'Programming Language :: Python :: 3.7',
-        'Programming Language :: Python :: 3.8',
-        'Programming Language :: Python :: 3.9',
-        'Programming Language :: Python :: 3.10',
-        'Programming Language :: Python :: 3.11',
-        'License :: OSI Approved :: MIT License',
+        "Development Status :: 4 - Beta",
+        "Programming Language :: Python",
+        "Programming Language :: Python :: 3 :: Only",
+        "Programming Language :: Python :: 3",
+        "Programming Language :: Python :: 3.7",
+        "Programming Language :: Python :: 3.8",
+        "Programming Language :: Python :: 3.9",
+        "Programming Language :: Python :: 3.10",
+        "Programming Language :: Python :: 3.11",
+        "License :: OSI Approved :: MIT License",
     ],
     zip_safe=False,
-    packages=find_packages(exclude=[
-        'tests',
-        # Exclude packages that will be covered by PEP420 or nspkg
-        'azure',
-        'azure.mgmt',
-    ]),
+    packages=find_packages(
+        exclude=[
+            "tests",
+            # Exclude packages that will be covered by PEP420 or nspkg
+            "azure",
+            "azure.mgmt",
+        ]
+    ),
     include_package_data=True,
     package_data={
-        'pytyped': ['py.typed'],
+        "pytyped": ["py.typed"],
     },
     install_requires=[
-        "msrest>=0.7.1",
+        "isodate<1.0.0,>=0.6.1",
         "azure-common~=1.1",
         "azure-mgmt-core>=1.3.2,<2.0.0",
         "typing-extensions>=4.3.0; python_version<'3.8.0'",
     ],
-    python_requires=">=3.7"
+    python_requires=">=3.7",
 )
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/_meta.json` & `azure-mgmt-hdinsight-9.0.0b2/_meta.json`

 * *Files 25% similar despite different names*

### Pretty-printed

 * *Similarity: 0.7777777777777777%*

 * *Differences: {"'autorest_command'": "'autorest specification/hdinsight/resource-manager/readme.md "*

 * *                       '--generate-sample=True --include-x-ms-examples-original-file=True --python '*

 * *                       '--python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk '*

 * *                       '--use=@autorest/python@6.6.0 --use=@autorest/modelerfour@4.24.3 '*

 * *                       "--version=3.9.2 --version-tolerant=False'",*

 * * "'commit'": "'237afa17929313c909f72f2fea59f4437e305c99'",*

 * * "'use'": "{inser […]*

```diff
@@ -1,11 +1,11 @@
 {
     "autorest": "3.9.2",
-    "autorest_command": "autorest specification/hdinsight/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.2.7 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
-    "commit": "3ce1e043e2d0e57016437a3870f40e33da8a6397",
+    "autorest_command": "autorest specification/hdinsight/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.6.0 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
+    "commit": "237afa17929313c909f72f2fea59f4437e305c99",
     "readme": "specification/hdinsight/resource-manager/readme.md",
     "repository_url": "https://github.com/Azure/azure-rest-api-specs",
     "use": [
-        "@autorest/python@6.2.7",
+        "@autorest/python@6.6.0",
         "@autorest/modelerfour@4.24.3"
     ]
 }
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/CHANGELOG.md` & `azure-mgmt-hdinsight-9.0.0b2/CHANGELOG.md`

 * *Files 1% similar despite different names*

```diff
@@ -1,9 +1,16 @@
 # Release History
 
+## 9.0.0b2 (2023-07-21)
+
+### Features Added
+
+  - Model StorageAccount has a new parameter enable_secure_channel
+  - Added feature to support selecting use secure channel during creation. The paramter would force to true if the cluster created based on a stroage account that secure transfer enabled, no matter it use 'blob' or 'dfs' type.
+
 ## 9.0.0b1 (2022-11-18)
 
 ### Other Changes
 
   - Added generated samples in github repo
   - Drop support for python<3.7.0
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/PKG-INFO` & `azure-mgmt-hdinsight-9.0.0b2/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-hdinsight
-Version: 9.0.0b1
+Version: 9.0.0b2
 Summary: Microsoft Azure HDInsight Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
-Classifier: Development Status :: 5 - Production/Stable
+Classifier: Development Status :: 4 - Beta
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
@@ -27,36 +27,79 @@
 This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
 
-# Usage
+## Getting started
 
+### Prerequisites
 
-To learn how to use this package, see the [quickstart guide](https://aka.ms/azsdk/python/mgmt)
- 
-For docs and references, see [Python SDK References](https://docs.microsoft.com/python/api/overview/azure/hdinsight)
-Code samples for this package can be found at [HDInsight Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com.
-Additional code samples for different Azure services are available at [Samples Repo](https://github.com/Azure-Samples/azure-samples-python-management/tree/main/samples/hdinsight)
+- Python 3.7+ is required to use this package.
+- [Azure subscription](https://azure.microsoft.com/free/)
 
+### Install the package
 
-# Provide Feedback
+```bash
+pip install azure-mgmt-hdinsight
+pip install azure-identity
+```
+
+### Authentication
+
+By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
+
+- `AZURE_CLIENT_ID` for Azure client ID.
+- `AZURE_TENANT_ID` for Azure tenant ID.
+- `AZURE_CLIENT_SECRET` for Azure client secret.
+
+In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
+
+With above configuration, client can be authenticated by following code:
+
+```python
+from azure.identity import DefaultAzureCredential
+from azure.mgmt.hdinsight import HDInsightManagementClient
+import os
+
+sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
+client = HDInsightManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
+```
+
+## Examples
+
+Code samples for this package can be found at:
+- [Search HDInsight Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+
+
+## Troubleshooting
+
+## Next steps
+
+## Provide Feedback
 
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-hdinsight%2FREADME.png)
 
 
 # Release History
 
+## 9.0.0b2 (2023-07-21)
+
+### Features Added
+
+  - Model StorageAccount has a new parameter enable_secure_channel
+  - Added feature to support selecting use secure channel during creation. The paramter would force to true if the cluster created based on a stroage account that secure transfer enabled, no matter it use 'blob' or 'dfs' type.
+
 ## 9.0.0b1 (2022-11-18)
 
 ### Other Changes
 
   - Added generated samples in github repo
   - Drop support for python<3.7.0
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure_mgmt_hdinsight.egg-info/SOURCES.txt` & `azure-mgmt-hdinsight-9.0.0b2/azure_mgmt_hdinsight.egg-info/SOURCES.txt`

 * *Files identical despite different names*

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure_mgmt_hdinsight.egg-info/PKG-INFO` & `azure-mgmt-hdinsight-9.0.0b2/azure_mgmt_hdinsight.egg-info/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-hdinsight
-Version: 9.0.0b1
+Version: 9.0.0b2
 Summary: Microsoft Azure HDInsight Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
-Classifier: Development Status :: 5 - Production/Stable
+Classifier: Development Status :: 4 - Beta
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
@@ -27,36 +27,79 @@
 This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
 
 _Azure SDK Python packages support for Python 2.7 has ended 01 January 2022. For more information and questions, please refer to https://github.com/Azure/azure-sdk-for-python/issues/20691_
 
-# Usage
+## Getting started
 
+### Prerequisites
 
-To learn how to use this package, see the [quickstart guide](https://aka.ms/azsdk/python/mgmt)
- 
-For docs and references, see [Python SDK References](https://docs.microsoft.com/python/api/overview/azure/hdinsight)
-Code samples for this package can be found at [HDInsight Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com.
-Additional code samples for different Azure services are available at [Samples Repo](https://github.com/Azure-Samples/azure-samples-python-management/tree/main/samples/hdinsight)
+- Python 3.7+ is required to use this package.
+- [Azure subscription](https://azure.microsoft.com/free/)
 
+### Install the package
 
-# Provide Feedback
+```bash
+pip install azure-mgmt-hdinsight
+pip install azure-identity
+```
+
+### Authentication
+
+By default, [Azure Active Directory](https://aka.ms/awps/aad) token authentication depends on correct configure of following environment variables.
+
+- `AZURE_CLIENT_ID` for Azure client ID.
+- `AZURE_TENANT_ID` for Azure tenant ID.
+- `AZURE_CLIENT_SECRET` for Azure client secret.
+
+In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
+
+With above configuration, client can be authenticated by following code:
+
+```python
+from azure.identity import DefaultAzureCredential
+from azure.mgmt.hdinsight import HDInsightManagementClient
+import os
+
+sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
+client = HDInsightManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
+```
+
+## Examples
+
+Code samples for this package can be found at:
+- [Search HDInsight Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+
+
+## Troubleshooting
+
+## Next steps
+
+## Provide Feedback
 
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-hdinsight%2FREADME.png)
 
 
 # Release History
 
+## 9.0.0b2 (2023-07-21)
+
+### Features Added
+
+  - Model StorageAccount has a new parameter enable_secure_channel
+  - Added feature to support selecting use secure channel during creation. The paramter would force to true if the cluster created based on a stroage account that secure transfer enabled, no matter it use 'blob' or 'dfs' type.
+
 ## 9.0.0b1 (2022-11-18)
 
 ### Other Changes
 
   - Added generated samples in github repo
   - Drop support for python<3.7.0
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_configuration.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/_configuration.py`

 * *Files 22% similar despite different names*

```diff
@@ -2,52 +2,46 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
+from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
-from ._version import VERSION
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from .._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
 class HDInsightManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for HDInsightManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The subscription credentials which uniquely identify Microsoft Azure
      subscription. The subscription ID forms part of the URI for every service call. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2021-06-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2023-04-15-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(HDInsightManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", "2021-06-01")
+        api_version: str = kwargs.pop("api_version", "2023-04-15-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -59,15 +53,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = ARMChallengeAuthenticationPolicy(
+            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_vendor.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_vendor.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,16 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
+from typing import List, cast
+
 from azure.core.pipeline.transport import HttpRequest
 
 
 def _convert_request(request, files=None):
     data = request.content if not files else None
     request = HttpRequest(method=request.method, url=request.url, headers=request.headers, data=data)
     if files:
@@ -18,10 +20,11 @@
 
 def _format_url_section(template, **kwargs):
     components = template.split("/")
     while components:
         try:
             return template.format(**kwargs)
         except KeyError as key:
-            formatted_components = template.split("/")
+            # Need the cast, as for some reasons "split" is typed as list[str | Any]
+            formatted_components = cast(List[str], template.split("/"))
             components = [c for c in formatted_components if "{}".format(key.args[0]) not in c]
             template = "/".join(components)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_serialization.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_serialization.py`

 * *Files 2% similar despite different names*

```diff
@@ -34,30 +34,47 @@
 import email
 from enum import Enum
 import json
 import logging
 import re
 import sys
 import codecs
-from typing import Optional, Union, AnyStr, IO, Mapping
+from typing import (
+    Dict,
+    Any,
+    cast,
+    Optional,
+    Union,
+    AnyStr,
+    IO,
+    Mapping,
+    Callable,
+    TypeVar,
+    MutableMapping,
+    Type,
+    List,
+    Mapping,
+)
 
 try:
     from urllib import quote  # type: ignore
 except ImportError:
     from urllib.parse import quote
 import xml.etree.ElementTree as ET
 
 import isodate  # type: ignore
 
-from typing import Dict, Any, cast
-
 from azure.core.exceptions import DeserializationError, SerializationError, raise_with_traceback
+from azure.core.serialization import NULL as AzureCoreNull
 
 _BOM = codecs.BOM_UTF8.decode(encoding="utf-8")
 
+ModelType = TypeVar("ModelType", bound="Model")
+JSON = MutableMapping[str, Any]
+
 
 class RawDeserializer:
 
     # Accept "text" because we're open minded people...
     JSON_REGEXP = re.compile(r"^(application|text)/([a-z+.]+\+)?json$")
 
     # Name used in context
@@ -273,43 +290,43 @@
     serialization and deserialization.
     """
 
     _subtype_map: Dict[str, Dict[str, Any]] = {}
     _attribute_map: Dict[str, Dict[str, Any]] = {}
     _validation: Dict[str, Dict[str, Any]] = {}
 
-    def __init__(self, **kwargs):
-        self.additional_properties = {}
+    def __init__(self, **kwargs: Any) -> None:
+        self.additional_properties: Dict[str, Any] = {}
         for k in kwargs:
             if k not in self._attribute_map:
                 _LOGGER.warning("%s is not a known attribute of class %s and will be ignored", k, self.__class__)
             elif k in self._validation and self._validation[k].get("readonly", False):
                 _LOGGER.warning("Readonly attribute %s will be ignored in class %s", k, self.__class__)
             else:
                 setattr(self, k, kwargs[k])
 
-    def __eq__(self, other):
+    def __eq__(self, other: Any) -> bool:
         """Compare objects by comparing all attributes."""
         if isinstance(other, self.__class__):
             return self.__dict__ == other.__dict__
         return False
 
-    def __ne__(self, other):
+    def __ne__(self, other: Any) -> bool:
         """Compare objects by comparing all attributes."""
         return not self.__eq__(other)
 
-    def __str__(self):
+    def __str__(self) -> str:
         return str(self.__dict__)
 
     @classmethod
-    def enable_additional_properties_sending(cls):
+    def enable_additional_properties_sending(cls) -> None:
         cls._attribute_map["additional_properties"] = {"key": "", "type": "{object}"}
 
     @classmethod
-    def is_xml_model(cls):
+    def is_xml_model(cls) -> bool:
         try:
             cls._xml_map  # type: ignore
         except AttributeError:
             return False
         return True
 
     @classmethod
@@ -318,30 +335,35 @@
         try:
             xml_map = cls._xml_map  # type: ignore
         except AttributeError:
             xml_map = {}
 
         return _create_xml_node(xml_map.get("name", cls.__name__), xml_map.get("prefix", None), xml_map.get("ns", None))
 
-    def serialize(self, keep_readonly=False, **kwargs):
+    def serialize(self, keep_readonly: bool = False, **kwargs: Any) -> JSON:
         """Return the JSON that would be sent to azure from this model.
 
         This is an alias to `as_dict(full_restapi_key_transformer, keep_readonly=False)`.
 
         If you want XML serialization, you can pass the kwargs is_xml=True.
 
         :param bool keep_readonly: If you want to serialize the readonly attributes
         :returns: A dict JSON compatible object
         :rtype: dict
         """
         serializer = Serializer(self._infer_class_models())
         return serializer._serialize(self, keep_readonly=keep_readonly, **kwargs)
 
-    def as_dict(self, keep_readonly=True, key_transformer=attribute_transformer, **kwargs):
-        """Return a dict that can be JSONify using json.dump.
+    def as_dict(
+        self,
+        keep_readonly: bool = True,
+        key_transformer: Callable[[str, Dict[str, Any], Any], Any] = attribute_transformer,
+        **kwargs: Any
+    ) -> JSON:
+        """Return a dict that can be serialized using json.dump.
 
         Advanced usage might optionally use a callback as parameter:
 
         .. code::python
 
             def my_key_transformer(key, attr_desc, value):
                 return key
@@ -380,41 +402,46 @@
                 raise ValueError("Not Autorest generated code")
         except Exception:
             # Assume it's not Autorest generated (tests?). Add ourselves as dependencies.
             client_models = {cls.__name__: cls}
         return client_models
 
     @classmethod
-    def deserialize(cls, data, content_type=None):
+    def deserialize(cls: Type[ModelType], data: Any, content_type: Optional[str] = None) -> ModelType:
         """Parse a str using the RestAPI syntax and return a model.
 
         :param str data: A str using RestAPI structure. JSON by default.
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
         return deserializer(cls.__name__, data, content_type=content_type)
 
     @classmethod
-    def from_dict(cls, data, key_extractors=None, content_type=None):
+    def from_dict(
+        cls: Type[ModelType],
+        data: Any,
+        key_extractors: Optional[Callable[[str, Dict[str, Any], Any], Any]] = None,
+        content_type: Optional[str] = None,
+    ) -> ModelType:
         """Parse a dict using given key extractor return a model.
 
         By default consider key
         extractors (rest_key_case_insensitive_extractor, attribute_key_case_insensitive_extractor
         and last_rest_key_case_insensitive_extractor)
 
         :param dict data: A dict using RestAPI structure
         :param str content_type: JSON by default, set application/xml if XML.
         :returns: An instance of this model
         :raises: DeserializationError if something went wrong
         """
         deserializer = Deserializer(cls._infer_class_models())
-        deserializer.key_extractors = (
-            [
+        deserializer.key_extractors = (  # type: ignore
+            [  # type: ignore
                 attribute_key_case_insensitive_extractor,
                 rest_key_case_insensitive_extractor,
                 last_rest_key_case_insensitive_extractor,
             ]
             if key_extractors is None
             else key_extractors
         )
@@ -514,15 +541,15 @@
         "min_items": lambda x, y: len(x) < y,
         "max_items": lambda x, y: len(x) > y,
         "pattern": lambda x, y: not re.match(y, x, re.UNICODE),
         "unique": lambda x, y: len(x) != len(set(x)),
         "multiple": lambda x, y: x % y != 0,
     }
 
-    def __init__(self, classes=None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
         self.serialize_type = {
             "iso-8601": Serializer.serialize_iso,
             "rfc-1123": Serializer.serialize_rfc,
             "unix-time": Serializer.serialize_unix,
             "duration": Serializer.serialize_duration,
             "date": Serializer.serialize_date,
             "time": Serializer.serialize_time,
@@ -530,15 +557,15 @@
             "long": Serializer.serialize_long,
             "bytearray": Serializer.serialize_bytearray,
             "base64": Serializer.serialize_base64,
             "object": self.serialize_object,
             "[]": self.serialize_iter,
             "{}": self.serialize_dict,
         }
-        self.dependencies = dict(classes) if classes else {}
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
         self.key_transformer = full_restapi_key_transformer
         self.client_side_validation = True
 
     def _serialize(self, target_obj, data_type=None, **kwargs):
         """Serialize data into a string according to type.
 
         :param target_obj: The data to be serialized.
@@ -598,15 +625,15 @@
                         xml_desc = attr_desc.get("xml", {})
                         xml_name = xml_desc.get("name", attr_desc["key"])
                         xml_prefix = xml_desc.get("prefix", None)
                         xml_ns = xml_desc.get("ns", None)
                         if xml_desc.get("attr", False):
                             if xml_ns:
                                 ET.register_namespace(xml_prefix, xml_ns)
-                                xml_name = "{}{}".format(xml_ns, xml_name)
+                                xml_name = "{{{}}}{}".format(xml_ns, xml_name)
                             serialized.set(xml_name, new_attr)  # type: ignore
                             continue
                         if xml_desc.get("text", False):
                             serialized.text = new_attr  # type: ignore
                             continue
                         if isinstance(new_attr, list):
                             serialized.extend(new_attr)  # type: ignore
@@ -622,16 +649,15 @@
                         else:  # That's a basic type
                             # Integrate namespace if necessary
                             local_node = _create_xml_node(xml_name, xml_prefix, xml_ns)
                             local_node.text = unicode_str(new_attr)
                             serialized.append(local_node)  # type: ignore
                     else:  # JSON
                         for k in reversed(keys):  # type: ignore
-                            unflattened = {k: new_attr}
-                            new_attr = unflattened
+                            new_attr = {k: new_attr}
 
                         _new_attr = new_attr
                         _serialized = serialized
                         for k in keys:  # type: ignore
                             if k not in _serialized:
                                 _serialized.update(_new_attr)  # type: ignore
                             _new_attr = _new_attr[k]  # type: ignore
@@ -652,16 +678,16 @@
         :param str data_type: The type to be serialized from.
         :rtype: dict
         :raises: SerializationError if serialization fails.
         :raises: ValueError if data is None
         """
 
         # Just in case this is a dict
-        internal_data_type = data_type.strip("[]{}")
-        internal_data_type = self.dependencies.get(internal_data_type, None)
+        internal_data_type_str = data_type.strip("[]{}")
+        internal_data_type = self.dependencies.get(internal_data_type_str, None)
         try:
             is_xml_model_serialization = kwargs["is_xml"]
         except KeyError:
             if internal_data_type and issubclass(internal_data_type, Model):
                 is_xml_model_serialization = kwargs.setdefault("is_xml", internal_data_type.is_xml_model())
             else:
                 is_xml_model_serialization = False
@@ -773,14 +799,16 @@
         :raises: ValueError if data is None
         :raises: SerializationError if serialization fails.
         """
         if data is None:
             raise ValueError("No value for given attribute")
 
         try:
+            if data is AzureCoreNull:
+                return None
             if data_type in self.basic_types.values():
                 return self.serialize_basic(data, data_type, **kwargs)
 
             elif data_type in self.serialize_type:
                 return self.serialize_type[data_type](data, **kwargs)
 
             # If dependencies is empty, try with current data class
@@ -1157,15 +1185,16 @@
 
 
 def rest_key_extractor(attr, attr_desc, data):
     key = attr_desc["key"]
     working_data = data
 
     while "." in key:
-        dict_keys = _FLATTEN.split(key)
+        # Need the cast, as for some reasons "split" is typed as list[str | Any]
+        dict_keys = cast(List[str], _FLATTEN.split(key))
         if len(dict_keys) == 1:
             key = _decode_attribute_map_key(dict_keys[0])
             break
         working_key = _decode_attribute_map_key(dict_keys[0])
         working_data = working_data.get(working_key, data)
         if working_data is None:
             # If at any point while following flatten JSON path see None, it means
@@ -1238,15 +1267,15 @@
     :rtype: tuple
     :returns: A tuple XML name + namespace dict
     """
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
     xml_name = internal_type_xml_map.get("name", internal_type.__name__)
     xml_ns = internal_type_xml_map.get("ns", None)
     if xml_ns:
-        xml_name = "{}{}".format(xml_ns, xml_name)
+        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
     return xml_name
 
 
 def xml_key_extractor(attr, attr_desc, data):
     if isinstance(data, dict):
         return None
 
@@ -1262,15 +1291,15 @@
     is_wrapped = xml_desc.get("wrapped", False)
     internal_type = attr_desc.get("internalType", None)
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
 
     # Integrate namespace if necessary
     xml_ns = xml_desc.get("ns", internal_type_xml_map.get("ns", None))
     if xml_ns:
-        xml_name = "{}{}".format(xml_ns, xml_name)
+        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
 
     # If it's an attribute, that's simple
     if xml_desc.get("attr", False):
         return data.get(xml_name)
 
     # If it's x-ms-text, that's simple too
     if xml_desc.get("text", False):
@@ -1328,15 +1357,15 @@
     :ivar list key_extractors: Ordered list of extractors to be used by this deserializer.
     """
 
     basic_types = {str: "str", int: "int", bool: "bool", float: "float"}
 
     valid_date = re.compile(r"\d{4}[-]\d{2}[-]\d{2}T\d{2}:\d{2}:\d{2}" r"\.?\d*Z?[-+]?[\d{2}]?:?[\d{2}]?")
 
-    def __init__(self, classes=None):
+    def __init__(self, classes: Optional[Mapping[str, Type[ModelType]]] = None):
         self.deserialize_type = {
             "iso-8601": Deserializer.deserialize_iso,
             "rfc-1123": Deserializer.deserialize_rfc,
             "unix-time": Deserializer.deserialize_unix,
             "duration": Deserializer.deserialize_duration,
             "date": Deserializer.deserialize_date,
             "time": Deserializer.deserialize_time,
@@ -1348,15 +1377,15 @@
             "[]": self.deserialize_iter,
             "{}": self.deserialize_dict,
         }
         self.deserialize_expected_types = {
             "duration": (isodate.Duration, datetime.timedelta),
             "iso-8601": (datetime.datetime),
         }
-        self.dependencies = dict(classes) if classes else {}
+        self.dependencies: Dict[str, Type[ModelType]] = dict(classes) if classes else {}
         self.key_extractors = [rest_key_extractor, xml_key_extractor]
         # Additional properties only works if the "rest_key_extractor" is used to
         # extract the keys. Making it to work whatever the key extractor is too much
         # complicated, with no real scenario for now.
         # So adding a flag to disable additional properties detection. This flag should be
         # used if your expect the deserialization to NOT come from a JSON REST syntax.
         # Otherwise, result are unexpected
@@ -1467,40 +1496,40 @@
 
     def _classify_target(self, target, data):
         """Check to see whether the deserialization target object can
         be classified into a subclass.
         Once classification has been determined, initialize object.
 
         :param str target: The target object type to deserialize to.
-        :param str/dict data: The response data to deseralize.
+        :param str/dict data: The response data to deserialize.
         """
         if target is None:
             return None, None
 
         if isinstance(target, basestring):
             try:
                 target = self.dependencies[target]
             except KeyError:
                 return target, target
 
         try:
             target = target._classify(data, self.dependencies)
         except AttributeError:
             pass  # Target is not a Model, no classify
-        return target, target.__class__.__name__
+        return target, target.__class__.__name__  # type: ignore
 
     def failsafe_deserialize(self, target_obj, data, content_type=None):
         """Ignores any errors encountered in deserialization,
         and falls back to not deserializing the object. Recommended
         for use in error deserialization, as we want to return the
         HttpResponseError to users, and not have them deal with
         a deserialization error.
 
         :param str target_obj: The target object type to deserialize to.
-        :param str/dict data: The response data to deseralize.
+        :param str/dict data: The response data to deserialize.
         :param str content_type: Swagger "produces" if available.
         """
         try:
             return self(target_obj, data, content_type=content_type)
         except:
             _LOGGER.debug(
                 "Ran into a deserialization error. Ignoring since this is failsafe deserialization", exc_info=True
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/__init__.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_hd_insight_management_client.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_hd_insight_management_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -33,47 +33,47 @@
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class HDInsightManagementClient:  # pylint: disable=client-accepts-api-version-keyword,too-many-instance-attributes
     """HDInsight Management Client.
 
-    :ivar clusters: ClustersOperations operations
-    :vartype clusters: azure.mgmt.hdinsight.operations.ClustersOperations
     :ivar applications: ApplicationsOperations operations
     :vartype applications: azure.mgmt.hdinsight.operations.ApplicationsOperations
-    :ivar locations: LocationsOperations operations
-    :vartype locations: azure.mgmt.hdinsight.operations.LocationsOperations
+    :ivar clusters: ClustersOperations operations
+    :vartype clusters: azure.mgmt.hdinsight.operations.ClustersOperations
     :ivar configurations: ConfigurationsOperations operations
     :vartype configurations: azure.mgmt.hdinsight.operations.ConfigurationsOperations
     :ivar extensions: ExtensionsOperations operations
     :vartype extensions: azure.mgmt.hdinsight.operations.ExtensionsOperations
-    :ivar script_actions: ScriptActionsOperations operations
-    :vartype script_actions: azure.mgmt.hdinsight.operations.ScriptActionsOperations
-    :ivar script_execution_history: ScriptExecutionHistoryOperations operations
-    :vartype script_execution_history:
-     azure.mgmt.hdinsight.operations.ScriptExecutionHistoryOperations
+    :ivar locations: LocationsOperations operations
+    :vartype locations: azure.mgmt.hdinsight.operations.LocationsOperations
     :ivar operations: Operations operations
     :vartype operations: azure.mgmt.hdinsight.operations.Operations
-    :ivar virtual_machines: VirtualMachinesOperations operations
-    :vartype virtual_machines: azure.mgmt.hdinsight.operations.VirtualMachinesOperations
     :ivar private_endpoint_connections: PrivateEndpointConnectionsOperations operations
     :vartype private_endpoint_connections:
      azure.mgmt.hdinsight.operations.PrivateEndpointConnectionsOperations
     :ivar private_link_resources: PrivateLinkResourcesOperations operations
     :vartype private_link_resources: azure.mgmt.hdinsight.operations.PrivateLinkResourcesOperations
+    :ivar script_actions: ScriptActionsOperations operations
+    :vartype script_actions: azure.mgmt.hdinsight.operations.ScriptActionsOperations
+    :ivar script_execution_history: ScriptExecutionHistoryOperations operations
+    :vartype script_execution_history:
+     azure.mgmt.hdinsight.operations.ScriptExecutionHistoryOperations
+    :ivar virtual_machines: VirtualMachinesOperations operations
+    :vartype virtual_machines: azure.mgmt.hdinsight.operations.VirtualMachinesOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The subscription credentials which uniquely identify Microsoft Azure
      subscription. The subscription ID forms part of the URI for every service call. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2021-06-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2023-04-15-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
         self,
@@ -81,37 +81,37 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = HDInsightManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
-        self.clusters = ClustersOperations(self._client, self._config, self._serialize, self._deserialize)
         self.applications = ApplicationsOperations(self._client, self._config, self._serialize, self._deserialize)
-        self.locations = LocationsOperations(self._client, self._config, self._serialize, self._deserialize)
+        self.clusters = ClustersOperations(self._client, self._config, self._serialize, self._deserialize)
         self.configurations = ConfigurationsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.extensions = ExtensionsOperations(self._client, self._config, self._serialize, self._deserialize)
-        self.script_actions = ScriptActionsOperations(self._client, self._config, self._serialize, self._deserialize)
-        self.script_execution_history = ScriptExecutionHistoryOperations(
+        self.locations = LocationsOperations(self._client, self._config, self._serialize, self._deserialize)
+        self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
+        self.private_endpoint_connections = PrivateEndpointConnectionsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
-        self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
-        self.virtual_machines = VirtualMachinesOperations(
+        self.private_link_resources = PrivateLinkResourcesOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
-        self.private_endpoint_connections = PrivateEndpointConnectionsOperations(
+        self.script_actions = ScriptActionsOperations(self._client, self._config, self._serialize, self._deserialize)
+        self.script_execution_history = ScriptExecutionHistoryOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
-        self.private_link_resources = PrivateLinkResourcesOperations(
+        self.virtual_machines = VirtualMachinesOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
@@ -136,9 +136,9 @@
     def close(self) -> None:
         self._client.close()
 
     def __enter__(self) -> "HDInsightManagementClient":
         self._client.__enter__()
         return self
 
-    def __exit__(self, *exc_details) -> None:
+    def __exit__(self, *exc_details: Any) -> None:
         self._client.__exit__(*exc_details)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/_patch.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_script_execution_history_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_script_execution_history_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,28 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_by_cluster_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/scriptExecutionHistory",
     )  # pylint: disable=line-too-long
@@ -74,15 +69,15 @@
 
 def build_promote_request(
     resource_group_name: str, cluster_name: str, script_execution_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/scriptExecutionHistory/{scriptExecutionId}/promote",
     )  # pylint: disable=line-too-long
@@ -138,17 +133,15 @@
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.hdinsight.models.RuntimeScriptActionDetail]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ScriptActionExecutionHistoryList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -194,16 +187,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -240,17 +234,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_promote_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             script_execution_id=script_execution_id,
             subscription_id=self._config.subscription_id,
@@ -258,16 +250,17 @@
             template_url=self.promote.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_private_link_resources_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_private_link_resources_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,32 +23,28 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_by_cluster_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/privateLinkResources",
     )  # pylint: disable=line-too-long
@@ -72,15 +67,15 @@
 
 def build_get_request(
     resource_group_name: str, cluster_name: str, private_link_resource_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/privateLinkResources/{privateLinkResourceName}",
     )  # pylint: disable=line-too-long
@@ -143,33 +138,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateLinkResourceListResult] = kwargs.pop("cls", None)
 
         request = build_list_by_cluster_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.list_by_cluster.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -210,17 +204,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateLinkResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             private_link_resource_name=private_link_resource_name,
             subscription_id=self._config.subscription_id,
@@ -228,16 +220,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_virtual_machines_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_virtual_machines_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,32 +26,28 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_hosts_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/listHosts",
     )  # pylint: disable=line-too-long
@@ -74,15 +70,15 @@
 
 def build_restart_hosts_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/restartHosts",
@@ -108,15 +104,15 @@
 
 def build_get_async_operation_status_request(
     resource_group_name: str, cluster_name: str, operation_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/restartHosts/azureasyncoperations/{operationId}",
     )  # pylint: disable=line-too-long
@@ -177,33 +173,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[List[_models.HostInfo]] = kwargs.pop("cls", None)
 
         request = build_list_hosts_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.list_hosts.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -230,24 +225,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(hosts, (IO, bytes)):
+        if isinstance(hosts, (IOBase, bytes)):
             _content = hosts
         else:
             _json = self._serialize.body(hosts, "[str]")
 
         request = build_restart_hosts_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -259,16 +252,17 @@
             template_url=self._restart_hosts_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -355,15 +349,15 @@
     ) -> LROPoller[None]:
         """Restarts the specified HDInsight cluster hosts.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
-        :param hosts: The list of hosts to restart. Is either a list type or a IO type. Required.
+        :param hosts: The list of hosts to restart. Is either a [str] type or a IO type. Required.
         :type hosts: list[str] or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -375,17 +369,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._restart_hosts_initial(  # type: ignore
@@ -450,17 +442,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AsyncOperationResult] = kwargs.pop("cls", None)
 
         request = build_get_async_operation_status_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
@@ -468,16 +458,17 @@
             template_url=self.get_async_operation_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.HDInsight/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -87,17 +82,15 @@
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.hdinsight.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -140,16 +133,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/__init__.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/__init__.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -2,38 +2,38 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-from ._clusters_operations import ClustersOperations
 from ._applications_operations import ApplicationsOperations
-from ._locations_operations import LocationsOperations
+from ._clusters_operations import ClustersOperations
 from ._configurations_operations import ConfigurationsOperations
 from ._extensions_operations import ExtensionsOperations
-from ._script_actions_operations import ScriptActionsOperations
-from ._script_execution_history_operations import ScriptExecutionHistoryOperations
+from ._locations_operations import LocationsOperations
 from ._operations import Operations
-from ._virtual_machines_operations import VirtualMachinesOperations
 from ._private_endpoint_connections_operations import PrivateEndpointConnectionsOperations
 from ._private_link_resources_operations import PrivateLinkResourcesOperations
+from ._script_actions_operations import ScriptActionsOperations
+from ._script_execution_history_operations import ScriptExecutionHistoryOperations
+from ._virtual_machines_operations import VirtualMachinesOperations
 
 from ._patch import __all__ as _patch_all
 from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
-    "ClustersOperations",
     "ApplicationsOperations",
-    "LocationsOperations",
+    "ClustersOperations",
     "ConfigurationsOperations",
     "ExtensionsOperations",
-    "ScriptActionsOperations",
-    "ScriptExecutionHistoryOperations",
+    "LocationsOperations",
     "Operations",
-    "VirtualMachinesOperations",
     "PrivateEndpointConnectionsOperations",
     "PrivateLinkResourcesOperations",
+    "ScriptActionsOperations",
+    "ScriptExecutionHistoryOperations",
+    "VirtualMachinesOperations",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_locations_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_locations_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,30 +24,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_capabilities_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.HDInsight/locations/{location}/capabilities",
     )  # pylint: disable=line-too-long
@@ -67,15 +63,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_usages_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.HDInsight/locations/{location}/usages"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
@@ -94,15 +90,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_billing_specs_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.HDInsight/locations/{location}/billingSpecs",
     )  # pylint: disable=line-too-long
@@ -124,15 +120,15 @@
 
 def build_get_azure_async_operation_status_request(
     location: str, operation_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.HDInsight/locations/{location}/azureasyncoperations/{operationId}",
     )  # pylint: disable=line-too-long
@@ -153,15 +149,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_check_name_availability_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.HDInsight/locations/{location}/checkNameAvailability",
@@ -184,15 +180,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_cluster_create_request_request(location: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.HDInsight/locations/{location}/validateCreateRequest",
@@ -252,32 +248,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.CapabilitiesResult] = kwargs.pop("cls", None)
 
         request = build_get_capabilities_request(
             location=location,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_capabilities.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -312,32 +307,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.UsagesListResult] = kwargs.pop("cls", None)
 
         request = build_list_usages_request(
             location=location,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.list_usages.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -372,32 +366,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.BillingResponseListResult] = kwargs.pop("cls", None)
 
         request = build_list_billing_specs_request(
             location=location,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.list_billing_specs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -436,33 +429,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AsyncOperationResult] = kwargs.pop("cls", None)
 
         request = build_get_azure_async_operation_status_request(
             location=location,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_azure_async_operation_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -526,15 +518,16 @@
     def check_name_availability(
         self, location: str, parameters: Union[_models.NameAvailabilityCheckRequestParameters, IO], **kwargs: Any
     ) -> _models.NameAvailabilityCheckResult:
         """Check the cluster name is available or not.
 
         :param location: The Azure location (region) for which to make the request. Required.
         :type location: str
-        :param parameters: Is either a model type or a IO type. Required.
+        :param parameters: Is either a NameAvailabilityCheckRequestParameters type or a IO type.
+         Required.
         :type parameters: ~azure.mgmt.hdinsight.models.NameAvailabilityCheckRequestParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: NameAvailabilityCheckResult or the result of cls(response)
         :rtype: ~azure.mgmt.hdinsight.models.NameAvailabilityCheckResult
@@ -547,24 +540,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.NameAvailabilityCheckResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "NameAvailabilityCheckRequestParameters")
 
         request = build_check_name_availability_request(
             location=location,
             subscription_id=self._config.subscription_id,
@@ -575,16 +566,17 @@
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -648,15 +640,16 @@
     def validate_cluster_create_request(
         self, location: str, parameters: Union[_models.ClusterCreateRequestValidationParameters, IO], **kwargs: Any
     ) -> _models.ClusterCreateValidationResult:
         """Validate the cluster create request spec is valid or not.
 
         :param location: The Azure location (region) for which to make the request. Required.
         :type location: str
-        :param parameters: Is either a model type or a IO type. Required.
+        :param parameters: Is either a ClusterCreateRequestValidationParameters type or a IO type.
+         Required.
         :type parameters: ~azure.mgmt.hdinsight.models.ClusterCreateRequestValidationParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ClusterCreateValidationResult or the result of cls(response)
         :rtype: ~azure.mgmt.hdinsight.models.ClusterCreateValidationResult
@@ -669,24 +662,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ClusterCreateValidationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ClusterCreateRequestValidationParameters")
 
         request = build_validate_cluster_create_request_request(
             location=location,
             subscription_id=self._config.subscription_id,
@@ -697,16 +688,17 @@
             template_url=self.validate_cluster_create_request.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_extensions_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_extensions_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,32 +26,28 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_enable_monitoring_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/clustermonitoring",
@@ -77,15 +73,15 @@
 
 def build_get_monitoring_status_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/clustermonitoring",
     )  # pylint: disable=line-too-long
@@ -108,15 +104,15 @@
 
 def build_disable_monitoring_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/clustermonitoring",
     )  # pylint: disable=line-too-long
@@ -139,15 +135,15 @@
 
 def build_enable_azure_monitor_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/azureMonitor",
@@ -173,15 +169,15 @@
 
 def build_get_azure_monitor_status_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/azureMonitor",
     )  # pylint: disable=line-too-long
@@ -204,15 +200,15 @@
 
 def build_disable_azure_monitor_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/azureMonitor",
     )  # pylint: disable=line-too-long
@@ -235,15 +231,15 @@
 
 def build_create_request(
     resource_group_name: str, cluster_name: str, extension_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/{extensionName}",
@@ -270,15 +266,15 @@
 
 def build_get_request(
     resource_group_name: str, cluster_name: str, extension_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/{extensionName}",
     )  # pylint: disable=line-too-long
@@ -302,15 +298,15 @@
 
 def build_delete_request(
     resource_group_name: str, cluster_name: str, extension_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/{extensionName}",
     )  # pylint: disable=line-too-long
@@ -339,15 +335,15 @@
     operation_id: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/{extensionName}/azureAsyncOperations/{operationId}",
     )  # pylint: disable=line-too-long
@@ -403,24 +399,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ClusterMonitoringRequest")
 
         request = build_enable_monitoring_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -432,16 +426,17 @@
             template_url=self._enable_monitoring_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -533,15 +528,15 @@
         """Enables the Operations Management Suite (OMS) on the HDInsight cluster.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
         :param parameters: The Operations Management Suite (OMS) workspace parameters. Is either a
-         model type or a IO type. Required.
+         ClusterMonitoringRequest type or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.ClusterMonitoringRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -553,17 +548,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._enable_monitoring_initial(  # type: ignore
@@ -626,33 +619,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ClusterMonitoringResponse] = kwargs.pop("cls", None)
 
         request = build_get_monitoring_status_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_monitoring_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -679,33 +671,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_disable_monitoring_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._disable_monitoring_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -737,17 +728,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._disable_monitoring_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -799,24 +788,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "AzureMonitorRequest")
 
         request = build_enable_azure_monitor_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -828,16 +815,17 @@
             template_url=self._enable_azure_monitor_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -928,16 +916,16 @@
     ) -> LROPoller[None]:
         """Enables the Azure Monitor on the HDInsight cluster.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
-        :param parameters: The Log Analytics workspace parameters. Is either a model type or a IO type.
-         Required.
+        :param parameters: The Log Analytics workspace parameters. Is either a AzureMonitorRequest type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.AzureMonitorRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -949,17 +937,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._enable_azure_monitor_initial(  # type: ignore
@@ -1022,33 +1008,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AzureMonitorResponse] = kwargs.pop("cls", None)
 
         request = build_get_azure_monitor_status_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_azure_monitor_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1075,33 +1060,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_disable_azure_monitor_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._disable_azure_monitor_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1135,17 +1119,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._disable_azure_monitor_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1198,24 +1180,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Extension")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1228,16 +1208,17 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1337,16 +1318,16 @@
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
         :param extension_name: The name of the cluster extension. Required.
         :type extension_name: str
-        :param parameters: The cluster extensions create request. Is either a model type or a IO type.
-         Required.
+        :param parameters: The cluster extensions create request. Is either a Extension type or a IO
+         type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.Extension or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -1358,17 +1339,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(  # type: ignore
@@ -1434,17 +1413,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ClusterMonitoringResponse] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             extension_name=extension_name,
             subscription_id=self._config.subscription_id,
@@ -1452,16 +1429,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1488,17 +1466,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             extension_name=extension_name,
             subscription_id=self._config.subscription_id,
@@ -1506,16 +1482,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1551,17 +1528,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1626,17 +1601,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AsyncOperationResult] = kwargs.pop("cls", None)
 
         request = build_get_azure_async_operation_status_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             extension_name=extension_name,
             operation_id=operation_id,
@@ -1645,16 +1618,17 @@
             template_url=self.get_azure_async_operation_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_configurations_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_configurations_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,30 +26,26 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/configurations",
     )  # pylint: disable=line-too-long
@@ -72,15 +68,15 @@
 
 def build_update_request(
     resource_group_name: str, cluster_name: str, configuration_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/configurations/{configurationName}",
@@ -107,15 +103,15 @@
 
 def build_get_request(
     resource_group_name: str, cluster_name: str, configuration_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/configurations/{configurationName}",
     )  # pylint: disable=line-too-long
@@ -176,33 +172,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ClusterConfigurations] = kwargs.pop("cls", None)
 
         request = build_list_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.list.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -234,24 +229,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "{str}")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -264,16 +257,17 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -376,15 +370,16 @@
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
         :param configuration_name: The name of the cluster configuration. Required.
         :type configuration_name: str
-        :param parameters: The cluster configurations. Is either a dict type or a IO type. Required.
+        :param parameters: The cluster configurations. Is either a {str: str} type or a IO type.
+         Required.
         :type parameters: dict[str, str] or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -396,17 +391,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_initial(  # type: ignore
@@ -473,17 +466,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[Dict[str, str]] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             configuration_name=configuration_name,
             subscription_id=self._config.subscription_id,
@@ -491,16 +482,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_patch.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_applications_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_applications_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,32 +28,28 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_by_cluster_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/applications",
     )  # pylint: disable=line-too-long
@@ -76,15 +72,15 @@
 
 def build_get_request(
     resource_group_name: str, cluster_name: str, application_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/applications/{applicationName}",
     )  # pylint: disable=line-too-long
@@ -108,15 +104,15 @@
 
 def build_create_request(
     resource_group_name: str, cluster_name: str, application_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/applications/{applicationName}",
@@ -143,15 +139,15 @@
 
 def build_delete_request(
     resource_group_name: str, cluster_name: str, application_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/applications/{applicationName}",
     )  # pylint: disable=line-too-long
@@ -180,15 +176,15 @@
     operation_id: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/applications/{applicationName}/azureasyncoperations/{operationId}",
     )  # pylint: disable=line-too-long
@@ -244,17 +240,15 @@
         :return: An iterator like instance of either Application or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.hdinsight.models.Application]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ApplicationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -300,16 +294,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -346,17 +341,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Application] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             application_name=application_name,
             subscription_id=self._config.subscription_id,
@@ -364,16 +357,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -405,24 +399,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Application] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Application")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -435,16 +427,17 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -550,15 +543,15 @@
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
         :param application_name: The constant value for the application name. Required.
         :type application_name: str
-        :param parameters: The application create request. Is either a model type or a IO type.
+        :param parameters: The application create request. Is either a Application type or a IO type.
          Required.
         :type parameters: ~azure.mgmt.hdinsight.models.Application or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -572,17 +565,15 @@
          cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.hdinsight.models.Application]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Application] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
@@ -636,17 +627,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             application_name=application_name,
             subscription_id=self._config.subscription_id,
@@ -654,16 +643,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -699,17 +689,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -774,17 +762,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AsyncOperationResult] = kwargs.pop("cls", None)
 
         request = build_get_azure_async_operation_status_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             application_name=application_name,
             operation_id=operation_id,
@@ -793,16 +779,17 @@
             template_url=self.get_azure_async_operation_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_clusters_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_clusters_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,32 +28,28 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}",
@@ -79,15 +75,15 @@
 
 def build_update_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}",
@@ -113,15 +109,15 @@
 
 def build_delete_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}",
     )  # pylint: disable=line-too-long
@@ -142,15 +138,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}",
     )  # pylint: disable=line-too-long
@@ -171,15 +167,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_by_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters",
     )  # pylint: disable=line-too-long
@@ -205,15 +201,15 @@
     role_name: Union[str, _models.RoleName],
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/roles/{roleName}/resize",
@@ -244,15 +240,15 @@
     role_name: Union[str, _models.RoleName],
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/roles/{roleName}/autoscale",
@@ -277,15 +273,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.HDInsight/clusters")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
@@ -303,15 +299,15 @@
 
 def build_rotate_disk_encryption_key_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/rotatediskencryptionkey",
@@ -337,15 +333,15 @@
 
 def build_get_gateway_settings_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/getGatewaySettings",
     )  # pylint: disable=line-too-long
@@ -368,15 +364,15 @@
 
 def build_update_gateway_settings_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/updateGatewaySettings",
@@ -402,15 +398,15 @@
 
 def build_get_azure_async_operation_status_request(
     resource_group_name: str, cluster_name: str, operation_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/azureasyncoperations/{operationId}",
     )  # pylint: disable=line-too-long
@@ -434,15 +430,15 @@
 
 def build_update_identity_certificate_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/updateClusterIdentityCertificate",
@@ -468,15 +464,15 @@
 
 def build_execute_script_actions_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/executeScriptActions",
@@ -533,24 +529,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ClusterCreateParametersExtended")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -562,16 +556,17 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -666,15 +661,16 @@
     ) -> LROPoller[_models.Cluster]:
         """Creates a new HDInsight cluster with the specified parameters.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
-        :param parameters: The cluster create request. Is either a model type or a IO type. Required.
+        :param parameters: The cluster create request. Is either a ClusterCreateParametersExtended type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.ClusterCreateParametersExtended or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -686,17 +682,15 @@
         :return: An instance of LROPoller that returns either Cluster or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.hdinsight.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_initial(
@@ -803,15 +797,16 @@
     ) -> _models.Cluster:
         """Patch HDInsight cluster with the specified parameters.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
-        :param parameters: The cluster patch request. Is either a model type or a IO type. Required.
+        :param parameters: The cluster patch request. Is either a ClusterPatchParameters type or a IO
+         type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.ClusterPatchParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Cluster or the result of cls(response)
         :rtype: ~azure.mgmt.hdinsight.models.Cluster
@@ -824,24 +819,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ClusterPatchParameters")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -853,16 +846,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -889,33 +883,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -947,17 +940,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1015,33 +1006,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1068,17 +1058,15 @@
         :return: An iterator like instance of either Cluster or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.hdinsight.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ClusterListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1123,16 +1111,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -1160,24 +1149,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ClusterResizeParameters")
 
         request = build_resize_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1190,16 +1177,17 @@
             template_url=self._resize_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1299,16 +1287,16 @@
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
         :param role_name: The constant value for the roleName. "workernode" Required.
         :type role_name: str or ~azure.mgmt.hdinsight.models.RoleName
-        :param parameters: The parameters for the resize operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the resize operation. Is either a ClusterResizeParameters
+         type or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.ClusterResizeParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -1320,17 +1308,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._resize_initial(  # type: ignore
@@ -1387,24 +1373,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "AutoscaleConfigurationUpdateParameter")
 
         request = build_update_auto_scale_configuration_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1417,16 +1401,17 @@
             template_url=self._update_auto_scale_configuration_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1527,15 +1512,15 @@
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
         :param role_name: The constant value for the roleName. "workernode" Required.
         :type role_name: str or ~azure.mgmt.hdinsight.models.RoleName
         :param parameters: The parameters for the update autoscale configuration operation. Is either a
-         model type or a IO type. Required.
+         AutoscaleConfigurationUpdateParameter type or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.AutoscaleConfigurationUpdateParameter or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -1547,17 +1532,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_auto_scale_configuration_initial(  # type: ignore
@@ -1607,17 +1590,15 @@
         :return: An iterator like instance of either Cluster or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.hdinsight.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ClusterListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1661,16 +1642,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -1695,24 +1677,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ClusterDiskEncryptionParameters")
 
         request = build_rotate_disk_encryption_key_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1724,16 +1704,17 @@
             template_url=self._rotate_disk_encryption_key_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1824,16 +1805,16 @@
     ) -> LROPoller[None]:
         """Rotate disk encryption key of the specified HDInsight cluster.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
-        :param parameters: The parameters for the disk encryption operation. Is either a model type or
-         a IO type. Required.
+        :param parameters: The parameters for the disk encryption operation. Is either a
+         ClusterDiskEncryptionParameters type or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.ClusterDiskEncryptionParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -1845,17 +1826,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._rotate_disk_encryption_key_initial(  # type: ignore
@@ -1918,33 +1897,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.GatewaySettings] = kwargs.pop("cls", None)
 
         request = build_get_gateway_settings_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_gateway_settings.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1975,24 +1953,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "UpdateGatewaySettingsParameters")
 
         request = build_update_gateway_settings_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -2004,16 +1980,17 @@
             template_url=self._update_gateway_settings_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -2104,15 +2081,16 @@
     ) -> LROPoller[None]:
         """Configures the gateway settings on the specified cluster.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
-        :param parameters: The cluster configurations. Is either a model type or a IO type. Required.
+        :param parameters: The cluster configurations. Is either a UpdateGatewaySettingsParameters type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.UpdateGatewaySettingsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -2124,17 +2102,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_gateway_settings_initial(  # type: ignore
@@ -2199,17 +2175,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AsyncOperationResult] = kwargs.pop("cls", None)
 
         request = build_get_azure_async_operation_status_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
@@ -2217,16 +2191,17 @@
             template_url=self.get_azure_async_operation_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -2257,24 +2232,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "UpdateClusterIdentityCertificateParameters")
 
         request = build_update_identity_certificate_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -2286,16 +2259,17 @@
             template_url=self._update_identity_certificate_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -2386,15 +2360,16 @@
     ) -> LROPoller[None]:
         """Updates the cluster identity certificate.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
-        :param parameters: The cluster configurations. Is either a model type or a IO type. Required.
+        :param parameters: The cluster configurations. Is either a
+         UpdateClusterIdentityCertificateParameters type or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.UpdateClusterIdentityCertificateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -2406,17 +2381,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._update_identity_certificate_initial(  # type: ignore
@@ -2471,24 +2444,22 @@
             404: lambda response: ResourceNotFoundError(response=response, error_format=ARMErrorFormat),
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ExecuteScriptActionParameters")
 
         request = build_execute_script_actions_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -2500,16 +2471,17 @@
             template_url=self._execute_script_actions_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -2600,16 +2572,16 @@
     ) -> LROPoller[None]:
         """Executes script actions on the specified HDInsight cluster.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
-        :param parameters: The parameters for executing script actions. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for executing script actions. Is either a
+         ExecuteScriptActionParameters type or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.ExecuteScriptActionParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -2621,17 +2593,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._execute_script_actions_initial(  # type: ignore
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_private_endpoint_connections_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_private_endpoint_connections_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,32 +28,28 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_by_cluster_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/privateEndpointConnections",
     )  # pylint: disable=line-too-long
@@ -80,15 +76,15 @@
     private_endpoint_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/privateEndpointConnections/{privateEndpointConnectionName}",
@@ -121,15 +117,15 @@
     private_endpoint_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/privateEndpointConnections/{privateEndpointConnectionName}",
     )  # pylint: disable=line-too-long
@@ -159,15 +155,15 @@
     private_endpoint_connection_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/privateEndpointConnections/{privateEndpointConnectionName}",
     )  # pylint: disable=line-too-long
@@ -225,17 +221,15 @@
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.hdinsight.models.PrivateEndpointConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateEndpointConnectionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -281,16 +275,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -318,24 +313,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "PrivateEndpointConnection")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -348,16 +341,17 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -467,16 +461,16 @@
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
-        :param parameters: The private endpoint connection create or update request. Is either a model
-         type or a IO type. Required.
+        :param parameters: The private endpoint connection create or update request. Is either a
+         PrivateEndpointConnection type or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.PrivateEndpointConnection or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be ARMPolling. Pass in False for this
@@ -489,17 +483,15 @@
          of cls(response)
         :rtype: ~azure.core.polling.LROPoller[~azure.mgmt.hdinsight.models.PrivateEndpointConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._create_or_update_initial(
@@ -567,17 +559,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             private_endpoint_connection_name=private_endpoint_connection_name,
             subscription_id=self._config.subscription_id,
@@ -585,16 +575,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -621,17 +612,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             private_endpoint_connection_name=private_endpoint_connection_name,
             subscription_id=self._config.subscription_id,
@@ -639,16 +628,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -684,17 +674,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/operations/_script_actions_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_script_actions_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,28 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_delete_request(
     resource_group_name: str, cluster_name: str, script_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/scriptActions/{scriptName}",
     )  # pylint: disable=line-too-long
@@ -75,15 +70,15 @@
 
 def build_list_by_cluster_request(
     resource_group_name: str, cluster_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/scriptActions",
     )  # pylint: disable=line-too-long
@@ -106,15 +101,15 @@
 
 def build_get_execution_detail_request(
     resource_group_name: str, cluster_name: str, script_execution_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/scriptExecutionHistory/{scriptExecutionId}",
     )  # pylint: disable=line-too-long
@@ -138,15 +133,15 @@
 
 def build_get_execution_async_operation_status_request(
     resource_group_name: str, cluster_name: str, operation_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2021-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-04-15-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/executeScriptActions/azureasyncoperations/{operationId}",
     )  # pylint: disable=line-too-long
@@ -211,17 +206,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             script_name=script_name,
             subscription_id=self._config.subscription_id,
@@ -229,16 +222,17 @@
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -266,17 +260,15 @@
          cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.hdinsight.models.RuntimeScriptActionDetail]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ScriptActionsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -322,16 +314,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -368,17 +361,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.RuntimeScriptActionDetail] = kwargs.pop("cls", None)
 
         request = build_get_execution_detail_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             script_execution_id=script_execution_id,
             subscription_id=self._config.subscription_id,
@@ -386,16 +377,17 @@
             template_url=self.get_execution_detail.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -436,17 +428,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AsyncOperationResult] = kwargs.pop("cls", None)
 
         request = build_get_execution_async_operation_status_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
@@ -454,16 +444,17 @@
             template_url=self.get_execution_async_operation_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/models/_models_py3.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/models/_models_py3.py`

 * *Files 4% similar despite different names*

```diff
@@ -59,16 +59,16 @@
         domain_name: Optional[str] = None,
         initial_sync_complete: Optional[bool] = None,
         ldaps_enabled: Optional[bool] = None,
         ldaps_public_certificate_in_base64: Optional[str] = None,
         resource_id: Optional[str] = None,
         subnet_id: Optional[str] = None,
         tenant_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword domain_name: The Azure active directory domain service name.
         :paramtype domain_name: str
         :keyword initial_sync_complete: This indicates whether initial sync complete or not.
         :paramtype initial_sync_complete: bool
         :keyword ldaps_enabled: This indicates whether enable ldaps or not.
         :paramtype ldaps_enabled: bool
@@ -115,24 +115,25 @@
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.name = None
         self.type = None
 
 
 class ProxyResource(Resource):
-    """The resource model definition for a Azure Resource Manager proxy resource. It will not have tags and a location.
+    """The resource model definition for a Azure Resource Manager proxy resource. It will not have
+    tags and a location.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar id: Fully qualified resource ID for the resource. Ex -
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
@@ -150,15 +151,15 @@
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
 
 
 class Application(ProxyResource):
     """The HDInsight cluster application.
 
@@ -201,16 +202,16 @@
 
     def __init__(
         self,
         *,
         etag: Optional[str] = None,
         tags: Optional[Dict[str, str]] = None,
         properties: Optional["_models.ApplicationProperties"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword etag: The ETag for the application.
         :paramtype etag: str
         :keyword tags: The tags for the application.
         :paramtype tags: dict[str, str]
         :keyword properties: The properties of the application.
         :paramtype properties: ~azure.mgmt.hdinsight.models.ApplicationProperties
@@ -245,16 +246,16 @@
     def __init__(
         self,
         *,
         location: Optional[str] = None,
         destination_port: Optional[int] = None,
         public_port: Optional[int] = None,
         private_ip_address: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword location: The location of the endpoint.
         :paramtype location: str
         :keyword destination_port: The destination port to connect to.
         :paramtype destination_port: int
         :keyword public_port: The public port to connect to.
         :paramtype public_port: int
@@ -308,16 +309,16 @@
         self,
         *,
         access_modes: Optional[List[str]] = None,
         destination_port: Optional[int] = None,
         private_ip_address: Optional[str] = None,
         sub_domain_suffix: Optional[str] = None,
         disable_gateway_auth: Optional[bool] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword access_modes: The list of access modes for the application.
         :paramtype access_modes: list[str]
         :keyword destination_port: The destination port to connect to.
         :paramtype destination_port: int
         :keyword private_ip_address: The private ip address of the endpoint.
         :paramtype private_ip_address: str
@@ -333,15 +334,16 @@
         self.public_port = None
         self.private_ip_address = private_ip_address
         self.sub_domain_suffix = sub_domain_suffix
         self.disable_gateway_auth = disable_gateway_auth
 
 
 class ApplicationListResult(_serialization.Model):
-    """Result of the request to list cluster Applications. It contains a list of operations and a URL link to get the next set of results.
+    """Result of the request to list cluster Applications. It contains a list of operations and a URL
+    link to get the next set of results.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     :ivar value: The list of HDInsight applications installed on HDInsight cluster.
     :vartype value: list[~azure.mgmt.hdinsight.models.Application]
     :ivar next_link: The URL to get the next set of operation list results if there are any.
     :vartype next_link: str
@@ -352,15 +354,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Application]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.Application"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.Application"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of HDInsight applications installed on HDInsight cluster.
         :paramtype value: list[~azure.mgmt.hdinsight.models.Application]
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = None
@@ -427,16 +429,16 @@
         install_script_actions: Optional[List["_models.RuntimeScriptAction"]] = None,
         uninstall_script_actions: Optional[List["_models.RuntimeScriptAction"]] = None,
         https_endpoints: Optional[List["_models.ApplicationGetHttpsEndpoint"]] = None,
         ssh_endpoints: Optional[List["_models.ApplicationGetEndpoint"]] = None,
         application_type: Optional[str] = None,
         errors: Optional[List["_models.Errors"]] = None,
         private_link_configurations: Optional[List["_models.PrivateLinkConfiguration"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword compute_profile: The list of roles in the cluster.
         :paramtype compute_profile: ~azure.mgmt.hdinsight.models.ComputeProfile
         :keyword install_script_actions: The list of install script actions.
         :paramtype install_script_actions: list[~azure.mgmt.hdinsight.models.RuntimeScriptAction]
         :keyword uninstall_script_actions: The list of uninstall script actions.
         :paramtype uninstall_script_actions: list[~azure.mgmt.hdinsight.models.RuntimeScriptAction]
@@ -483,16 +485,16 @@
     }
 
     def __init__(
         self,
         *,
         status: Optional[Union[str, "_models.AsyncOperationState"]] = None,
         error: Optional["_models.Errors"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: The async operation state. Known values are: "InProgress", "Succeeded", and
          "Failed".
         :paramtype status: str or ~azure.mgmt.hdinsight.models.AsyncOperationState
         :keyword error: The operation error information.
         :paramtype error: ~azure.mgmt.hdinsight.models.Errors
         """
@@ -516,16 +518,16 @@
     }
 
     def __init__(
         self,
         *,
         capacity: Optional["_models.AutoscaleCapacity"] = None,
         recurrence: Optional["_models.AutoscaleRecurrence"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword capacity: Parameters for load-based autoscale.
         :paramtype capacity: ~azure.mgmt.hdinsight.models.AutoscaleCapacity
         :keyword recurrence: Parameters for schedule-based autoscale.
         :paramtype recurrence: ~azure.mgmt.hdinsight.models.AutoscaleRecurrence
         """
         super().__init__(**kwargs)
@@ -543,15 +545,17 @@
     """
 
     _attribute_map = {
         "min_instance_count": {"key": "minInstanceCount", "type": "int"},
         "max_instance_count": {"key": "maxInstanceCount", "type": "int"},
     }
 
-    def __init__(self, *, min_instance_count: Optional[int] = None, max_instance_count: Optional[int] = None, **kwargs):
+    def __init__(
+        self, *, min_instance_count: Optional[int] = None, max_instance_count: Optional[int] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword min_instance_count: The minimum instance count of the cluster.
         :paramtype min_instance_count: int
         :keyword max_instance_count: The maximum instance count of the cluster.
         :paramtype max_instance_count: int
         """
         super().__init__(**kwargs)
@@ -566,15 +570,15 @@
     :vartype autoscale: ~azure.mgmt.hdinsight.models.Autoscale
     """
 
     _attribute_map = {
         "autoscale": {"key": "autoscale", "type": "Autoscale"},
     }
 
-    def __init__(self, *, autoscale: Optional["_models.Autoscale"] = None, **kwargs):
+    def __init__(self, *, autoscale: Optional["_models.Autoscale"] = None, **kwargs: Any) -> None:
         """
         :keyword autoscale: The autoscale configuration.
         :paramtype autoscale: ~azure.mgmt.hdinsight.models.Autoscale
         """
         super().__init__(**kwargs)
         self.autoscale = autoscale
 
@@ -590,29 +594,34 @@
 
     _attribute_map = {
         "time_zone": {"key": "timeZone", "type": "str"},
         "schedule": {"key": "schedule", "type": "[AutoscaleSchedule]"},
     }
 
     def __init__(
-        self, *, time_zone: Optional[str] = None, schedule: Optional[List["_models.AutoscaleSchedule"]] = None, **kwargs
-    ):
+        self,
+        *,
+        time_zone: Optional[str] = None,
+        schedule: Optional[List["_models.AutoscaleSchedule"]] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword time_zone: The time zone for the autoscale schedule times.
         :paramtype time_zone: str
         :keyword schedule: Array of schedule-based autoscale rules.
         :paramtype schedule: list[~azure.mgmt.hdinsight.models.AutoscaleSchedule]
         """
         super().__init__(**kwargs)
         self.time_zone = time_zone
         self.schedule = schedule
 
 
 class AutoscaleSchedule(_serialization.Model):
-    """Parameters for a schedule-based autoscale rule, consisting of an array of days + a time and capacity.
+    """Parameters for a schedule-based autoscale rule, consisting of an array of days + a time and
+    capacity.
 
     :ivar days: Days of the week for a schedule-based autoscale rule.
     :vartype days: list[str or ~azure.mgmt.hdinsight.models.DaysOfWeek]
     :ivar time_and_capacity: Time and capacity for a schedule-based autoscale rule.
     :vartype time_and_capacity: ~azure.mgmt.hdinsight.models.AutoscaleTimeAndCapacity
     """
 
@@ -622,16 +631,16 @@
     }
 
     def __init__(
         self,
         *,
         days: Optional[List[Union[str, "_models.DaysOfWeek"]]] = None,
         time_and_capacity: Optional["_models.AutoscaleTimeAndCapacity"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword days: Days of the week for a schedule-based autoscale rule.
         :paramtype days: list[str or ~azure.mgmt.hdinsight.models.DaysOfWeek]
         :keyword time_and_capacity: Time and capacity for a schedule-based autoscale rule.
         :paramtype time_and_capacity: ~azure.mgmt.hdinsight.models.AutoscaleTimeAndCapacity
         """
         super().__init__(**kwargs)
@@ -658,16 +667,16 @@
 
     def __init__(
         self,
         *,
         time: Optional[str] = None,
         min_instance_count: Optional[int] = None,
         max_instance_count: Optional[int] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword time: 24-hour time in the form xx:xx.
         :paramtype time: str
         :keyword min_instance_count: The minimum instance count of the cluster.
         :paramtype min_instance_count: int
         :keyword max_instance_count: The maximum instance count of the cluster.
         :paramtype max_instance_count: int
@@ -698,16 +707,16 @@
 
     def __init__(
         self,
         *,
         workspace_id: Optional[str] = None,
         primary_key: Optional[str] = None,
         selected_configurations: Optional["_models.AzureMonitorSelectedConfigurations"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword workspace_id: The Log Analytics workspace ID.
         :paramtype workspace_id: str
         :keyword primary_key: The Log Analytics workspace key.
         :paramtype primary_key: str
         :keyword selected_configurations: The selected configurations.
         :paramtype selected_configurations:
@@ -739,16 +748,16 @@
 
     def __init__(
         self,
         *,
         cluster_monitoring_enabled: Optional[bool] = None,
         workspace_id: Optional[str] = None,
         selected_configurations: Optional["_models.AzureMonitorSelectedConfigurations"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword cluster_monitoring_enabled: The status of the monitor on the HDInsight cluster.
         :paramtype cluster_monitoring_enabled: bool
         :keyword workspace_id: The workspace ID of the monitor on the HDInsight cluster.
         :paramtype workspace_id: str
         :keyword selected_configurations: The selected configurations.
         :paramtype selected_configurations:
@@ -779,16 +788,16 @@
 
     def __init__(
         self,
         *,
         configuration_version: Optional[str] = None,
         global_configurations: Optional[Dict[str, str]] = None,
         table_list: Optional[List["_models.AzureMonitorTableConfiguration"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword configuration_version: The configuration version.
         :paramtype configuration_version: str
         :keyword global_configurations: The global configurations of selected configurations.
         :paramtype global_configurations: dict[str, str]
         :keyword table_list: The table list.
         :paramtype table_list: list[~azure.mgmt.hdinsight.models.AzureMonitorTableConfiguration]
@@ -806,15 +815,15 @@
     :vartype name: str
     """
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
     }
 
-    def __init__(self, *, name: Optional[str] = None, **kwargs):
+    def __init__(self, *, name: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword name: The name.
         :paramtype name: str
         """
         super().__init__(**kwargs)
         self.name = name
 
@@ -838,16 +847,16 @@
 
     def __init__(
         self,
         *,
         meter_parameter: Optional[str] = None,
         meter: Optional[str] = None,
         unit: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword meter_parameter: The virtual machine sizes.
         :paramtype meter_parameter: str
         :keyword meter: The HDInsight meter guid.
         :paramtype meter: str
         :keyword unit: The unit of meter, VMHours or CoreHours.
         :paramtype unit: str
@@ -877,16 +886,16 @@
 
     def __init__(
         self,
         *,
         region: Optional[str] = None,
         billing_meters: Optional[List["_models.BillingMeters"]] = None,
         disk_billing_meters: Optional[List["_models.DiskBillingMeters"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword region: The region or location.
         :paramtype region: str
         :keyword billing_meters: The billing meter information.
         :paramtype billing_meters: list[~azure.mgmt.hdinsight.models.BillingMeters]
         :keyword disk_billing_meters: The managed disk billing information.
         :paramtype disk_billing_meters: list[~azure.mgmt.hdinsight.models.DiskBillingMeters]
@@ -930,16 +939,16 @@
     def __init__(
         self,
         *,
         vm_sizes: Optional[List[str]] = None,
         vm_sizes_with_encryption_at_host: Optional[List[str]] = None,
         vm_size_filters: Optional[List["_models.VmSizeCompatibilityFilterV2"]] = None,
         billing_resources: Optional[List["_models.BillingResources"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword vm_sizes: The virtual machine sizes to include or exclude.
         :paramtype vm_sizes: list[str]
         :keyword vm_sizes_with_encryption_at_host: The vm sizes which enable encryption at host.
         :paramtype vm_sizes_with_encryption_at_host: list[str]
         :keyword vm_size_filters: The virtual machine filtering mode. Effectively this can enabling or
          disabling the virtual machine sizes in a particular set.
@@ -983,16 +992,16 @@
 
     def __init__(
         self,
         *,
         versions: Optional[Dict[str, "_models.VersionsCapability"]] = None,
         regions: Optional[Dict[str, "_models.RegionsCapability"]] = None,
         features: Optional[List[str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword versions: The version capability.
         :paramtype versions: dict[str, ~azure.mgmt.hdinsight.models.VersionsCapability]
         :keyword regions: The virtual machine size compatibility features.
         :paramtype regions: dict[str, ~azure.mgmt.hdinsight.models.RegionsCapability]
         :keyword features: The capability features.
         :paramtype features: list[str]
@@ -1014,15 +1023,15 @@
     """
 
     _attribute_map = {
         "group_name": {"key": "groupName", "type": "str"},
         "group_id": {"key": "groupId", "type": "str"},
     }
 
-    def __init__(self, *, group_name: Optional[str] = None, group_id: Optional[str] = None, **kwargs):
+    def __init__(self, *, group_name: Optional[str] = None, group_id: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword group_name: The AAD security group name.
         :paramtype group_name: str
         :keyword group_id: The AAD security group id.
         :paramtype group_id: str
         """
         super().__init__(**kwargs)
@@ -1053,24 +1062,25 @@
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.name = None
         self.type = None
 
 
 class TrackedResource(ResourceAutoGenerated):
-    """The resource model definition for an Azure Resource Manager tracked top level resource which has 'tags' and a 'location'.
+    """The resource model definition for an Azure Resource Manager tracked top level resource which
+    has 'tags' and a 'location'.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar id: Fully qualified resource ID for the resource. Ex -
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
@@ -1097,15 +1107,15 @@
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
     }
 
-    def __init__(self, *, location: str, tags: Optional[Dict[str, str]] = None, **kwargs):
+    def __init__(self, *, location: str, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         """
         super().__init__(**kwargs)
@@ -1170,16 +1180,16 @@
         *,
         location: str,
         tags: Optional[Dict[str, str]] = None,
         etag: Optional[str] = None,
         zones: Optional[List[str]] = None,
         properties: Optional["_models.ClusterGetProperties"] = None,
         identity: Optional["_models.ClusterIdentity"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword tags: Resource tags.
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         :keyword etag: The ETag for the resource.
         :paramtype etag: str
@@ -1206,15 +1216,15 @@
     :vartype configurations: dict[str, dict[str, str]]
     """
 
     _attribute_map = {
         "configurations": {"key": "configurations", "type": "{{str}}"},
     }
 
-    def __init__(self, *, configurations: Optional[Dict[str, Dict[str, str]]] = None, **kwargs):
+    def __init__(self, *, configurations: Optional[Dict[str, Dict[str, str]]] = None, **kwargs: Any) -> None:
         """
         :keyword configurations: The configuration object for the specified configuration for the
          specified cluster.
         :paramtype configurations: dict[str, dict[str, str]]
         """
         super().__init__(**kwargs)
         self.configurations = configurations
@@ -1247,16 +1257,16 @@
         self,
         *,
         location: Optional[str] = None,
         tags: Optional[Dict[str, str]] = None,
         zones: Optional[List[str]] = None,
         properties: Optional["_models.ClusterCreateProperties"] = None,
         identity: Optional["_models.ClusterIdentity"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword location: The location of the cluster.
         :paramtype location: str
         :keyword tags: The resource tags.
         :paramtype tags: dict[str, str]
         :keyword zones: The availability zones.
         :paramtype zones: list[str]
@@ -1341,16 +1351,16 @@
         storage_profile: Optional["_models.StorageProfile"] = None,
         disk_encryption_properties: Optional["_models.DiskEncryptionProperties"] = None,
         encryption_in_transit_properties: Optional["_models.EncryptionInTransitProperties"] = None,
         min_supported_tls_version: Optional[str] = None,
         network_properties: Optional["_models.NetworkProperties"] = None,
         compute_isolation_properties: Optional["_models.ComputeIsolationProperties"] = None,
         private_link_configurations: Optional[List["_models.PrivateLinkConfiguration"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword cluster_version: The version of the cluster.
         :paramtype cluster_version: str
         :keyword os_type: The type of operating system. Known values are: "Windows" and "Linux".
         :paramtype os_type: str or ~azure.mgmt.hdinsight.models.OSType
         :keyword tier: The cluster tier. Known values are: "Standard" and "Premium".
         :paramtype tier: str or ~azure.mgmt.hdinsight.models.Tier
@@ -1440,16 +1450,16 @@
         zones: Optional[List[str]] = None,
         properties: Optional["_models.ClusterCreateProperties"] = None,
         identity: Optional["_models.ClusterIdentity"] = None,
         name: Optional[str] = None,
         type: Optional[str] = None,
         tenant_id: Optional[str] = None,
         fetch_aadds_resource: Optional[bool] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword location: The location of the cluster.
         :paramtype location: str
         :keyword tags: The resource tags.
         :paramtype tags: dict[str, str]
         :keyword zones: The availability zones.
         :paramtype zones: list[str]
@@ -1496,16 +1506,16 @@
     def __init__(
         self,
         *,
         validation_errors: Optional[List["_models.ValidationErrorInfo"]] = None,
         validation_warnings: Optional[List["_models.ValidationErrorInfo"]] = None,
         estimated_creation_duration: Optional[datetime.timedelta] = None,
         aadds_resources_details: Optional[List["_models.AaddsResourceDetails"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword validation_errors: The validation errors.
         :paramtype validation_errors: list[~azure.mgmt.hdinsight.models.ValidationErrorInfo]
         :keyword validation_warnings: The validation warnings.
         :paramtype validation_warnings: list[~azure.mgmt.hdinsight.models.ValidationErrorInfo]
         :keyword estimated_creation_duration: The estimated creation duration.
         :paramtype estimated_creation_duration: ~datetime.timedelta
@@ -1542,16 +1552,16 @@
     def __init__(
         self,
         *,
         blueprint: Optional[str] = None,
         kind: Optional[str] = None,
         component_version: Optional[Dict[str, str]] = None,
         configurations: Optional[JSON] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword blueprint: The link to the blueprint.
         :paramtype blueprint: str
         :keyword kind: The type of cluster.
         :paramtype kind: str
         :keyword component_version: The versions of different services in the cluster.
         :paramtype component_version: dict[str, str]
@@ -1585,16 +1595,16 @@
 
     def __init__(
         self,
         *,
         vault_uri: Optional[str] = None,
         key_name: Optional[str] = None,
         key_version: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword vault_uri: Base key vault URI where the customers key is located eg.
          https://myvault.vault.azure.net.
         :paramtype vault_uri: str
         :keyword key_name: Key name that is used for enabling disk encryption.
         :paramtype key_name: str
         :keyword key_version: Specific key version that is used for enabling disk encryption.
@@ -1725,16 +1735,16 @@
         encryption_in_transit_properties: Optional["_models.EncryptionInTransitProperties"] = None,
         storage_profile: Optional["_models.StorageProfile"] = None,
         min_supported_tls_version: Optional[str] = None,
         excluded_services_config: Optional["_models.ExcludedServicesConfig"] = None,
         network_properties: Optional["_models.NetworkProperties"] = None,
         compute_isolation_properties: Optional["_models.ComputeIsolationProperties"] = None,
         private_link_configurations: Optional[List["_models.PrivateLinkConfiguration"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword cluster_version: The version of the cluster.
         :paramtype cluster_version: str
         :keyword cluster_hdp_version: The hdp version of the cluster.
         :paramtype cluster_hdp_version: str
         :keyword os_type: The type of operating system. Known values are: "Windows" and "Linux".
         :paramtype os_type: str or ~azure.mgmt.hdinsight.models.OSType
@@ -1845,16 +1855,16 @@
     }
 
     def __init__(
         self,
         *,
         type: Optional[Union[str, "_models.ResourceIdentityType"]] = None,
         user_assigned_identities: Optional[Dict[str, "_models.UserAssignedIdentity"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword type: The type of identity used for the cluster. The type 'SystemAssigned,
          UserAssigned' includes both an implicitly created identity and a set of user assigned
          identities. Known values are: "SystemAssigned", "UserAssigned", "SystemAssigned, UserAssigned",
          and "None".
         :paramtype type: str or ~azure.mgmt.hdinsight.models.ResourceIdentityType
         :keyword user_assigned_identities: The list of user identities associated with the cluster. The
@@ -1886,15 +1896,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[RuntimeScriptAction]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.RuntimeScriptAction"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.RuntimeScriptAction"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of Persisted Script Actions.
         :paramtype value: list[~azure.mgmt.hdinsight.models.RuntimeScriptAction]
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = None
@@ -1916,15 +1926,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Cluster]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.Cluster"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.Cluster"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of Clusters.
         :paramtype value: list[~azure.mgmt.hdinsight.models.Cluster]
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = None
@@ -1940,15 +1950,15 @@
     """
 
     _attribute_map = {
         "workspace_id": {"key": "workspaceId", "type": "str"},
         "primary_key": {"key": "primaryKey", "type": "str"},
     }
 
-    def __init__(self, *, workspace_id: Optional[str] = None, primary_key: Optional[str] = None, **kwargs):
+    def __init__(self, *, workspace_id: Optional[str] = None, primary_key: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword workspace_id: The cluster monitor workspace ID.
         :paramtype workspace_id: str
         :keyword primary_key: The cluster monitor workspace key.
         :paramtype primary_key: str
         """
         super().__init__(**kwargs)
@@ -1967,16 +1977,16 @@
 
     _attribute_map = {
         "cluster_monitoring_enabled": {"key": "clusterMonitoringEnabled", "type": "bool"},
         "workspace_id": {"key": "workspaceId", "type": "str"},
     }
 
     def __init__(
-        self, *, cluster_monitoring_enabled: Optional[bool] = None, workspace_id: Optional[str] = None, **kwargs
-    ):
+        self, *, cluster_monitoring_enabled: Optional[bool] = None, workspace_id: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword cluster_monitoring_enabled: The status of the monitor on the HDInsight cluster.
         :paramtype cluster_monitoring_enabled: bool
         :keyword workspace_id: The workspace ID of the monitor on the HDInsight cluster.
         :paramtype workspace_id: str
         """
         super().__init__(**kwargs)
@@ -1991,15 +2001,15 @@
     :vartype tags: dict[str, str]
     """
 
     _attribute_map = {
         "tags": {"key": "tags", "type": "{str}"},
     }
 
-    def __init__(self, *, tags: Optional[Dict[str, str]] = None, **kwargs):
+    def __init__(self, *, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
         """
         :keyword tags: The resource tags.
         :paramtype tags: dict[str, str]
         """
         super().__init__(**kwargs)
         self.tags = tags
 
@@ -2011,15 +2021,15 @@
     :vartype target_instance_count: int
     """
 
     _attribute_map = {
         "target_instance_count": {"key": "targetInstanceCount", "type": "int"},
     }
 
-    def __init__(self, *, target_instance_count: Optional[int] = None, **kwargs):
+    def __init__(self, *, target_instance_count: Optional[int] = None, **kwargs: Any) -> None:
         """
         :keyword target_instance_count: The target instance count for the operation.
         :paramtype target_instance_count: int
         """
         super().__init__(**kwargs)
         self.target_instance_count = target_instance_count
 
@@ -2034,15 +2044,17 @@
     """
 
     _attribute_map = {
         "enable_compute_isolation": {"key": "enableComputeIsolation", "type": "bool"},
         "host_sku": {"key": "hostSku", "type": "str"},
     }
 
-    def __init__(self, *, enable_compute_isolation: bool = False, host_sku: Optional[str] = None, **kwargs):
+    def __init__(
+        self, *, enable_compute_isolation: bool = False, host_sku: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword enable_compute_isolation: The flag indicates whether enable compute isolation or not.
         :paramtype enable_compute_isolation: bool
         :keyword host_sku: The host sku.
         :paramtype host_sku: str
         """
         super().__init__(**kwargs)
@@ -2057,15 +2069,15 @@
     :vartype roles: list[~azure.mgmt.hdinsight.models.Role]
     """
 
     _attribute_map = {
         "roles": {"key": "roles", "type": "[Role]"},
     }
 
-    def __init__(self, *, roles: Optional[List["_models.Role"]] = None, **kwargs):
+    def __init__(self, *, roles: Optional[List["_models.Role"]] = None, **kwargs: Any) -> None:
         """
         :keyword roles: The list of roles in the cluster.
         :paramtype roles: list[~azure.mgmt.hdinsight.models.Role]
         """
         super().__init__(**kwargs)
         self.roles = roles
 
@@ -2097,16 +2109,16 @@
         self,
         *,
         name: Optional[str] = None,
         protocol: Optional[str] = None,
         location: Optional[str] = None,
         port: Optional[int] = None,
         private_ip_address: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name: The name of the endpoint.
         :paramtype name: str
         :keyword protocol: The protocol of the endpoint.
         :paramtype protocol: str
         :keyword location: The location of the endpoint.
         :paramtype location: str
@@ -2143,15 +2155,15 @@
 
     _attribute_map = {
         "disks_per_node": {"key": "disksPerNode", "type": "int"},
         "storage_account_type": {"key": "storageAccountType", "type": "str"},
         "disk_size_gb": {"key": "diskSizeGB", "type": "int"},
     }
 
-    def __init__(self, *, disks_per_node: Optional[int] = None, **kwargs):
+    def __init__(self, *, disks_per_node: Optional[int] = None, **kwargs: Any) -> None:
         """
         :keyword disks_per_node: The number of disks per node.
         :paramtype disks_per_node: int
         """
         super().__init__(**kwargs)
         self.disks_per_node = disks_per_node
         self.storage_account_type = None
@@ -2182,16 +2194,16 @@
     def __init__(
         self,
         *,
         name: Optional[str] = None,
         display_name: Optional[str] = None,
         internal_name: Optional[str] = None,
         to_be_exported_for_shoebox: Optional[bool] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name: The name of the dimension.
         :paramtype name: str
         :keyword display_name: The display name of the dimension.
         :paramtype display_name: str
         :keyword internal_name: The display name of the dimension.
         :paramtype internal_name: str
@@ -2226,16 +2238,16 @@
 
     def __init__(
         self,
         *,
         disk_rp_meter: Optional[str] = None,
         sku: Optional[str] = None,
         tier: Optional[Union[str, "_models.Tier"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword disk_rp_meter: The managed disk meter guid.
         :paramtype disk_rp_meter: str
         :keyword sku: The managed disk billing sku, P30 or S30.
         :paramtype sku: str
         :keyword tier: The managed disk billing tier, Standard or Premium. Known values are: "Standard"
          and "Premium".
@@ -2281,16 +2293,16 @@
         *,
         vault_uri: Optional[str] = None,
         key_name: Optional[str] = None,
         key_version: Optional[str] = None,
         encryption_algorithm: Optional[Union[str, "_models.JsonWebKeyEncryptionAlgorithm"]] = None,
         msi_resource_id: Optional[str] = None,
         encryption_at_host: bool = False,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword vault_uri: Base key vault URI where the customers key is located eg.
          https://myvault.vault.azure.net.
         :paramtype vault_uri: str
         :keyword key_name: Key name that is used for enabling disk encryption.
         :paramtype key_name: str
         :keyword key_version: Specific key version that is used for enabling disk encryption.
@@ -2321,15 +2333,15 @@
     :vartype is_encryption_in_transit_enabled: bool
     """
 
     _attribute_map = {
         "is_encryption_in_transit_enabled": {"key": "isEncryptionInTransitEnabled", "type": "bool"},
     }
 
-    def __init__(self, *, is_encryption_in_transit_enabled: bool = False, **kwargs):
+    def __init__(self, *, is_encryption_in_transit_enabled: bool = False, **kwargs: Any) -> None:
         """
         :keyword is_encryption_in_transit_enabled: Indicates whether or not inter cluster node
          communication is encrypted in transit.
         :paramtype is_encryption_in_transit_enabled: bool
         """
         super().__init__(**kwargs)
         self.is_encryption_in_transit_enabled = is_encryption_in_transit_enabled
@@ -2345,15 +2357,15 @@
     """
 
     _attribute_map = {
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
     }
 
-    def __init__(self, *, code: Optional[str] = None, message: Optional[str] = None, **kwargs):
+    def __init__(self, *, code: Optional[str] = None, message: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword code: Error code.
         :paramtype code: str
         :keyword message: Error message indicating why the operation failed.
         :paramtype message: str
         """
         super().__init__(**kwargs)
@@ -2371,15 +2383,15 @@
     """
 
     _attribute_map = {
         "code": {"key": "code", "type": "str"},
         "message": {"key": "message", "type": "str"},
     }
 
-    def __init__(self, *, code: Optional[str] = None, message: Optional[str] = None, **kwargs):
+    def __init__(self, *, code: Optional[str] = None, message: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword code: The error code.
         :paramtype code: str
         :keyword message: The error message.
         :paramtype message: str
         """
         super().__init__(**kwargs)
@@ -2402,16 +2414,16 @@
     }
 
     def __init__(
         self,
         *,
         excluded_services_config_id: Optional[str] = None,
         excluded_services_list: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword excluded_services_config_id: The config id of excluded services.
         :paramtype excluded_services_config_id: str
         :keyword excluded_services_list: The list of excluded services.
         :paramtype excluded_services_list: str
         """
         super().__init__(**kwargs)
@@ -2440,16 +2452,16 @@
     }
 
     def __init__(
         self,
         *,
         persist_on_success: bool,
         script_actions: Optional[List["_models.RuntimeScriptAction"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword script_actions: The list of run time script actions.
         :paramtype script_actions: list[~azure.mgmt.hdinsight.models.RuntimeScriptAction]
         :keyword persist_on_success: Gets or sets if the scripts needs to be persisted. Required.
         :paramtype persist_on_success: bool
         """
         super().__init__(**kwargs)
@@ -2467,15 +2479,15 @@
     """
 
     _attribute_map = {
         "workspace_id": {"key": "workspaceId", "type": "str"},
         "primary_key": {"key": "primaryKey", "type": "str"},
     }
 
-    def __init__(self, *, workspace_id: Optional[str] = None, primary_key: Optional[str] = None, **kwargs):
+    def __init__(self, *, workspace_id: Optional[str] = None, primary_key: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword workspace_id: The workspace ID for the cluster monitoring extension.
         :paramtype workspace_id: str
         :keyword primary_key: The certificate for the cluster monitoring extensions.
         :paramtype primary_key: str
         """
         super().__init__(**kwargs)
@@ -2505,15 +2517,15 @@
 
     _attribute_map = {
         "is_credential_enabled": {"key": "restAuthCredential\\.isEnabled", "type": "str"},
         "user_name": {"key": "restAuthCredential\\.username", "type": "str"},
         "password": {"key": "restAuthCredential\\.password", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.is_credential_enabled = None
         self.user_name = None
         self.password = None
 
 
@@ -2524,15 +2536,15 @@
     :vartype vm_size: str
     """
 
     _attribute_map = {
         "vm_size": {"key": "vmSize", "type": "str"},
     }
 
-    def __init__(self, *, vm_size: Optional[str] = None, **kwargs):
+    def __init__(self, *, vm_size: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword vm_size: The size of the VM.
         :paramtype vm_size: str
         """
         super().__init__(**kwargs)
         self.vm_size = vm_size
 
@@ -2557,16 +2569,16 @@
 
     def __init__(
         self,
         *,
         name: Optional[str] = None,
         fqdn: Optional[str] = None,
         effective_disk_encryption_key_url: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name: The host name.
         :paramtype name: str
         :keyword fqdn: The Fully Qualified Domain Name of host.
         :paramtype fqdn: str
         :keyword effective_disk_encryption_key_url: The effective disk encryption key URL used by the
          host.
@@ -2630,16 +2642,16 @@
         self,
         *,
         name: str,
         primary: Optional[bool] = None,
         private_ip_address: Optional[str] = None,
         private_ip_allocation_method: Optional[Union[str, "_models.PrivateIPAllocationMethod"]] = None,
         subnet: Optional["_models.ResourceId"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name: The name of private link IP configuration. Required.
         :paramtype name: str
         :keyword primary: Indicates whether this IP configuration is primary for the corresponding NIC.
         :paramtype primary: bool
         :keyword private_ip_address: The IP address.
         :paramtype private_ip_address: str
@@ -2676,16 +2688,16 @@
     }
 
     def __init__(
         self,
         *,
         client_group_info: Optional["_models.ClientGroupInfo"] = None,
         configuration_override: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword client_group_info: The information of AAD security group.
         :paramtype client_group_info: ~azure.mgmt.hdinsight.models.ClientGroupInfo
         :keyword configuration_override: The configurations that need to be overriden.
         :paramtype configuration_override: dict[str, str]
         """
         super().__init__(**kwargs)
@@ -2712,16 +2724,16 @@
 
     def __init__(
         self,
         *,
         username: Optional[str] = None,
         password: Optional[str] = None,
         ssh_profile: Optional["_models.SshProfile"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword username: The username.
         :paramtype username: str
         :keyword password: The password.
         :paramtype password: str
         :keyword ssh_profile: The SSH profile.
         :paramtype ssh_profile: ~azure.mgmt.hdinsight.models.SshProfile
@@ -2742,15 +2754,15 @@
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "str"},
         "localized_value": {"key": "localizedValue", "type": "str"},
     }
 
-    def __init__(self, *, value: Optional[str] = None, localized_value: Optional[str] = None, **kwargs):
+    def __init__(self, *, value: Optional[str] = None, localized_value: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword value: The name of the used resource.
         :paramtype value: str
         :keyword localized_value: The localized name of the used resource.
         :paramtype localized_value: str
         """
         super().__init__(**kwargs)
@@ -2834,16 +2846,16 @@
         metric_filter_pattern: Optional[str] = None,
         fill_gap_with_zero: Optional[bool] = None,
         category: Optional[str] = None,
         resource_id_dimension_name_override: Optional[str] = None,
         is_internal: Optional[bool] = None,
         delegate_metric_name_override: Optional[str] = None,
         dimensions: Optional[List["_models.Dimension"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name: The name of the metric specification.
         :paramtype name: str
         :keyword display_name: The display name of the metric specification.
         :paramtype display_name: str
         :keyword display_description: The display description of the metric specification.
         :paramtype display_description: str
@@ -2909,15 +2921,15 @@
     """
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
     }
 
-    def __init__(self, *, name: Optional[str] = None, type: Optional[str] = None, **kwargs):
+    def __init__(self, *, name: Optional[str] = None, type: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword name: The resource name.
         :paramtype name: str
         :keyword type: The resource type.
         :paramtype type: str
         """
         super().__init__(**kwargs)
@@ -2945,15 +2957,15 @@
 
     _attribute_map = {
         "name_available": {"key": "nameAvailable", "type": "bool"},
         "reason": {"key": "reason", "type": "str"},
         "message": {"key": "message", "type": "str"},
     }
 
-    def __init__(self, *, name_available: Optional[bool] = None, **kwargs):
+    def __init__(self, *, name_available: Optional[bool] = None, **kwargs: Any) -> None:
         """
         :keyword name_available: This indicates whether the name is available.
         :paramtype name_available: bool
         """
         super().__init__(**kwargs)
         self.name_available = name_available
         self.reason = None
@@ -2978,16 +2990,16 @@
     }
 
     def __init__(
         self,
         *,
         resource_provider_connection: Optional[Union[str, "_models.ResourceProviderConnection"]] = None,
         private_link: Optional[Union[str, "_models.PrivateLink"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword resource_provider_connection: The direction for the resource provider connection.
          Known values are: "Inbound" and "Outbound".
         :paramtype resource_provider_connection: str or
          ~azure.mgmt.hdinsight.models.ResourceProviderConnection
         :keyword private_link: Indicates whether or not private link is enabled. Known values are:
          "Disabled" and "Enabled".
@@ -3017,16 +3029,16 @@
 
     def __init__(
         self,
         *,
         name: Optional[str] = None,
         display: Optional["_models.OperationDisplay"] = None,
         properties: Optional["_models.OperationProperties"] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name: The operation name: {provider}/{resource}/{operation}.
         :paramtype name: str
         :keyword display: The display of operation.
         :paramtype display: ~azure.mgmt.hdinsight.models.OperationDisplay
         :keyword properties: The operation properties.
         :paramtype properties: ~azure.mgmt.hdinsight.models.OperationProperties
@@ -3060,16 +3072,16 @@
     def __init__(
         self,
         *,
         provider: Optional[str] = None,
         resource: Optional[str] = None,
         operation: Optional[str] = None,
         description: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword provider: The service provider: Microsoft.HDInsight.
         :paramtype provider: str
         :keyword resource: The resource on which the operation is performed: Cluster, Applications,
          etc.
         :paramtype resource: str
         :keyword operation: The operation type: read, write, delete, etc.
@@ -3081,28 +3093,31 @@
         self.provider = provider
         self.resource = resource
         self.operation = operation
         self.description = description
 
 
 class OperationListResult(_serialization.Model):
-    """Result of the request to list HDInsight operations. It contains a list of operations and a URL link to get the next set of results.
+    """Result of the request to list HDInsight operations. It contains a list of operations and a URL
+    link to get the next set of results.
 
     :ivar value: The list of HDInsight operations supported by the HDInsight resource provider.
     :vartype value: list[~azure.mgmt.hdinsight.models.Operation]
     :ivar next_link: The URL to get the next set of operation list results if there are any.
     :vartype next_link: str
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Operation]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.Operation"]] = None, next_link: Optional[str] = None, **kwargs):
+    def __init__(
+        self, *, value: Optional[List["_models.Operation"]] = None, next_link: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword value: The list of HDInsight operations supported by the HDInsight resource provider.
         :paramtype value: list[~azure.mgmt.hdinsight.models.Operation]
         :keyword next_link: The URL to get the next set of operation list results if there are any.
         :paramtype next_link: str
         """
         super().__init__(**kwargs)
@@ -3117,15 +3132,17 @@
     :vartype service_specification: ~azure.mgmt.hdinsight.models.ServiceSpecification
     """
 
     _attribute_map = {
         "service_specification": {"key": "serviceSpecification", "type": "ServiceSpecification"},
     }
 
-    def __init__(self, *, service_specification: Optional["_models.ServiceSpecification"] = None, **kwargs):
+    def __init__(
+        self, *, service_specification: Optional["_models.ServiceSpecification"] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword service_specification: The specification of the service.
         :paramtype service_specification: ~azure.mgmt.hdinsight.models.ServiceSpecification
         """
         super().__init__(**kwargs)
         self.service_specification = service_specification
 
@@ -3139,16 +3156,16 @@
     """
 
     _attribute_map = {
         "linux_operating_system_profile": {"key": "linuxOperatingSystemProfile", "type": "LinuxOperatingSystemProfile"},
     }
 
     def __init__(
-        self, *, linux_operating_system_profile: Optional["_models.LinuxOperatingSystemProfile"] = None, **kwargs
-    ):
+        self, *, linux_operating_system_profile: Optional["_models.LinuxOperatingSystemProfile"] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword linux_operating_system_profile: The Linux OS profile.
         :paramtype linux_operating_system_profile:
          ~azure.mgmt.hdinsight.models.LinuxOperatingSystemProfile
         """
         super().__init__(**kwargs)
         self.linux_operating_system_profile = linux_operating_system_profile
@@ -3161,15 +3178,15 @@
     :vartype id: str
     """
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
     }
 
-    def __init__(self, *, id: Optional[str] = None, **kwargs):  # pylint: disable=redefined-builtin
+    def __init__(self, *, id: Optional[str] = None, **kwargs: Any) -> None:  # pylint: disable=redefined-builtin
         """
         :keyword id: The private endpoint id.
         :paramtype id: str
         """
         super().__init__(**kwargs)
         self.id = id
 
@@ -3226,15 +3243,17 @@
             "key": "properties.privateLinkServiceConnectionState",
             "type": "PrivateLinkServiceConnectionState",
         },
         "link_identifier": {"key": "properties.linkIdentifier", "type": "str"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
     }
 
-    def __init__(self, *, private_link_service_connection_state: "_models.PrivateLinkServiceConnectionState", **kwargs):
+    def __init__(
+        self, *, private_link_service_connection_state: "_models.PrivateLinkServiceConnectionState", **kwargs: Any
+    ) -> None:
         """
         :keyword private_link_service_connection_state: The private link service connection state.
          Required.
         :paramtype private_link_service_connection_state:
          ~azure.mgmt.hdinsight.models.PrivateLinkServiceConnectionState
         """
         super().__init__(**kwargs)
@@ -3261,15 +3280,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[PrivateEndpointConnection]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.PrivateEndpointConnection"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.PrivateEndpointConnection"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of private endpoint connections.
         :paramtype value: list[~azure.mgmt.hdinsight.models.PrivateEndpointConnection]
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = None
@@ -3314,15 +3333,17 @@
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
         "group_id": {"key": "properties.groupId", "type": "str"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
         "ip_configurations": {"key": "properties.ipConfigurations", "type": "[IPConfiguration]"},
     }
 
-    def __init__(self, *, name: str, group_id: str, ip_configurations: List["_models.IPConfiguration"], **kwargs):
+    def __init__(
+        self, *, name: str, group_id: str, ip_configurations: List["_models.IPConfiguration"], **kwargs: Any
+    ) -> None:
         """
         :keyword name: The name of private link configuration. Required.
         :paramtype name: str
         :keyword group_id: The HDInsight private linkable sub-resource name to apply the private link
          configuration to. For example, 'headnode', 'gateway', 'edgenode'. Required.
         :paramtype group_id: str
         :keyword ip_configurations: The IP configurations for the private link service. Required.
@@ -3375,15 +3396,15 @@
         "type": {"key": "type", "type": "str"},
         "system_data": {"key": "systemData", "type": "SystemData"},
         "group_id": {"key": "properties.groupId", "type": "str"},
         "required_members": {"key": "properties.requiredMembers", "type": "[str]"},
         "required_zone_names": {"key": "properties.requiredZoneNames", "type": "[str]"},
     }
 
-    def __init__(self, *, required_zone_names: Optional[List[str]] = None, **kwargs):
+    def __init__(self, *, required_zone_names: Optional[List[str]] = None, **kwargs: Any) -> None:
         """
         :keyword required_zone_names: The private link resource Private link DNS zone name.
         :paramtype required_zone_names: list[str]
         """
         super().__init__(**kwargs)
         self.system_data = None
         self.group_id = None
@@ -3398,15 +3419,15 @@
     :vartype value: list[~azure.mgmt.hdinsight.models.PrivateLinkResource]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[PrivateLinkResource]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.PrivateLinkResource"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.PrivateLinkResource"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: Array of private link resources.
         :paramtype value: list[~azure.mgmt.hdinsight.models.PrivateLinkResource]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -3437,16 +3458,16 @@
 
     def __init__(
         self,
         *,
         status: Union[str, "_models.PrivateLinkServiceConnectionStatus"],
         description: Optional[str] = None,
         actions_required: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword status: The concrete private link service connection. Required. Known values are:
          "Approved", "Rejected", "Pending", and "Removed".
         :paramtype status: str or ~azure.mgmt.hdinsight.models.PrivateLinkServiceConnectionStatus
         :keyword description: The optional description of the status.
         :paramtype description: str
         :keyword actions_required: Whether there is further actions.
@@ -3477,16 +3498,16 @@
 
     def __init__(
         self,
         *,
         cores_used: Optional[int] = None,
         max_cores_allowed: Optional[int] = None,
         regional_quotas: Optional[List["_models.RegionalQuotaCapability"]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword cores_used: The number of cores used in the subscription.
         :paramtype cores_used: int
         :keyword max_cores_allowed: The number of cores that the subscription allowed.
         :paramtype max_cores_allowed: int
         :keyword regional_quotas: The list of region quota capabilities.
         :paramtype regional_quotas: list[~azure.mgmt.hdinsight.models.RegionalQuotaCapability]
@@ -3504,15 +3525,15 @@
     :vartype cores_used: int
     """
 
     _attribute_map = {
         "cores_used": {"key": "coresUsed", "type": "int"},
     }
 
-    def __init__(self, *, cores_used: Optional[int] = None, **kwargs):
+    def __init__(self, *, cores_used: Optional[int] = None, **kwargs: Any) -> None:
         """
         :keyword cores_used: The cores used by the cluster.
         :paramtype cores_used: int
         """
         super().__init__(**kwargs)
         self.cores_used = cores_used
 
@@ -3536,16 +3557,16 @@
 
     def __init__(
         self,
         *,
         region_name: Optional[str] = None,
         cores_used: Optional[int] = None,
         cores_available: Optional[int] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword region_name: The region name.
         :paramtype region_name: str
         :keyword cores_used: The number of cores used in the region.
         :paramtype cores_used: int
         :keyword cores_available: The number of cores available in the region.
         :paramtype cores_available: int
@@ -3563,15 +3584,15 @@
     :vartype available: list[str]
     """
 
     _attribute_map = {
         "available": {"key": "available", "type": "[str]"},
     }
 
-    def __init__(self, *, available: Optional[List[str]] = None, **kwargs):
+    def __init__(self, *, available: Optional[List[str]] = None, **kwargs: Any) -> None:
         """
         :keyword available: The list of region capabilities.
         :paramtype available: list[str]
         """
         super().__init__(**kwargs)
         self.available = available
 
@@ -3583,15 +3604,15 @@
     :vartype id: str
     """
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
     }
 
-    def __init__(self, *, id: Optional[str] = None, **kwargs):  # pylint: disable=redefined-builtin
+    def __init__(self, *, id: Optional[str] = None, **kwargs: Any) -> None:  # pylint: disable=redefined-builtin
         """
         :keyword id: The azure resource id.
         :paramtype id: str
         """
         super().__init__(**kwargs)
         self.id = id
 
@@ -3647,16 +3668,16 @@
         autoscale_configuration: Optional["_models.Autoscale"] = None,
         hardware_profile: Optional["_models.HardwareProfile"] = None,
         os_profile: Optional["_models.OsProfile"] = None,
         virtual_network_profile: Optional["_models.VirtualNetworkProfile"] = None,
         data_disks_groups: Optional[List["_models.DataDisksGroups"]] = None,
         script_actions: Optional[List["_models.ScriptAction"]] = None,
         encrypt_data_disks: bool = False,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name: The name of the role.
         :paramtype name: str
         :keyword min_instance_count: The minimum instance count of the cluster.
         :paramtype min_instance_count: int
         :keyword target_instance_count: The instance count of the cluster.
         :paramtype target_instance_count: int
@@ -3721,15 +3742,17 @@
         "name": {"key": "name", "type": "str"},
         "uri": {"key": "uri", "type": "str"},
         "parameters": {"key": "parameters", "type": "str"},
         "roles": {"key": "roles", "type": "[str]"},
         "application_name": {"key": "applicationName", "type": "str"},
     }
 
-    def __init__(self, *, name: str, uri: str, roles: List[str], parameters: Optional[str] = None, **kwargs):
+    def __init__(
+        self, *, name: str, uri: str, roles: List[str], parameters: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword name: The name of the script action. Required.
         :paramtype name: str
         :keyword uri: The URI to the script. Required.
         :paramtype uri: str
         :keyword parameters: The parameters for the script.
         :paramtype parameters: str
@@ -3802,15 +3825,17 @@
         "end_time": {"key": "endTime", "type": "str"},
         "status": {"key": "status", "type": "str"},
         "operation": {"key": "operation", "type": "str"},
         "execution_summary": {"key": "executionSummary", "type": "[ScriptActionExecutionSummary]"},
         "debug_information": {"key": "debugInformation", "type": "str"},
     }
 
-    def __init__(self, *, name: str, uri: str, roles: List[str], parameters: Optional[str] = None, **kwargs):
+    def __init__(
+        self, *, name: str, uri: str, roles: List[str], parameters: Optional[str] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword name: The name of the script action. Required.
         :paramtype name: str
         :keyword uri: The URI to the script. Required.
         :paramtype uri: str
         :keyword parameters: The parameters for the script.
         :paramtype parameters: str
@@ -3848,15 +3873,15 @@
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "uri": {"key": "uri", "type": "str"},
         "parameters": {"key": "parameters", "type": "str"},
     }
 
-    def __init__(self, *, name: str, uri: str, parameters: str, **kwargs):
+    def __init__(self, *, name: str, uri: str, parameters: str, **kwargs: Any) -> None:
         """
         :keyword name: The name of the script action. Required.
         :paramtype name: str
         :keyword uri: The URI to the script. Required.
         :paramtype uri: str
         :keyword parameters: The parameters for the script provided. Required.
         :paramtype parameters: str
@@ -3884,15 +3909,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[RuntimeScriptActionDetail]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.value = None
         self.next_link = None
 
 
 class ScriptActionExecutionSummary(_serialization.Model):
@@ -3912,15 +3937,15 @@
     }
 
     _attribute_map = {
         "status": {"key": "status", "type": "str"},
         "instance_count": {"key": "instanceCount", "type": "int"},
     }
 
-    def __init__(self, **kwargs):
+    def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.status = None
         self.instance_count = None
 
 
 class ScriptActionPersistedGetResponseSpec(_serialization.Model):
@@ -3950,16 +3975,16 @@
         self,
         *,
         name: Optional[str] = None,
         uri: Optional[str] = None,
         parameters: Optional[str] = None,
         roles: Optional[List[str]] = None,
         application_name: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name: The name of script action.
         :paramtype name: str
         :keyword uri: The URI to the script.
         :paramtype uri: str
         :keyword parameters: The parameters for the script provided.
         :paramtype parameters: str
@@ -3992,15 +4017,15 @@
     }
 
     _attribute_map = {
         "value": {"key": "value", "type": "[RuntimeScriptActionDetail]"},
         "next_link": {"key": "nextLink", "type": "str"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.RuntimeScriptActionDetail"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.RuntimeScriptActionDetail"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of persisted script action details for the cluster.
         :paramtype value: list[~azure.mgmt.hdinsight.models.RuntimeScriptActionDetail]
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = None
@@ -4051,16 +4076,16 @@
         organizational_unit_dn: Optional[str] = None,
         ldaps_urls: Optional[List[str]] = None,
         domain_username: Optional[str] = None,
         domain_user_password: Optional[str] = None,
         cluster_users_group_d_ns: Optional[List[str]] = None,
         aadds_resource_id: Optional[str] = None,
         msi_resource_id: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword directory_type: The directory type. "ActiveDirectory"
         :paramtype directory_type: str or ~azure.mgmt.hdinsight.models.DirectoryType
         :keyword domain: The organization's active directory domain.
         :paramtype domain: str
         :keyword organizational_unit_dn: The organizational unit within the Active Directory to place
          the cluster and service accounts.
@@ -4100,15 +4125,17 @@
     :vartype metric_specifications: list[~azure.mgmt.hdinsight.models.MetricSpecifications]
     """
 
     _attribute_map = {
         "metric_specifications": {"key": "metricSpecifications", "type": "[MetricSpecifications]"},
     }
 
-    def __init__(self, *, metric_specifications: Optional[List["_models.MetricSpecifications"]] = None, **kwargs):
+    def __init__(
+        self, *, metric_specifications: Optional[List["_models.MetricSpecifications"]] = None, **kwargs: Any
+    ) -> None:
         """
         :keyword metric_specifications: The metric specifications.
         :paramtype metric_specifications: list[~azure.mgmt.hdinsight.models.MetricSpecifications]
         """
         super().__init__(**kwargs)
         self.metric_specifications = metric_specifications
 
@@ -4120,15 +4147,15 @@
     :vartype public_keys: list[~azure.mgmt.hdinsight.models.SshPublicKey]
     """
 
     _attribute_map = {
         "public_keys": {"key": "publicKeys", "type": "[SshPublicKey]"},
     }
 
-    def __init__(self, *, public_keys: Optional[List["_models.SshPublicKey"]] = None, **kwargs):
+    def __init__(self, *, public_keys: Optional[List["_models.SshPublicKey"]] = None, **kwargs: Any) -> None:
         """
         :keyword public_keys: The list of SSH public keys.
         :paramtype public_keys: list[~azure.mgmt.hdinsight.models.SshPublicKey]
         """
         super().__init__(**kwargs)
         self.public_keys = public_keys
 
@@ -4140,15 +4167,15 @@
     :vartype certificate_data: str
     """
 
     _attribute_map = {
         "certificate_data": {"key": "certificateData", "type": "str"},
     }
 
-    def __init__(self, *, certificate_data: Optional[str] = None, **kwargs):
+    def __init__(self, *, certificate_data: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword certificate_data: The certificate for SSH.
         :paramtype certificate_data: str
         """
         super().__init__(**kwargs)
         self.certificate_data = certificate_data
 
@@ -4173,42 +4200,47 @@
     :ivar msi_resource_id: The managed identity (MSI) that is allowed to access the storage
      account, only to be specified for Azure Data Lake Storage Gen 2.
     :vartype msi_resource_id: str
     :ivar saskey: The shared access signature key.
     :vartype saskey: str
     :ivar fileshare: The file share name.
     :vartype fileshare: str
+    :ivar enable_secure_channel: Enable secure channel or not, it's an optional field. Default
+     value is false when cluster version < 5.1 and true when cluster version >= 5.1 ,.
+    :vartype enable_secure_channel: bool
     """
 
     _attribute_map = {
         "name": {"key": "name", "type": "str"},
         "is_default": {"key": "isDefault", "type": "bool"},
         "container": {"key": "container", "type": "str"},
         "file_system": {"key": "fileSystem", "type": "str"},
         "key": {"key": "key", "type": "str"},
         "resource_id": {"key": "resourceId", "type": "str"},
         "msi_resource_id": {"key": "msiResourceId", "type": "str"},
         "saskey": {"key": "saskey", "type": "str"},
         "fileshare": {"key": "fileshare", "type": "str"},
+        "enable_secure_channel": {"key": "enableSecureChannel", "type": "bool"},
     }
 
     def __init__(
         self,
         *,
         name: Optional[str] = None,
         is_default: Optional[bool] = None,
         container: Optional[str] = None,
         file_system: Optional[str] = None,
         key: Optional[str] = None,
         resource_id: Optional[str] = None,
         msi_resource_id: Optional[str] = None,
         saskey: Optional[str] = None,
         fileshare: Optional[str] = None,
-        **kwargs
-    ):
+        enable_secure_channel: Optional[bool] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name: The name of the storage account.
         :paramtype name: str
         :keyword is_default: Whether or not the storage account is the default storage account.
         :paramtype is_default: bool
         :keyword container: The container in the storage account, only to be specified for WASB storage
          accounts.
@@ -4223,39 +4255,43 @@
         :keyword msi_resource_id: The managed identity (MSI) that is allowed to access the storage
          account, only to be specified for Azure Data Lake Storage Gen 2.
         :paramtype msi_resource_id: str
         :keyword saskey: The shared access signature key.
         :paramtype saskey: str
         :keyword fileshare: The file share name.
         :paramtype fileshare: str
+        :keyword enable_secure_channel: Enable secure channel or not, it's an optional field. Default
+         value is false when cluster version < 5.1 and true when cluster version >= 5.1 ,.
+        :paramtype enable_secure_channel: bool
         """
         super().__init__(**kwargs)
         self.name = name
         self.is_default = is_default
         self.container = container
         self.file_system = file_system
         self.key = key
         self.resource_id = resource_id
         self.msi_resource_id = msi_resource_id
         self.saskey = saskey
         self.fileshare = fileshare
+        self.enable_secure_channel = enable_secure_channel
 
 
 class StorageProfile(_serialization.Model):
     """The storage profile.
 
     :ivar storageaccounts: The list of storage accounts in the cluster.
     :vartype storageaccounts: list[~azure.mgmt.hdinsight.models.StorageAccount]
     """
 
     _attribute_map = {
         "storageaccounts": {"key": "storageaccounts", "type": "[StorageAccount]"},
     }
 
-    def __init__(self, *, storageaccounts: Optional[List["_models.StorageAccount"]] = None, **kwargs):
+    def __init__(self, *, storageaccounts: Optional[List["_models.StorageAccount"]] = None, **kwargs: Any) -> None:
         """
         :keyword storageaccounts: The list of storage accounts in the cluster.
         :paramtype storageaccounts: list[~azure.mgmt.hdinsight.models.StorageAccount]
         """
         super().__init__(**kwargs)
         self.storageaccounts = storageaccounts
 
@@ -4293,16 +4329,16 @@
         *,
         created_by: Optional[str] = None,
         created_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
         created_at: Optional[datetime.datetime] = None,
         last_modified_by: Optional[str] = None,
         last_modified_by_type: Optional[Union[str, "_models.CreatedByType"]] = None,
         last_modified_at: Optional[datetime.datetime] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword created_by: The identity that created the resource.
         :paramtype created_by: str
         :keyword created_by_type: The type of identity that created the resource. Known values are:
          "User", "Application", "ManagedIdentity", and "Key".
         :paramtype created_by_type: str or ~azure.mgmt.hdinsight.models.CreatedByType
         :keyword created_at: The timestamp of resource creation (UTC).
@@ -4343,16 +4379,16 @@
 
     def __init__(
         self,
         *,
         application_id: Optional[str] = None,
         certificate: Optional[str] = None,
         certificate_password: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword application_id: The application id.
         :paramtype application_id: str
         :keyword certificate: The certificate in base64 encoded format.
         :paramtype certificate: str
         :keyword certificate_password: The password of the certificate.
         :paramtype certificate_password: str
@@ -4383,16 +4419,16 @@
 
     def __init__(
         self,
         *,
         is_credential_enabled: bool = True,
         user_name: Optional[str] = None,
         password: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword is_credential_enabled: Indicates whether or not the gateway settings based
          authorization is enabled.
         :paramtype is_credential_enabled: bool
         :keyword user_name: The gateway settings user name.
         :paramtype user_name: str
         :keyword password: The gateway settings user password.
@@ -4427,16 +4463,21 @@
         "unit": {"key": "unit", "type": "str"},
         "current_value": {"key": "currentValue", "type": "int"},
         "limit": {"key": "limit", "type": "int"},
         "name": {"key": "name", "type": "LocalizedName"},
     }
 
     def __init__(
-        self, *, unit: Optional[str] = None, current_value: Optional[int] = None, limit: Optional[int] = None, **kwargs
-    ):
+        self,
+        *,
+        unit: Optional[str] = None,
+        current_value: Optional[int] = None,
+        limit: Optional[int] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword unit: The type of measurement for usage.
         :paramtype unit: str
         :keyword current_value: The current usage.
         :paramtype current_value: int
         :keyword limit: The maximum allowed usage.
         :paramtype limit: int
@@ -4455,15 +4496,15 @@
     :vartype value: list[~azure.mgmt.hdinsight.models.Usage]
     """
 
     _attribute_map = {
         "value": {"key": "value", "type": "[Usage]"},
     }
 
-    def __init__(self, *, value: Optional[List["_models.Usage"]] = None, **kwargs):
+    def __init__(self, *, value: Optional[List["_models.Usage"]] = None, **kwargs: Any) -> None:
         """
         :keyword value: The list of usages.
         :paramtype value: list[~azure.mgmt.hdinsight.models.Usage]
         """
         super().__init__(**kwargs)
         self.value = value
 
@@ -4488,15 +4529,15 @@
 
     _attribute_map = {
         "principal_id": {"key": "principalId", "type": "str"},
         "client_id": {"key": "clientId", "type": "str"},
         "tenant_id": {"key": "tenantId", "type": "str"},
     }
 
-    def __init__(self, *, tenant_id: Optional[str] = None, **kwargs):
+    def __init__(self, *, tenant_id: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword tenant_id: The tenant id of user assigned identity.
         :paramtype tenant_id: str
         """
         super().__init__(**kwargs)
         self.principal_id = None
         self.client_id = None
@@ -4526,16 +4567,16 @@
     def __init__(
         self,
         *,
         code: Optional[str] = None,
         message: Optional[str] = None,
         error_resource: Optional[str] = None,
         message_arguments: Optional[List[str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword code: The error code.
         :paramtype code: str
         :keyword message: The error message.
         :paramtype message: str
         :keyword error_resource: The error resource.
         :paramtype error_resource: str
@@ -4556,15 +4597,15 @@
     :vartype available: list[~azure.mgmt.hdinsight.models.VersionSpec]
     """
 
     _attribute_map = {
         "available": {"key": "available", "type": "[VersionSpec]"},
     }
 
-    def __init__(self, *, available: Optional[List["_models.VersionSpec"]] = None, **kwargs):
+    def __init__(self, *, available: Optional[List["_models.VersionSpec"]] = None, **kwargs: Any) -> None:
         """
         :keyword available: The list of version capabilities.
         :paramtype available: list[~azure.mgmt.hdinsight.models.VersionSpec]
         """
         super().__init__(**kwargs)
         self.available = available
 
@@ -4592,16 +4633,16 @@
     def __init__(
         self,
         *,
         friendly_name: Optional[str] = None,
         display_name: Optional[str] = None,
         is_default: Optional[bool] = None,
         component_versions: Optional[Dict[str, str]] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword friendly_name: The friendly name.
         :paramtype friendly_name: str
         :keyword display_name: The display name.
         :paramtype display_name: str
         :keyword is_default: Whether or not the version is the default version.
         :paramtype is_default: bool
@@ -4626,29 +4667,37 @@
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "subnet": {"key": "subnet", "type": "str"},
     }
 
     def __init__(
-        self, *, id: Optional[str] = None, subnet: Optional[str] = None, **kwargs  # pylint: disable=redefined-builtin
-    ):
+        self,
+        *,
+        id: Optional[str] = None,  # pylint: disable=redefined-builtin
+        subnet: Optional[str] = None,
+        **kwargs: Any
+    ) -> None:
         """
         :keyword id: The ID of the virtual network.
         :paramtype id: str
         :keyword subnet: The name of the subnet.
         :paramtype subnet: str
         """
         super().__init__(**kwargs)
         self.id = id
         self.subnet = subnet
 
 
 class VmSizeCompatibilityFilterV2(_serialization.Model):
-    """This class represent a single filter object that defines a multidimensional set. The dimensions of this set are Regions, ClusterFlavors, NodeTypes and ClusterVersions. The constraint should be defined based on the following: FilterMode (Exclude vs Include), VMSizes (the vm sizes in affect of exclusion/inclusion) and the ordering of the Filters. Later filters override previous settings if conflicted.
+    """This class represent a single filter object that defines a multidimensional set. The dimensions
+    of this set are Regions, ClusterFlavors, NodeTypes and ClusterVersions. The constraint should
+    be defined based on the following: FilterMode (Exclude vs Include), VMSizes (the vm sizes in
+    affect of exclusion/inclusion) and the ordering of the Filters. Later filters override previous
+    settings if conflicted.
 
     :ivar filter_mode: The filtering mode. Effectively this can enabling or disabling the VM sizes
      in a particular set. Known values are: "Exclude", "Include", "Recommend", and "Default".
     :vartype filter_mode: str or ~azure.mgmt.hdinsight.models.FilterMode
     :ivar regions: The list of regions under the effect of the filter.
     :vartype regions: list[str]
     :ivar cluster_flavors: The list of cluster flavors under the effect of the filter.
@@ -4689,16 +4738,16 @@
         cluster_flavors: Optional[List[str]] = None,
         node_types: Optional[List[str]] = None,
         cluster_versions: Optional[List[str]] = None,
         os_type: Optional[List[Union[str, "_models.OSType"]]] = None,
         vm_sizes: Optional[List[str]] = None,
         esp_applied: Optional[str] = None,
         compute_isolation_supported: Optional[str] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword filter_mode: The filtering mode. Effectively this can enabling or disabling the VM
          sizes in a particular set. Known values are: "Exclude", "Include", "Recommend", and "Default".
         :paramtype filter_mode: str or ~azure.mgmt.hdinsight.models.FilterMode
         :keyword regions: The list of regions under the effect of the filter.
         :paramtype regions: list[str]
         :keyword cluster_flavors: The list of cluster flavors under the effect of the filter.
@@ -4781,16 +4830,16 @@
         label: Optional[str] = None,
         max_data_disk_count: Optional[int] = None,
         memory_in_mb: Optional[int] = None,
         supported_by_virtual_machines: Optional[bool] = None,
         supported_by_web_worker_roles: Optional[bool] = None,
         virtual_machine_resource_disk_size_in_mb: Optional[int] = None,
         web_worker_resource_disk_size_in_mb: Optional[int] = None,
-        **kwargs
-    ):
+        **kwargs: Any
+    ) -> None:
         """
         :keyword name: The vm size name.
         :paramtype name: str
         :keyword cores: The number of cores that the vm size has.
         :paramtype cores: int
         :keyword data_disk_storage_tier: The data disk storage tier of the vm size.
         :paramtype data_disk_storage_tier: str
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/models/_hd_insight_management_client_enums.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/models/_hd_insight_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/models/__init__.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/models/_patch.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/_configuration.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/_configuration.py`

 * *Files 23% similar despite different names*

```diff
@@ -2,52 +2,46 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
+from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
-from .._version import VERSION
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from ._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.credentials import TokenCredential
 
 
 class HDInsightManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for HDInsightManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
+    :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The subscription credentials which uniquely identify Microsoft Azure
      subscription. The subscription ID forms part of the URI for every service call. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2021-06-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2023-04-15-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(HDInsightManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2021-06-01"] = kwargs.pop("api_version", "2021-06-01")
+        api_version: str = kwargs.pop("api_version", "2023-04-15-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -59,15 +53,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
+            self.authentication_policy = ARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/__init__.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/_hd_insight_management_client.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/_hd_insight_management_client.py`

 * *Files 0% similar despite different names*

```diff
@@ -33,48 +33,48 @@
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class HDInsightManagementClient:  # pylint: disable=client-accepts-api-version-keyword,too-many-instance-attributes
     """HDInsight Management Client.
 
-    :ivar clusters: ClustersOperations operations
-    :vartype clusters: azure.mgmt.hdinsight.aio.operations.ClustersOperations
     :ivar applications: ApplicationsOperations operations
     :vartype applications: azure.mgmt.hdinsight.aio.operations.ApplicationsOperations
-    :ivar locations: LocationsOperations operations
-    :vartype locations: azure.mgmt.hdinsight.aio.operations.LocationsOperations
+    :ivar clusters: ClustersOperations operations
+    :vartype clusters: azure.mgmt.hdinsight.aio.operations.ClustersOperations
     :ivar configurations: ConfigurationsOperations operations
     :vartype configurations: azure.mgmt.hdinsight.aio.operations.ConfigurationsOperations
     :ivar extensions: ExtensionsOperations operations
     :vartype extensions: azure.mgmt.hdinsight.aio.operations.ExtensionsOperations
-    :ivar script_actions: ScriptActionsOperations operations
-    :vartype script_actions: azure.mgmt.hdinsight.aio.operations.ScriptActionsOperations
-    :ivar script_execution_history: ScriptExecutionHistoryOperations operations
-    :vartype script_execution_history:
-     azure.mgmt.hdinsight.aio.operations.ScriptExecutionHistoryOperations
+    :ivar locations: LocationsOperations operations
+    :vartype locations: azure.mgmt.hdinsight.aio.operations.LocationsOperations
     :ivar operations: Operations operations
     :vartype operations: azure.mgmt.hdinsight.aio.operations.Operations
-    :ivar virtual_machines: VirtualMachinesOperations operations
-    :vartype virtual_machines: azure.mgmt.hdinsight.aio.operations.VirtualMachinesOperations
     :ivar private_endpoint_connections: PrivateEndpointConnectionsOperations operations
     :vartype private_endpoint_connections:
      azure.mgmt.hdinsight.aio.operations.PrivateEndpointConnectionsOperations
     :ivar private_link_resources: PrivateLinkResourcesOperations operations
     :vartype private_link_resources:
      azure.mgmt.hdinsight.aio.operations.PrivateLinkResourcesOperations
+    :ivar script_actions: ScriptActionsOperations operations
+    :vartype script_actions: azure.mgmt.hdinsight.aio.operations.ScriptActionsOperations
+    :ivar script_execution_history: ScriptExecutionHistoryOperations operations
+    :vartype script_execution_history:
+     azure.mgmt.hdinsight.aio.operations.ScriptExecutionHistoryOperations
+    :ivar virtual_machines: VirtualMachinesOperations operations
+    :vartype virtual_machines: azure.mgmt.hdinsight.aio.operations.VirtualMachinesOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The subscription credentials which uniquely identify Microsoft Azure
      subscription. The subscription ID forms part of the URI for every service call. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2021-06-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2023-04-15-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
         self,
@@ -82,37 +82,37 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = HDInsightManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
-        self.clusters = ClustersOperations(self._client, self._config, self._serialize, self._deserialize)
         self.applications = ApplicationsOperations(self._client, self._config, self._serialize, self._deserialize)
-        self.locations = LocationsOperations(self._client, self._config, self._serialize, self._deserialize)
+        self.clusters = ClustersOperations(self._client, self._config, self._serialize, self._deserialize)
         self.configurations = ConfigurationsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.extensions = ExtensionsOperations(self._client, self._config, self._serialize, self._deserialize)
-        self.script_actions = ScriptActionsOperations(self._client, self._config, self._serialize, self._deserialize)
-        self.script_execution_history = ScriptExecutionHistoryOperations(
+        self.locations = LocationsOperations(self._client, self._config, self._serialize, self._deserialize)
+        self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
+        self.private_endpoint_connections = PrivateEndpointConnectionsOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
-        self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
-        self.virtual_machines = VirtualMachinesOperations(
+        self.private_link_resources = PrivateLinkResourcesOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
-        self.private_endpoint_connections = PrivateEndpointConnectionsOperations(
+        self.script_actions = ScriptActionsOperations(self._client, self._config, self._serialize, self._deserialize)
+        self.script_execution_history = ScriptExecutionHistoryOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
-        self.private_link_resources = PrivateLinkResourcesOperations(
+        self.virtual_machines = VirtualMachinesOperations(
             self._client, self._config, self._serialize, self._deserialize
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
@@ -137,9 +137,9 @@
     async def close(self) -> None:
         await self._client.close()
 
     async def __aenter__(self) -> "HDInsightManagementClient":
         await self._client.__aenter__()
         return self
 
-    async def __aexit__(self, *exc_details) -> None:
+    async def __aexit__(self, *exc_details: Any) -> None:
         await self._client.__aexit__(*exc_details)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/_patch.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_script_execution_history_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_script_execution_history_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -27,18 +26,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._script_execution_history_operations import build_list_by_cluster_request, build_promote_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ScriptExecutionHistoryOperations:
     """
     .. warning::
@@ -74,17 +69,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.hdinsight.models.RuntimeScriptActionDetail]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ScriptActionExecutionHistoryList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -130,16 +123,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -176,17 +170,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_promote_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             script_execution_id=script_execution_id,
             subscription_id=self._config.subscription_id,
@@ -194,16 +186,17 @@
             template_url=self.promote.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_private_link_resources_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_private_link_resources_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,18 +23,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._private_link_resources_operations import build_get_request, build_list_by_cluster_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class PrivateLinkResourcesOperations:
     """
     .. warning::
@@ -77,33 +72,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateLinkResourceListResult] = kwargs.pop("cls", None)
 
         request = build_list_by_cluster_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.list_by_cluster.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -144,17 +138,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateLinkResource] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             private_link_resource_name=private_link_resource_name,
             subscription_id=self._config.subscription_id,
@@ -162,16 +154,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_virtual_machines_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_virtual_machines_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -30,18 +30,14 @@
 from ..._vendor import _convert_request
 from ...operations._virtual_machines_operations import (
     build_get_async_operation_status_request,
     build_list_hosts_request,
     build_restart_hosts_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class VirtualMachinesOperations:
     """
     .. warning::
@@ -81,33 +77,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[List[_models.HostInfo]] = kwargs.pop("cls", None)
 
         request = build_list_hosts_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.list_hosts.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -134,24 +129,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(hosts, (IO, bytes)):
+        if isinstance(hosts, (IOBase, bytes)):
             _content = hosts
         else:
             _json = self._serialize.body(hosts, "[str]")
 
         request = build_restart_hosts_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -163,16 +156,17 @@
             template_url=self._restart_hosts_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -259,15 +253,15 @@
     ) -> AsyncLROPoller[None]:
         """Restarts the specified HDInsight cluster hosts.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
-        :param hosts: The list of hosts to restart. Is either a list type or a IO type. Required.
+        :param hosts: The list of hosts to restart. Is either a [str] type or a IO type. Required.
         :type hosts: list[str] or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -279,17 +273,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._restart_hosts_initial(  # type: ignore
@@ -354,17 +346,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AsyncOperationResult] = kwargs.pop("cls", None)
 
         request = build_get_async_operation_status_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
@@ -372,16 +362,17 @@
             template_url=self.get_async_operation_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
@@ -65,17 +60,15 @@
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.hdinsight.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -118,16 +111,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/__init__.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/__init__.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -2,38 +2,38 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-from ._clusters_operations import ClustersOperations
 from ._applications_operations import ApplicationsOperations
-from ._locations_operations import LocationsOperations
+from ._clusters_operations import ClustersOperations
 from ._configurations_operations import ConfigurationsOperations
 from ._extensions_operations import ExtensionsOperations
-from ._script_actions_operations import ScriptActionsOperations
-from ._script_execution_history_operations import ScriptExecutionHistoryOperations
+from ._locations_operations import LocationsOperations
 from ._operations import Operations
-from ._virtual_machines_operations import VirtualMachinesOperations
 from ._private_endpoint_connections_operations import PrivateEndpointConnectionsOperations
 from ._private_link_resources_operations import PrivateLinkResourcesOperations
+from ._script_actions_operations import ScriptActionsOperations
+from ._script_execution_history_operations import ScriptExecutionHistoryOperations
+from ._virtual_machines_operations import VirtualMachinesOperations
 
 from ._patch import __all__ as _patch_all
 from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
-    "ClustersOperations",
     "ApplicationsOperations",
-    "LocationsOperations",
+    "ClustersOperations",
     "ConfigurationsOperations",
     "ExtensionsOperations",
-    "ScriptActionsOperations",
-    "ScriptExecutionHistoryOperations",
+    "LocationsOperations",
     "Operations",
-    "VirtualMachinesOperations",
     "PrivateEndpointConnectionsOperations",
     "PrivateLinkResourcesOperations",
+    "ScriptActionsOperations",
+    "ScriptExecutionHistoryOperations",
+    "VirtualMachinesOperations",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_locations_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_locations_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -31,18 +31,14 @@
     build_get_azure_async_operation_status_request,
     build_get_capabilities_request,
     build_list_billing_specs_request,
     build_list_usages_request,
     build_validate_cluster_create_request_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class LocationsOperations:
     """
     .. warning::
@@ -80,32 +76,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.CapabilitiesResult] = kwargs.pop("cls", None)
 
         request = build_get_capabilities_request(
             location=location,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_capabilities.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -140,32 +135,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.UsagesListResult] = kwargs.pop("cls", None)
 
         request = build_list_usages_request(
             location=location,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.list_usages.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -200,32 +194,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.BillingResponseListResult] = kwargs.pop("cls", None)
 
         request = build_list_billing_specs_request(
             location=location,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.list_billing_specs.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -264,33 +257,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AsyncOperationResult] = kwargs.pop("cls", None)
 
         request = build_get_azure_async_operation_status_request(
             location=location,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_azure_async_operation_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -354,15 +346,16 @@
     async def check_name_availability(
         self, location: str, parameters: Union[_models.NameAvailabilityCheckRequestParameters, IO], **kwargs: Any
     ) -> _models.NameAvailabilityCheckResult:
         """Check the cluster name is available or not.
 
         :param location: The Azure location (region) for which to make the request. Required.
         :type location: str
-        :param parameters: Is either a model type or a IO type. Required.
+        :param parameters: Is either a NameAvailabilityCheckRequestParameters type or a IO type.
+         Required.
         :type parameters: ~azure.mgmt.hdinsight.models.NameAvailabilityCheckRequestParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: NameAvailabilityCheckResult or the result of cls(response)
         :rtype: ~azure.mgmt.hdinsight.models.NameAvailabilityCheckResult
@@ -375,24 +368,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.NameAvailabilityCheckResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "NameAvailabilityCheckRequestParameters")
 
         request = build_check_name_availability_request(
             location=location,
             subscription_id=self._config.subscription_id,
@@ -403,16 +394,17 @@
             template_url=self.check_name_availability.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -476,15 +468,16 @@
     async def validate_cluster_create_request(
         self, location: str, parameters: Union[_models.ClusterCreateRequestValidationParameters, IO], **kwargs: Any
     ) -> _models.ClusterCreateValidationResult:
         """Validate the cluster create request spec is valid or not.
 
         :param location: The Azure location (region) for which to make the request. Required.
         :type location: str
-        :param parameters: Is either a model type or a IO type. Required.
+        :param parameters: Is either a ClusterCreateRequestValidationParameters type or a IO type.
+         Required.
         :type parameters: ~azure.mgmt.hdinsight.models.ClusterCreateRequestValidationParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ClusterCreateValidationResult or the result of cls(response)
         :rtype: ~azure.mgmt.hdinsight.models.ClusterCreateValidationResult
@@ -497,24 +490,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ClusterCreateValidationResult] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ClusterCreateRequestValidationParameters")
 
         request = build_validate_cluster_create_request_request(
             location=location,
             subscription_id=self._config.subscription_id,
@@ -525,16 +516,17 @@
             template_url=self.validate_cluster_create_request.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_extensions_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_extensions_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -37,18 +37,14 @@
     build_enable_monitoring_request,
     build_get_azure_async_operation_status_request,
     build_get_azure_monitor_status_request,
     build_get_monitoring_status_request,
     build_get_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ExtensionsOperations:
     """
     .. warning::
@@ -82,24 +78,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ClusterMonitoringRequest")
 
         request = build_enable_monitoring_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -111,16 +105,17 @@
             template_url=self._enable_monitoring_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -212,15 +207,15 @@
         """Enables the Operations Management Suite (OMS) on the HDInsight cluster.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
         :param parameters: The Operations Management Suite (OMS) workspace parameters. Is either a
-         model type or a IO type. Required.
+         ClusterMonitoringRequest type or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.ClusterMonitoringRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -232,17 +227,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._enable_monitoring_initial(  # type: ignore
@@ -305,33 +298,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ClusterMonitoringResponse] = kwargs.pop("cls", None)
 
         request = build_get_monitoring_status_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_monitoring_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -358,33 +350,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_disable_monitoring_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._disable_monitoring_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -418,17 +409,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._disable_monitoring_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -480,24 +469,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "AzureMonitorRequest")
 
         request = build_enable_azure_monitor_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -509,16 +496,17 @@
             template_url=self._enable_azure_monitor_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -609,16 +597,16 @@
     ) -> AsyncLROPoller[None]:
         """Enables the Azure Monitor on the HDInsight cluster.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
-        :param parameters: The Log Analytics workspace parameters. Is either a model type or a IO type.
-         Required.
+        :param parameters: The Log Analytics workspace parameters. Is either a AzureMonitorRequest type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.AzureMonitorRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -630,17 +618,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._enable_azure_monitor_initial(  # type: ignore
@@ -703,33 +689,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AzureMonitorResponse] = kwargs.pop("cls", None)
 
         request = build_get_azure_monitor_status_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_azure_monitor_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -756,33 +741,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_disable_azure_monitor_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._disable_azure_monitor_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -816,17 +800,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._disable_azure_monitor_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -879,24 +861,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Extension")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -909,16 +889,17 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1018,16 +999,16 @@
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
         :param extension_name: The name of the cluster extension. Required.
         :type extension_name: str
-        :param parameters: The cluster extensions create request. Is either a model type or a IO type.
-         Required.
+        :param parameters: The cluster extensions create request. Is either a Extension type or a IO
+         type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.Extension or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -1039,17 +1020,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(  # type: ignore
@@ -1115,17 +1094,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ClusterMonitoringResponse] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             extension_name=extension_name,
             subscription_id=self._config.subscription_id,
@@ -1133,16 +1110,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1169,17 +1147,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             extension_name=extension_name,
             subscription_id=self._config.subscription_id,
@@ -1187,16 +1163,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1232,17 +1209,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1307,17 +1282,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AsyncOperationResult] = kwargs.pop("cls", None)
 
         request = build_get_azure_async_operation_status_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             extension_name=extension_name,
             operation_id=operation_id,
@@ -1326,16 +1299,17 @@
             template_url=self.get_azure_async_operation_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_configurations_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_configurations_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,18 +26,14 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._configurations_operations import build_get_request, build_list_request, build_update_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ConfigurationsOperations:
     """
     .. warning::
@@ -77,33 +73,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ClusterConfigurations] = kwargs.pop("cls", None)
 
         request = build_list_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.list.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -135,24 +130,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "{str}")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -165,16 +158,17 @@
             template_url=self._update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -277,15 +271,16 @@
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
         :param configuration_name: The name of the cluster configuration. Required.
         :type configuration_name: str
-        :param parameters: The cluster configurations. Is either a dict type or a IO type. Required.
+        :param parameters: The cluster configurations. Is either a {str: str} type or a IO type.
+         Required.
         :type parameters: dict[str, str] or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -297,17 +292,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_initial(  # type: ignore
@@ -374,17 +367,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[Dict[str, str]] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             configuration_name=configuration_name,
             subscription_id=self._config.subscription_id,
@@ -392,16 +383,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_patch.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_applications_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_applications_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -35,18 +35,14 @@
     build_create_request,
     build_delete_request,
     build_get_azure_async_operation_status_request,
     build_get_request,
     build_list_by_cluster_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ApplicationsOperations:
     """
     .. warning::
@@ -80,17 +76,15 @@
         :return: An iterator like instance of either Application or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.hdinsight.models.Application]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ApplicationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -136,16 +130,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -182,17 +177,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Application] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             application_name=application_name,
             subscription_id=self._config.subscription_id,
@@ -200,16 +193,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -241,24 +235,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Application] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Application")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -271,16 +263,17 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -386,15 +379,15 @@
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
         :param application_name: The constant value for the application name. Required.
         :type application_name: str
-        :param parameters: The application create request. Is either a model type or a IO type.
+        :param parameters: The application create request. Is either a Application type or a IO type.
          Required.
         :type parameters: ~azure.mgmt.hdinsight.models.Application or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
@@ -408,17 +401,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.hdinsight.models.Application]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Application] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
@@ -472,17 +463,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             application_name=application_name,
             subscription_id=self._config.subscription_id,
@@ -490,16 +479,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -535,17 +525,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -610,17 +598,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AsyncOperationResult] = kwargs.pop("cls", None)
 
         request = build_get_azure_async_operation_status_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             application_name=application_name,
             operation_id=operation_id,
@@ -629,16 +615,17 @@
             template_url=self.get_azure_async_operation_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_clusters_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_clusters_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -44,18 +44,14 @@
     build_rotate_disk_encryption_key_request,
     build_update_auto_scale_configuration_request,
     build_update_gateway_settings_request,
     build_update_identity_certificate_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ClustersOperations:  # pylint: disable=too-many-public-methods
     """
     .. warning::
@@ -89,24 +85,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ClusterCreateParametersExtended")
 
         request = build_create_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -118,16 +112,17 @@
             template_url=self._create_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -224,15 +219,16 @@
     ) -> AsyncLROPoller[_models.Cluster]:
         """Creates a new HDInsight cluster with the specified parameters.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
-        :param parameters: The cluster create request. Is either a model type or a IO type. Required.
+        :param parameters: The cluster create request. Is either a ClusterCreateParametersExtended type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.ClusterCreateParametersExtended or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -245,17 +241,15 @@
          cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.hdinsight.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_initial(
@@ -362,15 +356,16 @@
     ) -> _models.Cluster:
         """Patch HDInsight cluster with the specified parameters.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
-        :param parameters: The cluster patch request. Is either a model type or a IO type. Required.
+        :param parameters: The cluster patch request. Is either a ClusterPatchParameters type or a IO
+         type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.ClusterPatchParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Cluster or the result of cls(response)
         :rtype: ~azure.mgmt.hdinsight.models.Cluster
@@ -383,24 +378,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ClusterPatchParameters")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -412,16 +405,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -448,33 +442,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -506,17 +499,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -574,33 +565,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Cluster] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -627,17 +617,15 @@
         :return: An iterator like instance of either Cluster or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.hdinsight.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ClusterListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -682,16 +670,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -719,24 +708,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ClusterResizeParameters")
 
         request = build_resize_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -749,16 +736,17 @@
             template_url=self._resize_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -858,16 +846,16 @@
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
         :param role_name: The constant value for the roleName. "workernode" Required.
         :type role_name: str or ~azure.mgmt.hdinsight.models.RoleName
-        :param parameters: The parameters for the resize operation. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for the resize operation. Is either a ClusterResizeParameters
+         type or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.ClusterResizeParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -879,17 +867,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._resize_initial(  # type: ignore
@@ -946,24 +932,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "AutoscaleConfigurationUpdateParameter")
 
         request = build_update_auto_scale_configuration_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -976,16 +960,17 @@
             template_url=self._update_auto_scale_configuration_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1086,15 +1071,15 @@
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
         :param role_name: The constant value for the roleName. "workernode" Required.
         :type role_name: str or ~azure.mgmt.hdinsight.models.RoleName
         :param parameters: The parameters for the update autoscale configuration operation. Is either a
-         model type or a IO type. Required.
+         AutoscaleConfigurationUpdateParameter type or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.AutoscaleConfigurationUpdateParameter or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -1106,17 +1091,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_auto_scale_configuration_initial(  # type: ignore
@@ -1166,17 +1149,15 @@
         :return: An iterator like instance of either Cluster or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.hdinsight.models.Cluster]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ClusterListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1220,16 +1201,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -1254,24 +1236,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ClusterDiskEncryptionParameters")
 
         request = build_rotate_disk_encryption_key_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1283,16 +1263,17 @@
             template_url=self._rotate_disk_encryption_key_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1383,16 +1364,16 @@
     ) -> AsyncLROPoller[None]:
         """Rotate disk encryption key of the specified HDInsight cluster.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
-        :param parameters: The parameters for the disk encryption operation. Is either a model type or
-         a IO type. Required.
+        :param parameters: The parameters for the disk encryption operation. Is either a
+         ClusterDiskEncryptionParameters type or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.ClusterDiskEncryptionParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -1404,17 +1385,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._rotate_disk_encryption_key_initial(  # type: ignore
@@ -1477,33 +1456,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.GatewaySettings] = kwargs.pop("cls", None)
 
         request = build_get_gateway_settings_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_gateway_settings.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1534,24 +1512,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "UpdateGatewaySettingsParameters")
 
         request = build_update_gateway_settings_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1563,16 +1539,17 @@
             template_url=self._update_gateway_settings_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1663,15 +1640,16 @@
     ) -> AsyncLROPoller[None]:
         """Configures the gateway settings on the specified cluster.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
-        :param parameters: The cluster configurations. Is either a model type or a IO type. Required.
+        :param parameters: The cluster configurations. Is either a UpdateGatewaySettingsParameters type
+         or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.UpdateGatewaySettingsParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -1683,17 +1661,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_gateway_settings_initial(  # type: ignore
@@ -1758,17 +1734,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AsyncOperationResult] = kwargs.pop("cls", None)
 
         request = build_get_azure_async_operation_status_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
@@ -1776,16 +1750,17 @@
             template_url=self.get_azure_async_operation_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1816,24 +1791,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "UpdateClusterIdentityCertificateParameters")
 
         request = build_update_identity_certificate_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -1845,16 +1818,17 @@
             template_url=self._update_identity_certificate_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1945,15 +1919,16 @@
     ) -> AsyncLROPoller[None]:
         """Updates the cluster identity certificate.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
-        :param parameters: The cluster configurations. Is either a model type or a IO type. Required.
+        :param parameters: The cluster configurations. Is either a
+         UpdateClusterIdentityCertificateParameters type or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.UpdateClusterIdentityCertificateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -1965,17 +1940,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._update_identity_certificate_initial(  # type: ignore
@@ -2030,24 +2003,22 @@
             404: lambda response: ResourceNotFoundError(response=response, error_format=ARMErrorFormat),
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "ExecuteScriptActionParameters")
 
         request = build_execute_script_actions_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -2059,16 +2030,17 @@
             template_url=self._execute_script_actions_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -2159,16 +2131,16 @@
     ) -> AsyncLROPoller[None]:
         """Executes script actions on the specified HDInsight cluster.
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
-        :param parameters: The parameters for executing script actions. Is either a model type or a IO
-         type. Required.
+        :param parameters: The parameters for executing script actions. Is either a
+         ExecuteScriptActionParameters type or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.ExecuteScriptActionParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -2180,17 +2152,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._execute_script_actions_initial(  # type: ignore
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_private_endpoint_connections_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_private_endpoint_connections_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -34,18 +34,14 @@
 from ...operations._private_endpoint_connections_operations import (
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_list_by_cluster_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class PrivateEndpointConnectionsOperations:
     """
     .. warning::
@@ -81,17 +77,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.hdinsight.models.PrivateEndpointConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateEndpointConnectionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -137,16 +131,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -174,24 +169,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "PrivateEndpointConnection")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
@@ -204,16 +197,17 @@
             template_url=self._create_or_update_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -325,16 +319,16 @@
 
         :param resource_group_name: The name of the resource group. Required.
         :type resource_group_name: str
         :param cluster_name: The name of the cluster. Required.
         :type cluster_name: str
         :param private_endpoint_connection_name: The name of the private endpoint connection. Required.
         :type private_endpoint_connection_name: str
-        :param parameters: The private endpoint connection create or update request. Is either a model
-         type or a IO type. Required.
+        :param parameters: The private endpoint connection create or update request. Is either a
+         PrivateEndpointConnection type or a IO type. Required.
         :type parameters: ~azure.mgmt.hdinsight.models.PrivateEndpointConnection or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :keyword str continuation_token: A continuation token to restart a poller from a saved state.
         :keyword polling: By default, your polling method will be AsyncARMPolling. Pass in False for
@@ -348,17 +342,15 @@
         :rtype:
          ~azure.core.polling.AsyncLROPoller[~azure.mgmt.hdinsight.models.PrivateEndpointConnection]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._create_or_update_initial(
@@ -427,17 +419,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.PrivateEndpointConnection] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             private_endpoint_connection_name=private_endpoint_connection_name,
             subscription_id=self._config.subscription_id,
@@ -445,16 +435,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -481,17 +472,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             private_endpoint_connection_name=private_endpoint_connection_name,
             subscription_id=self._config.subscription_id,
@@ -499,16 +488,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -544,17 +534,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-hdinsight-9.0.0b1/azure/mgmt/hdinsight/aio/operations/_script_actions_operations.py` & `azure-mgmt-hdinsight-9.0.0b2/azure/mgmt/hdinsight/aio/operations/_script_actions_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -32,18 +31,14 @@
 from ...operations._script_actions_operations import (
     build_delete_request,
     build_get_execution_async_operation_status_request,
     build_get_execution_detail_request,
     build_list_by_cluster_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ScriptActionsOperations:
     """
     .. warning::
@@ -87,17 +82,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             script_name=script_name,
             subscription_id=self._config.subscription_id,
@@ -105,16 +98,17 @@
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -143,17 +137,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.hdinsight.models.RuntimeScriptActionDetail]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ScriptActionsList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -199,16 +191,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -245,17 +238,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.RuntimeScriptActionDetail] = kwargs.pop("cls", None)
 
         request = build_get_execution_detail_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             script_execution_id=script_execution_id,
             subscription_id=self._config.subscription_id,
@@ -263,16 +254,17 @@
             template_url=self.get_execution_detail.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -313,17 +305,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-06-01"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AsyncOperationResult] = kwargs.pop("cls", None)
 
         request = build_get_execution_async_operation_status_request(
             resource_group_name=resource_group_name,
             cluster_name=cluster_name,
             operation_id=operation_id,
             subscription_id=self._config.subscription_id,
@@ -331,16 +321,17 @@
             template_url=self.get_execution_async_operation_status.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

