# Comparing `tmp/xpressinsight-1.6.0.post1-py3-none-any.whl.zip` & `tmp/xpressinsight-1.7.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,40 +1,41 @@
-Zip file size: 143602 bytes, number of entries: 38
--rw-r--r--  2.0 unx     1399 b- defN 23-May-25 14:59 xpressinsight/__init__.py
--rw-r--r--  2.0 unx    23740 b- defN 23-May-25 14:59 xpressinsight/app_base.py
--rw-r--r--  2.0 unx     5149 b- defN 23-May-25 14:59 xpressinsight/app_runner.py
--rw-r--r--  2.0 unx    15730 b- defN 23-May-25 14:59 xpressinsight/code_generator.py
--rw-r--r--  2.0 unx    50601 b- defN 23-May-25 14:59 xpressinsight/entities.py
--rw-r--r--  2.0 unx    12929 b- defN 23-May-25 14:59 xpressinsight/exec_mode.py
--rw-r--r--  2.0 unx    83806 b- defN 23-May-25 14:59 xpressinsight/interface.py
--rw-r--r--  2.0 unx    17187 b- defN 23-May-25 14:59 xpressinsight/interface_rest.py
--rw-r--r--  2.0 unx    55004 b- defN 23-May-25 14:59 xpressinsight/interface_test.py
--rw-r--r--  2.0 unx    61835 b- defN 23-May-25 14:59 xpressinsight/mosel_keywords.py
--rw-r--r--  2.0 unx     6426 b- defN 23-May-25 14:59 xpressinsight/parquet_connector.py
--rw-r--r--  2.0 unx    11555 b- defN 23-May-25 14:59 xpressinsight/repository_path.py
--rw-r--r--  2.0 unx     5341 b- defN 23-May-25 14:59 xpressinsight/sqlite_connector.py
--rw-r--r--  2.0 unx    22740 b- defN 23-May-25 14:59 xpressinsight/table_connector.py
--rw-r--r--  2.0 unx    12020 b- defN 23-May-25 14:59 xpressinsight/test_runner.py
--rw-r--r--  2.0 unx     1678 b- defN 23-May-25 14:59 xpressinsight/rest/__init__.py
--rw-r--r--  2.0 unx    25253 b- defN 23-May-25 14:59 xpressinsight/rest/api_client.py
--rw-r--r--  2.0 unx    13369 b- defN 23-May-25 14:59 xpressinsight/rest/configuration.py
--rw-r--r--  2.0 unx     4161 b- defN 23-May-25 14:59 xpressinsight/rest/exceptions.py
--rw-r--r--  2.0 unx    11711 b- defN 23-May-25 14:59 xpressinsight/rest/rest.py
--rw-r--r--  2.0 unx      103 b- defN 23-May-25 14:59 xpressinsight/rest/api/__init__.py
--rw-r--r--  2.0 unx   143245 b- defN 23-May-25 14:59 xpressinsight/rest/api/default_api.py
--rw-r--r--  2.0 unx     1200 b- defN 23-May-25 14:59 xpressinsight/rest/models/__init__.py
--rw-r--r--  2.0 unx     3710 b- defN 23-May-25 14:59 xpressinsight/rest/models/attach_status.py
--rw-r--r--  2.0 unx     8739 b- defN 23-May-25 14:59 xpressinsight/rest/models/attachment.py
--rw-r--r--  2.0 unx     8047 b- defN 23-May-25 14:59 xpressinsight/rest/models/attachment_rules.py
--rw-r--r--  2.0 unx     6297 b- defN 23-May-25 14:59 xpressinsight/rest/models/attachment_tag.py
--rw-r--r--  2.0 unx     4430 b- defN 23-May-25 14:59 xpressinsight/rest/models/insight_context.py
--rw-r--r--  2.0 unx    11525 b- defN 23-May-25 14:59 xpressinsight/rest/models/insight_dmp_context.py
--rw-r--r--  2.0 unx     6321 b- defN 23-May-25 14:59 xpressinsight/rest/models/item_info.py
--rw-r--r--  2.0 unx     3132 b- defN 23-May-25 14:59 xpressinsight/rest/models/status.py
--rw-r--r--  2.0 unx      719 b- defN 23-May-25 14:59 xpressinsight/types/__init__.py
--rw-r--r--  2.0 unx    15667 b- defN 23-May-25 14:59 xpressinsight/types/helpers.py
--rw-r--r--  2.0 unx    47346 b- defN 23-May-25 14:59 xpressinsight-1.6.0.post1.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx     7170 b- defN 23-May-25 14:59 xpressinsight-1.6.0.post1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-25 14:59 xpressinsight-1.6.0.post1.dist-info/WHEEL
--rw-r--r--  2.0 unx       14 b- defN 23-May-25 14:59 xpressinsight-1.6.0.post1.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     3443 b- defN 23-May-25 14:59 xpressinsight-1.6.0.post1.dist-info/RECORD
-38 files, 712834 bytes uncompressed, 138056 bytes compressed:  80.6%
+Zip file size: 147831 bytes, number of entries: 39
+-rw-r--r--  2.0 unx     1415 b- defN 23-Jul-19 14:14 xpressinsight/__init__.py
+-rw-r--r--  2.0 unx    23740 b- defN 23-Jul-19 14:14 xpressinsight/app_base.py
+-rw-r--r--  2.0 unx     5149 b- defN 23-Jul-19 14:14 xpressinsight/app_runner.py
+-rw-r--r--  2.0 unx    15718 b- defN 23-Jul-19 14:14 xpressinsight/code_generator.py
+-rw-r--r--  2.0 unx    50688 b- defN 23-Jul-19 14:14 xpressinsight/entities.py
+-rw-r--r--  2.0 unx    12929 b- defN 23-Jul-19 14:14 xpressinsight/exec_mode.py
+-rw-r--r--  2.0 unx    87658 b- defN 23-Jul-19 14:14 xpressinsight/interface.py
+-rw-r--r--  2.0 unx    19690 b- defN 23-Jul-19 14:14 xpressinsight/interface_rest.py
+-rw-r--r--  2.0 unx    56613 b- defN 23-Jul-19 14:14 xpressinsight/interface_test.py
+-rw-r--r--  2.0 unx    61835 b- defN 23-Jul-19 14:14 xpressinsight/mosel_keywords.py
+-rw-r--r--  2.0 unx     6426 b- defN 23-Jul-19 14:14 xpressinsight/parquet_connector.py
+-rw-r--r--  2.0 unx    11555 b- defN 23-Jul-19 14:14 xpressinsight/repository_path.py
+-rw-r--r--  2.0 unx     5341 b- defN 23-Jul-19 14:14 xpressinsight/sqlite_connector.py
+-rw-r--r--  2.0 unx    22740 b- defN 23-Jul-19 14:14 xpressinsight/table_connector.py
+-rw-r--r--  2.0 unx    12051 b- defN 23-Jul-19 14:14 xpressinsight/test_runner.py
+-rw-r--r--  2.0 unx     1752 b- defN 23-Jul-19 14:14 xpressinsight/rest/__init__.py
+-rw-r--r--  2.0 unx    25255 b- defN 23-Jul-19 14:14 xpressinsight/rest/api_client.py
+-rw-r--r--  2.0 unx    13371 b- defN 23-Jul-19 14:14 xpressinsight/rest/configuration.py
+-rw-r--r--  2.0 unx     4163 b- defN 23-Jul-19 14:14 xpressinsight/rest/exceptions.py
+-rw-r--r--  2.0 unx    11713 b- defN 23-Jul-19 14:14 xpressinsight/rest/rest.py
+-rw-r--r--  2.0 unx      103 b- defN 23-Jul-19 14:14 xpressinsight/rest/api/__init__.py
+-rw-r--r--  2.0 unx   150291 b- defN 23-Jul-19 14:14 xpressinsight/rest/api/default_api.py
+-rw-r--r--  2.0 unx     1275 b- defN 23-Jul-19 14:14 xpressinsight/rest/models/__init__.py
+-rw-r--r--  2.0 unx     3712 b- defN 23-Jul-19 14:14 xpressinsight/rest/models/attach_status.py
+-rw-r--r--  2.0 unx     8741 b- defN 23-Jul-19 14:14 xpressinsight/rest/models/attachment.py
+-rw-r--r--  2.0 unx     8049 b- defN 23-Jul-19 14:14 xpressinsight/rest/models/attachment_rules.py
+-rw-r--r--  2.0 unx     6299 b- defN 23-Jul-19 14:14 xpressinsight/rest/models/attachment_tag.py
+-rw-r--r--  2.0 unx     4432 b- defN 23-Jul-19 14:14 xpressinsight/rest/models/insight_context.py
+-rw-r--r--  2.0 unx    11527 b- defN 23-Jul-19 14:14 xpressinsight/rest/models/insight_dmp_context.py
+-rw-r--r--  2.0 unx     6323 b- defN 23-Jul-19 14:14 xpressinsight/rest/models/item_info.py
+-rw-r--r--  2.0 unx     8292 b- defN 23-Jul-19 14:14 xpressinsight/rest/models/solution_database.py
+-rw-r--r--  2.0 unx     3134 b- defN 23-Jul-19 14:14 xpressinsight/rest/models/status.py
+-rw-r--r--  2.0 unx      713 b- defN 23-Jul-19 14:14 xpressinsight/types/__init__.py
+-rw-r--r--  2.0 unx    15667 b- defN 23-Jul-19 14:14 xpressinsight/types/helpers.py
+-rw-r--r--  2.0 unx    47346 b- defN 23-Jul-19 14:14 xpressinsight-1.7.1.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx     7971 b- defN 23-Jul-19 14:14 xpressinsight-1.7.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-19 14:14 xpressinsight-1.7.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       14 b- defN 23-Jul-19 14:14 xpressinsight-1.7.1.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     3516 b- defN 23-Jul-19 14:14 xpressinsight-1.7.1.dist-info/RECORD
+39 files, 737299 bytes uncompressed, 142177 bytes compressed:  80.7%
```

## zipnote {}

```diff
@@ -84,32 +84,35 @@
 
 Filename: xpressinsight/rest/models/insight_dmp_context.py
 Comment: 
 
 Filename: xpressinsight/rest/models/item_info.py
 Comment: 
 
+Filename: xpressinsight/rest/models/solution_database.py
+Comment: 
+
 Filename: xpressinsight/rest/models/status.py
 Comment: 
 
 Filename: xpressinsight/types/__init__.py
 Comment: 
 
 Filename: xpressinsight/types/helpers.py
 Comment: 
 
-Filename: xpressinsight-1.6.0.post1.dist-info/LICENSE.txt
+Filename: xpressinsight-1.7.1.dist-info/LICENSE.txt
 Comment: 
 
-Filename: xpressinsight-1.6.0.post1.dist-info/METADATA
+Filename: xpressinsight-1.7.1.dist-info/METADATA
 Comment: 
 
-Filename: xpressinsight-1.6.0.post1.dist-info/WHEEL
+Filename: xpressinsight-1.7.1.dist-info/WHEEL
 Comment: 
 
-Filename: xpressinsight-1.6.0.post1.dist-info/top_level.txt
+Filename: xpressinsight-1.7.1.dist-info/top_level.txt
 Comment: 
 
-Filename: xpressinsight-1.6.0.post1.dist-info/RECORD
+Filename: xpressinsight-1.7.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## xpressinsight/__init__.py

```diff
@@ -12,15 +12,15 @@
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
 #
 
 #
-__version__ = '1.6.0.post1'
+__version__ = '1.7.1'
 
 from .exec_mode import ExecMode, ExecModeRun, ExecModeLoad
 from .entities import (
     ResultData, ResultDataDelete, Manage, Hidden,
     BasicType,
     boolean, integer, string, real,
     EntityBase,
@@ -35,14 +35,15 @@
     AttachTagUsage,
     AppInterface,
     ItemInfo,
     ObjSense,
     Metric,
     InsightContext,
     InsightDmpContext,
+    SolutionDatabase,
     InterfaceError,
 )
 from .interface_test import (
     read_attach_info,
     write_attach_info,
 )
 from .repository_path import RepositoryPath
```

## xpressinsight/app_runner.py

```diff
@@ -124,15 +124,15 @@
         exit_msg(-1, 'app_runner.run: Parameter test_mode="{}" must be a bool.'.format(test_mode))
 
     #
     app_type = import_app(app_source_dir, app_package_name)
     app_type.get_app_cfg()._work_dir = work_dir
     app_type.get_app_cfg()._test_mode = test_mode
 
-    if apprunner_version is None or apprunner_version < '1.6.0':
+    if apprunner_version is None or apprunner_version < '1.7.1':
         print("ERROR: Old version of Xpress Insight server detected. Please upgrade to a more recent version, "
               "or downgrade 'xpressinsight' Python package.", file=sys.stderr)
         sys.exit(1)
 
     if exec_mode == ExecMode.NONE:
         exit_code = app_type().load_and_run(delete_work_dir=False)
     else:
```

## xpressinsight/code_generator.py

```diff
@@ -175,15 +175,15 @@
 
         if entity.transform_labels_entity != "":
             self.write_one_line_xi_annotation('transform.labels.entity', entity.transform_labels_entity)
 
         if not isinstance(entity, Param):
             if entity.update_after_execution:
                 self.write_one_line_xi_annotation('update.afterexecution', mos_repr_bool(entity.update_after_execution))
-            
+
             if entity.update_progress:
                 self.write_one_line_xi_annotation('update.progress', mos_repr_bool(entity.update_progress))
 
     def declare_param(self, param: Param):
         self.write_entity_annotations(param)
 
         #
```

## xpressinsight/entities.py

```diff
@@ -116,17 +116,22 @@
                                                     'Insight type string, integer, boolean, or real',
                                                     type(attr).__name__, attr))
         else:
             check_simple_python_type(attr, attr_name, attr_type, class_type)
 
 
 class XiEnum(Enum):
-    #
+    """
+    The base class for `Enum` types in the `xpressinsight` package.
+    """
+
     def __repr__(self):
-        return "{}.{}".format(self.__class__.__name__, self._name_)
+        #
+        #
+        return f"{self.__class__.__name__}.{self._name_}"
 
 
 class Manage(XiEnum):
     """
     How and whether Insight handles an entity.
 
     Attributes
@@ -1192,16 +1197,16 @@
         return
 
     if t == string:
         #
         #
         if not np.all(np.vectorize(check_str)(x)):
             msg = r"""
-            All values in {} must be strings, 
-            must not be longer than {} characters, 
+            All values in {} must be strings,
+            must not be longer than {} characters,
             and must not contain the null character "\0".
             """.format(name, MAX_STR_LENGTH_CHARS)
             raise TypeError(msg)
 
     elif t == integer:
         if x.dtype.kind != "i":
             msg = """
```

## xpressinsight/interface.py

```diff
@@ -13,15 +13,15 @@
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
 
 import datetime
 import os
 from dataclasses import dataclass, field
-from typing import List, Generator, Optional, Union
+from typing import Dict, List, Generator, Optional, Union
 from abc import ABC, abstractmethod
 from xpressinsight import ExecMode
 from xpressinsight.entities import XiEnum, check_instance_attribute_types
 from xpressinsight.repository_path import RepositoryPath
 
 #
 
@@ -482,14 +482,40 @@
         when executing outside DMP.
     """
 
     insight_url: str = field(default="")
     dmp: Optional[InsightDmpContext] = field(default=None)
 
 
+@dataclass
+class SolutionDatabase:
+    """
+    An object containing information about the shared MySQL solution database of the current DMP solution.
+
+    Attributes
+    ----------
+    host: str
+        The hostname of the solution database server.
+    port: int
+        The port on which to connect to the solution database server.
+    user: str
+        The username to use for accessing to the solution database.
+    password: str
+        The password to use for accessing to the solution database.
+    database: str
+        The name of the solution database.
+    """
+
+    host: str = field(default="")
+    port: int = field(default=3306)
+    user: str = field(default="")
+    password: str = field(default="")
+    database: str = field(default="")
+
+
 class AppInterface(ABC):
     """
     This class represents the Xpress Insight application interface. Use this interface to access attachments
     and meta data like the scenario ID.
 
     See Also
     --------
@@ -570,16 +596,14 @@
 
         Returns
         -------
         work_dir : str
             Absolute path to the internal working directory of the `xpressinsight` package.
         """
 
-        pass
-
     @abstractmethod
     def delete_work_dir(self):
         """
         Delete the internal working directory of the `xpressinsight` package.
 
         See Also
         --------
@@ -595,16 +619,14 @@
         directory cannot be deleted, e.g., because another application has a lock on a file, the function
         raises an exception.
 
         Setting this property when :param-ref:`insight.test_mode` is `False` will cause the model to abort with
         a runtime error.
         """
 
-        pass
-
     @property
     @abstractmethod
     def test_mode(self) -> bool:
         """
         Read-only property to check whether the Insight application is running in test mode or in Insight.
 
         Returns
@@ -613,16 +635,14 @@
             `True` if the application is executed in test mode and `False` if it is running in Insight.
 
         Notes
         -----
         When the application is running in Insight, then the value is `False`, otherwise the value is `True`.
         """
 
-        pass
-
     #
     @property
     @abstractmethod
     def exec_mode(self) -> str:
         """
         Property for the execution mode in which Xpress Insight is running the model. :index-name:`run mode`
 
@@ -661,16 +681,14 @@
         mode function. However, if you want to test another function, which is not an execution mode function,
         then it could make sense to set the `exec_mode` property manually.
 
         Modifying this property when :param-ref:`insight.test_mode` is `False` will cause the model to abort with a
         runtime error.
         """
 
-        pass
-
     #
     @exec_mode.setter
     @abstractmethod
     def exec_mode(self, exec_mode: str):
         pass
 
     #
@@ -701,16 +719,14 @@
         The `app_id` property can only be set in test mode.
 
         In test mode can be used to mock the Insight application state when testing code outside of an Insight scenario.
 
         Modifying this property when `insight.test_mode` is `False` will cause the model to abort with a runtime error.
         """
 
-        pass
-
     #
     @app_id.setter
     @abstractmethod
     def app_id(self, new_app_id: str):
         pass
 
     #
@@ -743,16 +759,14 @@
         The application name is not related to the name defined in the model's source code.
 
         Used to mock the Insight application state when testing code outside of an Insight scenario.
 
         Modifying this property when `insight.test_mode` is `False` will cause the model to abort with a runtime error.
         """
 
-        pass
-
     #
     @app_name.setter
     @abstractmethod
     def app_name(self, new_app_name: str):
         pass
 
     #
@@ -788,16 +802,14 @@
         not a unique identifier for the user's account, as users can change their names.
 
         Used to mock the user who requested the scenario execution, when testing code outside of an Insight scenario.
 
         Modifying this property when :param-ref:`insight.test_mode` is `False` will cause the model to abort with a runtime error.
         """
 
-        pass
-
     #
     @username.setter
     @abstractmethod
     def username(self, new_username: str):
         pass
 
     @property
@@ -818,16 +830,14 @@
         >>> insight.test_cfile_path = 'C:/dev/app/application.xml'
 
         Demonstration of getting the companion file path (test mode only).
 
         >>> print(insight.test_cfile_path)
         """
 
-        pass
-
     @test_cfile_path.setter
     @abstractmethod
     def test_cfile_path(self, cfile_path: str):
         pass
 
     @property
     @abstractmethod
@@ -852,16 +862,14 @@
 
         See Also
         --------
         AppInterface.test_app_attach_dir
         AppInterface.test_scen_attach_dir
         """
 
-        pass
-
     @test_attach_dir.setter
     @abstractmethod
     def test_attach_dir(self, attach_dir: str):
         pass
 
     #
     @property
@@ -894,16 +902,14 @@
 
         See Also
         --------
         AppInterface.test_attach_dir
         AppInterface.test_scen_attach_dir
         """
 
-        pass
-
     @test_app_attach_dir.setter
     @abstractmethod
     def test_app_attach_dir(self, app_attach_dir: str):
         pass
 
     #
     @property
@@ -936,16 +942,14 @@
 
         See Also
         --------
         AppInterface.test_attach_dir
         AppInterface.test_app_attach_dir
         """
 
-        pass
-
     @test_scen_attach_dir.setter
     @abstractmethod
     def test_scen_attach_dir(self, scen_attach_dir: str):
         pass
 
     #
     @abstractmethod
@@ -978,16 +982,14 @@
 
         See Also
         --------
         AppInterface.list_attach_tags
         AppInterface.set_attach_tags
         """
 
-        pass
-
     #
     @abstractmethod
     def set_attach_rules(self, new_rules: AttachmentRules):
         """
         Sets the 'rules' used to validate attachments and attachment meta-data.
 
         Parameters
@@ -1012,16 +1014,14 @@
         Used to change the rules that are applied to new attachments - for example, if you want to test how your
         code responds to the `AttachStatus.TOO_MANY` error code without actually creating a lot of attachments, you can
         use this procedure to set a lower number of attachments per scenario.
 
         Setting this property when :param-ref:`insight.test_mode` is `False` will cause the model to abort with a runtime error.
         """
 
-        pass
-
     #
     @property
     @abstractmethod
     def attach_status(self) -> AttachStatus:
         """
         Read-only property indicating the status of the most recent attempt to access or modify an attachment. :index-name:`attachment operation error codes`
 
@@ -1043,16 +1043,14 @@
         AppInterface.app_attach_info
 
         Notes
         -----
         After every call to an attachment-related function or procedure, you should check the value of `insight.attach_status` to see if your request succeeded.
         """
 
-        pass
-
     #
     #
 
     #
     @abstractmethod
     def list_attach_tags(self) -> List[AttachTag]:
         """
@@ -1078,31 +1076,35 @@
         Check the attachment status code using :fct-ref:`insight.attach_status` to determine whether the attachment was successfully fetched.
 
         See Also
         --------
         AppInterface.set_scen_attach_tags
         """
 
-        pass
-
+    #
     #
     #
     @abstractmethod
-    def get_scen_attach(self, filename: str, scenario_path: str = None) -> None:
+    def get_scen_attach(self, filename: str, scenario_path: str = None, *, destination_filename: str = None) -> None:
         """
-        Retrieves an attachment from the Insight server for a given scenario, placing it in the Python working directory where it can be read by the model. :index-name:`get scenario attachment`
+        Retrieves an attachment from the Insight server for a given scenario, placing it in a location where it can be
+        read by the model. :index-name:`get scenario attachment`
 
         Parameters
         ----------
         filename : str
             The filename of the attachment to be retrieved.
         scenario_path : str
             The path of a scenario. A scenario path is the full path to a scenario name starting from the repository root
             and including the app name. E.g. `/myapp/DirA/myscenario`
             If the scenario path is not specified, the attachment is retrieved for the current scenario.
+        destination_filename : Optional[str]
+            The local filename to which to write the attachment content; may be an absolute path or relative to the
+            Python working directory. If not specified, the attachment will be written to a file in the working
+            directory.
 
         Examples
         --------
         Example of copying a scenario attachment called `my_attach.dat` to the working directory.
 
         >>> insight.get_scen_attach('my_attach.dat')
         ... if insight.attach_status == AttachStatus.OK:
@@ -1130,31 +1132,35 @@
 
         See Also
         --------
         AppInterface.attach_status
         AppInterface.put_scen_attach
         """
 
-        pass
-
+    #
+    #
     #
     #
     @abstractmethod
-    def put_scen_attach(self, filename: str, overwrite: bool = True) -> None:
+    def put_scen_attach(self, filename: str, overwrite: bool = True, *, source_filename: str = None) -> None:
         """
-        Uploads a scenario attachment to the Insight server, reading it from the Python working directory. :index-name:`put scenario attachment`
+        Uploads a scenario attachment to the Insight server. :index-name:`put scenario attachment`
 
         Parameters
         ----------
         filename : str
             The filename of the attachment to be uploaded
         overwrite : bool
             If `True`, will overwrite attachment if it already exists.  If `False`
             and attachment already exists, will fail with insight.attach_status returning
             AttachStatus.ALREADY_EXISTS. Defaults to `True` if not given.
+        source_filename : Optional[str]
+            The local filename from which to read the attachment content; may be an absolute path or relative to the
+            Python working directory. If not specified, the attachment will be read from a file in the working
+            directory.
 
         Examples
         --------
         Example of taking a file `my_attach.dat` in the working directory, and saving it as a new scenario attachment called `my_attach.dat`.
 
         >>> insight.put_scen_attach('my_attach.dat', False)
         ... if insight.attach_status == AttachStatus.OK:
@@ -1174,16 +1180,14 @@
 
         See Also
         --------
         AppInterface.attach_status
         AppInterface.get_scen_attach
         """
 
-        pass
-
     #
     @abstractmethod
     def delete_scen_attach(self, filename: str) -> None:
         """
         Deletes a scenario attachment. :index-name:`delete scenario attachment`
 
         Parameters
@@ -1210,16 +1214,14 @@
         Attempting to access attachments when the model is not being run through Xpress Insight will cause the model to abort with an error.
 
         See Also
         --------
         AppInterface.attach_status
         """
 
-        pass
-
     #
     @abstractmethod
     def rename_scen_attach(self, old_name: str, new_name: str) -> None:
         """
         Renames an existing scenario attachment.
 
         Parameters
@@ -1248,16 +1250,14 @@
         Attempting to access attachments when the model is not being run through Xpress Insight will cause the model to abort with an error.
 
         See Also
         --------
         AppInterface.attach_status
         """
 
-        pass
-
     #
     @abstractmethod
     def set_scen_attach_desc(self, filename: str, description: str) -> None:
         """
         Update the description of an existing scenario attachment. :index-name:`set scenario attachment description`
 
         Parameters
@@ -1287,16 +1287,14 @@
         Attempting to access attachments when the model is not being run through Xpress Insight will cause the model to abort with an error.
 
         See Also
         --------
         AppInterface.attach_status
         """
 
-        pass
-
     #
     @abstractmethod
     def set_scen_attach_tags(self, filename: str, tags: List[str]) -> None:
         """
         Update the tags of an existing scenario attachment. :index-name:`set scenario attachment tags`
 
         Parameters
@@ -1328,16 +1326,14 @@
         If any of the specified tags are single-file tags, they will be removed from other scenarios as part of this operation.
 
         See Also
         --------
         AppInterface.attach_status
         """
 
-        pass
-
     #
     @abstractmethod
     def set_scen_attach_hidden(self, filename: str, hidden: bool) -> None:
         """
         Mark an existing scenario attachment as hidden or visible in the Xpress Insight UI. :index-name:`set scenario attachment hidden`
 
         Parameters
@@ -1366,16 +1362,14 @@
         Attempting to access attachments when the model is not being run through Xpress Insight will cause the model to abort with an error.
 
         See Also
         --------
         AppInterface.attach_status
         """
 
-        pass
-
     #
     #
     @abstractmethod
     def list_scen_attach(self, scenario_path: str = None) -> List[Attachment]:
         """
         Retrieves a list of all the files attached to a given scenario. :index-name:`list scenario attachments`
 
@@ -1419,16 +1413,14 @@
         See Also
         --------
         AppInterface.attach_status
         AppInterface.get_scen_attach
         AppInterface.list_scen_attach_by_tag
         """
 
-        pass
-
     #
     #
     @abstractmethod
     def list_scen_attach_by_tag(
             self, tag: str, scenario_path: str = None
     ) -> List[Attachment]:
         """
@@ -1478,16 +1470,14 @@
         See Also
         --------
         AppInterface.attach_status
         AppInterface.get_scen_attach
         AppInterface.list_scen_attach
         """
 
-        pass
-
     #
     @abstractmethod
     def scen_attach_info(self, filename: str) -> Optional[Attachment]:
         """
         Retrieves information about a given scenario attachment. :index-name:`query scenario attachment`
 
         Parameters
@@ -1517,26 +1507,30 @@
 
         See Also
         --------
         AppInterface.attach_status
         AppInterface.set_scen_attach_desc
         """
 
-        pass
-
+    #
     #
     @abstractmethod
-    def get_app_attach(self, filename: str) -> None:
+    def get_app_attach(self, filename: str, *, destination_filename: str = None) -> None:
         """
-        Retrieves an app attachment from the Insight server, placing it in the Python working directory where it can be read by the model. :index-name:`get app attachment`
+        Retrieves an app attachment from the Insight server, placing in a location where it can be
+        read by the model. :index-name:`get app attachment`
 
         Parameters
         ----------
         filename : str
             The filename of the attachment to be retrieved.
+        destination_filename : Optional[str]
+            The local filename to which to write the attachment content; may be an absolute path or relative to the
+            Python working directory. If not specified, the attachment will be written to a file in the working
+            directory.
 
         Examples
         --------
         Example of copying an app attachment called `my_attach.dat` to the working directory.
 
         >>> insight.get_app_attach('my_attach.dat')
         ... if insight.attach_status == AttachStatus.OK:
@@ -1552,16 +1546,14 @@
         Attempting to access attachments when the model is not being run through Xpress Insight will cause the model to abort with an error.
 
         See Also
         --------
         AppInterface.attach_status
         """
 
-        pass
-
     #
     @abstractmethod
     def list_app_attach(self) -> List[Attachment]:
         """
         Retrieves a list of all the files attached to the app. :index-name:`list app attachments`
 
         Returns
@@ -1589,16 +1581,14 @@
         --------
         AppInterface.attach_status
         AppInterface.app_attach_info
         AppInterface.get_app_attach
         AppInterface.list_app_attach_by_tag
         """
 
-        pass
-
     #
     @abstractmethod
     def list_app_attach_by_tag(self, tag: str) -> List[Attachment]:
         """
         Retrieves a list of all the files attached to the app with the given tag. :index-name:`list app attachments by tag`
 
         Parameters
@@ -1630,16 +1620,14 @@
         See Also
         --------
         AppInterface.attach_status
         AppInterface.get_app_attach
         AppInterface.list_app_attach
         """
 
-        pass
-
     #
     @abstractmethod
     def app_attach_info(self, filename: str) -> Optional[Attachment]:
         """
         Retrieves information about a given app attachment. :index-name:`query app attachment`
 
         Parameters
@@ -1668,32 +1656,34 @@
         Attempting to access attachments when the model is not being run through Xpress Insight will cause the model to abort with an error.
 
         See Also
         --------
         AppInterface.attach_status
         """
 
-        pass
-
+    #
     #
     @abstractmethod
-    def get_attachs_by_tag(self, tag: str) -> Optional[List[Attachment]]:
+    def get_attachs_by_tag(self, tag: str, *, destination_directory: str = None) -> Optional[List[Attachment]]:
         """
-        Gets Insight attachments by tag
+        Gets Insight attachments by tag.
 
         Searches the scenario and the containing app for an attachment or attachments with the given tag, and
-        retrieves them from the Insight server, placing them in the Python working directory where they can be read by
+        retrieves them from the Insight server, placing them in a local directory where they can be read by
         the model. If any scenario attachments with the given tag are found, these are retrieved without searching
         the app. If no scenario attachments with the given tag are found, then the search continues at the
         app level. :index-name:`get attachments by tag`
 
         Parameters
         ----------
         tag : str
             The tag to search for
+        destination_directory : str
+            The directory into which to copy the attachments, which must exist or a `FileNotFoundError` will be raised.
+            If not specified, the attachments will be copied into the Python working directory.
 
         Returns
         -------
         attachments : Optional[List[Attachment]]
             A list which will be populated with the details of the attachments that were retrieved.
 
         Examples
@@ -1718,32 +1708,34 @@
         AppInterface.attach_status
         AppInterface.list_scen_attach
         AppInterface.list_app_attach
         AppInterface.get_app_attach
         AppInterface.get_scen_attach
         """
 
-        pass
-
+    #
     #
     @abstractmethod
-    def get_attach_by_tag(self, tag: str) -> Optional[Attachment]:
+    def get_attach_by_tag(self, tag: str, *, destination_directory: str = None) -> Optional[Attachment]:
         """
         Gets Insight attachments by tag
 
         Searches the scenario and the containing app for an attachment or attachments with the given tag, and
-        retrieves them from the Insight server, placing them in the Python working directory where they can be read by
+        retrieves them from the Insight server, placing them in a local directory directory where they can be read by
         the model. If any scenario attachments with the given tag are found, these are retrieved without searching
         the app. If no scenario attachments with the given tag are found, then the search continues at the
         app level. :index-name:`get attachments by tag`
 
         Parameters
         ----------
         tag : str
             The tag to search for
+        destination_directory : str
+            The directory into which to copy the attachment, which must exist or a `FileNotFoundError` will be raised.
+            If not specified, the attachment will be copied into the Python working directory.
 
         Returns
         -------
         attachment : Optional[Attachment]
             An attachment object which will be populated with the details of the attachment that was retrieved.
 
         Examples
@@ -1768,32 +1760,34 @@
         AppInterface.attach_status
         AppInterface.list_scen_attach
         AppInterface.list_app_attach
         AppInterface.get_app_attach
         AppInterface.get_scen_attach
         """
 
-        pass
-
+    #
     #
     @abstractmethod
-    def get_attach_filenames_by_tag(self, tag: str) -> List[str]:
+    def get_attach_filenames_by_tag(self, tag: str, *, destination_directory: str = None) -> List[str]:
         """
         Gets Insight attachments by tag
 
         Searches the scenario and the containing app for an attachment or attachments with the given tag, and
-        retrieves them from the Insight server, placing them in the Python working directory where they can be read by
+        retrieves them from the Insight server, placing them in a local directory where they can be read by
         the model. If any scenario attachments with the given tag are found, these are retrieved without searching
         the app. If no scenario attachments with the given tag are found, then the search continues at the
         app level. :index-name:`get attachments by tag`
 
         Parameters
         ----------
         tag : str
             The tag to search for
+        destination_directory : str
+            The directory into which to copy the attachments, which must exist or a `FileNotFoundError` will be raised.
+            If not specified, the attachments will be copied into the Python working directory.
 
         Returns
         -------
         filenames : List[str]
             A list which will be populated with the filenames of the attachments that were retrieved.
 
         Examples
@@ -1818,16 +1812,14 @@
         AppInterface.attach_status
         AppInterface.list_scen_attach
         AppInterface.list_app_attach
         AppInterface.get_app_attach
         AppInterface.get_scen_attach
         """
 
-        pass
-
     #
     @abstractmethod
     def get_attach_rules(self) -> AttachmentRules:
         """
         Retrieves the the 'rules' used to validate attachments and attachment meta-data.
 
         Returns
@@ -1845,16 +1837,14 @@
         -----
         Used to retrieve the rules that are used to validate new attachments - for example, maximum attachment size.
 
         This will only be necessary if you want to validate new attachments within the model, before they
         trigger Insight attachment errors for violating any of these rules.
         """
 
-        pass
-
     @abstractmethod
     def get_item_info(self, path: str) -> ItemInfo:
         """
         Get information for a repository item with the supplied path.
 
         Parameters
         ----------
@@ -1890,15 +1880,14 @@
         --------
         ItemInfo
         InterfaceError
         AppInterface.get_item_infos
         AppInterface.add_item_info
         AppInterface.clear_item_infos
         """
-        pass
 
     @abstractmethod
     def get_item_infos(self, folder_path: str) -> List[ItemInfo]:
         """
         Get information for items in the folder with the supplied path.
 
         Parameters
@@ -1937,15 +1926,14 @@
         --------
         ItemInfo
         InterfaceError
         AppInterface.get_item_info
         AppInterface.add_item_info
         AppInterface.clear_item_infos
         """
-        pass
 
     def add_item_info(self, item_info: ItemInfo) -> None:
         """
         Adds the given ItemInfo object to the repository of item infos that are used in test mode.
 
         Parameters
         ----------
@@ -2043,15 +2031,14 @@
         --------
         ItemInfo
         AppInterface.test_mode
         AppInterface.get_item_info
         AppInterface.get_item_infos
         AppInterface.clear_item_infos
         """
-        pass
 
     def clear_item_infos(self) -> None:
         """
         Removes any ItemInfo objects previously added in test mode.
 
         Examples
         --------
@@ -2067,15 +2054,14 @@
         See Also
         --------
         ItemInfo
         AppInterface.get_item_info
         AppInterface.get_item_infos
         AppInterface.add_item_info
         """
-        pass
 
     #
 
     #
 
     @property
     @abstractmethod
@@ -2104,16 +2090,14 @@
         The `scenario_id` property can only be set in test mode.
 
         In test mode can be used to mock the Insight scenario id.
 
         Modifying this property when `insight.test_mode` is `False` will cause the model to abort with a runtime error.
         """
 
-        pass
-
     @scenario_id.setter
     @abstractmethod
     def scenario_id(self, scenario_id: str):
         pass
 
     @property
     @abstractmethod
@@ -2143,16 +2127,14 @@
         The `scenario_name` property can only be set in test mode.
 
         In test mode can be used to mock the Insight scenario name.
 
         Modifying this property when `insight.test_mode` is `False` will cause the model to abort with a runtime error.
         """
 
-        pass
-
     @scenario_name.setter
     @abstractmethod
     def scenario_name(self, scenario_name: str):
         pass
 
     @property
     @abstractmethod
@@ -2187,15 +2169,14 @@
 
         Modifying this property when `insight.test_mode` is `False` will cause the model to abort with a runtime error.
 
         See Also
         --------
         AppInterface.scenario_parent_path
         """
-        pass
 
     @scenario_path.setter
     @abstractmethod
     def scenario_path(self, scenario_path: str):
         pass
 
     @property
@@ -2308,16 +2289,14 @@
         --------
         AppInterface.reset_progress
         AppInterface.send_progress_update
         Metric
         ObjSense
         """
 
-        pass
-
     @abstractmethod
     def reset_progress(self) -> None:
         """
         Resets the progress state for each Xpress Insight v4 progress metric back to their initial values.
 
         Examples
         --------
@@ -2334,16 +2313,14 @@
         This function does nothing if the app is running in Xpress Insight v5 or later.
 
         See Also
         --------
         AppInterface.update
         """
 
-        pass
-
     @abstractmethod
     def send_progress_update(self) -> None:
         """
         Stores the current values of the progress entities into the Xpress Insight v5 scenario.
 
         Notes
         -----
@@ -2355,16 +2332,14 @@
 
         In the event of the progress update being rejected by the Insight server, an error will output to the
         run log but the model will not be terminated.
 
         This function does nothing if the app is running in Xpress Insight v4.
         """
 
-        pass
-
     @abstractmethod
     def get_messages(self) -> Generator[str, None, None]:
         """
         Returns a generator for reading the messages sent to the scenario.
 
         See Also
         --------
@@ -2386,16 +2361,14 @@
         The executing Insight scenario can only receive messages in Insight v5 and later. If called from a scenario
         running in Insight v4, the generator will always yield no values.
 
         When test mode has been activated, this function will return messages from a queue populated by the
         :fct-ref:`insight.put_messages` method.
         """
 
-        pass
-
     @abstractmethod
     def put_messages(self, *msgs: str) -> None:
         """
         Appends one or more messages to the tail of the messages queue, in test mode.
         These messages will be retrieved by a future call to :fct-ref:`insight.get_messages`.
 
         Examples
@@ -2415,16 +2388,14 @@
 
         See Also
         --------
         AppInterface.get_messages
 
         """
 
-        pass
-
     @property
     @abstractmethod
     def version(self) -> str:
         """
         Property for the version number of the Insight server that is executing the scenario.
 
         Returns
@@ -2449,16 +2420,14 @@
         The `version` property can only be set in test mode.
 
         In test mode can be used to mock the value of the `version` property.
 
         Modifying this property when `insight.test_mode` is `False` will cause the model to abort with a runtime error.
         """
 
-        pass
-
     @version.setter
     @abstractmethod
     def version(self, new_insight_version: str):
         pass
 
     @abstractmethod
     def get_insight_context(self, environment: Optional[str] = None) -> InsightContext:
@@ -2496,34 +2465,86 @@
         Used to retrieve information the app can use to reach outside itself - for example, to query the Insight server
         via its REST API, or to communicate with other DMP services in the same solution.
 
         When test mode has been activated, this function will return an object previously specified by the
         :fct-ref:`insight.set_insight_context` method, or a default context object if none was specified.
         """
 
-        pass
-
     @abstractmethod
     def set_insight_context(self, context: InsightContext) -> None:
         """
         Sets the value that will be returned by queries for the InsightContext, in test mode. This value will be
         returned regardless of the environment requested by get_insight_context (since the environment only affects
         the solution token, not any of the other fields).
 
+        Parameters
+        ----------
+        context : InsightContext
+            The context information to be returned in test mode.
+
         Examples
         --------
         Configure an `InsightContext` to be returned by future calls to `get_insight_context()`:
 
-        >>> context = InsightContext(insight_url="http://localhost:8080/")
+        >>> context = xi.InsightContext(insight_url="http://localhost:8080/")
         >>> insight.set_insight_context(context)
 
         Notes
         -----
         The `set_insight_context` method can only be called in test mode. Calling this method when `insight.test_mode`
         is `False` will cause the model to abort with a runtime error.
 
         See Also
         --------
         AppInterface.get_insight_context
         """
 
-        pass
+    @abstractmethod
+    def get_solution_database(self) -> SolutionDatabase:
+        """
+        Retrieves information about the solution database for the current DMP solution.
+
+        Returns
+        -------
+        solution_database : SolutionDatabase
+            An object containing location and credentials for the solution database.
+
+        Examples
+        --------
+        Demonstration of getting the solution database credentials:
+
+        >>> solution_database = insight.get_solution_database()
+
+        Notes
+        -----
+        Raises :fct-ref:`InterfaceError` if called when the app is not running in DMP.
+
+        When test mode has been activated, this function will return an object previously specified by the
+        :fct-ref:`insight.set_solution_database` method, or a default solution database object if none was specified.
+        """
+
+    @abstractmethod
+    def set_solution_database(self, solution_database: SolutionDatabase) -> None:
+        """
+        Sets the value that will be returned by queries for the solution database, in test mode.
+
+        Parameters
+        ----------
+        solution_database : SolutionDatabase
+            The solution database information to be returned in test mode.
+
+        Examples
+        --------
+        Configure a `SolutionDatabase` to be returned by future calls to `get_solution_database()`:
+
+        >>> solution_database = xi.SolutionDatabase(host="localhost")
+        >>> insight.set_solution_database(solution_database)
+
+        Notes
+        -----
+        The `set_solution_database` method can only be called in test mode. Calling this method when `insight.test_mode`
+        is `False` will cause the model to abort with a runtime error.
+
+        See Also
+        --------
+        AppInterface.get_solution_database
+        """
```

## xpressinsight/interface_rest.py

```diff
@@ -10,16 +10,17 @@
     does not convey rights to divulge, reproduce, use, or allow others
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
 import os
+import re
 from typing import Dict, Generator, List, Optional, Union, Type
-from datetime import datetime, timedelta
+from datetime import datetime, timedelta, timezone
 from xpressinsight.entities import XiEnum
 
 from xpressinsight.interface import (
     _raise_interface_error,
     Attachment,
     AttachmentRules,
     AttachStatus,
@@ -27,15 +28,16 @@
     AttachTagUsage,
     ItemInfo,
     ExecMode,
     AppInterface,
     Metric,
     ObjSense,
     InsightContext,
-    InsightDmpContext
+    InsightDmpContext,
+    SolutionDatabase,
 )
 import xpressinsight.rest as xi_rest
 
 ERROR_MSG_PROD_MODE_METHOD = 'The method "{}" cannot be used in production mode.'
 ATTACH_STATUS_PREFIX = "INSIGHT_ATTACH_"
 
 
@@ -116,14 +118,22 @@
         type=item_info["type"],
         name=item_info["name"],
         path=item_info["path"],
         parent_path=item_info["parentpath"]
     )
 
 
+def _verify_safe_mosel_filename(filename: Optional[str]):
+    """ Given a filename, verify it is 'safe' to pass to Mosel, and is not an 'extended' Mosel filename reading/writing
+        an IO driver.
+        Raises ValueError if filename is not safe. """
+    if re.match(r"^[^:][^:]+:.*", filename):
+        raise ValueError(f"Filename '{filename}' contains a Mosel I/O Driver, which may not be passed from Python apps")
+
+
 class AppRestInterface(AppInterface):
     """
     This class represents the Xpress Insight application interface. Use this interface to access attachments
     and meta data like the scenario ID.
     """
 
     #
@@ -239,27 +249,37 @@
                 usage=AttachTagUsage(tag["usage"]),
             )
             for tag in result["tags"]
         ]
 
     #
     #
-    def get_scen_attach(self, filename: str, scenario_path: str = None) -> None:
+    #
+    def get_scen_attach(self, filename: str, scenario_path: str = None, *, destination_filename: str = None) -> None:
+
+        if destination_filename:
+            _verify_safe_mosel_filename(destination_filename)
 
         if scenario_path is None:
             scenario_path = ""
 
-        attach_status_str = self._api.scenario_attachment_get(filename, scenariopath=scenario_path)
+        attach_status_str = self._api.scenario_attachment_get(filename, scenariopath=scenario_path,
+                                                              dstfilename=destination_filename)
         self._attach_status = parse_attach_status(attach_status_str)
 
     #
     #
-    def put_scen_attach(self, filename: str, overwrite: bool = True) -> None:
+    #
+    #
+    def put_scen_attach(self, filename: str, overwrite: bool = True, *, source_filename: str = None) -> None:
 
-        attach_status_str = self._api.scenario_attachment_put(filename, overwrite)
+        if source_filename:
+            _verify_safe_mosel_filename(source_filename)
+
+        attach_status_str = self._api.scenario_attachment_put(filename, overwrite, srcfilename=source_filename)
         self._attach_status = parse_attach_status(attach_status_str)
 
     #
     def delete_scen_attach(self, filename: str) -> None:
 
         attach_status_str = self._api.scenario_attachment_delete(filename)
         self._attach_status = parse_attach_status(attach_status_str)
@@ -318,17 +338,21 @@
 
         #
         #
         #
         return _attachment_from_dict(result["attachment"], self._attach_status)
 
     #
-    def get_app_attach(self, filename: str) -> None:
+    #
+    def get_app_attach(self, filename: str, *, destination_filename: str = None) -> None:
+
+        if destination_filename:
+            _verify_safe_mosel_filename(destination_filename)
 
-        attach_status_str = self._api.app_attachment_get(filename)
+        attach_status_str = self._api.app_attachment_get(filename, dstfilename=destination_filename)
         self._attach_status = parse_attach_status(attach_status_str)
 
     #
     def list_app_attach(self) -> List[Attachment]:
 
         tag = ""
         return self.list_app_attach_by_tag(tag)
@@ -344,36 +368,48 @@
     def app_attach_info(self, filename: str) -> Optional[Attachment]:
 
         result = self._api.app_attachment_info_get(filename)
         self._attach_status = parse_attach_status(result["status"])
         return _attachment_from_dict(result["attachment"], self.attach_status)
 
     #
-    def get_attachs_by_tag(self, tag: str) -> Optional[List[Attachment]]:
+    #
+    def get_attachs_by_tag(self, tag: str, *, destination_directory: str = None) -> Optional[List[Attachment]]:
+
+        #
+        if destination_directory:
+            _verify_safe_mosel_filename(destination_directory)
+
+            if not os.path.exists(destination_directory):
+                raise FileNotFoundError(f"Directory '{destination_directory}' not found")
+
+            if not os.path.isdir(destination_directory):
+                raise NotADirectoryError(f"Path '{destination_directory}' is not a directory")
 
-        result = self._api.attachments_tags_bytag_get(tag)
+        #
+        result = self._api.attachments_tags_bytag_get(tag, directory=destination_directory)
         self._attach_status = parse_attach_status(result["status"])
         return [_attachment_from_dict(a) for a in result["attachments"]]
 
     #
-    def get_attach_by_tag(self, tag: str) -> Optional[Attachment]:
+    def get_attach_by_tag(self, tag: str, *, destination_directory: str = None) -> Optional[Attachment]:
 
-        attachments = self.get_attachs_by_tag(tag)
+        attachments = self.get_attachs_by_tag(tag, destination_directory=destination_directory)
         if len(attachments) == 1:
             return attachments[0]
         elif len(attachments) == 0:
             return None
         else:
             self._attach_status = AttachStatus.TOO_MANY
             return None
 
     #
-    def get_attach_filenames_by_tag(self, tag: str) -> List[str]:
+    def get_attach_filenames_by_tag(self, tag: str, *, destination_directory: str = None) -> List[str]:
 
-        attachments = self.get_attachs_by_tag(tag)
+        attachments = self.get_attachs_by_tag(tag, destination_directory=destination_directory)
         return [a.filename for a in attachments]
 
     #
     def get_attach_rules(self) -> AttachmentRules:
         rules = self._api.attachments_rules_get()
 
         return AttachmentRules(
@@ -477,15 +513,15 @@
             self._app.data_connector.save_progress()
 
             #
             self._api.progress_send()
 
     def get_messages(self) -> Generator[str, None, None]:
         while True:
-            (msg, status_code, headers) = self._api.progress_get_message_with_http_info()
+            (msg, status_code, _) = self._api.progress_get_message_with_http_info()
 
             if status_code == 200:
                 yield msg
             else:
                 break
 
     def put_messages(self, *msgs: str) -> None:
@@ -512,22 +548,40 @@
                     solution_id=src_dmp_context.solutionid,
                     component_id=src_dmp_context.componentid,
                     component_instance_id=src_dmp_context.compinstid,
                     solution_token=src_dmp_context.soltoken,
                     #
                     #
                     #
-                    solution_token_expiry_time=datetime(1970, 1, 1) +
+                    solution_token_expiry_time=datetime(1970, 1, 1, tzinfo=timezone.utc) +
                                                timedelta(milliseconds=src_dmp_context.soltokenexpiry),
                     solution_token_environment=src_dmp_context.soltokenenv
                 )
             )
 
         except xi_rest.ApiException as e:
             if e.status == 412:
                 #
                 _raise_interface_error(f"Could not get Insight context due to: {e.body}")
             else:
                 raise e
 
     def set_insight_context(self, context: InsightContext, environment: Optional[str] = None) -> None:
         raise RuntimeError(ERROR_MSG_PROD_MODE_METHOD.format('set_insight_context'))
+
+    def get_solution_database(self) -> SolutionDatabase:
+        try:
+            src_info: xi_rest.SolutionDatabase = self._api.solution_database_get()
+            return SolutionDatabase(
+                host=src_info.server,
+                port=src_info.port if src_info.port else 3306,
+                user=src_info.username,
+                password=src_info.password,
+                database=src_info.database
+            )
+        except xi_rest.ApiException as e:
+            if e.status == 412:
+                #
+                _raise_interface_error(f"Could not get solution database info due to: {e.body}")
+
+    def set_solution_database(self, solution_database: SolutionDatabase) -> None:
+        raise RuntimeError(ERROR_MSG_PROD_MODE_METHOD.format('set_solution_database'))
```

## xpressinsight/interface_test.py

```diff
@@ -38,14 +38,15 @@
     AttachType,
     AttachUpdateType,
     AppInterface,
     ItemInfo,
     Metric,
     ObjSense,
     InsightContext,
+    SolutionDatabase,
 )
 
 from xpressinsight.exec_mode import ExecMode
 from xpressinsight.entities import check_simple_python_type
 from xpressinsight.repository_path import RepositoryPath
 
 
@@ -336,14 +337,17 @@
         #
         self._item_infos_by_id: Dict[str, ItemInfo] = {}
         self._item_infos_by_path: Dict[str, ItemInfo] = {}
 
         #
         self._insight_context = InsightContext()
 
+        #
+        self._solution_database = SolutionDatabase()
+
     @property
     def work_dir(self) -> str:
         return self._work_dir
 
     def delete_work_dir(self):
         if os.path.isdir(self.work_dir):
             print(f'Test mode: Deleting existing Insight working directory: "{self.work_dir}".')
@@ -512,35 +516,36 @@
             sorted_attach_tags = sorted_by_key(self._attach_tags)
 
             self._xpri_set_attach_stat(AttachStatus.OK)
             return sorted_attach_tags
 
     #
     #
-    def get_scen_attach(self, filename: str, scenario_path: str = None) -> None:
+    #
+    def get_scen_attach(self, filename: str, scenario_path: str = None, *, destination_filename: str = None) -> None:
 
         scenario_id = (
             self._scenario_id
             if scenario_path is None
             else self._xpri_get_scenario_id(scenario_path)
         )
 
         #
         self._xpri_ensure_scen_attach_cache_exists(scenario_id)
 
-        self._xpri_get_attach(self._scen_attach_cache_map[scenario_id], filename)
+        self._xpri_get_attach(self._scen_attach_cache_map[scenario_id], filename, destination_filename)
 
     #
     #
-    def put_scen_attach(self, filename: str, overwrite: bool = True) -> None:
+    def put_scen_attach(self, filename: str, overwrite: bool = True, source_filename: str = None) -> None:
 
         #
         self._xpri_ensure_scen_attach_cache_exists(self._scenario_id)
         self._xpri_put_attach(
-            self._scen_attach_cache_map[self._scenario_id], filename, overwrite
+            self._scen_attach_cache_map[self._scenario_id], filename, source_filename, overwrite
         )
 
     #
     def delete_scen_attach(self, filename: str) -> None:
 
         #
         self._xpri_ensure_scen_attach_cache_exists(self._scenario_id)
@@ -636,17 +641,17 @@
         #
         self._xpri_ensure_scen_attach_cache_exists(self._scenario_id)
         return self._xpri_get_attach_info(
             self._scen_attach_cache_map[self._scenario_id], filename
         )
 
     #
-    def get_app_attach(self, filename: str) -> None:
+    def get_app_attach(self, filename: str, *, destination_filename: str = None) -> None:
 
-        self._xpri_get_attach(self._app_attach_cache, filename)
+        self._xpri_get_attach(self._app_attach_cache, filename, destination_filename)
 
     #
     def list_app_attach(self) -> List[Attachment]:
 
         return self._xpri_list_attach(self._app_attach_cache)
 
     #
@@ -657,27 +662,30 @@
 
     #
     def app_attach_info(self, filename: str) -> Optional[Attachment]:
 
         return self._xpri_get_attach_info(self._app_attach_cache, filename)
 
     #
-    def get_attachs_by_tag(self, tag: str) -> Optional[List[Attachment]]:
+    #
+    def get_attachs_by_tag(self, tag: str, *, destination_directory: str = None) -> Optional[List[Attachment]]:
 
-        return self._xpri_get_attachs_by_tag(tag)
+        return self._xpri_get_attachs_by_tag(tag, destination_directory=destination_directory)
 
     #
-    def get_attach_by_tag(self, tag: str) -> Optional[Attachment]:
+    #
+    def get_attach_by_tag(self, tag: str, *, destination_directory: str = None) -> Optional[Attachment]:
 
-        return self._xpri_get_attach_by_tag(tag)
+        return self._xpri_get_attach_by_tag(tag, destination_directory=destination_directory)
 
     #
-    def get_attach_filenames_by_tag(self, tag: str) -> List[str]:
+    #
+    def get_attach_filenames_by_tag(self, tag: str, *, destination_directory: str = None) -> List[str]:
 
-        return self._xpri_get_attach_filenames_by_tag(tag)
+        return self._xpri_get_attach_filenames_by_tag(tag, destination_directory=destination_directory)
 
     #
     def get_attach_rules(self) -> AttachmentRules:
 
         self._xpri_load_attach_rules()
         return copy.deepcopy(self._attach_rules)
 
@@ -1126,15 +1134,15 @@
                 if t not in self._attach_tags:
                     return False
 
             return True
 
     #
     def _xpri_get_attach_common(
-            self, attach_cache: XpriAttachmentsCache, filename: str
+            self, attach_cache: XpriAttachmentsCache, filename: str, destination_filename: str = None
     ) -> AttachStatus:
         #
 
         #
         if not self._xpri_populate_cache(attach_cache):
             return AttachStatus.RUNTIME_ERROR
 
@@ -1145,26 +1153,26 @@
                 return AttachStatus.NOT_FOUND
             else:
                 src = os.path.join(
                     self._xpri_get_test_mode_dir(attach_cache),
                     test_attach.local_content_filename,
                 )
                 try:
-                    shutil.copy(src, filename)
+                    shutil.copy(src, filename if (destination_filename is None) else destination_filename)
                 except Exception as e:
                     _raise_io_error(f"Unable to write or overwrite file {filename}.", e)
                     return AttachStatus.RUNTIME_ERROR
 
                 return AttachStatus.OK
 
     #
     def _xpri_get_attach(
-            self, attach_cache: XpriAttachmentsCache, filename: str
+            self, attach_cache: XpriAttachmentsCache, filename: str, destination_filename: str = None
     ) -> None:
-        status = self._xpri_get_attach_common(attach_cache, filename)
+        status = self._xpri_get_attach_common(attach_cache, filename, destination_filename)
         self._xpri_attach_stat = status
 
     #
     def _xpri_remove_attach_updates(
             self, attach_id: str, attach_type: AttachType, update_type: AttachUpdateType
     ) -> None:
         #
@@ -1174,17 +1182,19 @@
             if u.attach_id != attach_id
             or u.update_type != update_type
             or u.attach_type != attach_type
         ]
 
     #
     def _xpri_put_attach(
-            self, attach_cache: XpriAttachmentsCache, filename: str, overwrite: bool
+            self, attach_cache: XpriAttachmentsCache, filename: str, source_filename: Optional[str], overwrite: bool
     ) -> None:
         #
+        if source_filename is None:
+            source_filename = filename
 
         self._xpri_clear_attach_stat()
 
         #
         if not self._xpri_populate_cache(attach_cache):
             self._xpri_set_attach_stat(AttachStatus.RUNTIME_ERROR)
             return
@@ -1201,20 +1211,20 @@
         if not self._xpri_check_can_add_new_attach(
                 attach_cache
         ) and not self._xpri_attach_exists(attach_cache, filename):
             self._xpri_set_attach_stat(AttachStatus.TOO_MANY)
             return
 
         #
-        if not os.path.isfile(filename):
-            _raise_io_error("Attachment file '{}' not found.".format(filename))
+        if not os.path.isfile(source_filename):
+            _raise_io_error("Attachment file '{}' not found.".format(source_filename))
             self._xpri_set_attach_stat(AttachStatus.RUNTIME_ERROR)
             return
 
-        if not self._xpri_check_attach_file_size(attach_cache, filename):
+        if not self._xpri_check_attach_file_size(attach_cache, source_filename):
             self._xpri_set_attach_stat(AttachStatus.TOO_LARGE)
             return
 
         #
         test_attach: XpriAttachment = self._xpri_find_test_mode_attachment(
             attach_cache, filename
         )
@@ -1235,15 +1245,15 @@
                         test_attach.local_content_filename,
                     )
             ):
                 c = c + 1
                 test_attach.local_content_filename = "{}_{}".format(filename, c)
 
         #
-        test_attach.size = os.path.getsize(filename)
+        test_attach.size = os.path.getsize(source_filename)
         test_attach.last_modified_user = self.username
         test_attach.last_modified_date = datetime.datetime.now()
 
         #
         test_attach_path = os.path.join(
             self._xpri_get_test_mode_dir(attach_cache),
             test_attach.local_content_filename,
@@ -1253,15 +1263,15 @@
             os.makedirs(os.path.dirname(test_attach_path), exist_ok=True)
         except Exception as e:
             _raise_io_error(f"Unable to create parent directory for file {test_attach_path}.", e)
             self._xpri_set_attach_stat(AttachStatus.RUNTIME_ERROR)
             return
 
         try:
-            shutil.copy(filename, test_attach_path)
+            shutil.copy(source_filename, test_attach_path)
         except Exception as e:
             _raise_io_error(f"Unable to copy attachment from {filename} to {test_attach_path}.", e)
             self._xpri_set_attach_stat(AttachStatus.RUNTIME_ERROR)
             return
 
         #
         #
@@ -1536,17 +1546,20 @@
         if scenario_path == self._scenario_path:
             return self._scenario_id
         else:
             raise NotImplementedError("Access to other scenarios is currently not supported in Insight test mode.")
 
     #
     #
-    def _xpri_get_attachs_by_tag(self, tag: str) -> Optional[List[Attachment]]:
+    def _xpri_get_attachs_by_tag(self, tag: str, destination_directory: str = None) -> Optional[List[Attachment]]:
         self._xpri_clear_attach_stat()
 
+        if not destination_directory:
+            destination_directory = '.'
+
         #
         if not self._xpri_check_tags_valid([tag]):
             self._xpri_set_attach_stat(AttachStatus.INVALID_TAGS)
             return None
 
         #
         attach_cache = self._scen_attach_cache_map[self._scenario_id]
@@ -1569,36 +1582,41 @@
         if a == []:
             self._xpri_set_attach_stat(AttachStatus.NOT_FOUND)
             return None
 
         #
         assert a is not None
         for attach in a:
-            status = self._xpri_get_attach_common(attach_cache, attach.filename)
+            status = self._xpri_get_attach_common(attach_cache, attach.filename,
+                                                  os.path.join(destination_directory, attach.filename))
             if status != AttachStatus.OK:
                 break
 
         #
         self._xpri_set_attach_stat(status)
         return a
 
     #
     #
-    def _xpri_get_attach_filenames_by_tag(self, tag: str) -> List[str]:
-        attachments = self._xpri_get_attachs_by_tag(tag)
+    def _xpri_get_attach_filenames_by_tag(self, tag: str, destination_directory: str = None) -> List[str]:
+        attachments = self._xpri_get_attachs_by_tag(tag, destination_directory)
         if self._xpri_attach_stat == AttachStatus.OK:
             assert attachments is not None
             return [attach.filename for attach in attachments]
         else:
             return []
 
     #
     #
-    def _xpri_get_attach_by_tag(self, tag: str) -> Optional[Attachment]:
+    def _xpri_get_attach_by_tag(self, tag: str, destination_directory: str = None) -> Optional[Attachment]:
         self._xpri_clear_attach_stat()
+
+        if not destination_directory:
+            destination_directory = '.'
+
         if not self._xpri_check_tags_valid([tag]):
             self._xpri_set_attach_stat(AttachStatus.INVALID_TAGS)
             return None
         else:
             (status, a) = self._xpri_list_attach_by_tag_common(
                 self._scen_attach_cache_map[self._scenario_id], tag
             )
@@ -1611,14 +1629,15 @@
                     self._xpri_set_attach_stat(AttachStatus.SEVERAL_FOUND)
                     return None
                 elif len(a) == 1:
                     attachment = a[0]
                     status = self._xpri_get_attach_common(
                         self._scen_attach_cache_map[self._scenario_id],
                         attachment.filename,
+                        os.path.join(destination_directory, attachment.filename)
                     )
                     self._xpri_set_attach_stat(status)  #
                     return attachment
                 else:
                     (status, a) = self._xpri_list_attach_by_tag_common(
                         self._app_attach_cache, tag
                     )
@@ -1632,15 +1651,16 @@
                             return None
                         elif len(a) > 1:
                             self._xpri_set_attach_stat(AttachStatus.SEVERAL_FOUND)
                             return None
                         else:
                             attachment = a[0]
                             status = self._xpri_get_attach_common(
-                                self._app_attach_cache, attachment.filename
+                                self._app_attach_cache, attachment.filename,
+                                os.path.join(destination_directory, attachment.filename)
                             )
                             self._xpri_set_attach_stat(
                                 status
                             )  #
                             return attachment
 
     #
@@ -1732,7 +1752,13 @@
         self._version = new_version
 
     def get_insight_context(self, environment : Optional[str] = None) -> InsightContext:
         return self._insight_context
 
     def set_insight_context(self, context: InsightContext) -> None:
         self._insight_context = context
+
+    def get_solution_database(self) -> SolutionDatabase:
+        return self._solution_database
+
+    def set_solution_database(self, solution_database: SolutionDatabase) -> None:
+        self._solution_database = solution_database
```

## xpressinsight/test_runner.py

```diff
@@ -38,18 +38,18 @@
                     shutil.copy(file_path, dst)
 
         except (OSError, shutil.SameFileError) as e:
             print('Could not copy files from {} to {}.'.format(repr(src), repr(dst)), file=sys.stderr)
             raise e
 
 
-def copy_flat_dir_if_exists(src: str, dst: str, dir_name: str):
+def copy_flat_dir_if_exists(src: str, dst: str, dir_name: str, quiet: bool = False):
     if os.path.exists(src):
         copy_flat_dir(src, dst)
-    else:
+    elif not quiet:
         print(f'Test mode: {dir_name} directory does not exist. Skipping: "{src}".')
 
 
 def _prepare_test_validate_input(insight: AppInterface, base_dir: str, app_work_dir: str):
     #
     if not os.path.exists(os.path.join(base_dir, 'python_source')):
         raise ValueError(f"Invalid 'base_dir' directory: {base_dir!r}. 'python_source' folder is missing.")
```

## xpressinsight/rest/__init__.py

```diff
@@ -14,14 +14,15 @@
     of Fair Isaac Corporation.  Receipt or possession of this material
     does not convey rights to divulge, reproduce, use, or allow others
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
+#
 
 
 from __future__ import absolute_import
 
 __version__ = "1.0.0"
 
 #
@@ -39,9 +40,9 @@
 from xpressinsight.rest.models.attach_status import AttachStatus
 from xpressinsight.rest.models.attachment import Attachment
 from xpressinsight.rest.models.attachment_rules import AttachmentRules
 from xpressinsight.rest.models.attachment_tag import AttachmentTag
 from xpressinsight.rest.models.insight_context import InsightContext
 from xpressinsight.rest.models.insight_dmp_context import InsightDmpContext
 from xpressinsight.rest.models.item_info import ItemInfo
+from xpressinsight.rest.models.solution_database import SolutionDatabase
 from xpressinsight.rest.models.status import Status
-
```

## xpressinsight/rest/api_client.py

```diff
@@ -11,14 +11,15 @@
     of Fair Isaac Corporation.  Receipt or possession of this material
     does not convey rights to divulge, reproduce, use, or allow others
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
+#
 
 from __future__ import absolute_import
 
 import atexit
 import datetime
 from dateutil.parser import parse
 import json
```

## xpressinsight/rest/configuration.py

```diff
@@ -12,14 +12,15 @@
     of Fair Isaac Corporation.  Receipt or possession of this material
     does not convey rights to divulge, reproduce, use, or allow others
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
+#
 
 
 from __future__ import absolute_import
 
 import logging
 import multiprocessing
 import sys
```

## xpressinsight/rest/exceptions.py

```diff
@@ -12,14 +12,15 @@
     of Fair Isaac Corporation.  Receipt or possession of this material
     does not convey rights to divulge, reproduce, use, or allow others
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
+#
 
 
 import six
 
 
 class OpenApiException(Exception):
     """The base exception class for all OpenAPIExceptions"""
```

## xpressinsight/rest/rest.py

```diff
@@ -12,14 +12,15 @@
     of Fair Isaac Corporation.  Receipt or possession of this material
     does not convey rights to divulge, reproduce, use, or allow others
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
+#
 
 
 from __future__ import absolute_import
 
 import io
 import json
 import logging
```

## xpressinsight/rest/api/default_api.py

```diff
@@ -12,14 +12,15 @@
     of Fair Isaac Corporation.  Receipt or possession of this material
     does not convey rights to divulge, reproduce, use, or allow others
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
+#
 
 
 from __future__ import absolute_import
 
 import re  #
 
 #
@@ -50,14 +51,15 @@
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.app_attachment_get(filename, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool: execute request asynchronously
         :param str filename: The filename of the attachment to be retrieved (required)
+        :param str dstfilename: The pathname into which to write the attachment. Uses attachment filename if unset.
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -74,14 +76,15 @@
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.app_attachment_get_with_http_info(filename, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool: execute request asynchronously
         :param str filename: The filename of the attachment to be retrieved (required)
+        :param str dstfilename: The pathname into which to write the attachment. Uses attachment filename if unset.
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -90,15 +93,15 @@
         :return: tuple(AttachStatus, status_code(int), headers(HTTPHeaderDict))
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         local_var_params = locals()
 
-        all_params = ['filename']  #
+        all_params = ['filename', 'dstfilename']  #
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
 
         for key, val in six.iteritems(local_var_params['kwargs']):
             if key not in all_params:
@@ -116,14 +119,16 @@
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'filename' in local_var_params and local_var_params['filename'] is not None:  #
             query_params.append(('filename', local_var_params['filename']))  #
+        if 'dstfilename' in local_var_params and local_var_params['dstfilename'] is not None:  #
+            query_params.append(('dstfilename', local_var_params['dstfilename']))  #
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -663,14 +668,15 @@
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.attachments_tags_bytag_get(tag, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool: execute request asynchronously
         :param str tag: The tag to search for (required)
+        :param str directory: Path to local directory into which to copy the attachments
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -688,14 +694,15 @@
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.attachments_tags_bytag_get_with_http_info(tag, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool: execute request asynchronously
         :param str tag: The tag to search for (required)
+        :param str directory: Path to local directory into which to copy the attachments
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -704,15 +711,15 @@
         :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         local_var_params = locals()
 
-        all_params = ['tag']  #
+        all_params = ['tag', 'directory']  #
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
 
         for key, val in six.iteritems(local_var_params['kwargs']):
             if key not in all_params:
@@ -730,14 +737,16 @@
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'tag' in local_var_params and local_var_params['tag'] is not None:  #
             query_params.append(('tag', local_var_params['tag']))  #
+        if 'directory' in local_var_params and local_var_params['directory'] is not None:  #
+            query_params.append(('directory', local_var_params['directory']))  #
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -1980,50 +1989,52 @@
             auth_settings=auth_settings,
             async_req=local_var_params.get('async_req'),
             _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
             _preload_content=local_var_params.get('_preload_content', True),
             _request_timeout=local_var_params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def scenario_attachment_get(self, filename, **kwargs):  #
+    def scenario_attachment_get(self, filename, scenariopath, **kwargs):  #
         """Retrieves an attachment from the Insight server for a given scenario, placing it in the Mosel working directory where it can be read by the model  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.scenario_attachment_get(filename, async_req=True)
+        >>> thread = api.scenario_attachment_get(filename, scenariopath, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool: execute request asynchronously
         :param str filename: The filename of the attachment to be retrieved (required)
-        :param str scenariopath: The path of a scenario. A scenario path is the full path to a scenario name starting from the repository root and including the app name. E.g. /myapp/FolderA/FolderB/myscenario If the scenario path is not specified, the attachment is retrieved for the current scenario.
+        :param str scenariopath: The path of a scenario. A scenario path is the full path to a scenario name starting from the repository root and including the app name. E.g. /myapp/FolderA/FolderB/myscenario If the scenario path is not specified, the attachment is retrieved for the current scenario. (required)
+        :param str dstfilename: The pathname into which to write the attachment. Uses attachment filename if unset.
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: AttachStatus
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        return self.scenario_attachment_get_with_http_info(filename, **kwargs)  #
+        return self.scenario_attachment_get_with_http_info(filename, scenariopath, **kwargs)  #
 
-    def scenario_attachment_get_with_http_info(self, filename, **kwargs):  #
+    def scenario_attachment_get_with_http_info(self, filename, scenariopath, **kwargs):  #
         """Retrieves an attachment from the Insight server for a given scenario, placing it in the Mosel working directory where it can be read by the model  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.scenario_attachment_get_with_http_info(filename, async_req=True)
+        >>> thread = api.scenario_attachment_get_with_http_info(filename, scenariopath, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool: execute request asynchronously
         :param str filename: The filename of the attachment to be retrieved (required)
-        :param str scenariopath: The path of a scenario. A scenario path is the full path to a scenario name starting from the repository root and including the app name. E.g. /myapp/FolderA/FolderB/myscenario If the scenario path is not specified, the attachment is retrieved for the current scenario.
+        :param str scenariopath: The path of a scenario. A scenario path is the full path to a scenario name starting from the repository root and including the app name. E.g. /myapp/FolderA/FolderB/myscenario If the scenario path is not specified, the attachment is retrieved for the current scenario. (required)
+        :param str dstfilename: The pathname into which to write the attachment. Uses attachment filename if unset.
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -2032,15 +2043,15 @@
         :return: tuple(AttachStatus, status_code(int), headers(HTTPHeaderDict))
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         local_var_params = locals()
 
-        all_params = ['filename', 'scenariopath']  #
+        all_params = ['filename', 'scenariopath', 'dstfilename']  #
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
 
         for key, val in six.iteritems(local_var_params['kwargs']):
             if key not in all_params:
@@ -2050,24 +2061,30 @@
                 )
             local_var_params[key] = val
         del local_var_params['kwargs']
         #
         if self.api_client.client_side_validation and ('filename' not in local_var_params or  #
                                                         local_var_params['filename'] is None):  #
             raise ApiValueError("Missing the required parameter `filename` when calling `scenario_attachment_get`")  #
+        #
+        if self.api_client.client_side_validation and ('scenariopath' not in local_var_params or  #
+                                                        local_var_params['scenariopath'] is None):  #
+            raise ApiValueError("Missing the required parameter `scenariopath` when calling `scenario_attachment_get`")  #
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'filename' in local_var_params and local_var_params['filename'] is not None:  #
             query_params.append(('filename', local_var_params['filename']))  #
         if 'scenariopath' in local_var_params and local_var_params['scenariopath'] is not None:  #
             query_params.append(('scenariopath', local_var_params['scenariopath']))  #
+        if 'dstfilename' in local_var_params and local_var_params['dstfilename'] is not None:  #
+            query_params.append(('dstfilename', local_var_params['dstfilename']))  #
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -2317,14 +2334,15 @@
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.scenario_attachment_put(filename, overwrite, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool: execute request asynchronously
         :param str filename: The filename of the attachment to be deleted (required)
         :param bool overwrite: If true, will overwrite attachment if it already exists. If false and attachment already exists, will fail with insightattachstatus INSIGHT_ATTACH_ALREADY_EXISTS. Defaults to true if not given. (required)
+        :param str srcfilename: The pathname from which to read the attachment content. Uses attachment filename if unset.
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
@@ -2342,14 +2360,15 @@
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.scenario_attachment_put_with_http_info(filename, overwrite, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool: execute request asynchronously
         :param str filename: The filename of the attachment to be deleted (required)
         :param bool overwrite: If true, will overwrite attachment if it already exists. If false and attachment already exists, will fail with insightattachstatus INSIGHT_ATTACH_ALREADY_EXISTS. Defaults to true if not given. (required)
+        :param str srcfilename: The pathname from which to read the attachment content. Uses attachment filename if unset.
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -2358,15 +2377,15 @@
         :return: tuple(AttachStatus, status_code(int), headers(HTTPHeaderDict))
                  If the method is called asynchronously,
                  returns the request thread.
         """
 
         local_var_params = locals()
 
-        all_params = ['filename', 'overwrite']  #
+        all_params = ['filename', 'overwrite', 'srcfilename']  #
         all_params.append('async_req')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
 
         for key, val in six.iteritems(local_var_params['kwargs']):
             if key not in all_params:
@@ -2390,14 +2409,16 @@
         path_params = {}
 
         query_params = []
         if 'filename' in local_var_params and local_var_params['filename'] is not None:  #
             query_params.append(('filename', local_var_params['filename']))  #
         if 'overwrite' in local_var_params and local_var_params['overwrite'] is not None:  #
             query_params.append(('overwrite', local_var_params['overwrite']))  #
+        if 'srcfilename' in local_var_params and local_var_params['srcfilename'] is not None:  #
+            query_params.append(('srcfilename', local_var_params['srcfilename']))  #
 
         header_params = {}
 
         form_params = []
         local_var_files = {}
 
         body_params = None
@@ -2645,50 +2666,50 @@
             auth_settings=auth_settings,
             async_req=local_var_params.get('async_req'),
             _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
             _preload_content=local_var_params.get('_preload_content', True),
             _request_timeout=local_var_params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def scenario_attachments_list_get(self, **kwargs):  #
+    def scenario_attachments_list_get(self, tag, scenariopath, **kwargs):  #
         """Retrieves a list of all the files attached to a given scenario  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.scenario_attachments_list_get(async_req=True)
+        >>> thread = api.scenario_attachments_list_get(tag, scenariopath, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool: execute request asynchronously
-        :param str tag: The tag to search for
-        :param str scenariopath: The path of a scenario. A scenario path is the full path to a scenario name starting from the repository root and including the app name. E.g. /myapp/FolderA/FolderB/myscenario If the scenario path is not specified, the attachment is retrieved for the current scenario.
+        :param str tag: The tag to search for (required)
+        :param str scenariopath: The path of a scenario. A scenario path is the full path to a scenario name starting from the repository root and including the app name. E.g. /myapp/FolderA/FolderB/myscenario If the scenario path is not specified, the attachment is retrieved for the current scenario. (required)
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: object
                  If the method is called asynchronously,
                  returns the request thread.
         """
         kwargs['_return_http_data_only'] = True
-        return self.scenario_attachments_list_get_with_http_info(**kwargs)  #
+        return self.scenario_attachments_list_get_with_http_info(tag, scenariopath, **kwargs)  #
 
-    def scenario_attachments_list_get_with_http_info(self, **kwargs):  #
+    def scenario_attachments_list_get_with_http_info(self, tag, scenariopath, **kwargs):  #
         """Retrieves a list of all the files attached to a given scenario  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.scenario_attachments_list_get_with_http_info(async_req=True)
+        >>> thread = api.scenario_attachments_list_get_with_http_info(tag, scenariopath, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool: execute request asynchronously
-        :param str tag: The tag to search for
-        :param str scenariopath: The path of a scenario. A scenario path is the full path to a scenario name starting from the repository root and including the app name. E.g. /myapp/FolderA/FolderB/myscenario If the scenario path is not specified, the attachment is retrieved for the current scenario.
+        :param str tag: The tag to search for (required)
+        :param str scenariopath: The path of a scenario. A scenario path is the full path to a scenario name starting from the repository root and including the app name. E.g. /myapp/FolderA/FolderB/myscenario If the scenario path is not specified, the attachment is retrieved for the current scenario. (required)
         :param _return_http_data_only: response data without head status code
                                        and headers
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
@@ -2711,14 +2732,22 @@
             if key not in all_params:
                 raise ApiTypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method scenario_attachments_list_get" % key
                 )
             local_var_params[key] = val
         del local_var_params['kwargs']
+        #
+        if self.api_client.client_side_validation and ('tag' not in local_var_params or  #
+                                                        local_var_params['tag'] is None):  #
+            raise ApiValueError("Missing the required parameter `tag` when calling `scenario_attachments_list_get`")  #
+        #
+        if self.api_client.client_side_validation and ('scenariopath' not in local_var_params or  #
+                                                        local_var_params['scenariopath'] is None):  #
+            raise ApiValueError("Missing the required parameter `scenariopath` when calling `scenario_attachments_list_get`")  #
 
         collection_formats = {}
 
         path_params = {}
 
         query_params = []
         if 'tag' in local_var_params and local_var_params['tag'] is not None:  #
@@ -3045,14 +3074,112 @@
             auth_settings=auth_settings,
             async_req=local_var_params.get('async_req'),
             _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
             _preload_content=local_var_params.get('_preload_content', True),
             _request_timeout=local_var_params.get('_request_timeout'),
             collection_formats=collection_formats)
 
+    def solution_database_get(self, **kwargs):  #
+        """Query the credentials of the solution database  # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.solution_database_get(async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: SolutionDatabase
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.solution_database_get_with_http_info(**kwargs)  #
+
+    def solution_database_get_with_http_info(self, **kwargs):  #
+        """Query the credentials of the solution database  # noqa: E501
+
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.solution_database_get_with_http_info(async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool: execute request asynchronously
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: tuple(SolutionDatabase, status_code(int), headers(HTTPHeaderDict))
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+
+        local_var_params = locals()
+
+        all_params = []  #
+        all_params.append('async_req')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+
+        for key, val in six.iteritems(local_var_params['kwargs']):
+            if key not in all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method solution_database_get" % key
+                )
+            local_var_params[key] = val
+        del local_var_params['kwargs']
+
+        collection_formats = {}
+
+        path_params = {}
+
+        query_params = []
+
+        header_params = {}
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+        #
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json', 'text/plain'])  #
+
+        #
+        auth_settings = ['cookieAuth']  #
+
+        return self.api_client.call_api(
+            '/solution/database', 'GET',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type='SolutionDatabase',  #
+            auth_settings=auth_settings,
+            async_req=local_var_params.get('async_req'),
+            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
+            _preload_content=local_var_params.get('_preload_content', True),
+            _request_timeout=local_var_params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
     def username_get(self, **kwargs):  #
         """Obtains the username of the Insight user that initiated the current scenario execution  # noqa: E501
 
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.username_get(async_req=True)
         >>> result = thread.get()
```

## xpressinsight/rest/models/__init__.py

```diff
@@ -13,20 +13,22 @@
     of Fair Isaac Corporation.  Receipt or possession of this material
     does not convey rights to divulge, reproduce, use, or allow others
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
+#
 
 
 from __future__ import absolute_import
 
 #
 from xpressinsight.rest.models.attach_status import AttachStatus
 from xpressinsight.rest.models.attachment import Attachment
 from xpressinsight.rest.models.attachment_rules import AttachmentRules
 from xpressinsight.rest.models.attachment_tag import AttachmentTag
 from xpressinsight.rest.models.insight_context import InsightContext
 from xpressinsight.rest.models.insight_dmp_context import InsightDmpContext
 from xpressinsight.rest.models.item_info import ItemInfo
+from xpressinsight.rest.models.solution_database import SolutionDatabase
 from xpressinsight.rest.models.status import Status
```

## xpressinsight/rest/models/attach_status.py

```diff
@@ -12,14 +12,15 @@
     of Fair Isaac Corporation.  Receipt or possession of this material
     does not convey rights to divulge, reproduce, use, or allow others
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
+#
 
 
 import pprint
 import re  #
 
 import six
```

## xpressinsight/rest/models/attachment.py

```diff
@@ -12,14 +12,15 @@
     of Fair Isaac Corporation.  Receipt or possession of this material
     does not convey rights to divulge, reproduce, use, or allow others
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
+#
 
 
 import pprint
 import re  #
 
 import six
```

## xpressinsight/rest/models/attachment_rules.py

```diff
@@ -12,14 +12,15 @@
     of Fair Isaac Corporation.  Receipt or possession of this material
     does not convey rights to divulge, reproduce, use, or allow others
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
+#
 
 
 import pprint
 import re  #
 
 import six
```

## xpressinsight/rest/models/attachment_tag.py

```diff
@@ -12,14 +12,15 @@
     of Fair Isaac Corporation.  Receipt or possession of this material
     does not convey rights to divulge, reproduce, use, or allow others
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
+#
 
 
 import pprint
 import re  #
 
 import six
```

## xpressinsight/rest/models/insight_context.py

```diff
@@ -12,14 +12,15 @@
     of Fair Isaac Corporation.  Receipt or possession of this material
     does not convey rights to divulge, reproduce, use, or allow others
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
+#
 
 
 import pprint
 import re  #
 
 import six
```

## xpressinsight/rest/models/insight_dmp_context.py

```diff
@@ -12,14 +12,15 @@
     of Fair Isaac Corporation.  Receipt or possession of this material
     does not convey rights to divulge, reproduce, use, or allow others
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
+#
 
 
 import pprint
 import re  #
 
 import six
```

## xpressinsight/rest/models/item_info.py

```diff
@@ -12,14 +12,15 @@
     of Fair Isaac Corporation.  Receipt or possession of this material
     does not convey rights to divulge, reproduce, use, or allow others
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
+#
 
 
 import pprint
 import re  #
 
 import six
```

## xpressinsight/rest/models/status.py

```diff
@@ -12,14 +12,15 @@
     of Fair Isaac Corporation.  Receipt or possession of this material
     does not convey rights to divulge, reproduce, use, or allow others
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
+#
 
 
 import pprint
 import re  #
 
 import six
```

## xpressinsight/types/__init__.py

```diff
@@ -11,10 +11,10 @@
     to use it without the specific written authorization of Fair Isaac
     Corporation and use must conform strictly to the license agreement.
 
     Copyright (c) 2020-2022 Fair Isaac Corporation. All rights reserved.
 """
 
 #
-__version__ = '1.6.0.post1'
+__version__ = '1.7.1'
 
 from .helpers import Scalar, Param, Index, Series, DataFrame
```

## Comparing `xpressinsight-1.6.0.post1.dist-info/LICENSE.txt` & `xpressinsight-1.7.1.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `xpressinsight-1.6.0.post1.dist-info/METADATA` & `xpressinsight-1.7.1.dist-info/METADATA`

 * *Files 6% similar despite different names*

```diff
@@ -1,34 +1,33 @@
 Metadata-Version: 2.1
 Name: xpressinsight
-Version: 1.6.0.post1
+Version: 1.7.1
 Summary: FICO Xpress - Insight Python package
 Home-page: https://www.fico.com/en/products/fico-xpress-optimization-suite
 Author: FICO Xpress dev. team
 Author-email: support@fico.com
 License: Xpress Shrinkwrap License Agreement
 Keywords: optimization xpress insight
 Platform: any
 Classifier: License :: Other/Proprietary License
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Science/Research
 Classifier: Intended Audience :: Developers
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Topic :: Software Development
 Classifier: Topic :: Scientific/Engineering
 Classifier: Operating System :: Microsoft :: Windows
 Classifier: Operating System :: Unix
 Classifier: Operating System :: MacOS
-Requires-Python: >=3.7
+Requires-Python: >=3.8
 Description-Content-Type: text/markdown
 License-File: LICENSE.txt
 Requires-Dist: pyarrow (>=4.0.0)
 Requires-Dist: pandas (>=1.0.0)
 Requires-Dist: numpy (>=1.17.0)
 Requires-Dist: urllib3
 Requires-Dist: certifi
@@ -46,14 +45,24 @@
 - [FICO Xpress Insight 4 Developers Guide For Python](https://www.fico.com/fico-xpress-optimization/docs/latest/insight_dev_guide_py)
 - [FICO Xpress Insight 5 Python Package Reference Manual](https://www.fico.com/fico-xpress-optimization/docs/latest/insight5-python-doc)
 - [FICO Xpress Insight 5 Developers Guide For Python](https://www.fico.com/fico-xpress-optimization/docs/latest/insight5_dev_guide_py)
 
 Release Notes
 -------------
 
+__v 1.7.1 (Insight 5.7.0)__
+
+- New function `get_solution_database` returns the location and credentials of the DMP solution's database.
+- Enabled functions `get_app_attach`, `get_scen_attach` and `put_scen_attach` to write/read the attachment to/from a 
+  folder other than the work directory or a local filename different from attachment name.
+- Enabled functions `get_attach_by_tag`, `get_attachs_by_tag` and `get_attach_filenames_by_tag` to write the
+  attachments to a folder other than the work directory.
+- Fixed an issue with the `InsightDmpContext.solution_token_expiry_time` value in non-UTC timezones.
+- Removed support for Python 3.7. This version supports only Python 3.8 - 3.11.
+
 __v 1.6.0 (Insight 5.6.0)__
 
 - Resolved an error when a script declares multiple app classes with a shared superclass.
 - Added attribute `default` to the `xi.Column` class.
 - Use of the old syntax for annotating entities (e.g. `xi.Scalar` instead of `xi.types.Scalar`) will cause a warning
   message when the app is built or executed in Python 3.11. This syntax has been deprecated and will not be usable 
   at all in Python 3.12+.
@@ -63,14 +72,19 @@
 
 __v 1.5.0 (Insight 5.5.0)__
 
 - Allow an Index entity to be referenced multiple times within a single Series or DataFrame - 
   e.g. `Distance: xi.types.Series(index=['City', 'City'], dtype=xi.real)`.
 - Support `multiprocessing` package.
 
+__v 1.4.1 (Insight 4.59.6)__
+
+- Resolve issue building apps with Xpress 9.2 and apprunner 1.4.
+- Update dependencies to require Pandas v1 with xpressinsight 1.4.
+
 __v 1.4.0 (Insight 5.4.0 and 4.59.2)__
 
 - New syntax for annotating entities, `xi.types.Scalar`/`Param`/`Index`/`Series`/`DataFrame` instead
   of `xi.Scalar`/`Param`/`Index`/`Series`/`DataFrame`.
   - The new syntax is compatible with forward annotations (`from __future__ import annotations`).
   - The old syntax will continue to work in Python 3.7-3.10 but will not be usable in Python 3.11+, 
     so we recommend existing apps are migrated from the old to the new syntax.
```

## Comparing `xpressinsight-1.6.0.post1.dist-info/RECORD` & `xpressinsight-1.7.1.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -1,38 +1,39 @@
-xpressinsight/__init__.py,sha256=VONHyM-aovJCxg7-5B9Axcu9WDe_gFL40BxxdcQLn6s,1399
+xpressinsight/__init__.py,sha256=wcGtEWtzbT1tQIWzUzXv_W0epg3WcYpqfj2lVnHs5Mk,1415
 xpressinsight/app_base.py,sha256=_8AzX-1EQW1IyPlBFo_Jk8C7NpMOSyZ6H-f8VpnNbIM,23740
-xpressinsight/app_runner.py,sha256=PCROFTsHpMSHN7te3k2u4hMqSPega3C1PoHDkaXBtxI,5149
-xpressinsight/code_generator.py,sha256=iUtS-AlSheNFk6qKVAA-qaiYEbP1ugpGOJuXe3NbrAA,15730
-xpressinsight/entities.py,sha256=WOP91W5GKvdxx0Kxvj4R2djVjCh4GIAsCgdzTuXmxZQ,50601
+xpressinsight/app_runner.py,sha256=F601t5H6fWKkFeUxY7k0LeXh6UN-MzINBcn6QLlI27Y,5149
+xpressinsight/code_generator.py,sha256=nonifz2zBi47C4fIvB1iBA8rqOO3yF3NQIDFudjD6XI,15718
+xpressinsight/entities.py,sha256=skFX_VOP5vhueQzK0oitkpggPWg2YZmxzBVM6KkrrUQ,50688
 xpressinsight/exec_mode.py,sha256=WB3wx3puS86O-wZS-XJj_pHjWgOaZGUmGvFBWOGRMl0,12929
-xpressinsight/interface.py,sha256=qMz0bTOCkD7coXqCJcXwn9xFQEQfFpWB6lwdM3GkwEc,83806
-xpressinsight/interface_rest.py,sha256=HB2TVuYLQDgzQ_aPzdDe8s0TtWjz2lqBXiqsjY3tVYU,17187
-xpressinsight/interface_test.py,sha256=cwe4eBrO3UBAQaT30XVjGUetdaSrYHuySZtW2LS0iL4,55004
+xpressinsight/interface.py,sha256=Ci5D2XN_-HLQxBEi5uKiB2_rvyhFICdQttMsnwQ-KWM,87658
+xpressinsight/interface_rest.py,sha256=8Fzw2o76mUsGvFwgR_qx5VD11k81dQ5D0_awA3S-S0s,19690
+xpressinsight/interface_test.py,sha256=bHe9yO3dG8Pk1m82p4g6EO0zO2xKq-tAl1vLjl8_QCs,56613
 xpressinsight/mosel_keywords.py,sha256=J8LZofqHrfngjn7uA2cnLN4NQrLJITqACTkb9-ieNPU,61835
 xpressinsight/parquet_connector.py,sha256=95ImJIIOZXHrTAN4ZCPPsngat2AzJmLOCJChfwSmLe0,6426
 xpressinsight/repository_path.py,sha256=RpicYqVC3aMIqr2fZfX7GJHFjQngYvJSbFeJvulKuCU,11555
 xpressinsight/sqlite_connector.py,sha256=qJqYzP19CFRX8lfhSo7Q08VLKQSta2ge8rtc9CE7ngU,5341
 xpressinsight/table_connector.py,sha256=VfUMPs_KS2PBwDTsSrXLJ0gfGwyqoB18IHwzWnb-ONs,22740
-xpressinsight/test_runner.py,sha256=QaUfmgoP8EZ-h2NbM6Pdy7YT1wGuNn8EYwieXUTJnJo,12020
-xpressinsight/rest/__init__.py,sha256=sBooA298WF5E67U62nn5EZn8HrlEUHdu8SoAbSWsyfI,1678
-xpressinsight/rest/api_client.py,sha256=9VHJMY3-Fn1ce1DkYQifeGu4UqnBsIxSqwgcEqsqO7Q,25253
-xpressinsight/rest/configuration.py,sha256=h1S5m8nEFq6w-5iMPVeKv691asiOEG8bdkIMqSePM0I,13369
-xpressinsight/rest/exceptions.py,sha256=PljZC7CgVMJb5JB9ELTnuFeiq78KLKQgyOcKKygP9aI,4161
-xpressinsight/rest/rest.py,sha256=VIKPP8cWUhTn4Ig6PJoxMgOjpAUICaKrccpIikkkHrk,11711
+xpressinsight/test_runner.py,sha256=RHmd1HBQOrq8I5t65RJqRGbOUX8jqpTVdLZxI_ogW9s,12051
+xpressinsight/rest/__init__.py,sha256=_toCRxAgcs6JxQID0FWpGI41-Z46UPaNuSQlnEdJYkQ,1752
+xpressinsight/rest/api_client.py,sha256=DBGEPjFEwwPEPHfspzrO58bf5X_oANdMlNCtTxXe8Ys,25255
+xpressinsight/rest/configuration.py,sha256=sCMKMjr2O8enElOqrMmvLYqNpTzfi7KGlfjTb-GjX-U,13371
+xpressinsight/rest/exceptions.py,sha256=6W7uQu1XyQzEXaFFpio5rclCwRa5TqJk9iI9xhDmaa4,4163
+xpressinsight/rest/rest.py,sha256=NP71BHXz-yzXIL2IEqI2TvHsLOmTLe6mwsuaonMcPo4,11713
 xpressinsight/rest/api/__init__.py,sha256=QFtWiOykSpAr6AjtpvGb_OHBzxiPDwM2j5pJt6Haziw,103
-xpressinsight/rest/api/default_api.py,sha256=Q5MSqxWxPT4ll_4Rb63lQo_xh4-JmMGYFSfsPnciLlY,143245
-xpressinsight/rest/models/__init__.py,sha256=wamAaf2wFDv-gKYKrWzm5TLnfmpA1AnhlOT0kXIrikg,1200
-xpressinsight/rest/models/attach_status.py,sha256=uYrPW2Axjc6_KV0zRWqpe3KoJnW8hE5KuuUQFI4iwbQ,3710
-xpressinsight/rest/models/attachment.py,sha256=iA78OuS9GxAzulYO0H-nWxma_M4zBp-_sMJgzRHdOXc,8739
-xpressinsight/rest/models/attachment_rules.py,sha256=yVVea006QCtrMQ83zLFuw4-MQjEp-EqWCPnkQdHy1y4,8047
-xpressinsight/rest/models/attachment_tag.py,sha256=W1y4fJDTUaZagzlqNvcLnAmi-aOGk5OONWkmSw7d3FM,6297
-xpressinsight/rest/models/insight_context.py,sha256=5TZWzK2iJ-TxS87zHc-lvVUajqChSjXnHrNbwD_r9eE,4430
-xpressinsight/rest/models/insight_dmp_context.py,sha256=AXoqq_2OQkSZ3Tk0tm5v6V6gQKnFWhvB4yL1qYTqgQ8,11525
-xpressinsight/rest/models/item_info.py,sha256=3XkZMta6mcDdXELH2eVrYaJ-3eNNqdQMwtE1X9q5HdA,6321
-xpressinsight/rest/models/status.py,sha256=beiYA8MjAyj-4AzF16CBOVYJPY5gQnlaCmz-PD4D190,3132
-xpressinsight/types/__init__.py,sha256=k4whmX55wGsX3PoKHj5SXhavM-8nZv6fcfWHp_Qe_QA,719
+xpressinsight/rest/api/default_api.py,sha256=ekNushT8qvuW3WxIoEehzf76bfPuyL-aO1nuy5fcmxA,150291
+xpressinsight/rest/models/__init__.py,sha256=vreHiGz_gRtewRkHvTcwjgSStKBa0RvR_hOm_uAQJbw,1275
+xpressinsight/rest/models/attach_status.py,sha256=uUXsnGUjnM9guy2mzOi6y9J8uNfINEmB_qsijh05cEY,3712
+xpressinsight/rest/models/attachment.py,sha256=JLjWTkjV4e-2nX38x7ug4QfzdngfZKQF3eEfxLFZPXA,8741
+xpressinsight/rest/models/attachment_rules.py,sha256=rt4f_GcNxwzjvvWXc5A6MpnawjhKRAX-M0sKq9yHshI,8049
+xpressinsight/rest/models/attachment_tag.py,sha256=oMXldlWXSEHHGH2E0M9rbgxtz5QwuG96l9aE3cNTGMU,6299
+xpressinsight/rest/models/insight_context.py,sha256=qjBNF4PoagRX3mpD9qYkhbbPbn8w3wmF8Ag4bB6EVl0,4432
+xpressinsight/rest/models/insight_dmp_context.py,sha256=7Wg242HnSdKRQzrETILjL12OKfinKV_CnFJiHIkB37I,11527
+xpressinsight/rest/models/item_info.py,sha256=NJ_1qXYdA408nJ_N8FlZw0uLPkc_b9F8r0eOOHyKPro,6323
+xpressinsight/rest/models/solution_database.py,sha256=Nr9SQU-Q08H_pwjifF3h1LYDHUW5e5bQw4EuRxNECXM,8292
+xpressinsight/rest/models/status.py,sha256=nO_Wb3uIwIQA0KhC1mgmhuKff-UTzr_DqxYG-CmnIJ0,3134
+xpressinsight/types/__init__.py,sha256=NAx7nMgrbncAa3wOcleXR2cw4w02zFvxgbL8D5im8mA,713
 xpressinsight/types/helpers.py,sha256=xd75jbVJ6DkAH1VAFN0hEbo13CKvsaIcHBX23CU47Rs,15667
-xpressinsight-1.6.0.post1.dist-info/LICENSE.txt,sha256=GkAG-gBY2EG3K9wtZmmul9p7bKsRhZ6pOt5ixb9Uo2o,47346
-xpressinsight-1.6.0.post1.dist-info/METADATA,sha256=1aTLnDlMgYU3L_VZ_I9kKkPpyYfwFGJ_SfCGKvs5TRw,7170
-xpressinsight-1.6.0.post1.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-xpressinsight-1.6.0.post1.dist-info/top_level.txt,sha256=F09HSBpCLADe_lsNzhGIsi76rvZ7qsWVil0AY4HVHNE,14
-xpressinsight-1.6.0.post1.dist-info/RECORD,,
+xpressinsight-1.7.1.dist-info/LICENSE.txt,sha256=GkAG-gBY2EG3K9wtZmmul9p7bKsRhZ6pOt5ixb9Uo2o,47346
+xpressinsight-1.7.1.dist-info/METADATA,sha256=pX7VokYK_h2B5xVRT5lhCyotRsPMHcV4N43HEmInv74,7971
+xpressinsight-1.7.1.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
+xpressinsight-1.7.1.dist-info/top_level.txt,sha256=F09HSBpCLADe_lsNzhGIsi76rvZ7qsWVil0AY4HVHNE,14
+xpressinsight-1.7.1.dist-info/RECORD,,
```

