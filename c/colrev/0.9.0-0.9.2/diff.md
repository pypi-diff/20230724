# Comparing `tmp/colrev-0.9.0.tar.gz` & `tmp/colrev-0.9.2.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "colrev-0.9.0.tar", max compression
+gzip compressed data, was "colrev-0.9.2.tar", max compression
```

## Comparing `colrev-0.9.0.tar` & `colrev-0.9.2.tar`

### file list

```diff
@@ -1,363 +1,375 @@
--rw-r--r--   0        0        0    10176 2023-05-31 20:23:35.825381 colrev-0.9.0/CHANGELOG.md
--rw-r--r--   0        0        0     4405 2023-05-31 20:23:35.825381 colrev-0.9.0/CONTRIBUTING.md
--rw-r--r--   0        0        0     1070 2023-05-31 20:23:35.825381 colrev-0.9.0/LICENSE
--rw-r--r--   0        0        0     8248 2023-05-31 20:23:35.825381 colrev-0.9.0/README.md
--rw-r--r--   0        0        0      314 2023-05-31 20:23:35.825381 colrev-0.9.0/colrev/__init__.py
--rw-r--r--   0        0        0      128 2023-05-31 20:23:35.825381 colrev-0.9.0/colrev/__version__.py
--rw-r--r--   0        0        0    31379 2023-05-31 20:23:35.825381 colrev-0.9.0/colrev/advisor.py
--rw-r--r--   0        0        0    31762 2023-05-31 20:23:35.825381 colrev-0.9.0/colrev/checker.py
--rw-r--r--   0        0        0    43268 2023-05-31 20:23:35.825381 colrev-0.9.0/colrev/dataset.py
--rw-r--r--   0        0        0      105 2023-05-31 20:23:35.825381 colrev-0.9.0/colrev/env/__init__.py
--rw-r--r--   0        0        0    15934 2023-05-31 20:23:35.825381 colrev-0.9.0/colrev/env/environment_manager.py
--rw-r--r--   0        0        0     2160 2023-05-31 20:23:35.825381 colrev-0.9.0/colrev/env/grobid_service.py
--rw-r--r--   0        0        0     3657 2023-05-31 20:23:35.825381 colrev-0.9.0/colrev/env/language_service.py
--rw-r--r--   0        0        0    53533 2023-05-31 20:23:35.825381 colrev-0.9.0/colrev/env/local_index.py
--rw-r--r--   0        0        0    39355 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/env/package_manager.py
--rw-r--r--   0        0        0     2270 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/env/resources.py
--rw-r--r--   0        0        0     3933 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/env/screenshot_service.py
--rw-r--r--   0        0        0    34818 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/env/tei_parser.py
--rw-r--r--   0        0        0     5724 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/env/utils.py
--rw-r--r--   0        0        0     2526 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/env/zotero_translation_service.py
--rw-r--r--   0        0        0    18180 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/exceptions.py
--rw-r--r--   0        0        0      151 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/exit_codes.py
--rw-r--r--   0        0        0       86 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/hooks/__init__.py
--rwxr-xr-x   0        0        0      352 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/hooks/check.py
--rwxr-xr-x   0        0        0      372 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/hooks/format.py
--rwxr-xr-x   0        0        0      468 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/hooks/report.py
--rwxr-xr-x   0        0        0      360 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/hooks/share.py
--rwxr-xr-x   0        0        0     1233 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/hooks/update.py
--rw-r--r--   0        0        0     1842 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/linter/colrev_lint.py
--rw-r--r--   0        0        0      310 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/linter/readme.md
--rw-r--r--   0        0        0     3082 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/logger.py
--rw-r--r--   0        0        0     7702 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/operation.py
--rw-r--r--   0        0        0       92 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/__init__.py
--rw-r--r--   0        0        0      119 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/__init__.py
--rw-r--r--   0        0        0      135 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/data/__init__.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/data/bibliography_export.md
--rw-r--r--   0        0        0     9191 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/data/bibliography_export.py
--rw-r--r--   0        0        0     1084 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/data/colrev_curation.md
--rw-r--r--   0        0        0    14961 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/data/colrev_curation.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/data/github_pages.md
--rw-r--r--   0        0        0    13410 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/data/github_pages.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/data/obsidian.md
--rw-r--r--   0        0        0     9428 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/data/obsidian.py
--rw-r--r--   0        0        0     1142 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/data/paper_md.md
--rw-r--r--   0        0        0    31983 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/data/paper_md.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/data/prisma.md
--rw-r--r--   0        0        0     9200 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/data/prisma.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/data/structured.md
--rw-r--r--   0        0        0    11223 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/data/structured.py
--rw-r--r--   0        0        0      126 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/dedupe/__init__.py
--rw-r--r--   0        0        0      159 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/dedupe/active_learning_dedup_io.md
--rw-r--r--   0        0        0    42748 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/dedupe/active_learning_dedup_io.py
--rw-r--r--   0        0        0      159 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/dedupe/curation_dedupe.md
--rw-r--r--   0        0        0    25476 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/dedupe/curation_dedupe.py
--rw-r--r--   0        0        0      159 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/dedupe/curation_missing_dedupe.md
--rw-r--r--   0        0        0    14316 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/dedupe/curation_missing_dedupe.py
--rw-r--r--   0        0        0      159 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/dedupe/simple_dedupe.md
--rw-r--r--   0        0        0    14251 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/dedupe/simple_dedupe.py
--rw-r--r--   0        0        0     1961 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/dedupe/utils.py
--rw-r--r--   0        0        0      135 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/load_conversion/__init__.py
--rw-r--r--   0        0        0      189 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/load_conversion/bib_pybtex_loader.md
--rw-r--r--   0        0        0     5304 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/load_conversion/bib_pybtex_loader.py
--rw-r--r--   0        0        0      189 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/load_conversion/bibutils_loader.md
--rw-r--r--   0        0        0     4381 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/load_conversion/bibutils_loader.py
--rw-r--r--   0        0        0      189 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/load_conversion/markdown_loader.md
--rw-r--r--   0        0        0     2870 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/load_conversion/markdown_loader.py
--rw-r--r--   0        0        0      189 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/load_conversion/table_loader.md
--rw-r--r--   0        0        0     8828 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/load_conversion/table_loader.py
--rw-r--r--   0        0        0      401 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/load_conversion/zotero_loader.md
--rw-r--r--   0        0        0     3377 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/load_conversion/zotero_loader.py
--rw-r--r--   0        0        0      127 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/pdf_get/__init__.py
--rw-r--r--   0        0        0      159 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/pdf_get/local_index_pdf_get.md
--rw-r--r--   0        0        0     2484 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/pdf_get/local_index_pdf_get.py
--rw-r--r--   0        0        0      432 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/pdf_get/unpaywall.md
--rw-r--r--   0        0        0     5281 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/pdf_get/unpaywall.py
--rw-r--r--   0        0        0      159 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/pdf_get/website_screenshot.md
--rw-r--r--   0        0        0     1786 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/pdf_get/website_screenshot.py
--rw-r--r--   0        0        0      131 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/pdf_get_man/__init__.py
--rw-r--r--   0        0        0      165 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/pdf_get_man/pdf_get_man_cli.md
--rw-r--r--   0        0        0    10924 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/pdf_get_man/pdf_get_man_cli.py
--rw-r--r--   0        0        0      128 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/pdf_prep/__init__.py
--rw-r--r--   0        0        0      161 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/pdf_prep/check_ocr.md
--rw-r--r--   0        0        0     4403 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/pdf_prep/check_ocr.py
--rw-r--r--   0        0        0      161 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/pdf_prep/completeness_validation.md
--rw-r--r--   0        0        0     6864 2023-05-31 20:23:35.829381 colrev-0.9.0/colrev/ops/built_in/pdf_prep/completeness_validation.py
--rw-r--r--   0        0        0      161 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/pdf_prep/cover_page.md
--rw-r--r--   0        0        0     7848 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/pdf_prep/cover_page.py
--rw-r--r--   0        0        0      161 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/pdf_prep/last_page.md
--rw-r--r--   0        0        0     4888 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/pdf_prep/last_page.py
--rw-r--r--   0        0        0      161 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/pdf_prep/metadata_validation.md
--rw-r--r--   0        0        0     6435 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/pdf_prep/metadata_validation.py
--rw-r--r--   0        0        0      161 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/pdf_prep/tei_prep.md
--rw-r--r--   0        0        0     2105 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/pdf_prep/tei_prep.py
--rw-r--r--   0        0        0      132 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/pdf_prep_man/__init__.py
--rw-r--r--   0        0        0      167 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/pdf_prep_man/pdf_prep_man_cli.md
--rw-r--r--   0        0        0    10062 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/pdf_prep_man/pdf_prep_man_cli.py
--rw-r--r--   0        0        0      124 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/__init__.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/bibtex_crossref_resolution.md
--rw-r--r--   0        0        0     2740 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/bibtex_crossref_resolution.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/citeas_prep.md
--rw-r--r--   0        0        0     4601 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/citeas_prep.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/crossref_metadata_prep.md
--rw-r--r--   0        0        0     2483 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/crossref_metadata_prep.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/curation_prep.md
--rw-r--r--   0        0        0     2161 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/curation_prep.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/dblp_metadata_prep.md
--rw-r--r--   0        0        0     2353 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/dblp_metadata_prep.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/doi_from_urls_prep.md
--rw-r--r--   0        0        0     4110 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/doi_from_urls_prep.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/doi_metadata_prep.md
--rw-r--r--   0        0        0     1961 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/doi_metadata_prep.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/europe_pmc_prep.md
--rw-r--r--   0        0        0     1701 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/europe_pmc_prep.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/exclude_collections.md
--rw-r--r--   0        0        0     1513 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/exclude_collections.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/exclude_complementary_materials.md
--rw-r--r--   0        0        0     2286 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/exclude_complementary_materials.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/exclude_languages.md
--rw-r--r--   0        0        0     5819 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/exclude_languages.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/exclude_non_latin_alphabets.md
--rw-r--r--   0        0        0     2384 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/exclude_non_latin_alphabets.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/general_polish.md
--rw-r--r--   0        0        0     2076 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/general_polish.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/local_index_prep.md
--rw-r--r--   0        0        0     2428 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/local_index_prep.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/open_library_prep.md
--rw-r--r--   0        0        0     2058 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/open_library_prep.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/pubmed_metadata_prep.md
--rw-r--r--   0        0        0     2318 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/pubmed_metadata_prep.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/remove_broken_ids.md
--rw-r--r--   0        0        0     2121 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/remove_broken_ids.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/remove_error500_urls.md
--rw-r--r--   0        0        0     2308 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/remove_error500_urls.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/semantic_scholar_prep.md
--rw-r--r--   0        0        0     6991 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/semantic_scholar_prep.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/source_specific_prep.md
--rw-r--r--   0        0        0     2974 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/source_specific_prep.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/update_masterdata_status.md
--rw-r--r--   0        0        0     1410 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/update_masterdata_status.py
--rw-r--r--   0        0        0     1106 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/utils.py
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/year_vol_iss_prep.md
--rw-r--r--   0        0        0     7724 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep/year_vol_iss_prep.py
--rw-r--r--   0        0        0      128 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep_man/__init__.py
--rw-r--r--   0        0        0      161 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep_man/curation_jupyter_prep_man.md
--rw-r--r--   0        0        0     1882 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep_man/curation_jupyter_prep_man.py
--rw-r--r--   0        0        0     1368 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep_man/prep_man_export.md
--rw-r--r--   0        0        0    13793 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prep_man/prep_man_export.py
--rw-r--r--   0        0        0      129 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prescreen/__init__.py
--rw-r--r--   0        0        0      165 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prescreen/asreview.md
--rw-r--r--   0        0        0     9793 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prescreen/asreview.py
--rw-r--r--   0        0        0      165 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prescreen/conditional_prescreen.md
--rw-r--r--   0        0        0     2033 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prescreen/conditional_prescreen.py
--rw-r--r--   0        0        0      165 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prescreen/prescreen_cli.md
--rw-r--r--   0        0        0     5047 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prescreen/prescreen_cli.py
--rw-r--r--   0        0        0      165 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prescreen/prescreen_table.md
--rw-r--r--   0        0        0     9643 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prescreen/prescreen_table.py
--rw-r--r--   0        0        0      165 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prescreen/scope_prescreen.md
--rw-r--r--   0        0        0     8976 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/prescreen/scope_prescreen.py
--rw-r--r--   0        0        0      132 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/__init__.py
--rw-r--r--   0        0        0      509 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/conceptual_review.md
--rw-r--r--   0        0        0     1258 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/conceptual_review.py
--rw-r--r--   0        0        0      507 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/critical_review.md
--rw-r--r--   0        0        0     1311 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/critical_review.py
--rw-r--r--   0        0        0     1141 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/curated_masterdata.md
--rw-r--r--   0        0        0     4667 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/curated_masterdata.py
--rw-r--r--   0        0        0      510 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/descriptive_review.md
--rw-r--r--   0        0        0     1325 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/descriptive_review.py
--rw-r--r--   0        0        0      509 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/literature_review.md
--rw-r--r--   0        0        0     1274 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/literature_review.py
--rw-r--r--   0        0        0      704 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/meta_analysis.md
--rw-r--r--   0        0        0     1807 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/meta_analysis.py
--rw-r--r--   0        0        0      508 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/narrative_review.md
--rw-r--r--   0        0        0     1253 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/narrative_review.py
--rw-r--r--   0        0        0      521 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/qualitative_systematic_review.md
--rw-r--r--   0        0        0     1886 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/qualitative_systematic_review.py
--rw-r--r--   0        0        0      633 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/scientometric.md
--rw-r--r--   0        0        0     1340 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/scientometric.py
--rw-r--r--   0        0        0      506 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/scoping_review.md
--rw-r--r--   0        0        0     1445 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/scoping_review.py
--rw-r--r--   0        0        0      510 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/theoretical_review.md
--rw-r--r--   0        0        0     1404 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/review_types/theoretical_review.py
--rw-r--r--   0        0        0      126 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/screen/__init__.py
--rw-r--r--   0        0        0      159 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/screen/screen_cli.md
--rw-r--r--   0        0        0     9743 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/screen/screen_cli.py
--rw-r--r--   0        0        0      159 2023-05-31 20:23:35.833381 colrev-0.9.0/colrev/ops/built_in/screen/screen_table.md
--rw-r--r--   0        0        0     8839 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/screen/screen_table.py
--rw-r--r--   0        0        0     2642 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/screen/utils.py
--rw-r--r--   0        0        0      133 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/__init__.py
--rw-r--r--   0        0        0      486 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/abi_inform_proquest.md
--rw-r--r--   0        0        0     4730 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/abi_inform_proquest.py
--rw-r--r--   0        0        0      437 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/acm_digital_library.md
--rw-r--r--   0        0        0     4252 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/acm_digital_library.py
--rw-r--r--   0        0        0      766 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/aisel.md
--rw-r--r--   0        0        0    18699 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/aisel.py
--rw-r--r--   0        0        0      373 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/colrev_project.md
--rw-r--r--   0        0        0     9151 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/colrev_project.py
--rw-r--r--   0        0        0      698 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/crossref.md
--rw-r--r--   0        0        0    34796 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/crossref.py
--rw-r--r--   0        0        0      587 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/dblp.md
--rw-r--r--   0        0        0    26791 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/dblp.py
--rw-r--r--   0        0        0     6348 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/doi_org.py
--rw-r--r--   0        0        0      509 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/ebsco_host.md
--rw-r--r--   0        0        0     3118 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/ebsco_host.py
--rw-r--r--   0        0        0      450 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/eric.md
--rw-r--r--   0        0        0     3596 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/eric.py
--rw-r--r--   0        0        0      585 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/europe_pmc.md
--rw-r--r--   0        0        0    21029 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/europe_pmc.py
--rw-r--r--   0        0        0      552 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/google_scholar.md
--rw-r--r--   0        0        0     4984 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/google_scholar.py
--rw-r--r--   0        0        0      433 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/ieee.md
--rw-r--r--   0        0        0     4035 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/ieee.py
--rw-r--r--   0        0        0      417 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/jstor.md
--rw-r--r--   0        0        0     3695 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/jstor.py
--rw-r--r--   0        0        0      367 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/local_index.md
--rw-r--r--   0        0        0    34279 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/local_index.py
--rw-r--r--   0        0        0      429 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/open_citations_forward_search.md
--rw-r--r--   0        0        0     9285 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/open_citations_forward_search.py
--rw-r--r--   0        0        0      391 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/open_library.md
--rw-r--r--   0        0        0    11541 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/open_library.py
--rw-r--r--   0        0        0      804 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/pdf_backward_search.md
--rw-r--r--   0        0        0    15938 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/pdf_backward_search.py
--rw-r--r--   0        0        0      396 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/pdfs_dir.md
--rw-r--r--   0        0        0    32716 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/pdfs_dir.py
--rw-r--r--   0        0        0      439 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/psycinfo.md
--rw-r--r--   0        0        0     3638 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/psycinfo.py
--rw-r--r--   0        0        0      570 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/pubmed.md
--rw-r--r--   0        0        0    26103 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/pubmed.py
--rw-r--r--   0        0        0      418 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/scopus.md
--rw-r--r--   0        0        0     5762 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/scopus.py
--rw-r--r--   0        0        0      435 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/springer_link.md
--rw-r--r--   0        0        0     6432 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/springer_link.py
--rw-r--r--   0        0        0      480 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/systematic_review_datasets.md
--rw-r--r--   0        0        0     5092 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/systematic_review_datasets.py
--rw-r--r--   0        0        0      442 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/taylor_and_francis.md
--rw-r--r--   0        0        0     3440 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/taylor_and_francis.py
--rw-r--r--   0        0        0      463 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/trid.md
--rw-r--r--   0        0        0     3929 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/trid.py
--rw-r--r--   0        0        0      406 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/unknown_source.md
--rw-r--r--   0        0        0    14276 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/unknown_source.py
--rw-r--r--   0        0        0     5747 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/utils.py
--rw-r--r--   0        0        0      330 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/video_dir.md
--rw-r--r--   0        0        0     6312 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/video_dir.py
--rw-r--r--   0        0        0      443 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/web_of_science.md
--rw-r--r--   0        0        0     4934 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/web_of_science.py
--rw-r--r--   0        0        0     6390 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/website.py
--rw-r--r--   0        0        0      543 2023-05-31 20:23:35.837381 colrev-0.9.0/colrev/ops/built_in/search_sources/wiley.md
--rw-r--r--   0        0        0     3730 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/built_in/search_sources/wiley.py
--rw-r--r--   0        0        0     1434 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/clone.py
--rw-r--r--   0        0        0     9485 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/commit.py
--rw-r--r--   0        0        0     7210 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/correct.py
--rw-r--r--   0        0        0    14978 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/data.py
--rw-r--r--   0        0        0    36862 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/dedupe.py
--rw-r--r--   0        0        0     4771 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/distribute.py
--rw-r--r--   0        0        0    16729 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/init.py
--rw-r--r--   0        0        0    40696 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/load.py
--rw-r--r--   0        0        0     9391 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/merge.py
--rw-r--r--   0        0        0    26121 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/pdf_get.py
--rw-r--r--   0        0        0     7955 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/pdf_get_man.py
--rw-r--r--   0        0        0    17798 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/pdf_prep.py
--rw-r--r--   0        0        0    13447 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/pdf_prep_man.py
--rw-r--r--   0        0        0    45321 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/prep.py
--rw-r--r--   0        0        0    11241 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/prep_man.py
--rw-r--r--   0        0        0    13905 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/prescreen.py
--rw-r--r--   0        0        0     1690 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/pull.py
--rw-r--r--   0        0        0     5710 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/push.py
--rw-r--r--   0        0        0     2229 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/remove.py
--rw-r--r--   0        0        0    16211 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/repare.py
--rw-r--r--   0        0        0     1088 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/review_types.py
--rw-r--r--   0        0        0    17173 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/screen.py
--rw-r--r--   0        0        0    24436 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/search.py
--rw-r--r--   0        0        0     1612 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/search_sources.py
--rwxr-xr-x   0        0        0    22099 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/status.py
--rw-r--r--   0        0        0     8906 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/sync.py
--rw-r--r--   0        0        0     4181 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/trace.py
--rw-r--r--   0        0        0    16619 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/upgrade.py
--rw-r--r--   0        0        0    21877 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/ops/validate.py
--rw-r--r--   0        0        0        0 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/py.typed
--rw-r--r--   0        0        0      112 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/qm/__init__.py
--rw-r--r--   0        0        0       91 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/qm/checkers/__init__.py
--rw-r--r--   0        0        0     1152 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/qm/checkers/container_title_abbreviated.py
--rw-r--r--   0        0        0     1105 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/qm/checkers/doi_not_matching_pattern.py
--rw-r--r--   0        0        0     1207 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/qm/checkers/erroneous_symbol_in_field.py
--rw-r--r--   0        0        0     1532 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/qm/checkers/erroneous_term_in_field.py
--rw-r--r--   0        0        0     1364 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/qm/checkers/erroneous_title_field.py
--rw-r--r--   0        0        0     1571 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/qm/checkers/identical_values_between_title_and_container.py
--rw-r--r--   0        0        0     1543 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/qm/checkers/incomplete_field.py
--rw-r--r--   0        0        0     1596 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/qm/checkers/inconsistent_content.py
--rw-r--r--   0        0        0     3083 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/qm/checkers/inconsistent_with_doi_metadata.py
--rw-r--r--   0        0        0     1957 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/qm/checkers/inconsistent_with_entrytype.py
--rw-r--r--   0        0        0     2363 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/qm/checkers/inconsistent_with_url_metadata.py
--rw-r--r--   0        0        0     1189 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/qm/checkers/isbn_not_matching_pattern.py
--rw-r--r--   0        0        0     1279 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/qm/checkers/language_format_error.py
--rw-r--r--   0        0        0    11720 2023-05-31 20:23:35.841381 colrev-0.9.0/colrev/qm/checkers/missing_field.py
--rw-r--r--   0        0        0     1442 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/qm/checkers/mostly_all_caps.py
--rw-r--r--   0        0        0     1211 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/qm/checkers/name_abbreviated.py
--rw-r--r--   0        0        0     2392 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/qm/checkers/name_format_separators.py
--rw-r--r--   0        0        0     1379 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/qm/checkers/name_format_titles.py
--rw-r--r--   0        0        0     1754 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/qm/checkers/record_not_in_toc.py
--rw-r--r--   0        0        0     1231 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/qm/checkers/thesis_with_multiple_authors.py
--rw-r--r--   0        0        0     1018 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/qm/checkers/year_format.py
--rw-r--r--   0        0        0     7063 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/qm/colrev_id.py
--rw-r--r--   0        0        0     1493 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/qm/colrev_pdf_id.py
--rw-r--r--   0        0        0     1722 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/qm/quality_model.py
--rw-r--r--   0        0        0     2967 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/qm/readme.md
--rw-r--r--   0        0        0      104 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/readme.md
--rw-r--r--   0        0        0    90460 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/record.py
--rw-r--r--   0        0        0    25592 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/review_manager.py
--rw-r--r--   0        0        0    11425 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/service.py
--rw-r--r--   0        0        0    19654 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/settings.py
--rw-r--r--   0        0        0     1820 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/custom_scripts/custom_data_script.py
--rw-r--r--   0        0        0     1096 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/custom_scripts/custom_pdf_get_script.py
--rw-r--r--   0        0        0     1365 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/custom_scripts/custom_pdf_prep_script.py
--rw-r--r--   0        0        0     1314 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/custom_scripts/custom_prep_script.py
--rw-r--r--   0        0        0     1829 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/custom_scripts/custom_prescreen_script.py
--rw-r--r--   0        0        0     2345 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/custom_scripts/custom_screen_script.py
--rw-r--r--   0        0        0     3239 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/custom_scripts/custom_search_source_script.py
--rw-r--r--   0        0        0    15707 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/example/30_example_records.bib
--rw-r--r--   0        0        0      143 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/github_pages/README.md
--rw-r--r--   0        0        0      155 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/github_pages/_config.yml
--rw-r--r--   0        0        0       73 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/github_pages/about.md
--rw-r--r--   0        0        0     4953 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/github_pages/index.html
--rw-r--r--   0        0        0      185 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/github_pages/pre-commit-config.yaml
--rw-r--r--   0        0        0    18650 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/init/LICENSE-CC-BY-4.0.txt
--rw-r--r--   0        0        0     1770 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/init/colrev_update.yml
--rw-r--r--   0        0        0     1555 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/init/colrev_update_curation.yml
--rw-r--r--   0        0        0       54 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/init/gitattributes
--rw-r--r--   0        0        0       85 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/init/markdownlint.yaml
--rw-r--r--   0        0        0      936 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/init/pre-commit-config.yaml
--rw-r--r--   0        0        0      480 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/init/pre-commit.yml
--rw-r--r--   0        0        0      276 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/init/readme.md
--rw-r--r--   0        0        0     5226 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/init/settings.json
--rw-r--r--   0        0        0      930 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/ops/commit_report_details.txt
--rw-r--r--   0        0        0      271 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/ops/commit_report_header.txt
--rw-r--r--   0        0        0      352 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/ops/complementary_material_keywords.txt
--rw-r--r--   0        0        0      318 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/ops/complementary_material_strings.txt
--rw-r--r--   0        0        0      494 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/ops/masterdata_curations.csv
--rw-r--r--   0        0        0      462 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/ops/pdf_get_man_mail.txt
--rw-r--r--   0        0        0    76341 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/ops/predatory_journals_beall.csv
--rw-r--r--   0        0        0     2729 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/ops/prep_man_curation.ipynb
--rw-r--r--   0        0        0     3830 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/ops/status.txt
--rw-r--r--   0        0        0    50201 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/package_endpoints.json
--rw-r--r--   0        0        0    12922 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/package_status.json
--rw-r--r--   0        0        0       94 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/packages.json
--rw-r--r--   0        0        0    25233 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/paper_md/APA-7.docx
--rw-r--r--   0        0        0      381 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/paper_md/non_sample_references.bib
--rw-r--r--   0        0        0      673 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/paper_md/paper.md
--rw-r--r--   0        0        0     4935 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/prisma/PRISMA.csv
--rw-r--r--   0        0        0     5108 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/prisma/PRISMA_original.csv
--rw-r--r--   0        0        0      872 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/prisma/prisma-refs.bib
--rw-r--r--   0        0        0      262 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/prisma/prisma_text.md
--rw-r--r--   0        0        0     1506 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/review_type/curated_masterdata/curations_github_colrev_update.yml
--rw-r--r--   0        0        0      460 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/review_type/curated_masterdata/readme.md
--rw-r--r--   0        0        0      586 2023-05-31 20:23:35.845381 colrev-0.9.0/colrev/template/review_type/meta_analysis/paper.md
--rw-r--r--   0        0        0      104 2023-05-31 20:23:35.849381 colrev-0.9.0/colrev/ui_cli/__init__.py
--rw-r--r--   0        0        0     5534 2023-05-31 20:23:35.849381 colrev-0.9.0/colrev/ui_cli/add_packages.py
--rw-r--r--   0        0        0    75497 2023-05-31 20:23:35.849381 colrev-0.9.0/colrev/ui_cli/cli.py
--rw-r--r--   0        0        0      146 2023-05-31 20:23:35.849381 colrev-0.9.0/colrev/ui_cli/cli_colors.py
--rw-r--r--   0        0        0     9349 2023-05-31 20:23:35.849381 colrev-0.9.0/colrev/ui_cli/cli_status_printer.py
--rw-r--r--   0        0        0     7346 2023-05-31 20:23:35.849381 colrev-0.9.0/colrev/ui_cli/cli_validation.py
--rw-r--r--   0        0        0     2757 2023-05-31 20:23:35.849381 colrev-0.9.0/colrev/ui_cli/dedupe_errors.py
--rw-r--r--   0        0        0     2853 2023-05-31 20:23:35.849381 colrev-0.9.0/colrev/ui_cli/show_printer.py
--rw-r--r--   0        0        0     2932 2023-05-31 20:23:35.881381 colrev-0.9.0/pyproject.toml
--rw-r--r--   0        0        0    11074 1970-01-01 00:00:00.000000 colrev-0.9.0/PKG-INFO
+-rw-r--r--   0        0        0    10435 2023-07-24 05:33:42.615498 colrev-0.9.2/CHANGELOG.md
+-rw-r--r--   0        0        0     4405 2023-07-24 05:33:42.615498 colrev-0.9.2/CONTRIBUTING.md
+-rw-r--r--   0        0        0     1070 2023-07-24 05:33:42.615498 colrev-0.9.2/LICENSE
+-rw-r--r--   0        0        0    12200 2023-07-24 05:33:42.615498 colrev-0.9.2/README.md
+-rw-r--r--   0        0        0      314 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/__init__.py
+-rw-r--r--   0        0        0      128 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/__version__.py
+-rw-r--r--   0        0        0    31399 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/advisor.py
+-rw-r--r--   0        0        0    32084 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/checker.py
+-rw-r--r--   0        0        0    43795 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/dataset.py
+-rw-r--r--   0        0        0      105 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/env/__init__.py
+-rw-r--r--   0        0        0    15226 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/env/environment_manager.py
+-rw-r--r--   0        0        0     2151 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/env/grobid_service.py
+-rw-r--r--   0        0        0     3657 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/env/language_service.py
+-rw-r--r--   0        0        0    54392 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/env/local_index.py
+-rw-r--r--   0        0        0    38756 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/env/package_manager.py
+-rw-r--r--   0        0        0     2270 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/env/resources.py
+-rw-r--r--   0        0        0     3933 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/env/screenshot_service.py
+-rw-r--r--   0        0        0    34818 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/env/tei_parser.py
+-rw-r--r--   0        0        0     6161 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/env/utils.py
+-rw-r--r--   0        0        0     2518 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/env/zotero_translation_service.py
+-rw-r--r--   0        0        0    18399 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/exceptions.py
+-rw-r--r--   0        0        0      151 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/exit_codes.py
+-rw-r--r--   0        0        0       86 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/hooks/__init__.py
+-rwxr-xr-x   0        0        0      352 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/hooks/check.py
+-rwxr-xr-x   0        0        0      372 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/hooks/format.py
+-rwxr-xr-x   0        0        0      468 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/hooks/report.py
+-rwxr-xr-x   0        0        0      360 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/hooks/share.py
+-rwxr-xr-x   0        0        0     1233 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/hooks/update.py
+-rw-r--r--   0        0        0     1842 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/linter/colrev_lint.py
+-rw-r--r--   0        0        0      310 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/linter/readme.md
+-rw-r--r--   0        0        0     3082 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/logger.py
+-rw-r--r--   0        0        0     8951 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/operation.py
+-rw-r--r--   0        0        0       92 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/ops/__init__.py
+-rw-r--r--   0        0        0    42838 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/ops/assets/favicon.ico
+-rw-r--r--   0        0        0    52916 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/ops/assets/faviconWhiteBg.ico
+-rw-r--r--   0        0        0     2222 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/ops/assets/style.css
+-rw-r--r--   0        0        0      119 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/ops/built_in/__init__.py
+-rw-r--r--   0        0        0      135 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/ops/built_in/data/__init__.py
+-rw-r--r--   0        0        0      432 2023-07-24 05:33:42.615498 colrev-0.9.2/colrev/ops/built_in/data/bibliography_export.md
+-rw-r--r--   0        0        0     9191 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/data/bibliography_export.py
+-rw-r--r--   0        0        0     1084 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/data/colrev_curation.md
+-rw-r--r--   0        0        0    14961 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/data/colrev_curation.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/data/github_pages.md
+-rw-r--r--   0        0        0    13410 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/data/github_pages.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/data/obsidian.md
+-rw-r--r--   0        0        0     9428 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/data/obsidian.py
+-rw-r--r--   0        0        0     1142 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/data/paper_md.md
+-rw-r--r--   0        0        0    31983 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/data/paper_md.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/data/prisma.md
+-rw-r--r--   0        0        0     9200 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/data/prisma.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/data/structured.md
+-rw-r--r--   0        0        0    11223 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/data/structured.py
+-rw-r--r--   0        0        0      126 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/dedupe/__init__.py
+-rw-r--r--   0        0        0      159 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/dedupe/active_learning_dedup_io.md
+-rw-r--r--   0        0        0    42748 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/dedupe/active_learning_dedup_io.py
+-rw-r--r--   0        0        0      159 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/dedupe/curation_dedupe.md
+-rw-r--r--   0        0        0    25476 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/dedupe/curation_dedupe.py
+-rw-r--r--   0        0        0      159 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/dedupe/curation_missing_dedupe.md
+-rw-r--r--   0        0        0    14391 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/dedupe/curation_missing_dedupe.py
+-rw-r--r--   0        0        0      159 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/dedupe/simple_dedupe.md
+-rw-r--r--   0        0        0    14251 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/dedupe/simple_dedupe.py
+-rw-r--r--   0        0        0     1961 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/dedupe/utils.py
+-rw-r--r--   0        0        0      127 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_get/__init__.py
+-rw-r--r--   0        0        0      159 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_get/local_index_pdf_get.md
+-rw-r--r--   0        0        0     2483 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_get/local_index_pdf_get.py
+-rw-r--r--   0        0        0      432 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_get/unpaywall.md
+-rw-r--r--   0        0        0     5280 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_get/unpaywall.py
+-rw-r--r--   0        0        0      159 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_get/website_screenshot.md
+-rw-r--r--   0        0        0     1785 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_get/website_screenshot.py
+-rw-r--r--   0        0        0      131 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_get_man/__init__.py
+-rw-r--r--   0        0        0      165 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_get_man/pdf_get_man_cli.md
+-rw-r--r--   0        0        0    12016 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_get_man/pdf_get_man_cli.py
+-rw-r--r--   0        0        0      128 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_prep/__init__.py
+-rw-r--r--   0        0        0      161 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_prep/check_ocr.md
+-rw-r--r--   0        0        0     4403 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_prep/check_ocr.py
+-rw-r--r--   0        0        0      161 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_prep/completeness_validation.md
+-rw-r--r--   0        0        0     6864 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_prep/completeness_validation.py
+-rw-r--r--   0        0        0      161 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_prep/cover_page.md
+-rw-r--r--   0        0        0     7848 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_prep/cover_page.py
+-rw-r--r--   0        0        0      161 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_prep/last_page.md
+-rw-r--r--   0        0        0     4888 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_prep/last_page.py
+-rw-r--r--   0        0        0      161 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_prep/metadata_validation.md
+-rw-r--r--   0        0        0     6435 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_prep/metadata_validation.py
+-rw-r--r--   0        0        0      161 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_prep/tei_prep.md
+-rw-r--r--   0        0        0     2194 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_prep/tei_prep.py
+-rw-r--r--   0        0        0      132 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_prep_man/__init__.py
+-rw-r--r--   0        0        0      167 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_prep_man/pdf_prep_man_cli.md
+-rw-r--r--   0        0        0    10062 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/pdf_prep_man/pdf_prep_man_cli.py
+-rw-r--r--   0        0        0      124 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/__init__.py
+-rw-r--r--   0        0        0     1393 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/add_journal_ranking.md
+-rw-r--r--   0        0        0     1983 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/add_journal_ranking.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/bibtex_crossref_resolution.md
+-rw-r--r--   0        0        0     2740 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/bibtex_crossref_resolution.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/citeas_prep.md
+-rw-r--r--   0        0        0     4601 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/citeas_prep.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/crossref_metadata_prep.md
+-rw-r--r--   0        0        0     2483 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/crossref_metadata_prep.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/curation_prep.md
+-rw-r--r--   0        0        0     2161 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/curation_prep.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/dblp_metadata_prep.md
+-rw-r--r--   0        0        0     2353 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/dblp_metadata_prep.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/doi_from_urls_prep.md
+-rw-r--r--   0        0        0     4110 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/doi_from_urls_prep.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/doi_metadata_prep.md
+-rw-r--r--   0        0        0     1961 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/doi_metadata_prep.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/europe_pmc_prep.md
+-rw-r--r--   0        0        0     1701 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/europe_pmc_prep.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/exclude_collections.md
+-rw-r--r--   0        0        0     1513 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/exclude_collections.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/exclude_complementary_materials.md
+-rw-r--r--   0        0        0     2671 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/exclude_complementary_materials.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/exclude_languages.md
+-rw-r--r--   0        0        0     6553 2023-07-24 05:33:42.619498 colrev-0.9.2/colrev/ops/built_in/prep/exclude_languages.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/exclude_non_latin_alphabets.md
+-rw-r--r--   0        0        0     2384 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/exclude_non_latin_alphabets.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/general_polish.md
+-rw-r--r--   0        0        0     2076 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/general_polish.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/local_index_prep.md
+-rw-r--r--   0        0        0     2428 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/local_index_prep.py
+-rw-r--r--   0        0        0      145 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/open_alex_metadata_prep.md
+-rw-r--r--   0        0        0     2310 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/open_alex_metadata_prep.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/open_library_prep.md
+-rw-r--r--   0        0        0     2058 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/open_library_prep.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/pubmed_metadata_prep.md
+-rw-r--r--   0        0        0     2318 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/pubmed_metadata_prep.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/remove_broken_ids.md
+-rw-r--r--   0        0        0     2121 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/remove_broken_ids.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/remove_error500_urls.md
+-rw-r--r--   0        0        0     2308 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/remove_error500_urls.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/semantic_scholar_prep.md
+-rw-r--r--   0        0        0     6991 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/semantic_scholar_prep.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/source_specific_prep.md
+-rw-r--r--   0        0        0     2974 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/source_specific_prep.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/update_masterdata_status.md
+-rw-r--r--   0        0        0     1410 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/update_masterdata_status.py
+-rw-r--r--   0        0        0     1106 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/utils.py
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/year_vol_iss_prep.md
+-rw-r--r--   0        0        0     7724 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep/year_vol_iss_prep.py
+-rw-r--r--   0        0        0      128 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep_man/__init__.py
+-rw-r--r--   0        0        0      161 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep_man/curation_jupyter_prep_man.md
+-rw-r--r--   0        0        0     1882 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep_man/curation_jupyter_prep_man.py
+-rw-r--r--   0        0        0     1368 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep_man/prep_man_export.md
+-rw-r--r--   0        0        0    15009 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prep_man/prep_man_export.py
+-rw-r--r--   0        0        0      129 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prescreen/__init__.py
+-rw-r--r--   0        0        0      165 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prescreen/conditional_prescreen.md
+-rw-r--r--   0        0        0     2033 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prescreen/conditional_prescreen.py
+-rw-r--r--   0        0        0      165 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prescreen/prescreen_cli.md
+-rw-r--r--   0        0        0     5047 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prescreen/prescreen_cli.py
+-rw-r--r--   0        0        0      165 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prescreen/prescreen_table.md
+-rw-r--r--   0        0        0     9643 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prescreen/prescreen_table.py
+-rw-r--r--   0        0        0     1263 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prescreen/scope_prescreen.md
+-rw-r--r--   0        0        0    10746 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/prescreen/scope_prescreen.py
+-rw-r--r--   0        0        0      132 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/__init__.py
+-rw-r--r--   0        0        0      509 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/conceptual_review.md
+-rw-r--r--   0        0        0     1258 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/conceptual_review.py
+-rw-r--r--   0        0        0      507 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/critical_review.md
+-rw-r--r--   0        0        0     1311 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/critical_review.py
+-rw-r--r--   0        0        0     1141 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/curated_masterdata.md
+-rw-r--r--   0        0        0     4667 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/curated_masterdata.py
+-rw-r--r--   0        0        0      510 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/descriptive_review.md
+-rw-r--r--   0        0        0     1325 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/descriptive_review.py
+-rw-r--r--   0        0        0      509 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/literature_review.md
+-rw-r--r--   0        0        0     1274 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/literature_review.py
+-rw-r--r--   0        0        0      704 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/meta_analysis.md
+-rw-r--r--   0        0        0     1807 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/meta_analysis.py
+-rw-r--r--   0        0        0      508 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/narrative_review.md
+-rw-r--r--   0        0        0     1253 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/narrative_review.py
+-rw-r--r--   0        0        0      521 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/qualitative_systematic_review.md
+-rw-r--r--   0        0        0     1886 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/qualitative_systematic_review.py
+-rw-r--r--   0        0        0      633 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/scientometric.md
+-rw-r--r--   0        0        0     1340 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/scientometric.py
+-rw-r--r--   0        0        0      506 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/scoping_review.md
+-rw-r--r--   0        0        0     1445 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/scoping_review.py
+-rw-r--r--   0        0        0      510 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/theoretical_review.md
+-rw-r--r--   0        0        0     1404 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/review_types/theoretical_review.py
+-rw-r--r--   0        0        0      126 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/screen/__init__.py
+-rw-r--r--   0        0        0      159 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/screen/screen_cli.md
+-rw-r--r--   0        0        0     9714 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/screen/screen_cli.py
+-rw-r--r--   0        0        0      159 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/screen/screen_table.md
+-rw-r--r--   0        0        0     8839 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/screen/screen_table.py
+-rw-r--r--   0        0        0     2642 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/screen/utils.py
+-rw-r--r--   0        0        0      133 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/search_sources/__init__.py
+-rw-r--r--   0        0        0      496 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/search_sources/abi_inform_proquest.md
+-rw-r--r--   0        0        0     5208 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/search_sources/abi_inform_proquest.py
+-rw-r--r--   0        0        0      447 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/search_sources/acm_digital_library.md
+-rw-r--r--   0        0        0     4421 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/search_sources/acm_digital_library.py
+-rw-r--r--   0        0        0      915 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/search_sources/aisel.md
+-rw-r--r--   0        0        0    18514 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/search_sources/aisel.py
+-rw-r--r--   0        0        0      383 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/search_sources/colrev_project.md
+-rw-r--r--   0        0        0     9505 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/search_sources/colrev_project.py
+-rw-r--r--   0        0        0      936 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/search_sources/crossref.md
+-rw-r--r--   0        0        0    37312 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/search_sources/crossref.py
+-rw-r--r--   0        0        0      597 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/search_sources/dblp.md
+-rw-r--r--   0        0        0    26917 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/search_sources/dblp.py
+-rw-r--r--   0        0        0     6348 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/search_sources/doi_org.py
+-rw-r--r--   0        0        0      519 2023-07-24 05:33:42.623499 colrev-0.9.2/colrev/ops/built_in/search_sources/ebsco_host.md
+-rw-r--r--   0        0        0     3539 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/ebsco_host.py
+-rw-r--r--   0        0        0     1771 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/eric.md
+-rw-r--r--   0        0        0    10593 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/eric.py
+-rw-r--r--   0        0        0      595 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/europe_pmc.md
+-rw-r--r--   0        0        0    21014 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/europe_pmc.py
+-rw-r--r--   0        0        0      562 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/google_scholar.md
+-rw-r--r--   0        0        0     5159 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/google_scholar.py
+-rw-r--r--   0        0        0     1814 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/ieee.md
+-rw-r--r--   0        0        0    11716 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/ieee.py
+-rw-r--r--   0        0        0    13215 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/ieee_api.py
+-rw-r--r--   0        0        0      427 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/jstor.md
+-rw-r--r--   0        0        0     4511 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/jstor.py
+-rw-r--r--   0        0        0      377 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/local_index.md
+-rw-r--r--   0        0        0    34582 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/local_index.py
+-rw-r--r--   0        0        0      593 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/open_alex.md
+-rw-r--r--   0        0        0    11269 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/open_alex.py
+-rw-r--r--   0        0        0      439 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/open_citations_forward_search.md
+-rw-r--r--   0        0        0     9349 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/open_citations_forward_search.py
+-rw-r--r--   0        0        0      401 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/open_library.md
+-rw-r--r--   0        0        0    11634 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/open_library.py
+-rw-r--r--   0        0        0     1047 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/pdf_backward_search.md
+-rw-r--r--   0        0        0    16019 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/pdf_backward_search.py
+-rw-r--r--   0        0        0      406 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/pdfs_dir.md
+-rw-r--r--   0        0        0    33076 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/pdfs_dir.py
+-rw-r--r--   0        0        0      449 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/psycinfo.md
+-rw-r--r--   0        0        0     5667 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/psycinfo.py
+-rw-r--r--   0        0        0      580 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/pubmed.md
+-rw-r--r--   0        0        0    26892 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/pubmed.py
+-rw-r--r--   0        0        0      428 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/scopus.md
+-rw-r--r--   0        0        0     5944 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/scopus.py
+-rw-r--r--   0        0        0      445 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/springer_link.md
+-rw-r--r--   0        0        0     7160 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/springer_link.py
+-rw-r--r--   0        0        0      572 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/synergy_datasets.md
+-rw-r--r--   0        0        0     7051 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/synergy_datasets.py
+-rw-r--r--   0        0        0      452 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/taylor_and_francis.md
+-rw-r--r--   0        0        0     3610 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/taylor_and_francis.py
+-rw-r--r--   0        0        0      473 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/trid.md
+-rw-r--r--   0        0        0     4875 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/trid.py
+-rw-r--r--   0        0        0      416 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/unknown_source.md
+-rw-r--r--   0        0        0    16667 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/unknown_source.py
+-rw-r--r--   0        0        0     5869 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/utils.py
+-rw-r--r--   0        0        0      340 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/video_dir.md
+-rw-r--r--   0        0        0     6483 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/video_dir.py
+-rw-r--r--   0        0        0      453 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/web_of_science.md
+-rw-r--r--   0        0        0     4965 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/web_of_science.py
+-rw-r--r--   0        0        0     6390 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/website.py
+-rw-r--r--   0        0        0      553 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/wiley.md
+-rw-r--r--   0        0        0     4227 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/built_in/search_sources/wiley.py
+-rw-r--r--   0        0        0     1434 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/clone.py
+-rw-r--r--   0        0        0     9485 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/commit.py
+-rw-r--r--   0        0        0     7210 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/correct.py
+-rw-r--r--   0        0        0     1181 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/dashboard.py
+-rw-r--r--   0        0        0    15081 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/data.py
+-rw-r--r--   0        0        0    36901 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/dedupe.py
+-rw-r--r--   0        0        0     4753 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/distribute.py
+-rw-r--r--   0        0        0    16771 2023-07-24 05:33:42.627499 colrev-0.9.2/colrev/ops/init.py
+-rw-r--r--   0        0        0    25462 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/load.py
+-rw-r--r--   0        0        0     6635 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/load_utils_bib.py
+-rw-r--r--   0        0        0     1983 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/load_utils_md.py
+-rw-r--r--   0        0        0     6380 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/load_utils_ris.py
+-rw-r--r--   0        0        0     7195 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/load_utils_table.py
+-rw-r--r--   0        0        0     9434 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/merge.py
+-rw-r--r--   0        0        0     2887 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/pages/home.py
+-rw-r--r--   0        0        0     8944 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/pages/synthesizedrecords.py
+-rw-r--r--   0        0        0    26024 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/pdf_get.py
+-rw-r--r--   0        0        0     7998 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/pdf_get_man.py
+-rw-r--r--   0        0        0    17845 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/pdf_prep.py
+-rw-r--r--   0        0        0    13490 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/pdf_prep_man.py
+-rw-r--r--   0        0        0    45364 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/prep.py
+-rw-r--r--   0        0        0    11284 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/prep_man.py
+-rw-r--r--   0        0        0    14957 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/prescreen.py
+-rw-r--r--   0        0        0     1733 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/pull.py
+-rw-r--r--   0        0        0     5753 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/push.py
+-rw-r--r--   0        0        0     2272 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/remove.py
+-rw-r--r--   0        0        0    16253 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/repare.py
+-rw-r--r--   0        0        0     1088 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/review_types.py
+-rw-r--r--   0        0        0    18921 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/screen.py
+-rw-r--r--   0        0        0     8516 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/search.py
+-rw-r--r--   0        0        0    16327 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/search_feed.py
+-rw-r--r--   0        0        0     1612 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/search_sources.py
+-rwxr-xr-x   0        0        0    22234 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/status.py
+-rw-r--r--   0        0        0    10891 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/sync.py
+-rw-r--r--   0        0        0     4224 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/trace.py
+-rw-r--r--   0        0        0    17244 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/upgrade.py
+-rw-r--r--   0        0        0    21920 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/ops/validate.py
+-rw-r--r--   0        0        0        0 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/py.typed
+-rw-r--r--   0        0        0      112 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/__init__.py
+-rw-r--r--   0        0        0       91 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/__init__.py
+-rw-r--r--   0        0        0     1152 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/container_title_abbreviated.py
+-rw-r--r--   0        0        0     1105 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/doi_not_matching_pattern.py
+-rw-r--r--   0        0        0     1207 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/erroneous_symbol_in_field.py
+-rw-r--r--   0        0        0     1532 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/erroneous_term_in_field.py
+-rw-r--r--   0        0        0     1364 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/erroneous_title_field.py
+-rw-r--r--   0        0        0     1130 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/html_chars.py
+-rw-r--r--   0        0        0     1761 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/identical_values_between_title_and_container.py
+-rw-r--r--   0        0        0     1543 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/incomplete_field.py
+-rw-r--r--   0        0        0     1596 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/inconsistent_content.py
+-rw-r--r--   0        0        0     3083 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/inconsistent_with_doi_metadata.py
+-rw-r--r--   0        0        0     1957 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/inconsistent_with_entrytype.py
+-rw-r--r--   0        0        0     2363 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/inconsistent_with_url_metadata.py
+-rw-r--r--   0        0        0     1189 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/isbn_not_matching_pattern.py
+-rw-r--r--   0        0        0     1279 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/language_format_error.py
+-rw-r--r--   0        0        0     1130 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/language_unknown.py
+-rw-r--r--   0        0        0    11894 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/missing_field.py
+-rw-r--r--   0        0        0     1703 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/mostly_all_caps.py
+-rw-r--r--   0        0        0     1211 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/name_abbreviated.py
+-rw-r--r--   0        0        0     2392 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/name_format_separators.py
+-rw-r--r--   0        0        0     1379 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/name_format_titles.py
+-rw-r--r--   0        0        0     1243 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/page_range.py
+-rw-r--r--   0        0        0     1754 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/record_not_in_toc.py
+-rw-r--r--   0        0        0     1231 2023-07-24 05:33:42.631499 colrev-0.9.2/colrev/qm/checkers/thesis_with_multiple_authors.py
+-rw-r--r--   0        0        0     1018 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/qm/checkers/year_format.py
+-rw-r--r--   0        0        0     7096 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/qm/colrev_id.py
+-rw-r--r--   0        0        0     1493 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/qm/colrev_pdf_id.py
+-rw-r--r--   0        0        0     1722 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/qm/quality_model.py
+-rw-r--r--   0        0        0     2967 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/qm/readme.md
+-rw-r--r--   0        0        0      104 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/readme.md
+-rw-r--r--   0        0        0    91568 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/record.py
+-rw-r--r--   0        0        0    26329 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/review_manager.py
+-rw-r--r--   0        0        0    11725 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/service.py
+-rw-r--r--   0        0        0    19349 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/settings.py
+-rw-r--r--   0        0        0     1820 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/custom_scripts/custom_data_script.py
+-rw-r--r--   0        0        0     1095 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/custom_scripts/custom_pdf_get_script.py
+-rw-r--r--   0        0        0     1365 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/custom_scripts/custom_pdf_prep_script.py
+-rw-r--r--   0        0        0     1314 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/custom_scripts/custom_prep_script.py
+-rw-r--r--   0        0        0     1829 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/custom_scripts/custom_prescreen_script.py
+-rw-r--r--   0        0        0     2345 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/custom_scripts/custom_screen_script.py
+-rw-r--r--   0        0        0     3239 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/custom_scripts/custom_search_source_script.py
+-rw-r--r--   0        0        0    15707 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/example/30_example_records.bib
+-rw-r--r--   0        0        0      143 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/github_pages/README.md
+-rw-r--r--   0        0        0      155 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/github_pages/_config.yml
+-rw-r--r--   0        0        0       73 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/github_pages/about.md
+-rw-r--r--   0        0        0     4953 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/github_pages/index.html
+-rw-r--r--   0        0        0      185 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/github_pages/pre-commit-config.yaml
+-rw-r--r--   0        0        0    18650 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/init/LICENSE-CC-BY-4.0.txt
+-rw-r--r--   0        0        0     1770 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/init/colrev_update.yml
+-rw-r--r--   0        0        0     1555 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/init/colrev_update_curation.yml
+-rw-r--r--   0        0        0       54 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/init/gitattributes
+-rw-r--r--   0        0        0       85 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/init/markdownlint.yaml
+-rw-r--r--   0        0        0      936 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/init/pre-commit-config.yaml
+-rw-r--r--   0        0        0      480 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/init/pre-commit.yml
+-rw-r--r--   0        0        0      276 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/init/readme.md
+-rw-r--r--   0        0        0     5023 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/init/settings.json
+-rw-r--r--   0        0        0      930 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/ops/commit_report_details.txt
+-rw-r--r--   0        0        0      271 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/ops/commit_report_header.txt
+-rw-r--r--   0        0        0      352 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/ops/complementary_material_keywords.txt
+-rw-r--r--   0        0        0       25 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/ops/complementary_material_prefixes.txt
+-rw-r--r--   0        0        0      318 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/ops/complementary_material_strings.txt
+-rw-r--r--   0        0        0   190600 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/ops/journal_rankings.csv
+-rw-r--r--   0        0        0      494 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/ops/masterdata_curations.csv
+-rw-r--r--   0        0        0      462 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/ops/pdf_get_man_mail.txt
+-rw-r--r--   0        0        0     2729 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/ops/prep_man_curation.ipynb
+-rw-r--r--   0        0        0     3830 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/ops/status.txt
+-rw-r--r--   0        0        0    48591 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/package_endpoints.json
+-rw-r--r--   0        0        0    12566 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/package_status.json
+-rw-r--r--   0        0        0      227 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/packages.json
+-rw-r--r--   0        0        0    25233 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/paper_md/APA-7.docx
+-rw-r--r--   0        0        0      381 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/paper_md/non_sample_references.bib
+-rw-r--r--   0        0        0      673 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/paper_md/paper.md
+-rw-r--r--   0        0        0     4935 2023-07-24 05:33:42.635499 colrev-0.9.2/colrev/template/prisma/PRISMA.csv
+-rw-r--r--   0        0        0     5108 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/template/prisma/PRISMA_original.csv
+-rw-r--r--   0        0        0      872 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/template/prisma/prisma-refs.bib
+-rw-r--r--   0        0        0      262 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/template/prisma/prisma_text.md
+-rw-r--r--   0        0        0     1506 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/template/review_type/curated_masterdata/curations_github_colrev_update.yml
+-rw-r--r--   0        0        0      460 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/template/review_type/curated_masterdata/readme.md
+-rw-r--r--   0        0        0      586 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/template/review_type/meta_analysis/paper.md
+-rw-r--r--   0        0        0      104 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/ui_cli/__init__.py
+-rw-r--r--   0        0        0     7665 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/ui_cli/add_packages.py
+-rw-r--r--   0        0        0    81725 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/ui_cli/cli.py
+-rw-r--r--   0        0        0      146 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/ui_cli/cli_colors.py
+-rw-r--r--   0        0        0     3729 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/ui_cli/cli_load.py
+-rw-r--r--   0        0        0     9349 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/ui_cli/cli_status_printer.py
+-rw-r--r--   0        0        0     7346 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/ui_cli/cli_validation.py
+-rw-r--r--   0        0        0     2757 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/ui_cli/dedupe_errors.py
+-rw-r--r--   0        0        0     2089 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/ui_cli/search_backward_selective.py
+-rw-r--r--   0        0        0      975 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/ui_cli/setup_custom_scripts.py
+-rw-r--r--   0        0        0     2853 2023-07-24 05:33:42.639500 colrev-0.9.2/colrev/ui_cli/show_printer.py
+-rw-r--r--   0        0        0     3050 2023-07-24 05:33:42.675502 colrev-0.9.2/pyproject.toml
+-rw-r--r--   0        0        0    15193 1970-01-01 00:00:00.000000 colrev-0.9.2/PKG-INFO
```

### Comparing `colrev-0.9.0/CHANGELOG.md` & `colrev-0.9.2/CHANGELOG.md`

 * *Files 4% similar despite different names*

```diff
@@ -11,14 +11,26 @@
 
 ### Changed
 
 ### Removed
 
 ### Fixed
 
+## 0.9.2 - 2023-07-24
+
+### Changed
+
+- Updated colrev-asreview dependency (PyPI instead of GitHub)
+
+## 0.9.1 - 2023-07-23
+
+### Changed
+
+- Integrated `load` into `SearchSource`. Removed `load_conversion` endpoint: `settings.json`, `packages`, `interface` etc.
+
 ## 0.9.0 - 2023-06-01
 
 ### Added
 
 - The `quality_model` was created to check for quality defects
 - The `auto_upgrade` flag allows users to enable/disable automated upgrades
 - All-contributors bot to acknowledge contributions to CoLRev
```

### Comparing `colrev-0.9.0/CONTRIBUTING.md` & `colrev-0.9.2/CONTRIBUTING.md`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/LICENSE` & `colrev-0.9.2/LICENSE`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/advisor.py` & `colrev-0.9.2/colrev/advisor.py`

 * *Files 0% similar despite different names*

```diff
@@ -495,15 +495,15 @@
                 if len(missing_files) < 10:
                     non_existent_pdfs = ",".join(missing_files)
                 else:
                     non_existent_pdfs = ",".join(missing_files[0:10] + ["..."])
                 review_instructions.append(
                     {
                         "msg": f"record with broken file link ({non_existent_pdfs})."
-                        " Use\n    colrev pdf-get --relink_files"
+                        " Use\n    colrev pdf-get --relink_pdfs"
                     }
                 )
 
         pdfs_no_longer_available = []
         for record_dict in status_stats.records.values():
             if "file" in record_dict:
                 if not (self.review_manager.path / Path(record_dict["file"])).is_file():
@@ -645,18 +645,18 @@
         """Get instructions related to downloading outlets (resources)"""
 
         # pylint: disable=too-many-locals
 
         with open(self.review_manager.dataset.records_file, encoding="utf8") as file:
             outlets = []
             for line in file.readlines():
-                if line.lstrip()[:7] == "journal":
+                if line.lstrip()[:8] == "journal ":
                     journal = line[line.find("{") + 1 : line.rfind("}")]
                     outlets.append(journal)
-                if line.lstrip()[:9] == "booktitle":
+                if line.lstrip()[:10] == "booktitle ":
                     booktitle = line[line.find("{") + 1 : line.rfind("}")]
                     outlets.append(booktitle)
 
         outlet_counter: typing.List[typing.Tuple[str, int]] = [
             (j, x) for j, x in Counter(outlets).most_common(10) if x > 5
         ]
         selected = []
@@ -667,15 +667,15 @@
             if cumulative > 0.7:
                 break
         if len(selected) > 0:
             curated_outlets = environment_manager.get_curated_outlets()
             selected_journals = [
                 (candidate, freq)
                 for candidate, freq in selected
-                if candidate not in curated_outlets
+                if candidate not in curated_outlets + ["", "UNKNOWN"]
             ]
 
             journals = "\n   - " + "\n   - ".join(
                 [
                     f"{candidate} ({round((freq/len(outlets))*100, 2)}%)"
                     for candidate, freq in selected_journals
                 ]
```

### Comparing `colrev-0.9.0/colrev/checker.py` & `colrev-0.9.2/colrev/checker.py`

 * *Files 0% similar despite different names*

```diff
@@ -287,18 +287,25 @@
             else:
                 pattern = "=(in|out);".join(screening_criteria.keys()) + "=(in|out)"
                 pattern_inclusion = "=in;".join(screening_criteria.keys()) + "=in"
 
             for [record_id, status, screen_crit] in status_data[
                 "screening_criteria_list"
             ]:
-                if status not in colrev.record.RecordState.get_post_x_states(
-                    state=colrev.record.RecordState.rev_included
+                if (
+                    status
+                    not in colrev.record.RecordState.get_post_x_states(
+                        state=colrev.record.RecordState.rev_included
+                    )
+                    and status != colrev.record.RecordState.md_needs_manual_preparation
                 ):
-                    assert "NA" == screen_crit
+                    if "NA" != screen_crit:
+                        raise colrev_exceptions.FieldValueError(
+                            f"{record_id}: screen_crit != NA ({screen_crit})"
+                        )
                     continue
 
                 # print([record_id, status, screen_crit])
                 if not re.match(pattern, screen_crit):
                     # Note: this should also catch cases of missing
                     # screening criteria
                     field_errors.append(
```

### Comparing `colrev-0.9.0/colrev/dataset.py` & `colrev-0.9.2/colrev/dataset.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,14 +7,15 @@
 import os
 import re
 import string
 import time
 import typing
 from copy import deepcopy
 from pathlib import Path
+from random import randint
 from typing import Optional
 from typing import TYPE_CHECKING
 
 import git
 import pybtex.errors
 from git.exc import GitCommandError
 from git.exc import InvalidGitRepositoryError
@@ -50,14 +51,15 @@
         "__pycache__",
         "output",
         "data/pdf_get_man/missing_pdf_files.csv",
         "data/.tei/",
         "data/prep_man/records_prep_man.bib",
         "data/prep/",
         "data/dedupe/",
+        ".history",
     ]
     DEPRECATED_GIT_IGNORE_ITEMS = [
         "missing_pdf_files.csv",
         "manual_cleansing_statistics.csv",
         ".references_learned_settings",
         "pdfs",
         ".tei",
@@ -477,14 +479,16 @@
 
         if file_path:
             with open(file_path, encoding="utf-8") as file:
                 load_str = file.read()
 
         parser = bibtex.Parser()
         if load_str:
+            # Fix missing comma after fields
+            load_str = re.sub(r"(.)}\n", r"\g<1>},\n", load_str)
             bib_data = parser.parse_string(load_str)
             records_dict = self.parse_records_dict(records_dict=bib_data.entries)
 
         elif self.records_file.is_file():
             bib_data = parser.parse_file(str(self.records_file))
             records_dict = self.parse_records_dict(records_dict=bib_data.entries)
         else:
@@ -543,32 +547,35 @@
                 "journal",
                 "title",
                 "year",
                 "volume",
                 "number",
                 "pages",
                 "editor",
+                "publisher",
+                "url",
+                "abstract",
             ]
 
             record = colrev.record.Record(data=record_dict)
             record_dict = record.get_data(stringify=True)
 
             for ordered_field in field_order:
                 if ordered_field in record_dict:
                     if record_dict[ordered_field] == "":
                         continue
                     bibtex_str += format_field(
                         ordered_field, record_dict[ordered_field]
                     )
 
-            for key, value in record_dict.items():
+            for key in sorted(record_dict.keys()):
                 if key in field_order + ["ID", "ENTRYTYPE"]:
                     continue
 
-                bibtex_str += format_field(key, value)
+                bibtex_str += format_field(key, record_dict[key])
 
             bibtex_str += ",\n}\n"
 
         return bibtex_str
 
     def save_records_dict_to_file(self, *, records: dict, save_path: Path) -> None:
         """Save the records dict to specified file"""
@@ -968,15 +975,15 @@
     def add_changes(self, *, path: Path, remove: bool = False) -> None:
         """Add changed file to git"""
 
         if path.is_absolute():
             path = path.relative_to(self.review_manager.path)
 
         while (self.review_manager.path / Path(".git/index.lock")).is_file():
-            time.sleep(0.5)
+            time.sleep(randint(1, 50) * 0.1)  # nosec
             print("Waiting for previous git operation to complete")
 
         try:
             if remove:
                 self.__git_repo.index.remove([str(path)])
             else:
                 self.__git_repo.index.add([str(path)])
@@ -1040,22 +1047,22 @@
         if commit_nr == 0:
             cmsg = master.commit.message
         return cmsg
 
     def add_record_changes(self) -> None:
         """Add changes in records to git"""
         while (self.review_manager.path / Path(".git/index.lock")).is_file():
-            time.sleep(0.5)
+            time.sleep(randint(1, 50) * 0.1)  # nosec
             print("Waiting for previous git operation to complete")
         self.__git_repo.index.add([str(self.RECORDS_FILE_RELATIVE)])
 
     def add_setting_changes(self) -> None:
         """Add changes in settings to git"""
         while (self.review_manager.path / Path(".git/index.lock")).is_file():
-            time.sleep(0.5)
+            time.sleep(randint(1, 50) * 0.1)  # nosec
             print("Waiting for previous git operation to complete")
 
         self.__git_repo.index.add([str(self.review_manager.SETTINGS_RELATIVE)])
 
     def has_untracked_search_records(self) -> bool:
         """Check whether there are untracked search records"""
         search_dir = str(self.review_manager.SEARCHDIR_RELATIVE) + "/"
@@ -1138,7 +1145,13 @@
     def get_remote_url(self) -> str:  # pragma: no cover
         """Get the remote url"""
         remote_url = "NA"
         for remote in self.__git_repo.remotes:
             if remote.name == "origin":
                 remote_url = remote.url
         return remote_url
+
+    def stash_unstaged_changes(self) -> bool:
+        """Stash unstaged changes"""
+        return "No local changes to save" != self.__git_repo.git.stash(
+            "push", "--keep-index"
+        )
```

### Comparing `colrev-0.9.0/colrev/env/environment_manager.py` & `colrev-0.9.2/colrev/env/environment_manager.py`

 * *Files 3% similar despite different names*

```diff
@@ -34,52 +34,35 @@
     REGISTRY_RELATIVE_YAML = Path("registry.yaml")
     registry_yaml = colrev_path.joinpath(REGISTRY_RELATIVE_YAML)
     load_yaml = False
 
     def __init__(self) -> None:
         self.environment_registry = self.load_environment_registry()
         self.__registered_ports: typing.List[str] = []
-        self.__registered_services: typing.List[str] = []
 
     def register_ports(self, *, ports: typing.List[str]) -> None:
         """Register a localhost port to avoid conflicts"""
         for port_to_register in ports:
             if port_to_register in self.__registered_ports:
                 raise colrev_exceptions.PortAlreadyRegisteredException(
                     f"Port {port_to_register} already registered"
                 )
             self.__registered_ports.append(port_to_register)
 
-    def register_docker_service(self, *, imagename: str) -> None:
-        """Register a docker service"""
-        self.__registered_services.append(imagename)
-
-    def stop_docker_services(self) -> None:
-        """Stop registered docker services"""
-
-        try:
-            client = docker.from_env()
-            for container in client.containers.list():
-                if any(x in str(container.image) for x in self.__registered_services):
-                    container.stop()
-                    print(f"Stopped container {container.name} ({container.image})")
-        except DockerException as exc:
-            raise colrev_exceptions.ServiceNotAvailableException(
-                f"Docker service not available ({exc}). Please install/start Docker."
-            ) from exc
-
     def load_environment_registry(self) -> dict:
         """Load the local registry"""
         environment_registry_path = self.registry
         environment_registry_path_yaml = self.registry_yaml
         environment_registry = {}
         if environment_registry_path.is_file():
             self.load_yaml = False
             with open(environment_registry_path, encoding="utf8") as file:
                 environment_registry = json.load(fp=file)
+            # assert "local_index" in environment_registry
+            # assert "packages" in environment_registry
         elif environment_registry_path_yaml.is_file():
             self.load_yaml = True
             backup_file = Path(str(environment_registry_path_yaml) + ".bk")
             print(
                 f"Found a yaml file, converting to json, it will be backed up as {backup_file}"
             )
             with open(environment_registry_path_yaml, encoding="utf8") as file:
@@ -379,12 +362,12 @@
         return None
 
     def update_registry(self, key: str, value: str) -> None:
         """updates given key in the registry with new value"""
 
         keys = key.split(".")
         # We don't want to allow user to replace any core settings, so check for packages key
-        if keys[0] != "packages":
+        if keys[0] != "packages" or len(keys) < 2:
             raise colrev_exceptions.PackageSettingMustStartWithPackagesException(key)
         self.environment_registry = self.load_environment_registry()
         dict_set_nested(self.environment_registry, keys, value)
         self.save_environment_registry(updated_registry=self.environment_registry)
```

### Comparing `colrev-0.9.0/colrev/env/grobid_service.py` & `colrev-0.9.2/colrev/env/grobid_service.py`

 * *Files 13% similar despite different names*

```diff
@@ -11,20 +11,20 @@
 import colrev.env.environment_manager
 
 
 class GrobidService:
     """An environment service for machine readability/annotation (PDF to TEI conversion)"""
 
     GROBID_URL = "http://localhost:8070"
+    GROBID_IMAGE = "lfoppiano/grobid:0.7.3"
 
     def __init__(
         self, *, environment_manager: colrev.env.environment_manager.EnvironmentManager
     ) -> None:
-        self.grobid_image = "lfoppiano/grobid:0.7.3"
-        environment_manager.build_docker_image(imagename=self.grobid_image)
+        environment_manager.build_docker_image(imagename=self.GROBID_IMAGE)
         self.start()
         if not self.check_grobid_availability():
             environment_manager.register_ports(ports=["8070", "8071"])
 
     def check_grobid_availability(self, *, wait: bool = True) -> bool:
         """Check whether the GROBID service is available"""
         i = 0
@@ -53,18 +53,18 @@
             res = self.check_grobid_availability(wait=False)
             if res:
                 return
         except requests.exceptions.ConnectionError:
             pass
 
         client = docker.from_env()
-        logging.info("Running docker container created from %s", self.grobid_image)
+        logging.info("Running docker container created from %s", self.GROBID_IMAGE)
         logging.info("Starting grobid service...")
         client.containers.run(
-            self.grobid_image,
+            self.GROBID_IMAGE,
             auto_remove=True,
             tty=True,
             mem_limit="4g",
             ports={8070: 8070, 8071: 8071},
             detach=True,
         )
```

### Comparing `colrev-0.9.0/colrev/env/language_service.py` & `colrev-0.9.2/colrev/env/language_service.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/env/local_index.py` & `colrev-0.9.2/colrev/env/local_index.py`

 * *Files 1% similar despite different names*

```diff
@@ -11,14 +11,15 @@
 from copy import deepcopy
 from datetime import timedelta
 from multiprocessing import Lock
 from pathlib import Path
 from threading import Timer
 
 import git
+import pandas as pd
 import requests_cache
 from git.exc import GitCommandError
 from pybtex.database.input import bibtex
 from thefuzz import fuzz
 from tqdm import tqdm
 
 import colrev.dataset
@@ -125,15 +126,41 @@
     def __get_sqlite_cursor(self, *, init: bool = False) -> sqlite3.Cursor:
         if init:
             Path(self.SQLITE_PATH).unlink(missing_ok=True)
 
         self.sqlite_connection = sqlite3.connect(self.SQLITE_PATH, timeout=90)
         self.sqlite_connection.row_factory = self.__dict_factory
         return self.sqlite_connection.cursor()
-        # raise colrev_exceptions.ServiceNotAvailableException(dep="local_index")
+
+    def load_journal_rankings(self) -> None:
+        """Loads journal rankings into sqlite database"""
+
+        print("Index rankings")
+
+        rankings_csv_path = (
+            str(Path(__file__).parents[1])
+            / Path("template")
+            / Path("ops")
+            / Path("journal_rankings.csv")
+        )
+        conn = sqlite3.connect(self.SQLITE_PATH)
+        data_frame = pd.read_csv(rankings_csv_path, encoding="utf-8")
+        data_frame.to_sql("rankings", conn, if_exists="replace", index=False)
+        conn.commit()
+        conn.close()
+
+    def search_in_database(self, journal: typing.Optional[typing.Any]) -> list:
+        """Searches for journalranking in database"""
+        cur = self.__get_sqlite_cursor(init=False)
+        cur.execute(
+            "SELECT * FROM rankings WHERE journal_name = ?",
+            (journal,),
+        )
+        rankings = cur.fetchall()
+        return rankings
 
     def __dict_factory(self, cursor: sqlite3.Cursor, row: dict) -> dict:
         ret_dict = {}
         for idx, col in enumerate(cursor.description):
             ret_dict[col[0]] = row[idx]
         return ret_dict
```

### Comparing `colrev-0.9.0/colrev/env/package_manager.py` & `colrev-0.9.2/colrev/env/package_manager.py`

 * *Files 8% similar despite different names*

```diff
@@ -23,29 +23,28 @@
 import colrev.exceptions as colrev_exceptions
 import colrev.operation
 import colrev.record
 import colrev.settings
 import colrev.ui_cli.cli_colors as colors
 
 # pylint: disable=too-many-lines
+# pylint: disable=too-many-ancestors
 
 
 # Inspiration for package descriptions:
 # https://github.com/rstudio/reticulate/blob/
 # 9ebca7ecc028549dadb3d51d2184f9850f6f9f9d/DESCRIPTION
 
 
 class PackageEndpointType(Enum):
     """An enum for the types of PackageEndpoints"""
 
     # pylint: disable=C0103
     review_type = "review_type"
     """Endpoint for review types"""
-    load_conversion = "load_conversion"
-    """Endpoint for load conversion"""
     search_source = "search_source"
     """Endpoint for search sources"""
     prep = "prep"
     """Endpoint for prep"""
     prep_man = "prep_man"
     """Endpoint for prep-man"""
     dedupe = "dedupe"
@@ -63,16 +62,28 @@
     screen = "screen"
     """Endpoint for screen"""
     data = "data"
     """Endpoint for data"""
 
 
 # pylint: disable=too-few-public-methods
+class GeneralInterface(zope.interface.Interface):  # pylint: disable=inherit-non-class
+    """The General Interface for all package endpoints
+
+    Each package endpoint must implement the following attributes (methods)"""
+
+    ci_supported = zope.interface.Attribute(
+        """Flag indicating whether the extension can be run in
+        continuous integration environments (e.g. GitHub Actions)"""
+    )
+
+
+# pylint: disable=too-few-public-methods
 class ReviewTypePackageEndpointInterface(
-    zope.interface.Interface
+    GeneralInterface, zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for ReviewTypes"""
 
     # pylint: disable=no-self-argument
     def initialize(settings: dict) -> dict:  # type: ignore
         """Initialize the review type"""
         return settings  # pragma: no cover
@@ -88,15 +99,15 @@
     todo = "to_be_implemented"
 
     def __str__(self) -> str:
         return f"{self.name}"  # pragma: no cover
 
 
 class SearchSourcePackageEndpointInterface(
-    zope.interface.Interface
+    GeneralInterface, zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for SearchSources"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
     source_identifier = zope.interface.Attribute(
         """Source identifier for search and provenance
         Retrieved records are identified through the source_identifier
@@ -141,45 +152,27 @@
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ):
         """Retrieve masterdata from the SearchSource"""
 
     # pylint: disable=no-self-argument
-    def load_fixes(  # type: ignore
+    def load(  # type: ignore
         load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: dict,
-    ) -> None:
-        """SearchSource-specific fixes to ensure that load_records (from .bib) works"""
+    ) -> dict:
+        """Load records from the SearchSource (and convert to .bib)"""
 
     # pylint: disable=no-self-argument
     def prepare(record: dict, source: colrev.settings.SearchSource) -> None:  # type: ignore
         """Run the custom source-prep operation"""
 
 
 # pylint: disable=too-few-public-methods
-class LoadConversionPackageEndpointInterface(
-    zope.interface.Interface
-):  # pylint: disable=inherit-non-class
-    """The PackageEndpoint interface for loading (different filetypes)"""
-
-    settings_class = zope.interface.Attribute("""Class for the package settings""")
-    supported_extensions = zope.interface.Attribute("""List of supported extensions""")
-
-    # pylint: disable=no-self-argument
-    def load(  # type: ignore
-        load_operation: colrev.ops.load.Load, source: colrev.settings.SearchSource
-    ) -> None:
-        """Run the load operation"""
-
-
-# pylint: disable=too-few-public-methods
 class PrepPackageEndpointInterface(
-    zope.interface.Interface
+    GeneralInterface, zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for prep operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
     source_correction_hint = zope.interface.Attribute(
         """Hint on how to correct metadata at source"""
     )
@@ -192,72 +185,72 @@
     # pylint: disable=no-self-argument
     def prepare(prep_operation: colrev.ops.prep.Prep, prep_record: dict) -> dict:  # type: ignore
         """Run the prep operation"""
 
 
 # pylint: disable=too-few-public-methods
 class PrepManPackageEndpointInterface(
-    zope.interface.Interface
+    GeneralInterface, zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for prep-man operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
     # pylint: disable=no-self-argument
     def prepare_manual(  # type: ignore
         prep_man_operation: colrev.ops.prep_man.PrepMan, records: dict
     ) -> dict:
         """Run the prep-man operation"""
 
 
 # pylint: disable=too-few-public-methods
 class DedupePackageEndpointInterface(
-    zope.interface.Interface
+    GeneralInterface, zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for dedupe operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
     # pylint: disable=no-self-argument
     def run_dedupe(dedupe_operation: colrev.ops.dedupe.Dedupe) -> None:  # type: ignore
         """Run the dedupe operation"""
 
 
 # pylint: disable=too-few-public-methods
 class PrescreenPackageEndpointInterface(
-    zope.interface.Interface
+    GeneralInterface, zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for prescreen operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
     # pylint: disable=no-self-argument
     def run_prescreen(  # type: ignore
         prescreen_operation: colrev.ops.prescreen.Prescreen, records: dict, split: list
     ) -> dict:
         """Run the prescreen operation"""
 
 
 # pylint: disable=too-few-public-methods
 class PDFGetPackageEndpointInterface(
-    zope.interface.Interface
+    GeneralInterface, zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for pdf-get operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
     # pylint: disable=no-self-argument
     def get_pdf(pdf_get_operation: colrev.ops.pdf_get.PDFGet, record: dict) -> dict:  # type: ignore
         """Run the pdf-get operation"""
         return record  # pragma: no cover
 
 
 # pylint: disable=too-few-public-methods
 class PDFGetManPackageEndpointInterface(
-    zope.interface.Interface
+    GeneralInterface, zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for pdf-get-man operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
     # pylint: disable=no-self-argument
     def pdf_get_man(  # type: ignore
@@ -265,15 +258,15 @@
     ) -> dict:
         """Run the pdf-get-man operation"""
         return records  # pragma: no cover
 
 
 # pylint: disable=too-few-public-methods
 class PDFPrepPackageEndpointInterface(
-    zope.interface.Interface
+    GeneralInterface, zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for pdf-prep operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
     # pylint: disable=unused-argument
     # pylint: disable=no-self-argument
@@ -284,15 +277,15 @@
     ) -> dict:
         """Run the prep-pdf operation"""
         return record.data  # pragma: no cover
 
 
 # pylint: disable=too-few-public-methods
 class PDFPrepManPackageEndpointInterface(
-    zope.interface.Interface
+    GeneralInterface, zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for pdf-prep-man operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
     # pylint: disable=no-self-argument
     def pdf_prep_man(  # type: ignore
@@ -300,29 +293,29 @@
     ) -> dict:
         """Run the prep-man operation"""
         return records  # pragma: no cover
 
 
 # pylint: disable=too-few-public-methods
 class ScreenPackageEndpointInterface(
-    zope.interface.Interface
+    GeneralInterface, zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for screen operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
     # pylint: disable=no-self-argument
     def run_screen(  # type: ignore
         screen_operation: colrev.ops.screen.Screen, records: dict, split: list
     ) -> dict:
         """Run the screen operation"""
 
 
 class DataPackageEndpointInterface(
-    zope.interface.Interface
+    GeneralInterface, zope.interface.Interface
 ):  # pylint: disable=inherit-non-class
     """The PackageEndpoint interface for data operations"""
 
     settings_class = zope.interface.Attribute("""Class for the package settings""")
 
     # pylint: disable=no-self-argument
     # pylint: disable=no-method-argument
@@ -391,15 +384,14 @@
 
     # pylint: disable=duplicate-code
     # pylint: disable=too-many-instance-attributes
     endpoint: str
     filename: Path
     search_type: colrev.settings.SearchType
     search_parameters: dict
-    load_conversion_package_endpoint: dict
     comment: typing.Optional[str]
 
 
 class PackageManager:
     """The PackageManager provides functionality for package lookup and discovery"""
 
     package_type_overview = {
@@ -409,19 +401,14 @@
             "operation_name": "operation",
         },
         PackageEndpointType.search_source: {
             "import_name": SearchSourcePackageEndpointInterface,
             "custom_class": "CustomSearchSource",
             "operation_name": "source_operation",
         },
-        PackageEndpointType.load_conversion: {
-            "import_name": LoadConversionPackageEndpointInterface,
-            "custom_class": "CustomLoad",
-            "operation_name": "load_operation",
-        },
         PackageEndpointType.prep: {
             "import_name": PrepPackageEndpointInterface,
             "custom_class": "CustomPrep",
             "operation_name": "prep_operation",
         },
         PackageEndpointType.prep_man: {
             "import_name": PrepManPackageEndpointInterface,
@@ -551,18 +538,14 @@
         if "word_template" in package_details["properties"]:
             package_details["properties"]["word_template"]["type"] = "path"
         if "paper_output" in package_details["properties"]:
             package_details["properties"]["paper_output"]["type"] = "path"
 
         if PackageEndpointType.search_source == package_type:
             package_details["properties"]["filename"] = {"type": "path"}
-            package_details["properties"]["load_conversion_package_endpoint"] = {
-                "type": "script",
-                "package_endpoint_type": "load_conversion",
-            }
 
         package_details = self.__replace_path_by_str(orig_dict=package_details)  # type: ignore
 
     def get_package_details(
         self, *, package_type: PackageEndpointType, package_identifier: str
     ) -> dict:
         """Get the package details"""
@@ -703,59 +686,48 @@
 
         packages_dict: typing.Dict = {}
         for selected_package in selected_packages:
             package_identifier = selected_package["endpoint"].lower()
             packages_dict[package_identifier] = {}
 
             packages_dict[package_identifier]["settings"] = selected_package
-            # print(self.packages[package_type])
-            # print(package_identifier)
+
             # 1. Load built-in packages
-            # if package_identifier in cls.packages[package_type]
-            if package_identifier in self.packages[package_type]:
+            if not Path(package_identifier + ".py").is_file():
+                if package_identifier not in self.packages[package_type]:
+                    raise colrev_exceptions.MissingDependencyError(
+                        "Built-in dependency "
+                        + f"{package_identifier} ({package_type}) not in package_endpoints.json. "
+                    )
                 if not self.packages[package_type][package_identifier][
                     "installed"
                 ]:  # pragma: no cover
                     raise colrev_exceptions.MissingDependencyError(
-                        "Dependency "
-                        + f"{package_identifier} ({package_type}) not found. "
-                        "Please install it\n  pip install "
-                        f"{package_identifier.split('.')[0]}"
-                    )
-
-                if self.packages[package_type][package_identifier]["installed"]:
-                    packages_dict[package_identifier][
-                        "endpoint"
-                    ] = self.load_package_endpoint(
-                        package_type=package_type, package_identifier=package_identifier
+                        f"Dependency {package_identifier} ({package_type}) not found. "
+                        f"Please install it\n  pip install {package_identifier.split('.')[0]}"
                     )
+                packages_dict[package_identifier][
+                    "endpoint"
+                ] = self.load_package_endpoint(
+                    package_type=package_type, package_identifier=package_identifier
+                )
 
-            # 2. Load module packages
-            elif not Path(package_identifier + ".py").is_file():
-                try:
-                    packages_dict[package_identifier]["settings"] = selected_package
-                    packages_dict[package_identifier][
-                        "endpoint"
-                    ] = importlib.import_module(package_identifier)
-                    packages_dict[package_identifier][
-                        "custom_flag"
-                    ] = True  # pragma: no cover
-                except ModuleNotFoundError as exc:
-                    if ignore_not_available:
-                        print(f"Could not load {selected_package}")
-                        del packages_dict[package_identifier]
-                        continue
-                    raise colrev_exceptions.MissingDependencyError(
-                        "Dependency "
-                        + f"{package_identifier} ({package_type}) not found. "
-                        "Please install it\n  pip install "
-                        f"{package_identifier.split('.')[0]}"
-                    ) from exc
+            #     except ModuleNotFoundError as exc:
+            #         if ignore_not_available:
+            #             print(f"Could not load {selected_package}")
+            #             del packages_dict[package_identifier]
+            #             continue
+            #         raise colrev_exceptions.MissingDependencyError(
+            #             "Dependency "
+            #             f"{package_identifier} ({package_type}) not installed. "
+            #             "Please install it\n  pip install "
+            #             f"{package_identifier.split('.')[0]}"
+            #         ) from exc
 
-            # 3. Load custom packages in the directory
+            # 2. Load custom packages in the directory
             elif Path(package_identifier + ".py").is_file():
                 try:
                     # to import custom packages from the project dir
                     sys.path.append(".")
                     packages_dict[package_identifier]["settings"] = selected_package
                     packages_dict[package_identifier][
                         "endpoint"
@@ -788,15 +760,14 @@
         """Load the packages for a particular package_type"""
 
         packages_dict = self.__get_packages_dict(
             selected_packages=selected_packages,
             package_type=package_type,
             ignore_not_available=ignore_not_available,
         )
-
         self.__drop_broken_packages(
             packages_dict=packages_dict,
             package_type=package_type,
             ignore_not_available=ignore_not_available,
         )
 
         package_details = self.package_type_overview[package_type]
@@ -840,28 +811,34 @@
         packages_dict = {k: v for k, v in packages_dict.items() if k not in to_remove}
 
         return packages_dict
 
     def __add_package_endpoints(
         self,
         *,
+        selected_package: str,
         package_endpoints_json: dict,
         package_endpoints: dict,
         package_status: dict,
     ) -> None:
         for endpoint_type, endpoint_list in package_endpoints_json.items():
             if endpoint_type not in package_endpoints["endpoints"]:
                 continue
 
             package_list = "\n -  ".join(
                 p["package_endpoint_identifier"]
                 for p in package_endpoints["endpoints"][endpoint_type]
             )
             print(f" load {endpoint_type}: \n -  {package_list}")
             for endpoint_item in package_endpoints["endpoints"][endpoint_type]:
+                if (
+                    not endpoint_item["package_endpoint_identifier"].split(".")[0]
+                    == selected_package
+                ):
+                    continue
                 self.packages[PackageEndpointType[endpoint_type]][
                     endpoint_item["package_endpoint_identifier"]
                 ] = {"endpoint": endpoint_item["endpoint"], "installed": True}
                 endpoint = self.load_package_endpoint(
                     package_type=PackageEndpointType[endpoint_type],
                     package_identifier=endpoint_item["package_endpoint_identifier"],
                 )
@@ -915,15 +892,19 @@
                 else:
                     link = code_link
                 # Note: link format for the sphinx docs
                 endpoint_item["short_description"] = (
                     endpoint_item["short_description"] + f" (`instructions <{link}>`_)"
                 )
 
-            endpoint_list += package_endpoints["endpoints"][endpoint_type]
+            endpoint_list += [
+                x
+                for x in package_endpoints["endpoints"][endpoint_type]
+                if x["package_endpoint_identifier"].split(".")[0] == selected_package
+            ]
 
     def __load_packages_json(self) -> list:
         filedata = colrev.env.utils.get_package_file_content(
             file_path=Path("template/packages.json")
         )
         if not filedata:  # pragma: no cover
             raise colrev_exceptions.CoLRevException(
@@ -970,19 +951,19 @@
                 with open(endpoints_path, encoding="utf-8") as file:
                     package_endpoints = json.load(file)
             except json.decoder.JSONDecodeError as exc:  # pragma: no cover
                 print(f"Invalid json {exc}")
                 continue
 
             self.__add_package_endpoints(
+                selected_package=package["module"],
                 package_endpoints_json=package_endpoints_json,
                 package_endpoints=package_endpoints,
                 package_status=package_status,
             )
-
         for key in package_endpoints_json.keys():
             package_endpoints_json[key] = sorted(
                 package_endpoints_json[key],
                 key=lambda d: d["package_endpoint_identifier"],
             )
 
         json_object = json.dumps(package_endpoints_json, indent=4)
```

### Comparing `colrev-0.9.0/colrev/env/resources.py` & `colrev-0.9.2/colrev/env/resources.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/env/screenshot_service.py` & `colrev-0.9.2/colrev/env/screenshot_service.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/env/tei_parser.py` & `colrev-0.9.2/colrev/env/tei_parser.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/env/utils.py` & `colrev-0.9.2/colrev/env/utils.py`

 * *Files 3% similar despite different names*

```diff
@@ -137,14 +137,27 @@
     )
     if filedata:
         complementary_material_keywords = list(filedata.decode("utf-8").splitlines())
 
     return complementary_material_keywords
 
 
+def load_complementary_material_prefixes() -> list:
+    """Load the list of prefixes identifying complementary materials"""
+
+    complementary_material_keywords = []
+    filedata = get_package_file_content(
+        file_path=Path("template/ops/complementary_material_prefixes.txt")
+    )
+    if filedata:
+        complementary_material_keywords = list(filedata.decode("utf-8").splitlines())
+
+    return complementary_material_keywords
+
+
 def dict_keys_exists(element: dict, *keys: str) -> bool:
     """Check if *keys (nested) exists in `element` (dict)."""
     if len(keys) == 0:
         raise AttributeError("keys_exists() expects at least two arguments, one given.")
 
     _element = element
     for key in keys:
```

### Comparing `colrev-0.9.0/colrev/env/zotero_translation_service.py` & `colrev-0.9.2/colrev/env/zotero_translation_service.py`

 * *Files 4% similar despite different names*

```diff
@@ -15,27 +15,28 @@
 # https://www.zotero.org/support/dev/translators
 # https://github.com/zotero/translation-server/blob/master/src/formats.js
 
 
 class ZoteroTranslationService:
     """An environment service based on zotero translators"""
 
+    IMAGE_NAME = "zotero/translation-server:2.0.4"
+
     def __init__(
         self, *, environment_manager: colrev.env.environment_manager.EnvironmentManager
     ) -> None:
-        self.image_name = "zotero/translation-server:2.0.4"
-        environment_manager.build_docker_image(imagename=self.image_name)
+        environment_manager.build_docker_image(imagename=self.IMAGE_NAME)
 
     def stop(self) -> None:
         """Stop the zotero translation service"""
 
         try:
             client = docker.from_env()
             for container in client.containers.list():
-                if self.image_name in str(container.image):
+                if self.IMAGE_NAME in str(container.image):
                     container.stop()
         except DockerException as exc:
             raise colrev_exceptions.ServiceNotAvailableException(
                 dep="Zotero (Docker)", detailed_trace=exc
             ) from exc
 
     def start(self) -> None:
@@ -44,15 +45,15 @@
         # pylint: disable=duplicate-code
 
         try:
             self.stop()
 
             client = docker.from_env()
             _ = client.containers.run(
-                self.image_name,
+                self.IMAGE_NAME,
                 ports={"1969/tcp": ("127.0.0.1", 1969)},
                 auto_remove=True,
                 detach=True,
             )
 
             tries = 0
             while tries < 10:
```

### Comparing `colrev-0.9.0/colrev/exceptions.py` & `colrev-0.9.2/colrev/exceptions.py`

 * *Files 1% similar despite different names*

```diff
@@ -367,25 +367,35 @@
         self,
         msg: str,
     ) -> None:
         self.message = msg
         super().__init__(self.message)
 
 
+class SourceHeuristicsException(CoLRevException):
+    """An error occured in the SearchSource heuristics."""
+
+    def __init__(
+        self,
+        msg: str,
+    ) -> None:
+        self.message = msg
+        super().__init__(self.message)
+
+
 class UnsupportedImportFormatError(CoLRevException):
     """The file format is not supported."""
 
     def __init__(
         self,
         import_path: Path,
     ) -> None:
         self.import_path = import_path
         self.message = (
-            "Format of search result file not (yet) supported "
-            + f"({self.import_path.name}) "
+            f"Format of SearchSource file not supported ({self.import_path.name}) "
         )
         super().__init__(self.message)
 
 
 # Prep
```

### Comparing `colrev-0.9.0/colrev/hooks/update.py` & `colrev-0.9.2/colrev/hooks/update.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/linter/colrev_lint.py` & `colrev-0.9.2/colrev/linter/colrev_lint.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/logger.py` & `colrev-0.9.2/colrev/logger.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/operation.py` & `colrev-0.9.2/colrev/operation.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,24 +1,32 @@
 #!/usr/bin/env python3
 """Types and model of CoLRev operations."""
 from __future__ import annotations
 
+import typing
 from enum import auto
 from enum import Enum
+from typing import Any
+from typing import Callable
 from typing import Optional
 from typing import TYPE_CHECKING
+from typing import TypeVar
 
+import docker
 import git
+from docker.errors import DockerException
 
 import colrev.exceptions as colrev_exceptions
 import colrev.record
 
 if TYPE_CHECKING:
     import colrev.review_manager
 
+F = TypeVar("F", bound=Callable[..., Any])
+
 
 class OperationsType(Enum):
     """Operation types correspond to the main state transitions (see RecordStateModel)"""
 
     # pylint: disable=invalid-name
 
     search = auto()
@@ -65,20 +73,41 @@
         if notify_state_transition_operation:
             self.review_manager.notify(operation=self)
         else:
             self.review_manager.notify(operation=self, state_transition=False)
 
         self.cpus = 4
 
+        self.docker_images_to_stop: typing.List[str] = []
+
         # Note: the following call seems to block the flow (if debug is enabled)
         # self.review_manager.logger.debug(f"Created {self.type} operation")
 
         # Note: we call review_manager.notify() in the subclasses
         # to make sure that the review_manager calls the right check_preconditions()
 
+    # pylint: disable=too-many-nested-blocks
+    @classmethod
+    def decorate(cls) -> Callable:
+        """Decorator for operations"""
+
+        def decorator_func(func: F) -> Callable:
+            def wrapper_func(self, *args, **kwargs) -> Any:  # type: ignore
+                # Invoke the wrapped function
+                retval = func(self, *args, **kwargs)
+                # Conclude the operation
+                self.conclude()
+                if self.review_manager.in_ci_environment():
+                    print("\n\n")
+                return retval
+
+            return wrapper_func
+
+        return decorator_func
+
     def __check_record_state_model_precondition(self) -> None:
         colrev.record.RecordStateModel.check_operation_precondition(operation=self)
 
     def __require_clean_repo_general(
         self,
         *,
         git_repo: Optional[git.Repo] = None,
@@ -187,14 +216,24 @@
             #         # data.csv, paper.md etc.?,
             #     ]
             # )
             self.__check_record_state_model_precondition()
 
         # ie., implicit pass for format, explore, check, pdf_prep_man
 
+    def conclude(self) -> None:
+        """Conclude the operation (stop Docker containers)"""
+        try:
+            client = docker.from_env()
+            for container in client.containers.list():
+                if any(x in container.image.tags for x in self.docker_images_to_stop):
+                    container.stop()
+        except DockerException:
+            pass
+
 
 class FormatOperation(Operation):
     """A dummy operation that is expected to introduce formatting changes only"""
 
     # pylint: disable=too-few-public-methods
 
     def __init__(
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/data/bibliography_export.py` & `colrev-0.9.2/colrev/ops/built_in/data/bibliography_export.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/data/colrev_curation.md` & `colrev-0.9.2/colrev/ops/built_in/data/colrev_curation.md`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/data/colrev_curation.py` & `colrev-0.9.2/colrev/ops/built_in/data/colrev_curation.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/data/github_pages.py` & `colrev-0.9.2/colrev/ops/built_in/data/github_pages.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/data/obsidian.py` & `colrev-0.9.2/colrev/ops/built_in/data/obsidian.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/data/paper_md.md` & `colrev-0.9.2/colrev/ops/built_in/data/paper_md.md`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/data/paper_md.py` & `colrev-0.9.2/colrev/ops/built_in/data/paper_md.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/data/prisma.py` & `colrev-0.9.2/colrev/ops/built_in/data/prisma.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/data/structured.py` & `colrev-0.9.2/colrev/ops/built_in/data/structured.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/dedupe/active_learning_dedup_io.py` & `colrev-0.9.2/colrev/ops/built_in/dedupe/active_learning_dedup_io.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/dedupe/curation_dedupe.py` & `colrev-0.9.2/colrev/ops/built_in/dedupe/curation_dedupe.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/dedupe/curation_missing_dedupe.py` & `colrev-0.9.2/colrev/ops/built_in/dedupe/curation_missing_dedupe.py`

 * *Files 2% similar despite different names*

```diff
@@ -153,15 +153,15 @@
             ]:
                 continue
             same_toc_recs.append(record_candidate)
         return same_toc_recs
 
     def __print_same_toc_recs(
         self, *, same_toc_recs: list, record: colrev.record.Record
-    ) -> None:
+    ) -> list:
         for same_toc_rec in same_toc_recs:
             same_toc_rec["similarity"] = colrev.record.PrepRecord.get_record_similarity(
                 record_a=colrev.record.Record(data=same_toc_rec), record_b=record
             )
 
         same_toc_recs = sorted(
             same_toc_recs, key=lambda d: d["similarity"], reverse=True
@@ -177,14 +177,15 @@
             )
 
             if same_toc_rec["similarity"] > 0.8:
                 print(f"{i + 1} - {colors.ORANGE}{author_title_string}{colors.END}")
 
             else:
                 print(f"{i + 1} - {author_title_string}")
+        return same_toc_recs
 
     def __get_nr_recs_to_merge(self, *, records: dict) -> int:
         if self.review_manager.force_mode:
             self.review_manager.logger.info(
                 "Scope: md_prepared, md_needs_manual_preparation, md_imported"
             )
             nr_recs_to_merge = len(
@@ -229,15 +230,17 @@
                 continue
 
             print("\n\n\n")
             print(colors.ORANGE)
             record.print_citation_format()
             print(colors.END)
 
-            self.__print_same_toc_recs(same_toc_recs=same_toc_recs, record=record)
+            same_toc_recs = self.__print_same_toc_recs(
+                same_toc_recs=same_toc_recs, record=record
+            )
             i = len(same_toc_recs)
             valid_selection = False
             quit_pressed = False
             while not valid_selection:
                 ret = input(
                     f"({nr_recs_checked}/{nr_recs_to_merge}) "
                     f"Merge with record [{1}...{i+1} / s / a / p / q]?   "
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/dedupe/simple_dedupe.py` & `colrev-0.9.2/colrev/ops/built_in/dedupe/simple_dedupe.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/dedupe/utils.py` & `colrev-0.9.2/colrev/ops/built_in/dedupe/utils.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/load_conversion/bib_pybtex_loader.py` & `colrev-0.9.2/colrev/ops/load_utils_bib.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,149 +1,176 @@
 #! /usr/bin/env python
-"""Load conversion of bib files using pybtex"""
+"""Convenience functions to load bib files"""
 from __future__ import annotations
 
 import os
 import re
 import typing
-from dataclasses import dataclass
 from pathlib import Path
 from typing import TYPE_CHECKING
 
-import zope.interface
-from dataclasses_jsonschema import JsonSchemaMixin
-
-import colrev.env.package_manager
+import colrev.exceptions as colrev_exceptions
 
 if TYPE_CHECKING:
     import colrev.ops.load
 
-# pylint: disable=too-few-public-methods
-# pylint: disable=unused-argument
-
-
-@zope.interface.implementer(
-    colrev.env.package_manager.LoadConversionPackageEndpointInterface
-)
-@dataclass
-class BibPybtexLoader(JsonSchemaMixin):
-
-    """Loads BibTeX files (based on pybtex)"""
-
-    settings_class = colrev.env.package_manager.DefaultSettings
 
-    supported_extensions = ["bib"]
+def __apply_file_fixes(*, load_operation: colrev.ops.load.Load, filename: Path) -> None:
+    # pylint: disable=duplicate-code
 
-    ci_supported: bool = True
+    if not filename.is_file():
+        return
 
-    def __init__(
-        self,
-        *,
-        load_operation: colrev.ops.load.Load,
-        settings: dict,
-    ) -> None:
-        self.settings = self.settings_class.load_settings(data=settings)
-
-    def __general_load_fixes(self, records: dict) -> dict:
-        return records
-
-    def __apply_file_fixes(
-        self, *, load_operation: colrev.ops.load.Load, filename: Path
-    ) -> None:
-        # pylint: disable=duplicate-code
-
-        # Errors to fix before pybtex loading:
-        # - set_incremental_ids (otherwise, not all records will be loaded)
-        # - fix_keys (keys containing white spaces)
-        record_ids: typing.List[str] = []
-        with open(filename, "r+b") as file:
-            seekpos = file.tell()
-            line = file.readline()
-            while line:
-                if b"@" in line[:3]:
-                    current_id = line[line.find(b"{") + 1 : line.rfind(b",")]
-                    current_id_str = current_id.decode("utf-8").lstrip().rstrip()
-
-                    if current_id_str in record_ids:
-                        next_id = load_operation.review_manager.dataset.generate_next_unique_id(
+    # Errors to fix before pybtex loading:
+    # - set_incremental_ids (otherwise, not all records will be loaded)
+    # - fix_keys (keys containing white spaces)
+    record_ids: typing.List[str] = []
+    with open(filename, "r+b") as file:
+        seekpos = file.tell()
+        line = file.readline()
+        while line:
+            if b"@" in line[:3]:
+                current_id = line[line.find(b"{") + 1 : line.rfind(b",")]
+                current_id_str = current_id.decode("utf-8").lstrip().rstrip()
+
+                if current_id_str in record_ids:
+                    next_id = (
+                        load_operation.review_manager.dataset.generate_next_unique_id(
                             temp_id=current_id_str, existing_ids=record_ids
                         )
-                        load_operation.review_manager.logger.info(
-                            f"Fix duplicate ID: {current_id_str} >> {next_id}"
-                        )
-
-                        replacement_line = (
-                            line.decode("utf-8")
-                            .replace(current_id.decode("utf-8"), next_id)
-                            .encode("utf-8")
-                        )
-
-                        line = file.readline()
-                        remaining = line + file.read()
-                        file.seek(seekpos)
-                        file.write(replacement_line)
-                        seekpos = file.tell()
-                        file.flush()
-                        os.fsync(file)
-                        file.write(remaining)
-                        file.truncate()  # if the replacement is shorter...
-                        file.seek(seekpos)
-
-                        record_ids.append(next_id)
-
-                    else:
-                        record_ids.append(current_id_str)
-                if re.match(
-                    r"^\s*[a-zA-Z0-9]+\s+[a-zA-Z0-9]+\s*\=", line.decode("utf-8")
-                ):
-                    replacement_line = re.sub(
-                        r"(^\s*)([a-zA-Z0-9]+)\s+([a-zA-Z0-9]+)(\s*\=)",
-                        r"\1\2_\3\4",
-                        line.decode("utf-8"),
-                    ).encode("utf-8")
+                    )
                     load_operation.review_manager.logger.info(
-                        f"Fix invalid key: \n{line.decode('utf-8')}"
-                        f"{replacement_line.decode('utf-8')}"
+                        f"Fix duplicate ID: {current_id_str} >> {next_id}"
+                    )
+
+                    replacement_line = (
+                        line.decode("utf-8")
+                        .replace(current_id.decode("utf-8"), next_id)
+                        .encode("utf-8")
                     )
+
                     line = file.readline()
                     remaining = line + file.read()
                     file.seek(seekpos)
                     file.write(replacement_line)
                     seekpos = file.tell()
                     file.flush()
                     os.fsync(file)
                     file.write(remaining)
                     file.truncate()  # if the replacement is shorter...
                     file.seek(seekpos)
 
+                    record_ids.append(next_id)
+
+                else:
+                    record_ids.append(current_id_str)
+
+            # Fix keys
+            if re.match(r"^\s*[a-zA-Z0-9]+\s+[a-zA-Z0-9]+\s*\=", line.decode("utf-8")):
+                replacement_line = re.sub(
+                    r"(^\s*)([a-zA-Z0-9]+)\s+([a-zA-Z0-9]+)(\s*\=)",
+                    r"\1\2_\3\4",
+                    line.decode("utf-8"),
+                ).encode("utf-8")
+                load_operation.review_manager.logger.info(
+                    f"Fix invalid key: \n{line.decode('utf-8')}"
+                    f"{replacement_line.decode('utf-8')}"
+                )
+                line = file.readline()
+                remaining = line + file.read()
+                file.seek(seekpos)
+                file.write(replacement_line)
                 seekpos = file.tell()
+                file.flush()
+                os.fsync(file)
+                file.write(remaining)
+                file.truncate()  # if the replacement is shorter...
+                file.seek(seekpos)
+
+            seekpos = file.tell()
+            line = file.readline()
+
+
+def load_bib_file(
+    load_operation: colrev.ops.load.Load, source: colrev.settings.SearchSource
+) -> dict:
+    """Load a bib file and return records dict"""
+
+    def drop_empty_fields(*, records: dict) -> None:
+        for record_id in records:
+            records[record_id] = {
+                k: v for k, v in records[record_id].items() if v is not None
+            }
+            records[record_id] = {
+                k: v for k, v in records[record_id].items() if v != "nan"
+            }
+
+    def check_nr_in_bib(*, source: colrev.settings.SearchSource, records: dict) -> None:
+        nr_in_bib = load_operation.review_manager.dataset.get_nr_in_bib(
+            file_path=source.get_corresponding_bib_file()
+        )
+        if len(records) < nr_in_bib:
+            load_operation.review_manager.logger.error(
+                "broken bib file (not imported all records)"
+            )
+            with open(source.get_corresponding_bib_file(), encoding="utf8") as file:
                 line = file.readline()
+                while line:
+                    if "@" in line[:3]:
+                        record_id = line[line.find("{") + 1 : line.rfind(",")]
+                        if record_id not in [x["ID"] for x in records]:
+                            load_operation.review_manager.logger.error(
+                                f"{record_id} not imported"
+                            )
+                    line = file.readline()
 
-    def load(
-        self, load_operation: colrev.ops.load.Load, source: colrev.settings.SearchSource
-    ) -> dict:
-        """Load records from the source"""
-        records = {}
-        if source.filename.is_file():
-            self.__apply_file_fixes(
-                load_operation=load_operation, filename=source.filename
+    def check_bib_file(*, source: colrev.settings.SearchSource, records: dict) -> None:
+        if len(records.items()) <= 3:
+            return
+        if not any("author" in r for ID, r in records.items()):
+            raise colrev_exceptions.ImportException(
+                f"Import failed (no record with author field): {source.filename.name}"
             )
 
-            with open(source.filename, encoding="utf8") as bibtex_file:
-                records = load_operation.review_manager.dataset.load_records_dict(
-                    load_str=bibtex_file.read()
-                )
-        records = self.__general_load_fixes(records)
+        if not any("title" in r for ID, r in records.items()):
+            raise colrev_exceptions.ImportException(
+                f"Import failed (no record with title field): {source.filename.name}"
+            )
 
-        endpoint_dict = load_operation.package_manager.load_packages(
-            package_type=colrev.env.package_manager.PackageEndpointType.search_source,
-            selected_packages=[source.get_dict()],
-            operation=load_operation,
-            ignore_not_available=False,
+    if not source.filename.is_file():
+        load_operation.review_manager.logger.debug(
+            f"Did not find bib file {source.get_corresponding_bib_file().name} "
         )
-        endpoint = endpoint_dict[source.endpoint]
+        return {}
 
-        records = endpoint.load_fixes(  # type: ignore
-            load_operation, source=source, records=records
+    with open(source.filename, encoding="utf8") as bibtex_file:
+        contents = bibtex_file.read()
+        bib_r = re.compile(r"@.*{.*,", re.M)
+        if len(re.findall(bib_r, contents)) == 0:
+            load_operation.review_manager.logger.error(
+                f"Not a bib file? {source.filename.name}"
+            )
+            return {}
+
+    __apply_file_fixes(load_operation=load_operation, filename=source.filename)
+
+    with open(source.filename, encoding="utf8") as bibtex_file:
+        records = load_operation.review_manager.dataset.load_records_dict(
+            load_str=bibtex_file.read()
         )
 
+    if len(records) == 0:
+        load_operation.review_manager.report_logger.debug("No records loaded")
+        load_operation.review_manager.logger.debug("No records loaded")
         return records
+
+    drop_empty_fields(records=records)
+    records = dict(sorted(records.items()))
+
+    load_operation.review_manager.logger.debug(
+        f"Loaded {source.get_corresponding_bib_file().name} "
+        f"with {len(records)} records"
+    )
+
+    check_nr_in_bib(source=source, records=records)
+    check_bib_file(source=source, records=records)
+    return records
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/load_conversion/markdown_loader.py` & `colrev-0.9.2/colrev/ops/load_utils_md.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,65 +1,50 @@
 #! /usr/bin/env python
 """Load conversion of reference sections (bibliographies) in md-documents based on GROBID"""
 from __future__ import annotations
 
-from dataclasses import asdict
-from dataclasses import dataclass
 from typing import TYPE_CHECKING
 
 import requests
-import zope.interface
-from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 
 if TYPE_CHECKING:
     import colrev.ops.load
 
 # pylint: disable=too-few-public-methods
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 
-@zope.interface.implementer(
-    colrev.env.package_manager.LoadConversionPackageEndpointInterface
-)
-@dataclass
-class MarkdownLoader(JsonSchemaMixin):
+class MarkdownLoader:
 
     """Loads reference strings from text (md) files (based on GROBID)"""
 
-    settings_class = colrev.env.package_manager.DefaultSettings
-
-    ci_supported: bool = False
-
-    supported_extensions = ["md"]
-
     def __init__(
         self,
         *,
         load_operation: colrev.ops.load.Load,
-        settings: dict,
+        source: colrev.settings.SearchSource,
     ):
-        self.settings = self.settings_class.load_settings(data=settings)
+        self.source = source
+        self.load_operation = load_operation
 
-    def load(
-        self, load_operation: colrev.ops.load.Load, source: colrev.settings.SearchSource
-    ) -> dict:
+    def load(self) -> dict:
         """Load records from the source"""
 
-        load_operation.review_manager.logger.info(
+        self.load_operation.review_manager.logger.info(
             "Running GROBID to parse structured reference data"
         )
 
-        grobid_service = load_operation.review_manager.get_grobid_service()
+        grobid_service = self.load_operation.review_manager.get_grobid_service()
 
         grobid_service.check_grobid_availability()
-        with open(source.filename, encoding="utf8") as file:
-            if source.filename.suffix == ".md":
+        with open(self.source.filename, encoding="utf8") as file:
+            if self.source.filename.suffix == ".md":
                 references = [line.rstrip() for line in file if "#" not in line[:2]]
             else:
                 references = [line.rstrip() for line in file]
 
         data = ""
         ind = 0
         for ref in references:
@@ -71,21 +56,12 @@
                 data=options,
                 headers={"Accept": "application/x-bibtex"},
                 timeout=30,
             )
             ind += 1
             data = data + "\n" + ret.text.replace("{-1,", "{" + str(ind) + ",")
 
-        records = load_operation.review_manager.dataset.load_records_dict(load_str=data)
-
-        endpoint_dict = load_operation.package_manager.load_packages(
-            package_type=colrev.env.package_manager.PackageEndpointType.search_source,
-            selected_packages=[asdict(source)],
-            operation=load_operation,
-            ignore_not_available=False,
+        records = self.load_operation.review_manager.dataset.load_records_dict(
+            load_str=data
         )
-        endpoint = endpoint_dict[source.endpoint]
 
-        records = endpoint.load_fixes(  # type: ignore
-            load_operation, source=source, records=records
-        )
         return records
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/load_conversion/table_loader.py` & `colrev-0.9.2/colrev/ops/built_in/prep/year_vol_iss_prep.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,259 +1,211 @@
 #! /usr/bin/env python
-"""Load conversion of tables (xlsx, csv)"""
+"""Completion of metadata based on year-volume-issue dependency as a prep operation"""
 from __future__ import annotations
 
-from dataclasses import asdict
 from dataclasses import dataclass
 from typing import TYPE_CHECKING
 
-import pandas as pd
+import requests
 import zope.interface
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.built_in.search_sources.crossref as crossref_connector
+import colrev.ops.search_sources
+import colrev.record
 
-if TYPE_CHECKING:
-    import colrev.ops.load
-
-# pylint: disable=too-few-public-methods
-# pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
+if TYPE_CHECKING:
+    import colrev.ops.prep
 
-class TableLoadUtility:
-    """Utility for tables loading"""
-
-    @classmethod
-    def __rename_fields(cls, *, record_dict: dict) -> dict:
-        if "issue" in record_dict and "number" not in record_dict:
-            record_dict["number"] = record_dict["issue"]
-            if record_dict["number"] == "no issue":
-                del record_dict["number"]
-            del record_dict["issue"]
-
-        if "authors" in record_dict and "author" not in record_dict:
-            record_dict["author"] = record_dict["authors"]
-            del record_dict["authors"]
-
-        if "publication_year" in record_dict and "year" not in record_dict:
-            record_dict["year"] = record_dict["publication_year"]
-            del record_dict["publication_year"]
-
-        # Note: this is a simple heuristic:
-        if (
-            "journal/book" in record_dict
-            and "journal" not in record_dict
-            and "doi" in record_dict
-        ):
-            record_dict["journal"] = record_dict["journal/book"]
-            del record_dict["journal/book"]
-
-        return record_dict
-
-    @classmethod
-    def __set_entrytype(cls, *, record_dict: dict) -> dict:
-        record_dict["ENTRYTYPE"] = "misc"
-        if "type" in record_dict:
-            record_dict["ENTRYTYPE"] = record_dict["type"]
-            del record_dict["type"]
-            if record_dict["ENTRYTYPE"] == "inproceedings":
-                if "journal" in record_dict and "booktitle" not in record_dict:
-                    record_dict["booktitle"] = record_dict["journal"]
-                    del record_dict["journal"]
-            if record_dict["ENTRYTYPE"] == "article":
-                if "booktitle" in record_dict and "journal" not in record_dict:
-                    record_dict["journal"] = record_dict["booktitle"]
-                    del record_dict["booktitle"]
-
-        if "ENTRYTYPE" not in record_dict:
-            if record_dict.get("journal", "") != "":
-                record_dict["ENTRYTYPE"] = "article"
-            if record_dict.get("booktitle", "") != "":
-                record_dict["ENTRYTYPE"] = "inproceedings"
-        return record_dict
-
-    @classmethod
-    def __parse_record_dict(cls, *, record_dict: dict) -> dict:
-        record_dict = cls.__set_entrytype(record_dict=record_dict)
-
-        for key, value in record_dict.items():
-            record_dict[key] = str(value)
-
-        record_dict = cls.__rename_fields(record_dict=record_dict)
-
-        return record_dict
-
-    @classmethod
-    def __get_records_dict(cls, *, records: list) -> dict:
-        next_id = 1
-        for record_dict in records:
-            if "ID" not in record_dict:
-                if "citation_key" in record_dict:
-                    record_dict["ID"] = record_dict["citation_key"]
-                else:
-                    record_dict["ID"] = next_id
-                    next_id += 1
-            record_dict = cls.__parse_record_dict(record_dict=record_dict)
-
-        if all("ID" in r for r in records):
-            records_dict = {r["ID"]: r for r in records}
-        else:
-            records_dict = {}
-            for i, record in enumerate(records):
-                records_dict[str(i)] = record
-
-        return records_dict
-
-    @classmethod
-    def __drop_fields(cls, *, records_dict: dict) -> dict:
-        for r_dict in records_dict.values():
-            for key in list(r_dict.keys()):
-                if r_dict[key] == f"no {key}":
-                    del r_dict[key]
-            if (
-                r_dict.get("number_of_cited_references", "NA")
-                == "no Number-of-Cited-References"
-            ):
-                del r_dict["number_of_cited_references"]
-            if "no file" in r_dict.get("file_name", "NA"):
-                del r_dict["file_name"]
-
-            if r_dict.get("cited_by", "NA") in [
-                "no Times-Cited",
-            ]:
-                del r_dict["cited_by"]
-
-            if "author_count" in r_dict:
-                del r_dict["author_count"]
-            if "entrytype" in r_dict:
-                del r_dict["entrytype"]
-            if "citation_key" in r_dict:
-                del r_dict["citation_key"]
-
-        return records_dict
-
-    @classmethod
-    def preprocess_records(cls, *, records: list) -> dict:
-        """Preprocess records imported from a table"""
-
-        records_dict = cls.__get_records_dict(records=records)
-        records_dict = cls.__drop_fields(records_dict=records_dict)
-
-        return records_dict
+# pylint: disable=too-few-public-methods
 
 
-@zope.interface.implementer(
-    colrev.env.package_manager.LoadConversionPackageEndpointInterface
-)
+@zope.interface.implementer(colrev.env.package_manager.PrepPackageEndpointInterface)
 @dataclass
-class CSVLoader(JsonSchemaMixin):
-
-    """Loads csv files (based on pandas)"""
+class YearVolIssPrep(JsonSchemaMixin):
+    """Prepares records based on year-volume-issue dependency"""
 
     settings_class = colrev.env.package_manager.DefaultSettings
     ci_supported: bool = True
 
-    supported_extensions = ["csv"]
+    source_correction_hint = (
+        "ask the publisher to correct the metadata"
+        + " (see https://www.crossref.org/blog/"
+        + "metadata-corrections-updates-and-additions-in-metadata-manager/"
+    )
+    always_apply_changes = True
 
     def __init__(
         self,
         *,
-        load_operation: colrev.ops.load.Load,
+        prep_operation: colrev.ops.prep.Prep,  # pylint: disable=unused-argument
         settings: dict,
-    ):
+    ) -> None:
         self.settings = self.settings_class.load_settings(data=settings)
+        self.review_manager = prep_operation.review_manager
+        self.local_index = prep_operation.review_manager.get_local_index()
+        self.vol_nr_dict = self.__get_vol_nr_dict()
+        self.quality_model = self.review_manager.get_qm()
+
+    def __get_vol_nr_dict(self) -> dict:
+        vol_nr_dict: dict = {}
+        if not hasattr(self.review_manager, "dataset"):
+            return vol_nr_dict
+        records = self.review_manager.dataset.load_records_dict()
+        for record in records.values():
+            # pylint: disable=duplicate-code
+            if record[
+                "colrev_status"
+            ] not in colrev.record.RecordState.get_post_x_states(
+                state=colrev.record.RecordState.md_processed
+            ):
+                continue
+            if not record.get("year", "NA").isdigit():
+                continue
+
+            if "journal" not in record or "volume" not in record:
+                continue
+
+            if record["journal"] not in vol_nr_dict:
+                vol_nr_dict[record["journal"]] = {}
+
+            if record["volume"] not in vol_nr_dict[record["journal"]]:
+                vol_nr_dict[record["journal"]][record["volume"]] = {}
+
+            if "number" not in record:
+                vol_nr_dict[record["journal"]][record["volume"]] = record["year"]
+            else:
+                if isinstance(vol_nr_dict[record["journal"]][record["volume"]], dict):
+                    vol_nr_dict[record["journal"]][record["volume"]][
+                        record["number"]
+                    ] = record["year"]
+                else:
+                    # do not use inconsistent data (has/has no number)
+                    del vol_nr_dict[record["journal"]][record["volume"]]
 
-    def load(
-        self, load_operation: colrev.ops.load.Load, source: colrev.settings.SearchSource
-    ) -> dict:
-        """Load records from the source"""
+        return vol_nr_dict
 
+    def __get_year_from_toc(self, *, record: colrev.record.Record) -> None:
+        # TBD: maybe extract the following three lines as a separate script...
         try:
-            data = pd.read_csv(source.filename)
-        except pd.errors.ParserError as exc:
-            raise colrev_exceptions.ImportException(
-                f"Error: Not a csv file? {source.filename.name}"
-            ) from exc
-
-        data.columns = data.columns.str.replace(" ", "_")
-        data.columns = data.columns.str.replace("-", "_")
-        data.columns = data.columns.str.lower()
-        records_value_list = data.to_dict("records")
-
-        records_dict = TableLoadUtility.preprocess_records(records=records_value_list)
-
-        if not all("ID" in r for r in records_dict.values()):
-            for i, record in enumerate(records_dict.values()):
-                record["ID"] = str(i).rjust(6, "0")
-
-        records = {r["ID"]: r for r in records_dict.values()}
-
-        endpoint_dict = load_operation.package_manager.load_packages(
-            package_type=colrev.env.package_manager.PackageEndpointType.search_source,
-            selected_packages=[asdict(source)],
-            operation=load_operation,
-            ignore_not_available=False,
-        )
-        endpoint = endpoint_dict[source.endpoint]
-
-        records = endpoint.load_fixes(  # type: ignore
-            load_operation, source=source, records=records
-        )
-
-        return records
-
-
-@zope.interface.implementer(
-    colrev.env.package_manager.LoadConversionPackageEndpointInterface
-)
-class ExcelLoader:
-    """Loads Excel (xls, xlsx) files (based on pandas)"""
-
-    settings_class = colrev.env.package_manager.DefaultSettings
-    ci_supported: bool = True
+            year = self.local_index.get_year_from_toc(record_dict=record.get_data())
+            record.update_field(
+                key="year",
+                value=year,
+                source="LocalIndexPrep",
+                note="",
+                keep_source_if_equal=True,
+            )
+        except colrev_exceptions.TOCNotAvailableException:
+            pass
 
-    supported_extensions = ["xls", "xlsx"]
+    def __get_year_from_vol_nr_dict(self, *, record: colrev.record.Record) -> None:
+        if "journal" not in record.data or "volume" not in record.data:
+            return
 
-    def __init__(
-        self,
-        *,
-        load_operation: colrev.ops.load.Load,
-        settings: dict,
-    ):
-        self.settings = self.settings_class.load_settings(data=settings)
+        if record.data["journal"] not in self.vol_nr_dict:
+            return
 
-    def load(
-        self, load_operation: colrev.ops.load.Load, source: colrev.settings.SearchSource
-    ) -> dict:
-        """Load records from the source"""
+        if record.data["volume"] not in self.vol_nr_dict[record.data["journal"]]:
+            return
 
+        if "number" in record.data:
+            if (
+                record.data["number"]
+                in self.vol_nr_dict[record.data["journal"]][record.data["volume"]]
+            ):
+                record.update_field(
+                    key="year",
+                    value=self.vol_nr_dict[record.data["journal"]][
+                        record.data["volume"]
+                    ][record.data["number"]],
+                    source="year_vol_iss_prep",
+                    note="",
+                )
+                record.update_masterdata_provenance(qm=self.quality_model)
+        else:
+            if isinstance(
+                self.vol_nr_dict[record.data["journal"]][record.data["volume"]],
+                (str, int),
+            ):
+                record.update_field(
+                    key="year",
+                    value=self.vol_nr_dict[record.data["journal"]][
+                        record.data["volume"]
+                    ],
+                    source="year_vol_iss_prep",
+                    note="",
+                )
+                record.update_masterdata_provenance(qm=self.quality_model)
+
+    def __get_year_from_crossref(
+        self, *, record: colrev.record.Record, prep_operation: colrev.ops.prep.Prep
+    ) -> None:
         try:
-            data = pd.read_excel(
-                source.filename, dtype=str
-            )  # dtype=str to avoid type casting
-        except pd.errors.ParserError:
-            load_operation.review_manager.logger.error(
-                f"Error: Not an xlsx file: {source.filename.name}"
+            crossref_source = crossref_connector.CrossrefSearchSource(
+                source_operation=prep_operation
+            )
+            retrieved_records = crossref_source.crossref_query(
+                record_input=record,
+                jour_vol_iss_list=True,
+                timeout=prep_operation.timeout,
             )
-            return {}
+            retries = 0
+            while (
+                not retrieved_records and retries < prep_operation.max_retries_on_error
+            ):
+                retries += 1
+                retrieved_records = crossref_source.crossref_query(
+                    record_input=record,
+                    jour_vol_iss_list=True,
+                    timeout=prep_operation.timeout,
+                )
+            if 0 == len(retrieved_records):
+                return
+
+            retrieved_records = [
+                retrieved_record
+                for retrieved_record in retrieved_records
+                if retrieved_record.data.get("volume", "NA")
+                == record.data.get("volume", "NA")
+                and retrieved_record.data.get("journal", "NA")
+                == record.data.get("journal", "NA")
+                and retrieved_record.data.get("number", "NA")
+                == record.data.get("number", "NA")
+            ]
+
+            years = [r.data["year"] for r in retrieved_records]
+            if len(years) == 0:
+                return
+            most_common = max(years, key=years.count)
+            if years.count(most_common) > 3:
+                record.update_field(
+                    key="year", value=most_common, source="CROSSREF(average)", note=""
+                )
+        except requests.exceptions.RequestException:
+            pass
+
+    def prepare(
+        self, prep_operation: colrev.ops.prep.Prep, record: colrev.record.PrepRecord
+    ) -> colrev.record.Record:
+        """Prepare a record based on year-volume-issue dependency"""
+
+        if record.data.get("year", "NA").isdigit() or record.masterdata_is_curated():
+            return record
+
+        self.__get_year_from_toc(record=record)
+
+        if "year" in record.data:
+            return record
+
+        self.__get_year_from_vol_nr_dict(record=record)
+
+        if "year" in record.data:
+            return record
+
+        self.__get_year_from_crossref(record=record, prep_operation=prep_operation)
 
-        data.columns = data.columns.str.replace(" ", "_")
-        data.columns = data.columns.str.replace("-", "_")
-        data.columns = data.columns.str.lower()
-        record_value_list = data.to_dict("records")
-        records_dicts = TableLoadUtility.preprocess_records(records=record_value_list)
-        records = {r["ID"]: r for r in records_dicts}
-
-        endpoint_dict = load_operation.package_manager.load_packages(
-            package_type=colrev.env.package_manager.PackageEndpointType.search_source,
-            selected_packages=[asdict(source)],
-            operation=load_operation,
-            ignore_not_available=False,
-        )
-        endpoint = endpoint_dict[source.endpoint]
-
-        records = endpoint.load_fixes(  # type: ignore
-            load_operation, source=source, records=records
-        )
-        return records
+        return record
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/pdf_get/local_index_pdf_get.py` & `colrev-0.9.2/colrev/ops/built_in/pdf_get/local_index_pdf_get.py`

 * *Files 5% similar despite different names*

```diff
@@ -52,15 +52,15 @@
         except colrev_exceptions.RecordNotInIndexException:
             return record
 
         if "file" in retrieved_record:
             record.update_field(
                 key="file", value=str(retrieved_record["file"]), source="local_index"
             )
-            pdf_get_operation.import_file(record=record)
+            pdf_get_operation.import_pdf(record=record)
             if "fulltext" in retrieved_record:
                 try:
                     record.get_tei_filename().write_text(retrieved_record["fulltext"])
                 except FileNotFoundError:
                     pass
                 del retrieved_record["fulltext"]
             else:
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/pdf_get/unpaywall.py` & `colrev-0.9.2/colrev/ops/built_in/pdf_get/unpaywall.py`

 * *Files 1% similar despite different names*

```diff
@@ -144,15 +144,15 @@
                     source = (
                         f"https://api.unpaywall.org/v2/{record.data['doi']}"
                         + f"?email={self.email}"
                     )
                     record.update_field(
                         key="file", value=str(pdf_filepath), source=source
                     )
-                    pdf_get_operation.import_file(record=record)
+                    pdf_get_operation.import_pdf(record=record)
 
                 else:
                     os.remove(pdf_filepath)
             else:
                 if "fulltext" not in record.data:
                     record.data["fulltext"] = url
                 if pdf_get_operation.review_manager.verbose_mode:
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/pdf_get/website_screenshot.py` & `colrev-0.9.2/colrev/ops/built_in/pdf_get/website_screenshot.py`

 * *Files 4% similar despite different names*

```diff
@@ -51,10 +51,10 @@
             f"{record.data['ID']}.pdf"
         )
         record = screenshot_service.add_screenshot(
             record=record, pdf_filepath=pdf_filepath
         )
 
         if "file" in record.data:
-            pdf_get_operation.import_file(record=record)
+            pdf_get_operation.import_pdf(record=record)
 
         return record
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/pdf_get_man/pdf_get_man_cli.py` & `colrev-0.9.2/colrev/ops/built_in/pdf_get_man/pdf_get_man_cli.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 
 import zope.interface
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.ops.pdf_get
 import colrev.record
+import colrev.ui_cli.cli_colors as colors
 
 if TYPE_CHECKING:
     import colrev.ops.pdf_get_man
 
 
 # pylint: disable=too-few-public-methods
 # pylint: disable=unused-argument
@@ -48,15 +49,15 @@
         pdf_get_man_operation: colrev.ops.pdf_get_man.PDFGetMan,
         record: colrev.record.Record,
     ) -> colrev.record.Record:
         # import webbrowser
 
         title = record.data.get("title", "no title")
         title = urllib.parse.quote_plus(title)
-        url = f"https://www.google.com/search?q={title}+filetype%3Apdf"
+        url = f"  google:   https://www.google.com/search?q={title}+filetype%3Apdf"
         # webbrowser.open_new_tab(url)
         print(url)
         return record
 
     def __ask_authors_for_pdf(
         self,
         pdf_get_man_operation: colrev.ops.pdf_get_man.PDFGetMan,
@@ -188,26 +189,53 @@
             return
 
         pdf_in_downloads_folder.rename(
             pdf_get_man_operation.review_manager.pdf_dir
             / Path(f"{record.data['ID']}.pdf")
         )
 
+    def print_record(self, *, record_dict: dict) -> None:
+        """Print the record for pdf-get-man (cli)"""
+
+        ret_str = f"  ID:       {record_dict['ID']} ({record_dict['ENTRYTYPE']})"
+        ret_str += (
+            f"\n  title:    {colors.GREEN}{record_dict.get('title', 'no title')}{colors.END}"
+            f"\n  author:   {record_dict.get('author', 'no-author')}"
+        )
+        if record_dict["ENTRYTYPE"] == "article":
+            ret_str += (
+                f"\n  outlet: {record_dict.get('journal', 'no-journal')} "
+                f"({record_dict.get('year', 'no-year')}) "
+                f"{record_dict.get('volume', 'no-volume')}"
+                f"({record_dict.get('number', '')})"
+            )
+        elif record_dict["ENTRYTYPE"] == "inproceedings":
+            ret_str += f"\n  {record_dict.get('booktitle', 'no-booktitle')}"
+        if "fulltext" in record_dict:
+            ret_str += (
+                f"\n  fulltext: {colors.ORANGE}{record_dict['fulltext']}{colors.END}"
+            )
+
+        if "url" in record_dict:
+            ret_str += f"\n  url:      {record_dict['url']}"
+
+        print(ret_str)
+
     def __pdf_get_man_record_cli(
         self,
         *,
         pdf_get_man_operation: colrev.ops.pdf_get_man.PDFGetMan,
         record: colrev.record.Record,
     ) -> None:
         # pdf_get_man_operation.review_manager.logger.debug(
         #     f"called pdf_get_man_cli for {record}"
         # )
 
         # to print only the essential information
-        colrev.record.Record(data=record.get_data()).print_prescreen_record()
+        self.print_record(record_dict=record.get_data())
 
         if (
             colrev.record.RecordState.pdf_needs_manual_retrieval
             != record.data["colrev_status"]
         ):
             return
 
@@ -216,18 +244,15 @@
             "ask_authors": self.__ask_authors_for_pdf
             # 'get_pdf_from_researchgate': get_pdf_from_researchgate,
         }
 
         filepath = self.__get_filepath(
             pdf_get_man_operation=pdf_get_man_operation, record=record
         )
-        for (
-            script_name,  # pylint: disable=unused-variable
-            retrieval_script,
-        ) in retrieval_scripts.items():
+        for retrieval_script in retrieval_scripts.values():
             # pdf_get_man_operation.review_manager.logger.debug(
             #     f'{script_name}({record.data["ID"]}) called'
             # )
             record = retrieval_script(pdf_get_man_operation, record)
 
             if input("Retrieved (y/n)?") == "y":
                 if self.__get_from_downloads_folder:
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/pdf_prep/check_ocr.py` & `colrev-0.9.2/colrev/ops/built_in/pdf_prep/check_ocr.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/pdf_prep/completeness_validation.py` & `colrev-0.9.2/colrev/ops/built_in/pdf_prep/completeness_validation.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/pdf_prep/cover_page.py` & `colrev-0.9.2/colrev/ops/built_in/pdf_prep/cover_page.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/pdf_prep/last_page.py` & `colrev-0.9.2/colrev/ops/built_in/pdf_prep/last_page.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/pdf_prep/metadata_validation.py` & `colrev-0.9.2/colrev/ops/built_in/pdf_prep/metadata_validation.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/pdf_prep/tei_prep.py` & `colrev-0.9.2/colrev/ops/built_in/pdf_prep/tei_prep.py`

 * *Files 3% similar despite different names*

```diff
@@ -36,14 +36,15 @@
         if not pdf_prep_operation.review_manager.in_ci_environment():
             grobid_service = pdf_prep_operation.review_manager.get_grobid_service()
             grobid_service.start()
             self.tei_path = (
                 pdf_prep_operation.review_manager.path / self.TEI_PATH_RELATIVE
             )
             self.tei_path.mkdir(exist_ok=True, parents=True)
+            pdf_prep_operation.docker_images_to_stop.append(grobid_service.GROBID_IMAGE)
 
     def prep_pdf(
         self,
         pdf_prep_operation: colrev.ops.pdf_prep.PDFPrep,
         record: colrev.record.Record,
         pad: int,  # pylint: disable=unused-argument
     ) -> dict:
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/pdf_prep_man/pdf_prep_man_cli.py` & `colrev-0.9.2/colrev/ops/built_in/pdf_prep_man/pdf_prep_man_cli.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/bibtex_crossref_resolution.py` & `colrev-0.9.2/colrev/ops/built_in/prep/bibtex_crossref_resolution.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/citeas_prep.py` & `colrev-0.9.2/colrev/ops/built_in/prep/citeas_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/crossref_metadata_prep.py` & `colrev-0.9.2/colrev/ops/built_in/prep/crossref_metadata_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/curation_prep.py` & `colrev-0.9.2/colrev/ops/built_in/prep/curation_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/dblp_metadata_prep.py` & `colrev-0.9.2/colrev/ops/built_in/prep/dblp_metadata_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/doi_from_urls_prep.py` & `colrev-0.9.2/colrev/ops/built_in/prep/doi_from_urls_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/doi_metadata_prep.py` & `colrev-0.9.2/colrev/ops/built_in/prep/doi_metadata_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/europe_pmc_prep.py` & `colrev-0.9.2/colrev/ops/built_in/prep/europe_pmc_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/exclude_collections.py` & `colrev-0.9.2/colrev/ops/built_in/prep/exclude_collections.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/exclude_complementary_materials.py` & `colrev-0.9.2/colrev/ops/built_in/prep/exclude_complementary_materials.py`

 * *Files 12% similar despite different names*

```diff
@@ -47,24 +47,36 @@
         )
 
         # for exact matches:
         self.complementary_materials_strings = (
             colrev.env.utils.load_complementary_material_strings()
         )
 
+        # for prefixes:
+        self.complementary_material_prefixes = (
+            colrev.env.utils.load_complementary_material_prefixes()
+        )
+
     def prepare(
         self,
         prep_operation: colrev.ops.prep.Prep,  # pylint: disable=unused-argument
         record: colrev.record.PrepRecord,
     ) -> colrev.record.Record:
         """Prepare the records by excluding complementary materials"""
 
-        if any(
-            complementary_materials_keyword in record.data.get("title", "").lower()
-            for complementary_materials_keyword in self.complementary_materials_keywords
-        ) or any(
-            complementary_materials_string == record.data.get("title", "").lower()
-            for complementary_materials_string in self.complementary_materials_strings
+        if (
+            any(
+                complementary_materials_keyword in record.data.get("title", "").lower()
+                for complementary_materials_keyword in self.complementary_materials_keywords
+            )
+            or any(
+                complementary_materials_string == record.data.get("title", "").lower()
+                for complementary_materials_string in self.complementary_materials_strings
+            )
+            or any(
+                record.data.get("title", "").lower().startswith(prefix)
+                for prefix in self.complementary_material_prefixes
+            )
         ):
             record.prescreen_exclude(reason="complementary material")
 
         return record
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/exclude_languages.py` & `colrev-0.9.2/colrev/ops/built_in/prep/exclude_languages.py`

 * *Files 6% similar despite different names*

```diff
@@ -76,33 +76,46 @@
         record: colrev.record.PrepRecord,
     ) -> colrev.record.Record:
         """Prepare the record by excluding records whose metadata is not in English"""
 
         # Note : other languages are not yet supported
         # because the dedupe does not yet support cross-language merges
 
+        if record.data.get("title", "UNKNOWN") == "UNKNOWN":
+            record.remove_field(key="language")
+            return record
+
         if "language" in record.data:
-            if record.data["language"] not in self.languages_to_include:
-                record.prescreen_exclude(
-                    reason=(
-                        "language of title not in "
-                        f"[{','.join(self.languages_to_include)}]"
-                    )
-                )
+            # Note: classification of non-english titles is not reliable.
+            # Other languages should be checked in man-prep.
+            # if "eng" != language:
+            #     return record
+
+            # if record.data["language"] not in self.languages_to_include:
+            #     record.prescreen_exclude(
+            #         reason=(
+            #             "language of title not in "
+            #             f"[{','.join(self.languages_to_include)}]"
+            #         )
+            #     )
             return record
 
         # To avoid misclassifications for short titles
         if len(record.data.get("title", "")) < 30:
             # If language not in record, add language
             # (always - needed in dedupe.)
             record.data["language"] = "eng"
             return record
 
         if not self.__title_has_multiple_languages(title=record.data.get("title", "")):
             language = self.language_service.compute_language(text=record.data["title"])
+            # Note: classification of non-english titles is not reliable.
+            # Other languages should be checked in man-prep.
+            if "eng" != language:
+                return record
             record.update_field(
                 key="language",
                 value=language,
                 source="LanguageDetector",
                 note="",
                 append_edit=False,
             )
@@ -142,12 +155,15 @@
             )
             record.set_status(
                 target_state=colrev.record.RecordState.md_needs_manual_preparation
             )
             return record
 
         if record.data.get("language", "") not in self.languages_to_include:
-            record.prescreen_exclude(
-                reason=f"language of title not in [{','.join(self.languages_to_include)}]"
+            record.remove_field(key="language")
+            # record.prescreen_exclude(
+            #     reason=f"language of title not in [{','.join(self.languages_to_include)}]"
+            # )
+            record.set_status(
+                target_state=colrev.record.RecordState.md_needs_manual_preparation
             )
-
         return record
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/exclude_non_latin_alphabets.py` & `colrev-0.9.2/colrev/ops/built_in/prep/exclude_non_latin_alphabets.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/general_polish.py` & `colrev-0.9.2/colrev/ops/built_in/prep/general_polish.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/local_index_prep.py` & `colrev-0.9.2/colrev/ops/built_in/prep/local_index_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/open_library_prep.py` & `colrev-0.9.2/colrev/ops/built_in/prep/open_library_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/pubmed_metadata_prep.py` & `colrev-0.9.2/colrev/ops/built_in/prep/pubmed_metadata_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/remove_broken_ids.py` & `colrev-0.9.2/colrev/ops/built_in/prep/remove_broken_ids.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/remove_error500_urls.py` & `colrev-0.9.2/colrev/ops/built_in/prep/remove_error500_urls.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/semantic_scholar_prep.py` & `colrev-0.9.2/colrev/ops/built_in/prep/semantic_scholar_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/source_specific_prep.py` & `colrev-0.9.2/colrev/ops/built_in/prep/source_specific_prep.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/update_masterdata_status.py` & `colrev-0.9.2/colrev/ops/built_in/prep/update_masterdata_status.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/utils.py` & `colrev-0.9.2/colrev/ops/built_in/prep/utils.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep/year_vol_iss_prep.py` & `colrev-0.9.2/colrev/ops/correct.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,211 +1,222 @@
-#! /usr/bin/env python
-"""Completion of metadata based on year-volume-issue dependency as a prep operation"""
+#!/usr/bin/env python3
+"""Create and apply record corrections in source repositories."""
 from __future__ import annotations
 
-from dataclasses import dataclass
+import json
+from pathlib import Path
 from typing import TYPE_CHECKING
 
-import requests
-import zope.interface
-from dataclasses_jsonschema import JsonSchemaMixin
-
-import colrev.env.package_manager
-import colrev.exceptions as colrev_exceptions
-import colrev.ops.built_in.search_sources.crossref as crossref_connector
-import colrev.ops.search_sources
-import colrev.record
+from dictdiffer import diff
 
-# pylint: disable=duplicate-code
+import colrev.record
 
 if TYPE_CHECKING:
-    import colrev.ops.prep
+    import colrev.review_manager
 
 # pylint: disable=too-few-public-methods
 
 
-@zope.interface.implementer(colrev.env.package_manager.PrepPackageEndpointInterface)
-@dataclass
-class YearVolIssPrep(JsonSchemaMixin):
-    """Prepares records based on year-volume-issue dependency"""
-
-    settings_class = colrev.env.package_manager.DefaultSettings
-    ci_supported: bool = True
-
-    source_correction_hint = (
-        "ask the publisher to correct the metadata"
-        + " (see https://www.crossref.org/blog/"
-        + "metadata-corrections-updates-and-additions-in-metadata-manager/"
-    )
-    always_apply_changes = True
+class Corrections:
+    """Handling corrections of metadata"""
+
+    # pylint: disable=duplicate-code
+    essential_md_keys = [
+        "title",
+        "author",
+        "journal",
+        "year",
+        "booktitle",
+        "number",
+        "volume",
+        "issue",
+        "author",
+        "doi",
+        "colrev_origin",  # Note : for merges
+    ]
+
+    keys_to_ignore = [
+        "ID",
+        "screening_criteria",
+        "colrev_status",
+        "source_url",
+        "metadata_source_repository_paths",
+        "grobid-version",
+        "colrev_pdf_id",
+        "file",
+        "colrev_origin",
+        "colrev_data_provenance",
+        "colrev_masterdata_provenance",
+        "sem_scholar_id",
+        "cited_by",
+        "abstract",
+        "pages",
+    ]
 
     def __init__(
         self,
         *,
-        prep_operation: colrev.ops.prep.Prep,  # pylint: disable=unused-argument
-        settings: dict,
+        review_manager: colrev.review_manager.ReviewManager,
     ) -> None:
-        self.settings = self.settings_class.load_settings(data=settings)
-        self.review_manager = prep_operation.review_manager
-        self.local_index = prep_operation.review_manager.get_local_index()
-        self.vol_nr_dict = self.__get_vol_nr_dict()
-        self.quality_model = self.review_manager.get_qm()
-
-    def __get_vol_nr_dict(self) -> dict:
-        vol_nr_dict: dict = {}
-        if not hasattr(self.review_manager, "dataset"):
-            return vol_nr_dict
-        records = self.review_manager.dataset.load_records_dict()
-        for record in records.values():
-            # pylint: disable=duplicate-code
-            if record[
-                "colrev_status"
-            ] not in colrev.record.RecordState.get_post_x_states(
-                state=colrev.record.RecordState.md_processed
-            ):
-                continue
-            if not record.get("year", "NA").isdigit():
+        self.review_manager = review_manager
+        self.local_index = self.review_manager.get_local_index()
+        self.resources = self.review_manager.get_resources()
+
+    def __record_corrected(self, *, prior_r: dict, record_dict: dict) -> bool:
+        return not all(
+            prior_r.get(k, "NA") == record_dict.get(k, "NA")
+            for k in self.essential_md_keys
+        )
+
+    def __prep_for_change_item_creation(
+        self, *, original_record: dict, corrected_record: dict
+    ) -> None:
+        # Cast to string for persistence
+        original_record = {k: str(v) for k, v in original_record.items()}
+        corrected_record = {k: str(v) for k, v in corrected_record.items()}
+
+        # Note : removing the fields is a temporary fix
+        # because the subsetting of change_items does not seem to
+        # work properly
+        keys_to_drop = ["pages", "colrev_status"]
+        for k in keys_to_drop:
+            original_record.pop(k, None)
+            corrected_record.pop(k, None)
+
+        # if "dblp_key" in corrected_record:
+        #     del corrected_record["dblp_key"]
+
+    def __create_change_item(
+        self,
+        *,
+        original_record: dict,
+        corrected_record: dict,
+    ) -> None:
+        # pylint: disable=too-many-branches
+
+        self.__prep_for_change_item_creation(
+            original_record=original_record,
+            corrected_record=corrected_record,
+        )
+
+        changes = diff(original_record, corrected_record)
+
+        selected_change_items = []
+        for change_item in list(changes):
+            change_type, key, val = change_item
+
+            if not isinstance(key, str):
                 continue
 
-            if "journal" not in record or "volume" not in record:
+            if change_type != "add" and key == "":
                 continue
 
-            if record["journal"] not in vol_nr_dict:
-                vol_nr_dict[record["journal"]] = {}
+            if key.split(".")[0] in self.keys_to_ignore:
+                continue
 
-            if record["volume"] not in vol_nr_dict[record["journal"]]:
-                vol_nr_dict[record["journal"]][record["volume"]] = {}
+            if change_type == "add":
+                for add_item in val:
+                    add_item_key, add_item_val = add_item
+                    if not isinstance(add_item_key, str):
+                        break
+                    if add_item_key.split(".")[0] in self.keys_to_ignore:
+                        break
+                    selected_change_items.append(
+                        ("add", "", [(add_item_key, add_item_val)])
+                    )
 
-            if "number" not in record:
-                vol_nr_dict[record["journal"]][record["volume"]] = record["year"]
-            else:
-                if isinstance(vol_nr_dict[record["journal"]][record["volume"]], dict):
-                    vol_nr_dict[record["journal"]][record["volume"]][
-                        record["number"]
-                    ] = record["year"]
-                else:
-                    # do not use inconsistent data (has/has no number)
-                    del vol_nr_dict[record["journal"]][record["volume"]]
-
-        return vol_nr_dict
-
-    def __get_year_from_toc(self, *, record: colrev.record.Record) -> None:
-        # TBD: maybe extract the following three lines as a separate script...
-        try:
-            year = self.local_index.get_year_from_toc(record_dict=record.get_data())
-            record.update_field(
-                key="year",
-                value=year,
-                source="LocalIndexPrep",
-                note="",
-                keep_source_if_equal=True,
-            )
-        except colrev_exceptions.TOCNotAvailableException:
-            pass
+            elif change_type == "change":
+                selected_change_items.append(change_item)
 
-    def __get_year_from_vol_nr_dict(self, *, record: colrev.record.Record) -> None:
-        if "journal" not in record.data or "volume" not in record.data:
+        if len(selected_change_items) == 0:
             return
 
-        if record.data["journal"] not in self.vol_nr_dict:
+        if len(corrected_record.get("colrev_origin", [])) > len(
+            original_record.get("colrev_origin", [])
+        ):
+            if "dblp_key" in corrected_record and "dblp_key" in original_record:
+                if corrected_record["dblp_key"] != original_record["dblp_key"]:
+                    selected_change_items = {  # type: ignore
+                        "merge": [
+                            corrected_record["dblp_key"],
+                            original_record["dblp_key"],
+                        ]
+                    }
+            # else:
+            #     selected_change_items = {
+            #         "merge": [
+            #             corrected_record["ID"],
+            #             original_record["ID"],
+            #         ]
+            #     }
+
+        # gh_issue https://github.com/CoLRev-Environment/colrev/issues/63
+        # cover non-masterdata corrections
+        if "colrev_masterdata_provenance" not in original_record:
             return
 
-        if record.data["volume"] not in self.vol_nr_dict[record.data["journal"]]:
-            return
+        dict_to_save = {
+            # "source_url": original_record["colrev_masterdata_provenance"],
+            "original_record": {
+                k: v for k, v in original_record.items() if k not in ["colrev_status"]
+            },
+            "changes": selected_change_items,
+        }
+
+        filepath = self.review_manager.corrections_path / Path(
+            f"{corrected_record['ID']}.json"
+        )
+        filepath.parent.mkdir(exist_ok=True)
+
+        with open(filepath, "w", encoding="utf8") as corrections_file:
+            json.dump(dict_to_save, corrections_file, indent=4)
+
+        # gh_issue https://github.com/CoLRev-Environment/colrev/issues/63
+        # combine merge-record corrections
+
+    def check_corrections_of_records(self) -> None:
+        """Check for corrections of records"""
 
-        if "number" in record.data:
-            if (
-                record.data["number"]
-                in self.vol_nr_dict[record.data["journal"]][record.data["volume"]]
-            ):
-                record.update_field(
-                    key="year",
-                    value=self.vol_nr_dict[record.data["journal"]][
-                        record.data["volume"]
-                    ][record.data["number"]],
-                    source="year_vol_iss_prep",
-                    note="",
-                )
-                record.update_masterdata_provenance(qm=self.quality_model)
-        else:
-            if isinstance(
-                self.vol_nr_dict[record.data["journal"]][record.data["volume"]],
-                (str, int),
-            ):
-                record.update_field(
-                    key="year",
-                    value=self.vol_nr_dict[record.data["journal"]][
-                        record.data["volume"]
-                    ],
-                    source="year_vol_iss_prep",
-                    note="",
-                )
-                record.update_masterdata_provenance(qm=self.quality_model)
+        # to test run
+        # colrev-hooks-report .report.log
 
-    def __get_year_from_crossref(
-        self, *, record: colrev.record.Record, prep_operation: colrev.ops.prep.Prep
-    ) -> None:
-        try:
-            crossref_source = crossref_connector.CrossrefSearchSource(
-                source_operation=prep_operation
-            )
-            retrieved_records = crossref_source.crossref_query(
-                record_input=record,
-                jour_vol_iss_list=True,
-                timeout=prep_operation.timeout,
-            )
-            retries = 0
-            while (
-                not retrieved_records and retries < prep_operation.max_retries_on_error
-            ):
-                retries += 1
-                retrieved_records = crossref_source.crossref_query(
-                    record_input=record,
-                    jour_vol_iss_list=True,
-                    timeout=prep_operation.timeout,
-                )
-            if 0 == len(retrieved_records):
-                return
-
-            retrieved_records = [
-                retrieved_record
-                for retrieved_record in retrieved_records
-                if retrieved_record.data.get("volume", "NA")
-                == record.data.get("volume", "NA")
-                and retrieved_record.data.get("journal", "NA")
-                == record.data.get("journal", "NA")
-                and retrieved_record.data.get("number", "NA")
-                == record.data.get("number", "NA")
-            ]
+        dataset = self.review_manager.dataset
 
-            years = [r.data["year"] for r in retrieved_records]
-            if len(years) == 0:
-                return
-            most_common = max(years, key=years.count)
-            if years.count(most_common) > 3:
-                record.update_field(
-                    key="year", value=most_common, source="CROSSREF(average)", note=""
-                )
-        except requests.exceptions.RequestException:
-            pass
-
-    def prepare(
-        self, prep_operation: colrev.ops.prep.Prep, record: colrev.record.PrepRecord
-    ) -> colrev.record.Record:
-        """Prepare a record based on year-volume-issue dependency"""
-
-        if record.data.get("year", "NA").isdigit() or record.masterdata_is_curated():
-            return record
-
-        self.__get_year_from_toc(record=record)
-
-        if "year" in record.data:
-            return record
+        if not dataset.records_file.is_file():
+            return
 
-        self.__get_year_from_vol_nr_dict(record=record)
+        records = self.review_manager.dataset.load_records_dict()
 
-        if "year" in record.data:
-            return record
+        prior_records_dict = next(
+            self.review_manager.dataset.load_records_from_history()
+        )
+        # gh_issue https://github.com/CoLRev-Environment/colrev/issues/63
+        # The following code should be much simpler...
+        for record_dict in records.values():
+            # gh_issue https://github.com/CoLRev-Environment/colrev/issues/63
+            # use origin-indexed dict (discarding changes during merges)
+
+            # identify curated records for which essential metadata is changed
+            record_prior = [
+                x
+                for x in prior_records_dict.values()
+                if any(y in record_dict["colrev_origin"] for y in x["colrev_origin"])
+            ]
 
-        self.__get_year_from_crossref(record=record, prep_operation=prep_operation)
+            if len(record_prior) == 0:
+                self.review_manager.logger.debug("No prior records found")
+                continue
 
-        return record
+            for prior_r in record_prior:
+                if self.__record_corrected(prior_r=prior_r, record_dict=record_dict):
+                    corrected_record = record_dict.copy()
+
+                    # original_record = (
+                    #     self.__get_original_record_from_index(prior_r=prior_r)
+                    # )
+                    # if not original_record:
+                    #     continue
+
+                    self.__create_change_item(
+                        original_record=prior_r,
+                        corrected_record=corrected_record,
+                    )
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep_man/curation_jupyter_prep_man.py` & `colrev-0.9.2/colrev/ops/built_in/prep_man/curation_jupyter_prep_man.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep_man/prep_man_export.md` & `colrev-0.9.2/colrev/ops/built_in/prep_man/prep_man_export.md`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prep_man/prep_man_export.py` & `colrev-0.9.2/colrev/ops/built_in/prep_man/prep_man_export.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 #! /usr/bin/env python
 """Export of bib/pdfs as a prep-man operation"""
 from __future__ import annotations
 
+import platform
 import typing
 from dataclasses import dataclass
 from pathlib import Path
 from typing import TYPE_CHECKING
 
 import pandas as pd
 import zope.interface
@@ -31,28 +32,30 @@
     """Manual preparation based on exported and imported metadata (and PDFs if any)"""
 
     settings: ExportManPrepSettings
     ci_supported: bool = False
 
     RELATIVE_PREP_MAN_PATH = Path("records_prep_man.bib")
     RELATIVE_PREP_MAN_INFO_PATH = Path("records_prep_man_info.csv")
+    RELATIVE_PREP_MAN_INFO_PATH_XLS = Path("records_prep_man_info.xlsx")
 
     __FIELDS_TO_KEEP = [
         "ENTRYTYPE",
         "author",
         "title",
         "year",
         "journal",
         "booktitle",
         "incollection",
         "colrev_status",
         "volume",
         "number",
         "pages",
         "doi",
+        "file",
     ]
 
     @dataclass
     class ExportManPrepSettings(
         colrev.env.package_manager.DefaultSettings, JsonSchemaMixin
     ):
         """Settings for ExportManPrep"""
@@ -86,14 +89,18 @@
             self.review_manager.prep_dir / self.RELATIVE_PREP_MAN_PATH
         )
 
         self.prep_man_csv_path = (
             self.review_manager.prep_dir / self.RELATIVE_PREP_MAN_INFO_PATH
         )
 
+        self.prep_man_xlsx_path = (
+            self.review_manager.prep_dir / self.RELATIVE_PREP_MAN_INFO_PATH_XLS
+        )
+
         self.review_manager.prep_dir.mkdir(exist_ok=True, parents=True)
 
     def __copy_files_for_man_prep(self, *, records: dict) -> None:
         prep_man_path_pdfs = self.review_manager.prep_dir / Path("pdfs")
         if prep_man_path_pdfs.is_dir():
             input(f"Remove {prep_man_path_pdfs} and press Enter.")
         prep_man_path_pdfs.mkdir(exist_ok=True, parents=True)
@@ -106,15 +113,15 @@
                 if self.settings.pdf_handling_mode == "symlink":
                     target_path.symlink_to(Path(record["file"]).resolve())
 
                 if self.settings.pdf_handling_mode == "copy_first_page":
                     pdf_reader = PdfFileReader(str(record["file"]), strict=False)
                     if len(pdf_reader.pages) >= 1:
                         writer = PdfFileWriter()
-                        writer.addPage(pdf_reader.getPage(0))
+                        writer.addPage(pdf_reader.pages[0])
                         with open(target_path, "wb") as outfile:
                             writer.write(outfile)
 
     def __export_prep_man(
         self,
         *,
         records: typing.Dict[str, typing.Dict],
@@ -157,15 +164,21 @@
             for field, value in record["colrev_masterdata_provenance"].items():
                 if value["note"]:
                     man_prep_info.append(
                         {"ID": record["ID"], "field": field, "note": value["note"]}
                     )
 
         man_prep_info_df = pd.DataFrame(man_prep_info)
-        man_prep_info_df.to_csv(self.prep_man_csv_path, index=False)
+        if platform.system() == "Windows":
+            # until https://github.com/pylint-dev/pylint/issues/3060 is resolved
+            # pylint: disable=abstract-class-instantiated
+            with pd.ExcelWriter(self.prep_man_xlsx_path) as writer:
+                man_prep_info_df.to_excel(writer, index=False)
+        else:
+            man_prep_info_df.to_csv(self.prep_man_csv_path, index=False)
 
     def __drop_unnecessary_provenance_fiels(
         self, *, record: colrev.record.Record
     ) -> None:
         colrev_data_provenance_keys_to_drop = []
         for key, items in record.data.get("colrev_data_provenance", {}).items():
             if key not in record.data and "not-missing" not in items["note"]:
@@ -188,24 +201,31 @@
 
     def __update_original_record_based_on_man_prepped(
         self, *, original_record: colrev.record.Record, man_prepped_record_dict: dict
     ) -> None:
         dropped_keys = [
             k
             for k in original_record.data
-            if k in self.__FIELDS_TO_KEEP and k not in man_prepped_record_dict
+            if (k not in man_prepped_record_dict) and k in self.__FIELDS_TO_KEEP
         ]
+
+        if original_record.data["ENTRYTYPE"] != man_prepped_record_dict["ENTRYTYPE"]:
+            original_record.change_entrytype(
+                new_entrytype=man_prepped_record_dict["ENTRYTYPE"],
+                qm=self.quality_model,
+            )
+
         if man_prepped_record_dict["ENTRYTYPE"] != original_record.data["ENTRYTYPE"]:
             original_record.data["ENTRYTYPE"] = man_prepped_record_dict["ENTRYTYPE"]
             original_record.update_masterdata_provenance(qm=self.quality_model)
 
         for key, value in man_prepped_record_dict.items():
             if key in ["colrev_status"]:
                 continue
-            if value != original_record.data.get(key, ""):
+            if value != original_record.data.get(key, "") and value != "UNKNOWN":
                 original_record.update_field(
                     key=key, value=value, source="man_prep", append_edit=False
                 )
                 original_record.remove_masterdata_provenance_note(
                     key=key, note="missing"
                 )
 
@@ -262,19 +282,26 @@
             original_record=original_record,
             man_prepped_record_dict=man_prepped_record_dict,
         )
 
         self.__drop_unnecessary_provenance_fiels(record=original_record)
         if (
             man_prepped_record_dict["colrev_status"]
-            != colrev.record.RecordState.rev_prescreen_excluded
+            == colrev.record.RecordState.rev_prescreen_excluded
         ):
+            original_record.set_status(
+                target_state=colrev.record.RecordState.rev_prescreen_excluded,
+                force=True,
+            )
+
+        else:
             original_record.update_masterdata_provenance(
                 qm=self.quality_model, set_prepared=True
             )
+
         if override:
             original_record.set_status(
                 target_state=colrev.record.RecordState.md_prepared, force=True
             )
 
         self.__print_stats(original_record=original_record)
 
@@ -290,16 +317,16 @@
             )
 
         imported_records: typing.List[dict] = []
         records = self.review_manager.dataset.load_records_dict()
         for record_id, record_dict in records.items():
             if (
                 record_dict["colrev_status"]
-                == colrev.record.RecordState.md_needs_manual_preparation
-                and record_id not in man_prep_recs
+                == colrev.record.RecordState.rev_prescreen_excluded
+                # or record_id not in man_prep_recs
             ):
                 records[record_id][  # pylint: disable=direct-status-assign
                     "colrev_status"
                 ] = colrev.record.RecordState.rev_prescreen_excluded
                 self.review_manager.logger.info(
                     f" {colors.RED}{record_id}".ljust(46)
                     + "md_needs_manual_preparation →  rev_prescreen_excluded"
@@ -324,17 +351,22 @@
         self.review_manager.create_commit(msg="Prep-man (ExportManPrep)")
 
         self.review_manager.dataset.set_ids(selected_ids=imported_records)
         self.review_manager.create_commit(msg="Set IDs")
 
     def __print_export_prep_man_instructions(self) -> None:
         print("Created two files:")
-        print(
-            f" - {self.prep_man_csv_path.relative_to(self.review_manager.path)}  (CSV file)"
-        )
+        if platform.system() == "Windows":
+            print(
+                f" - {self.prep_man_xlsx_path.relative_to(self.review_manager.path)}  (EXCEL file)"
+            )
+        else:
+            print(
+                f" - {self.prep_man_csv_path.relative_to(self.review_manager.path)}  (CSV file)"
+            )
         print(
             f" - {self.prep_man_bib_path.relative_to(self.review_manager.path)}       (BIB file)"
         )
         print()
         print("To prepare records:")
         print("- check the defect codes in the CSV file")
         print(
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/prescreen/conditional_prescreen.py` & `colrev-0.9.2/colrev/ops/built_in/prescreen/conditional_prescreen.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prescreen/prescreen_cli.py` & `colrev-0.9.2/colrev/ops/built_in/prescreen/prescreen_cli.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prescreen/prescreen_table.py` & `colrev-0.9.2/colrev/ops/built_in/prescreen/prescreen_table.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/prescreen/scope_prescreen.py` & `colrev-0.9.2/colrev/ops/built_in/prescreen/scope_prescreen.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 #! /usr/bin/env python
 """Prescreen based on specified scope"""
 from __future__ import annotations
 
 import typing
 from dataclasses import dataclass
-from pathlib import Path
 
 import zope.interface
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.language_service
+import colrev.env.local_index
 import colrev.env.package_manager
 import colrev.record
 
 if typing.TYPE_CHECKING:
     import colrev.ops.prescreen.Prescreen
 
 # pylint: disable=too-few-public-methods
@@ -37,21 +37,23 @@
     ):
         """Settings for ScopePrescreen"""
 
         # pylint: disable=invalid-name
         # pylint: disable=too-many-instance-attributes
 
         endpoint: str
+        ExcludePredatoryJournals: bool
         TimeScopeFrom: typing.Optional[int]
         TimeScopeTo: typing.Optional[int]
         LanguageScope: typing.Optional[list]
         ExcludeComplementaryMaterials: typing.Optional[bool]
         OutletInclusionScope: typing.Optional[dict]
         OutletExclusionScope: typing.Optional[dict]
         ENTRYTYPEScope: typing.Optional[list]
+        RequireRankedJournals: typing.Optional[list]
 
         _details = {
             "TimeScopeFrom": {
                 "tooltip": "Lower bound for the time scope",
                 "min": 1900,
                 "max": 2050,
             },
@@ -66,103 +68,95 @@
             },
             "OutletInclusionScope": {
                 "tooltip": "Particular outlets that should be included (exclusively)"
             },
             "OutletExclusionScope": {
                 "tooltip": "Particular outlets that should be excluded"
             },
+            "ExcludePredatoryJournals": {"tooltip": "Exclude predatory journals"},
             "ENTRYTYPEScope": {
                 "tooltip": "Particular ENTRYTYPEs that should be included (exclusively)"
             },
         }
 
     settings_class = ScopePrescreenSettings
 
     def __init__(
         self,
         *,
-        prescreen_operation: colrev.ops.prescreen.Prescreen,  # pylint: disable=unused-argument
+        prescreen_operation: colrev.ops.prescreen.Prescreen,
         settings: dict,
     ) -> None:
         if "TimeScopeFrom" in settings:
+            settings["TimeScopeFrom"] = int(settings["TimeScopeFrom"])
             assert settings["TimeScopeFrom"] > 1900
-        if "TimeScopeFrom" in settings:
             assert settings["TimeScopeFrom"] < 2100
         if "TimeScopeTo" in settings:
+            settings["TimeScopeTo"] = int(settings["TimeScopeTo"])
             assert settings["TimeScopeTo"] > 1900
-        if "TimeScopeTo" in settings:
             assert settings["TimeScopeTo"] < 2100
         if "LanguageScope" in settings:
             self.language_service = colrev.env.language_service.LanguageService()
             self.language_service.validate_iso_639_3_language_codes(
                 lang_code_list=settings["LanguageScope"]
             )
+        if "ExcludePredatoryJournals" not in settings:
+            settings["ExcludePredatoryJournals"] = True
 
+        self.review_manager = prescreen_operation.review_manager
         self.settings = self.settings_class.load_settings(data=settings)
-
-        self.predatory_journals_beal = self.__load_predatory_journals_beal()
+        self.local_index = colrev.env.local_index.LocalIndex()
 
         self.title_complementary_materials_keywords = (
             colrev.env.utils.load_complementary_material_keywords()
         )
 
-    def __load_predatory_journals_beal(self) -> dict:
-        predatory_journals = {}
-
-        filedata = colrev.env.utils.get_package_file_content(
-            file_path=Path("template/ops/predatory_journals_beall.csv")
-        )
-
-        if filedata:
-            for pred_journal in filedata.decode("utf-8").splitlines():
-                predatory_journals[pred_journal.lower()] = pred_journal.lower()
-
-        return predatory_journals
-
     def __conditional_prescreen_entrytypes(self, record: colrev.record.Record) -> None:
         if self.settings.ENTRYTYPEScope:
             if record.data["ENTRYTYPE"] not in self.settings.ENTRYTYPEScope:
                 record.prescreen_exclude(reason="not in ENTRYTYPEScope")
 
+    def __predatory_journal_exclusion(self, record: colrev.record.Record) -> None:
+        print(self.settings.ExcludePredatoryJournals)
+        if not self.settings.ExcludePredatoryJournals:
+            return
+        if "journal" not in record.data:
+            return
+
+        rankings = self.local_index.search_in_database(record.data["journal"])
+        if any(x["predatory"] == "yes" for x in rankings):
+            record.prescreen_exclude(reason="predatory_journals_beal")
+
     def __conditional_prescreen_outlets_exclusion(
         self, record: colrev.record.Record
     ) -> None:
-        if self.settings.OutletExclusionScope:
-            if "values" in self.settings.OutletExclusionScope:
-                for resource in self.settings.OutletExclusionScope["values"]:
-                    for key, value in resource.items():
-                        if key in record.data and record.data.get(key, "") == value:
-                            record.prescreen_exclude(reason="in OutletExclusionScope")
-            if "list" in self.settings.OutletExclusionScope:
-                for resource in self.settings.OutletExclusionScope["list"]:
-                    for key, value in resource.items():
-                        if not (
-                            key == "resource" and value == "predatory_journals_beal"
-                        ):
-                            continue
-                        if "journal" not in record.data:
-                            continue
-                        if (
-                            record.data["journal"].lower()
-                            in self.predatory_journals_beal
-                        ):
-                            record.prescreen_exclude(reason="predatory_journals_beal")
+        if not self.settings.OutletExclusionScope:
+            return
+        if "values" not in self.settings.OutletExclusionScope:
+            return
+
+        for resource in self.settings.OutletExclusionScope["values"]:
+            for key, value in resource.items():
+                if key in record.data and record.data.get(key, "") == value:
+                    record.prescreen_exclude(reason="in OutletExclusionScope")
 
     def __conditional_prescreen_outlets_inclusion(
         self, record: colrev.record.Record
     ) -> None:
-        if self.settings.OutletInclusionScope:
-            in_outlet_scope = False
-            if "values" in self.settings.OutletInclusionScope:
-                for outlet in self.settings.OutletInclusionScope["values"]:
-                    for key, value in outlet.items():
-                        if key in record.data and record.data.get(key, "") == value:
-                            in_outlet_scope = True
-            if not in_outlet_scope:
-                record.prescreen_exclude(reason="not in OutletInclusionScope")
+        if not self.settings.OutletInclusionScope:
+            return
+
+        in_outlet_scope = False
+        if "values" in self.settings.OutletInclusionScope:
+            for outlet in self.settings.OutletInclusionScope["values"]:
+                for key, value in outlet.items():
+                    if key in record.data and record.data.get(key, "") == value:
+                        in_outlet_scope = True
+        if not in_outlet_scope:
+            record.prescreen_exclude(reason="not in OutletInclusionScope")
 
     def __conditional_prescreen_timescope(self, record: colrev.record.Record) -> None:
         if self.settings.TimeScopeFrom:
             if int(record.data.get("year", 0)) < self.settings.TimeScopeFrom:
                 record.prescreen_exclude(
                     reason="not in TimeScopeFrom " f"(>{self.settings.TimeScopeFrom})"
                 )
@@ -172,58 +166,114 @@
                 record.prescreen_exclude(
                     reason="not in TimeScopeTo " f"(<{self.settings.TimeScopeTo})"
                 )
 
     def __conditional_prescreen_complementary_materials(
         self, record: colrev.record.Record
     ) -> None:
-        if self.settings.ExcludeComplementaryMaterials:
-            if "title" in record.data:
-                if (
-                    record.data["title"].lower()
-                    in self.title_complementary_materials_keywords
-                ):
-                    record.prescreen_exclude(reason="complementary material")
+        if not self.settings.ExcludeComplementaryMaterials:
+            return
+
+        if "title" in record.data:
+            if (
+                record.data["title"].lower()
+                in self.title_complementary_materials_keywords
+            ):
+                record.prescreen_exclude(reason="complementary material")
+
+    def __conditional_presecreen_not_in_ranking(
+        self, record: colrev.record.Record
+    ) -> None:
+        if not self.settings.RequireRankedJournals:
+            return
+
+        if record.data["journal_ranking"] == "not included in a ranking":
+            record.set_status(
+                target_state=colrev.record.RecordState.rev_prescreen_excluded
+            )
 
     def __conditional_prescreen(
-        self, *, prescreen_operation: colrev.ops.prescreen.Prescreen, record_dict: dict
+        self,
+        *,
+        prescreen_operation: colrev.ops.prescreen.Prescreen,  # pylint: disable=unused-argument
+        record_dict: dict,
     ) -> None:
         if record_dict["colrev_status"] != colrev.record.RecordState.md_processed:
             return
 
         # Note : LanguageScope is covered in prep
         # because dedupe cannot handle merges between languages
         record = colrev.record.Record(data=record_dict)
 
+        self.__predatory_journal_exclusion(record=record)
         self.__conditional_prescreen_entrytypes(record=record)
         self.__conditional_prescreen_outlets_inclusion(record=record)
         self.__conditional_prescreen_outlets_exclusion(record=record)
         self.__conditional_prescreen_timescope(record=record)
         self.__conditional_prescreen_complementary_materials(record=record)
+        self.__conditional_presecreen_not_in_ranking(record=record)
 
         if (
             record.data["colrev_status"]
             == colrev.record.RecordState.rev_prescreen_excluded
         ):
-            prescreen_operation.review_manager.report_logger.info(
+            self.review_manager.report_logger.info(
                 f' {record.data["ID"]}'.ljust(50, " ")
                 + "Prescreen excluded (automatically)"
             )
+        elif (
+            len(self.review_manager.settings.prescreen.prescreen_package_endpoints) == 1
+        ):
+            record.set_status(
+                target_state=colrev.record.RecordState.rev_prescreen_included
+            )
+            self.review_manager.report_logger.info(
+                f' {record.data["ID"]}'.ljust(50, " ")
+                + "Prescreen included (automatically)"
+            )
+
+    def add_endpoint(self, *, params: dict) -> None:
+        """Add  the scope_prescreen as an endpoint"""
+
+        for (
+            existing_scope_prescreen
+        ) in self.review_manager.settings.prescreen.prescreen_package_endpoints:
+            if existing_scope_prescreen["endpoint"] != "colrev.scope_prescreen":
+                continue
+            self.review_manager.logger.info(
+                "Integrating into existing colrev.scope_prescreen"
+            )
+            for key, value in params.items():
+                if (
+                    key in existing_scope_prescreen
+                    and existing_scope_prescreen[key] != value
+                ):
+                    self.review_manager.logger.info(
+                        f"Replacing {key} ({existing_scope_prescreen[key]} -> {value})"
+                    )
+                existing_scope_prescreen[key] = value
+            return
+
+        # Insert (if not added before)
+        self.review_manager.settings.prescreen.prescreen_package_endpoints.insert(
+            0, {**{"endpoint": "colrev.scope_prescreen"}, **params}
+        )
 
     def run_prescreen(
         self,
         prescreen_operation: colrev.ops.prescreen.Prescreen,
         records: dict,
         split: list,  # pylint: disable=unused-argument
     ) -> dict:
         """Prescreen records based on the scope parameters"""
 
         for record_dict in records.values():
             self.__conditional_prescreen(
-                prescreen_operation=prescreen_operation, record_dict=record_dict
+                prescreen_operation=prescreen_operation,
+                record_dict=record_dict,
             )
 
         prescreen_operation.review_manager.dataset.save_records_dict(records=records)
         prescreen_operation.review_manager.dataset.add_record_changes()
         prescreen_operation.review_manager.create_commit(
             msg="Pre-screen (scope)",
             manual_author=False,
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/review_types/conceptual_review.py` & `colrev-0.9.2/colrev/ops/built_in/review_types/conceptual_review.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/review_types/critical_review.py` & `colrev-0.9.2/colrev/ops/built_in/review_types/critical_review.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/review_types/curated_masterdata.md` & `colrev-0.9.2/colrev/ops/built_in/review_types/curated_masterdata.md`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/review_types/curated_masterdata.py` & `colrev-0.9.2/colrev/ops/built_in/review_types/curated_masterdata.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/review_types/descriptive_review.py` & `colrev-0.9.2/colrev/ops/built_in/review_types/descriptive_review.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/review_types/literature_review.py` & `colrev-0.9.2/colrev/ops/built_in/review_types/literature_review.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/review_types/meta_analysis.md` & `colrev-0.9.2/colrev/ops/built_in/review_types/meta_analysis.md`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/review_types/meta_analysis.py` & `colrev-0.9.2/colrev/ops/built_in/review_types/meta_analysis.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/review_types/narrative_review.py` & `colrev-0.9.2/colrev/ops/built_in/review_types/narrative_review.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/review_types/qualitative_systematic_review.md` & `colrev-0.9.2/colrev/ops/built_in/review_types/qualitative_systematic_review.md`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/review_types/qualitative_systematic_review.py` & `colrev-0.9.2/colrev/ops/built_in/review_types/qualitative_systematic_review.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/review_types/scientometric.md` & `colrev-0.9.2/colrev/ops/built_in/review_types/scientometric.md`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/review_types/scientometric.py` & `colrev-0.9.2/colrev/ops/built_in/review_types/scientometric.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/review_types/scoping_review.py` & `colrev-0.9.2/colrev/ops/built_in/review_types/scoping_review.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/review_types/theoretical_review.py` & `colrev-0.9.2/colrev/ops/built_in/review_types/theoretical_review.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/screen/screen_cli.py` & `colrev-0.9.2/colrev/ops/built_in/screen/screen_cli.py`

 * *Files 1% similar despite different names*

```diff
@@ -250,17 +250,16 @@
             util_cli_screen.get_screening_criteria_from_user_input(
                 screen_operation=screen_operation, records=records
             )
         )
         self.criteria_available = len(self.screening_criteria.keys())
 
         for record_dict in screen_data["items"]:
-            if len(split) > 0:
-                if record_dict["ID"] not in split:
-                    continue
+            if record_dict["ID"] not in split:
+                continue
 
             ret = self.__screen_record(
                 screen_operation=screen_operation, record_dict=record_dict
             )
 
             if ret == "skip":
                 continue
@@ -270,15 +269,15 @@
 
         if self.__stat_len == 0:
             screen_operation.review_manager.logger.info("No records to screen")
             return records
 
         screen_operation.review_manager.dataset.add_record_changes()
 
-        if self.__i < self.__stat_len:  # if records remain for screening
+        if self.__i < self.__stat_len and split:  # if records remain for screening
             if input("Create commit (y/n)?") != "y":
                 return records
 
         screen_operation.review_manager.create_commit(
             msg="Screening (manual)", manual_author=True
         )
         return records
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/screen/screen_table.py` & `colrev-0.9.2/colrev/ops/built_in/screen/screen_table.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/screen/utils.py` & `colrev-0.9.2/colrev/ops/built_in/screen/utils.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/abi_inform_proquest.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/abi_inform_proquest.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 #! /usr/bin/env python
 """SearchSource: ABI/INFORM (ProQuest)"""
 from __future__ import annotations
 
 import re
-import typing
 from dataclasses import dataclass
 from pathlib import Path
 
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
+import colrev.ops.load_utils_bib
 import colrev.ops.search
 import colrev.record
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 
@@ -81,51 +81,56 @@
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for ABI/INFORM (ProQuest)"""
-
-        to_delete = []
-        for record in records.values():
-            if re.search(r"-\d{1,2}$", record["ID"]):
-                original_record_id = re.sub(r"-\d{1,2}$", "", record["ID"])
-                original_record = records[original_record_id]
-
-                # Note: between duplicate records, there are variations in spelling and completeness
-                if (
-                    colrev.record.Record.get_record_similarity(
-                        record_a=colrev.record.Record(data=record),
-                        record_b=colrev.record.Record(data=original_record),
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
+
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            to_delete = []
+            for record in records.values():
+                if re.search(r"-\d{1,2}$", record["ID"]):
+                    original_record_id = re.sub(r"-\d{1,2}$", "", record["ID"])
+                    if original_record_id not in records:
+                        continue
+                    original_record = records[original_record_id]
+
+                    # Note: between duplicate records,
+                    # there are variations in spelling and completeness
+                    if (
+                        colrev.record.Record.get_record_similarity(
+                            record_a=colrev.record.Record(data=record),
+                            record_b=colrev.record.Record(data=original_record),
+                        )
+                        < 0.9
+                    ):
+                        continue
+
+                    if original_record_id not in records:
+                        continue
+                    to_delete.append(record["ID"])
+            if to_delete:
+                for rid in to_delete:
+                    load_operation.review_manager.logger.info(
+                        f" remove duplicate {rid}"
                     )
-                    < 0.9
-                ):
-                    continue
-
-                if original_record_id not in records:
-                    continue
-                to_delete.append(record["ID"])
-
-        for rid in to_delete:
-            load_operation.review_manager.logger.info(f" remove duplicate {rid}")
-            del records[rid]
-
-        load_operation.review_manager.dataset.save_records_dict_to_file(
-            records=records, save_path=source.filename
-        )
+                    del records[rid]
 
-        return records
+                load_operation.review_manager.dataset.save_records_dict_to_file(
+                    records=records, save_path=self.search_source.filename
+                )
+            return records
+
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for ABI/INFORM (ProQuest)"""
 
         if record.data.get("journal", "").lower().endswith("conference proceedings."):
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/acm_digital_library.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/acm_digital_library.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 #! /usr/bin/env python
 """SearchSource: ACM Digital Library"""
 from __future__ import annotations
 
-import typing
 from dataclasses import dataclass
 from pathlib import Path
 
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_bib
 import colrev.ops.search
 import colrev.record
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 
@@ -102,23 +102,24 @@
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for ACM Digital Library"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
 
-        return records
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            return records
+
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for ACM Digital Library"""
         record.remove_field(key="url")
         record.remove_field(key="numpages")
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/aisel.md` & `colrev-0.9.2/colrev/ops/built_in/search_sources/aisel.md`

 * *Files 14% similar despite different names*

```diff
@@ -1,23 +1,32 @@
 # SearchSource: AIS electronic Library
 
+<!--
 Note: This document is currently under development. It will contain the following elements.
 
 - description
 - coverage (disciplines, types of work)
-- supported (details): search updates, get_masterdata, run_search, load_fixes, prep
+- supported (details): run_search (including updates), load,  prep (including get_masterdata)
+ -->
 
-[AIS eLibrary](https://aisel.aisnet.org/)
 
 ## Add the search source
 
 Run a search on [aisel.aisnet.org](https://aisel.aisnet.org/).
 
 Option 1: download the search results (advanced search, format:Bibliography Export, click Search) and store them in the `data/search/` directory.
 
 Option 2: copy the search link and add an API search (replacing the link):
 
 ```
 colrev search -a colrev.ais_library:"https://aisel.aisnet.org/do/search/?q=microsourcing&start=0&context=509156&facet="
 ```
 
+Note: Complex queries can be entered in the basic search field. Example:
+
+```
+title:microsourcing AND ( digital OR online)
+```
+
 ## Links
+
+[AIS eLibrary](https://aisel.aisnet.org/)
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/aisel.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/aisel.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,13 @@
 #! /usr/bin/env python
 """SearchSource: AIS electronic Library"""
 from __future__ import annotations
 
 import json
 import re
-import typing
 import urllib.parse
 from dataclasses import dataclass
 from pathlib import Path
 from urllib.parse import urlparse
 
 import requests
 import zope.interface
@@ -160,15 +159,14 @@
             params = cls.__parse_query(query=query)
             filename = search_operation.get_unique_filename(file_path_string="ais")
             add_source = colrev.settings.SearchSource(
                 endpoint="colrev.ais_library",
                 filename=filename,
                 search_type=colrev.settings.SearchType.DB,
                 search_parameters={"query": params},
-                load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                 comment="",
             )
             return add_source
 
         raise colrev_exceptions.PackageParameterError(
             f"Cannot add aisel endpoint with query {query}"
         )
@@ -270,15 +268,15 @@
 
         return list(records.values())
 
     def __run_parameter_search(
         self,
         *,
         search_operation: colrev.ops.search.Search,
-        ais_feed: colrev.ops.search.GeneralOriginFeed,
+        ais_feed: colrev.ops.search_feed.GeneralOriginFeed,
         rerun: bool,
     ) -> None:
         # pylint: disable=too-many-branches
 
         if rerun:
             search_operation.review_manager.logger.info(
                 "Performing a search of the full history (may take time)"
@@ -369,23 +367,18 @@
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for AIS electronic Library (AISeL)"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
 
-        return records
+        raise NotImplementedError
 
     def __fix_entrytype(self, *, record: colrev.record.Record) -> None:
         # Note : simple heuristic
         # but at the moment, AISeLibrary only indexes articles and conference papers
         if (
             record.data.get("volume", "UNKNOWN") != "UNKNOWN"
             or record.data.get("number", "UNKNOWN") != "UNKNOWN"
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/colrev_project.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/colrev_project.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,28 +1,28 @@
 #! /usr/bin/env python
 """SearchSource: CoLRev project"""
 from __future__ import annotations
 
 import shutil
 import tempfile
-import typing
 from dataclasses import dataclass
 from pathlib import Path
 
 import pandas as pd
 import pandasql as ps
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 from git import Repo
 from pandasql.sqldf import PandaSQLException
 from tqdm import tqdm
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_bib
 import colrev.ops.search
 import colrev.record
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 
@@ -85,15 +85,14 @@
                 file_path_string=query.split("/")[-1]
             )
             return colrev.settings.SearchSource(
                 endpoint="colrev.colrev_project",
                 filename=filename,
                 search_type=colrev.settings.SearchType.OTHER,
                 search_parameters={"scope": {"url": query[4:]}},
-                load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                 comment="",
             )
 
         raise NotImplementedError
 
     def __load_records_to_import(self, *, project_url: str, project_name: str) -> dict:
         temp_path = tempfile.gettempdir() / Path(project_name)
@@ -182,15 +181,15 @@
             # otherwise, we may also consider retrieving PDFs from local_index automatically
             # if "file" in record_to_import:
             #     record_to_import["file"] = (
             #         Path(self.search_source.search_parameters["scope"]["url"])
             #         / record_to_import["file"]
             #     )
 
-            #     pdf_get_operation.import_file(
+            #     pdf_get_operation.import_pdf(
             #         record=colrev.record.Record(data=record_to_import)
             #     )
 
             record_to_import[
                 "colrev_project_identifier"
             ] = f"{project_url}#{record_to_import['ID']}"
             record_to_import = {
@@ -227,23 +226,31 @@
 
         result = {"confidence": 0.0}
         if "colrev_project" in data:
             result["confidence"] = 1.0
 
         return result
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for CoLRev projects"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
+
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            for record_id in records:
+                records[record_id] = {
+                    k: v
+                    for k, v in records[record_id].items()
+                    if k not in ["colrev_status", "colrev_masterdata_provenance"]
+                }
+
+            return records
 
-        return records
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for CoLRev projects"""
 
         return record
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/crossref.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/crossref.py`

 * *Files 4% similar despite different names*

```diff
@@ -42,15 +42,15 @@
 @zope.interface.implementer(
     colrev.env.package_manager.SearchSourcePackageEndpointInterface
 )
 @dataclass
 class CrossrefSearchSource(JsonSchemaMixin):
     """SearchSource for the Crossref API"""
 
-    __issn_regex = r"^\d{4}-?\d{3}[\dxX]$"
+    __ISSN_REGEX = r"^\d{4}-?\d{3}[\dxX]$"
 
     # https://github.com/CrossRef/rest-api-doc
     __api_url = "https://api.crossref.org/works?"
 
     settings_class = colrev.env.package_manager.DefaultSourceSettings
     source_identifier = "doi"
     # "https://api.crossref.org/works/{{doi}}"
@@ -91,15 +91,14 @@
                 self.search_source = crossref_md_source_l[0]
             else:
                 self.search_source = colrev.settings.SearchSource(
                     endpoint="colrev.crossref",
                     filename=self.__crossref_md_filename,
                     search_type=colrev.settings.SearchType.OTHER,
                     search_parameters={},
-                    load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                     comment="",
                 )
 
             self.crossref_lock = Lock()
 
         self.language_service = colrev.env.language_service.LanguageService()
 
@@ -168,16 +167,16 @@
         crossref_query_return = works.query(**kwargs).sort("deposited").order("desc")
         yield from crossref_query_return
 
     @classmethod
     def query_doi(cls, *, doi: str, etiquette: Etiquette) -> colrev.record.PrepRecord:
         """Get records from Crossref based on a doi query"""
 
-        works = Works(etiquette=etiquette)
         try:
+            works = Works(etiquette=etiquette)
             crossref_query_return = works.doi(doi)
             if crossref_query_return is None:
                 raise colrev_exceptions.RecordNotFoundInPrepSourceException(
                     msg="Record not found in crossref (based on doi)"
                 )
 
             retrieved_record_dict = connector_utils.json_to_record(
@@ -195,15 +194,15 @@
             ) from exc
 
     def __query_journal(
         self, *, journal_issn: str, rerun: bool
     ) -> typing.Iterator[dict]:
         """Get records of a selected journal from Crossref"""
 
-        assert re.match(self.__issn_regex, journal_issn)
+        assert re.match(self.__ISSN_REGEX, journal_issn)
 
         journals = Journals(etiquette=self.etiquette)
         if rerun:
             # Note : the "deposited" field is not always provided.
             # only the general query will return all records.
             crossref_query_return = journals.works(journal_issn).query()
         else:
@@ -360,15 +359,15 @@
         except (
             colrev_exceptions.NotEnoughDataToIdentifyException,
             json.decoder.JSONDecodeError,
             requests.exceptions.RequestException,
         ):
             return []
 
-        return data["message"]["items"]
+        return data["message"].get("items", [])
 
     def crossref_query(
         self,
         *,
         record_input: colrev.record.Record,
         jour_vol_iss_list: bool = False,
         timeout: int = 40,
@@ -529,14 +528,15 @@
             return record
 
         except (
             requests.exceptions.RequestException,
             OSError,
             IndexError,
             colrev_exceptions.RecordNotFoundInPrepSourceException,
+            colrev_exceptions.RecordNotParsableException,
         ) as exc:
             if prep_operation.review_manager.verbose_mode:
                 print(exc)
 
         return record
 
     def __check_doi_masterdata(
@@ -561,14 +561,15 @@
                 # retrieved_record.print_citation_format()
 
         except (
             requests.exceptions.RequestException,
             OSError,
             IndexError,
             colrev_exceptions.RecordNotFoundInPrepSourceException,
+            colrev_exceptions.RecordNotParsableException,
         ):
             pass
 
         return record
 
     def get_masterdata(
         self,
@@ -623,17 +624,15 @@
                 raise colrev_exceptions.InvalidQueryException(
                     "Crossref search_parameters requires a query or journal_issn field"
                 )
 
             if "scope" in source.search_parameters:
                 if "journal_issn" in source.search_parameters["scope"]:
                     issn_field = source.search_parameters["scope"]["journal_issn"]
-                    if not re.match(
-                        "[0-9][0-9][0-9][0-9][-]?[0-9][0-9][0-9][X0-9]", issn_field
-                    ):
+                    if not re.match(self.__ISSN_REGEX, issn_field):
                         raise colrev_exceptions.InvalidQueryException(
                             f"Crossref journal issn ({issn_field}) not matching required format"
                         )
                 else:
                     raise colrev_exceptions.InvalidQueryException(
                         "Query missing valid parameters"
                     )
@@ -677,19 +676,35 @@
                 # potential extension : add the container_title:
                 # crossref_query_return = works.query(
                 #     container_title=
                 #       "Journal of the Association for Information Systems"
                 # )
                 yield from self.__query(**crossref_query)
 
+    def __restore_url(
+        self,
+        *,
+        record: colrev.record.Record,
+        feed: colrev.ops.search_feed.GeneralOriginFeed,
+    ) -> None:
+        """Restore the url from the feed if it exists
+        (url-resolution is not always available)"""
+        if record.data["ID"] not in feed.feed_records:
+            return
+        prev_url = feed.feed_records[record.data["ID"]].get("url", None)
+        if prev_url is None:
+            return
+        record.data["url"] = prev_url
+
     def __run_md_search_update(
         self,
         *,
         search_operation: colrev.ops.search.Search,
-        crossref_feed: colrev.ops.search.GeneralOriginFeed,
+        crossref_feed: colrev.ops.search_feed.GeneralOriginFeed,
+        rerun: bool,
     ) -> None:
         records = search_operation.review_manager.dataset.load_records_dict()
 
         for feed_record_dict in crossref_feed.feed_records.values():
             feed_record = colrev.record.Record(data=feed_record_dict)
 
             try:
@@ -703,28 +718,31 @@
                 crossref_feed.set_id(record_dict=retrieved_record.data)
             except (
                 colrev_exceptions.RecordNotFoundInPrepSourceException,
                 colrev_exceptions.NotFeedIdentifiableException,
             ):
                 continue
 
+            self.__prep_crossref_record(record=retrieved_record, prep_main_record=False)
+
             prev_record_dict_version = {}
             if retrieved_record.data["ID"] in crossref_feed.feed_records:
                 prev_record_dict_version = crossref_feed.feed_records[
                     retrieved_record.data["ID"]
                 ]
 
+            self.__restore_url(record=retrieved_record, feed=crossref_feed)
             crossref_feed.add_record(record=retrieved_record)
 
-            changed = search_operation.update_existing_record(
+            changed = crossref_feed.update_existing_record(
                 records=records,
                 record_dict=retrieved_record.data,
                 prev_record_dict_version=prev_record_dict_version,
                 source=self.search_source,
-                update_time_variant_fields=True,
+                update_time_variant_fields=rerun,
             )
             if changed:
                 crossref_feed.nr_changed += 1
 
         if crossref_feed.nr_changed > 0:
             self.review_manager.logger.info(
                 f"{colors.GREEN}Updated {crossref_feed.nr_changed} "
@@ -740,47 +758,51 @@
         search_operation.review_manager.dataset.save_records_dict(records=records)
         search_operation.review_manager.dataset.add_record_changes()
 
     def __run_parameter_search(
         self,
         *,
         search_operation: colrev.ops.search.Search,
-        crossref_feed: colrev.ops.search.GeneralOriginFeed,
+        crossref_feed: colrev.ops.search_feed.GeneralOriginFeed,
         rerun: bool,
     ) -> None:
         if rerun:
             search_operation.review_manager.logger.info(
                 "Performing a search of the full history (may take time)"
             )
 
         records = search_operation.review_manager.dataset.load_records_dict()
         for item in self.__get_crossref_query_return(rerun=rerun):
             try:
-                record_dict = connector_utils.json_to_record(item=item)
-                crossref_feed.set_id(record_dict=record_dict)
+                retrieved_record_dict = connector_utils.json_to_record(item=item)
+                crossref_feed.set_id(record_dict=retrieved_record_dict)
                 prev_record_dict_version = {}
-                if record_dict["ID"] in crossref_feed.feed_records:
+                if retrieved_record_dict["ID"] in crossref_feed.feed_records:
                     prev_record_dict_version = deepcopy(
-                        crossref_feed.feed_records[record_dict["ID"]]
+                        crossref_feed.feed_records[retrieved_record_dict["ID"]]
                     )
 
-                record = colrev.record.Record(data=record_dict)
-                self.__prep_crossref_record(record=record, prep_main_record=False)
+                retrieved_record = colrev.record.Record(data=retrieved_record_dict)
+                self.__prep_crossref_record(
+                    record=retrieved_record, prep_main_record=False
+                )
 
-                added = crossref_feed.add_record(record=record)
+                self.__restore_url(record=retrieved_record, feed=crossref_feed)
+
+                added = crossref_feed.add_record(record=retrieved_record)
 
                 if added:
                     search_operation.review_manager.logger.info(
-                        " retrieve " + record.data["doi"]
+                        " retrieve " + retrieved_record.data["doi"]
                     )
                     crossref_feed.nr_added += 1
                 else:
-                    changed = search_operation.update_existing_record(
+                    changed = crossref_feed.update_existing_record(
                         records=records,
-                        record_dict=record.data,
+                        record_dict=retrieved_record.data,
                         prev_record_dict_version=prev_record_dict_version,
                         source=self.search_source,
                         update_time_variant_fields=rerun,
                     )
                     if changed:
                         crossref_feed.nr_changed += 1
 
@@ -816,14 +838,15 @@
             if (
                 self.search_source.is_md_source()
                 or self.search_source.is_quasi_md_source()
             ):
                 self.__run_md_search_update(
                     search_operation=search_operation,
                     crossref_feed=crossref_feed,
+                    rerun=rerun,
                 )
 
             else:
                 self.__run_parameter_search(
                     search_operation=search_operation,
                     crossref_feed=crossref_feed,
                     rerun=rerun,
@@ -867,47 +890,85 @@
                 file_path_string=f"crossref_{query}"
             )
             add_source = colrev.settings.SearchSource(
                 endpoint="colrev.crossref",
                 filename=filename,
                 search_type=colrev.settings.SearchType.DB,
                 search_parameters={"query": query},
-                load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                 comment="",
             )
             return add_source
 
-        if query.startswith("jissn="):
-            query = query.replace("jissn=", "")
+        if query.startswith("issn="):
+            query = query.replace("issn=", "")
             filename = search_operation.get_unique_filename(
-                file_path_string=f"crossref_jissn_{query}"
+                file_path_string=f"crossref_issn_{query}"
             )
             add_source = colrev.settings.SearchSource(
                 endpoint="colrev.crossref",
                 filename=filename,
                 search_type=colrev.settings.SearchType.DB,
                 search_parameters={"scope": {"journal_issn": query}},
-                load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                 comment="",
             )
             return add_source
+        print("Interactively add Crossref as a SearchSource")
+        print()
+        print("Documentation:")
+        print(
+            "https://github.com/CoLRev-Environment/colrev/blob/"
+            + "main/colrev/ops/built_in/search_sources/crossref.md"
+        )
+        print()
+        query_type = ""
+        while query_type not in ["j", "k"]:
+            query_type = input("Create a query based on [k]eywords or [j]ournal?")
+        if query_type == "j":
+            print("Get ISSN from https://portal.issn.org/issn/search")
+            issn = ""
+            while not re.match(cls.__ISSN_REGEX, issn):
+                issn = input("Enter the ISSN of the journal:")
+            filename = search_operation.get_unique_filename(
+                file_path_string=f"crossref_issn_{issn}"
+            )
+            add_source = colrev.settings.SearchSource(
+                endpoint="colrev.crossref",
+                filename=filename,
+                search_type=colrev.settings.SearchType.DB,
+                search_parameters={"scope": {"journal_issn": issn}},
+                comment="",
+            )
+            return add_source
+        # if query_type == "k":
+        keywords = input("Enter the keywords:")
+        keywords = keywords.replace(" ", "+")
+        query = f"https://search.crossref.org/?q={keywords}"
 
-        raise colrev_exceptions.PackageParameterError(
-            f"Cannot add crossref endpoint with query {query}"
+        filename = search_operation.get_unique_filename(
+            file_path_string=f"crossref_{keywords}"
         )
+        add_source = colrev.settings.SearchSource(
+            endpoint="colrev.crossref",
+            filename=filename,
+            search_type=colrev.settings.SearchType.DB,
+            search_parameters={"query": keywords},
+            comment="",
+        )
+        return add_source
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for Crossref"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
+
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            return records
 
-        return records
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for Crossref"""
 
         source_item = [
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/dblp.md` & `colrev-0.9.2/colrev/ops/built_in/search_sources/dblp.md`

 * *Files 9% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # SearchSource: DBLP
 
 Note: This document is currently under development. It will contain the following elements.
 
 - description
 - coverage (disciplines, types of work): Computer science disciplines
-- supported (details): search updates, get_masterdata, run_search, load_fixes, prep
+- supported (details): run_search (including updates), load,  prep (including get_masterdata)
 
 [DBLP](https://dblp.org/)
 
 License: [Open Data Commons ODC-BY 1.0 license](https://dblp.org/db/about/copyright.html)
 
 ## Add the search source
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/dblp.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/dblp.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 #! /usr/bin/env python
 """SearchSource: DBLP"""
 from __future__ import annotations
 
 import html
 import json
 import re
-import typing
 from dataclasses import dataclass
 from datetime import datetime
 from multiprocessing import Lock
 from pathlib import Path
 from sqlite3 import OperationalError
 from typing import Optional
 
 import requests
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_bib
 import colrev.ops.search
 import colrev.record
 import colrev.settings
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
@@ -58,15 +58,14 @@
 
         # pylint: disable=duplicate-code
         # pylint: disable=too-many-instance-attributes
         endpoint: str
         filename: Path
         search_type: colrev.settings.SearchType
         search_parameters: dict
-        load_conversion_package_endpoint: dict
         comment: Optional[str]
 
         _details = {
             "search_parameters": {
                 "tooltip": "Currently supports a scope item "
                 "with venue_key and journal_abbreviated fields."
             },
@@ -96,15 +95,14 @@
                 self.search_source = dblp_md_source_l[0]
             else:
                 self.search_source = colrev.settings.SearchSource(
                     endpoint="colrev.dblp",
                     filename=self.__dblp_md_filename,
                     search_type=colrev.settings.SearchType.OTHER,
                     search_parameters={},
-                    load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                     comment="",
                 )
         self.dblp_lock = Lock()
         self.origin_prefix = self.search_source.get_origin_prefix()
         self.review_manager = source_operation.review_manager
 
         _, self.email = source_operation.review_manager.get_committer()
@@ -210,14 +208,15 @@
 
     def __dblp_json_to_dict(
         self,
         *,
         session: requests.Session,
         item: dict,
     ) -> dict:
+        # pylint: disable=too-many-branches
         # To test in browser:
         # https://dblp.org/search/publ/api?q=ADD_TITLE&format=json
 
         self.__dblp_json_set_type(item=item, session=session)
         if "title" in item:
             item["title"] = item["title"].rstrip(".").rstrip().replace("\n", " ")
             item["title"] = re.sub(r"\s+", " ", item["title"])
@@ -246,14 +245,17 @@
         if "doi" in item:
             item["doi"] = item["doi"].upper()
         if "ee" in item:
             if not any(
                 x in item["ee"] for x in ["https://doi.org", "https://dblp.org"]
             ):
                 item["url"] = item["ee"]
+        if "url" in item:
+            if "https://dblp.org" in item["url"]:
+                del item["url"]
 
         item = {
             k: v
             for k, v in item.items()
             if k not in ["venue", "type", "access", "key", "ee", "authors"]
         }
         for key, value in item.items():
@@ -362,15 +364,15 @@
             f"SearchSource {source.filename} validated"
         )
 
     def __run_md_search_update(
         self,
         *,
         search_operation: colrev.ops.search.Search,
-        dblp_feed: colrev.ops.search.GeneralOriginFeed,
+        dblp_feed: colrev.ops.search_feed.GeneralOriginFeed,
     ) -> None:
         records = search_operation.review_manager.dataset.load_records_dict()
 
         for feed_record_dict in dblp_feed.feed_records.values():
             feed_record = colrev.record.Record(data=feed_record_dict)
             query = "" + feed_record.data.get("title", "").replace("-", "_")
             for retrieved_record in self.__retrieve_dblp_records(
@@ -387,15 +389,15 @@
                 prev_record_dict_version = {}
                 if retrieved_record.data["ID"] in dblp_feed.feed_records:
                     prev_record_dict_version = dblp_feed.feed_records[
                         retrieved_record.data["ID"]
                     ]
 
                 dblp_feed.add_record(record=retrieved_record)
-                changed = search_operation.update_existing_record(
+                changed = dblp_feed.update_existing_record(
                     records=records,
                     record_dict=retrieved_record.data,
                     prev_record_dict_version=prev_record_dict_version,
                     source=self.search_source,
                     update_time_variant_fields=True,
                 )
                 if changed:
@@ -407,15 +409,15 @@
         search_operation.review_manager.dataset.add_record_changes()
 
     def __run_param_search_year_batch(
         self,
         *,
         query: str,
         search_operation: colrev.ops.search.Search,
-        dblp_feed: colrev.ops.search.GeneralOriginFeed,
+        dblp_feed: colrev.ops.search_feed.GeneralOriginFeed,
         records: dict,
         rerun: bool,
     ) -> None:
         batch_size_cumulative = 0
         batch_size = 250
         while True:
             url = (
@@ -458,15 +460,15 @@
                 if added:
                     self.review_manager.logger.info(
                         " retrieve " + retrieved_record.data["dblp_key"]
                     )
                     dblp_feed.nr_added += 1
 
                 else:
-                    changed = search_operation.update_existing_record(
+                    changed = dblp_feed.update_existing_record(
                         records=records,
                         record_dict=retrieved_record.data,
                         prev_record_dict_version=prev_record_dict_version,
                         source=self.search_source,
                         update_time_variant_fields=rerun,
                     )
                     if changed:
@@ -493,15 +495,15 @@
             query = self.search_source.search_parameters["query"] + "+" + str(year)
         return query
 
     def __run_parameter_search(
         self,
         *,
         search_operation: colrev.ops.search.Search,
-        dblp_feed: colrev.ops.search.GeneralOriginFeed,
+        dblp_feed: colrev.ops.search_feed.GeneralOriginFeed,
         rerun: bool,
     ) -> None:
         records = self.review_manager.dataset.load_records_dict()
         try:
             start = self.__START_YEAR
             if len(dblp_feed.feed_records) > 100 and not rerun:
                 start = datetime.now().year - 2
@@ -583,32 +585,32 @@
                 file_path_string=f"dblp_{query.replace(cls.__api_url, '')}"
             )
             add_source = colrev.settings.SearchSource(
                 endpoint="colrev.dblp",
                 filename=filename,
                 search_type=colrev.settings.SearchType.DB,
                 search_parameters={"query": query},
-                load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                 comment="",
             )
             return add_source
 
         raise colrev_exceptions.PackageParameterError(
             f"Cannot add backward_search endpoint with query {query}"
         )
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for DBLP"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
+
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            return records
 
-        return records
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for DBLP"""
 
         if record.data.get("author", "UNKNOWN") != "UNKNOWN":
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/doi_org.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/doi_org.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/ebsco_host.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/ebsco_host.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 #! /usr/bin/env python
 """SearchSource: EBSCOHost"""
 from __future__ import annotations
 
-import typing
 from dataclasses import dataclass
 from pathlib import Path
 
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
+import colrev.ops.load_utils_bib
 import colrev.ops.search
 import colrev.record
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 
@@ -83,23 +83,29 @@
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for EBSCOHost"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
 
-        return records
+        if self.search_source.filename.suffix == ".csv":
+            csv_loader = colrev.ops.load_utils_table.CSVLoader(
+                load_operation=load_operation, settings=self.search_source
+            )
+            records = csv_loader.load()
+            load_operation.review_manager.dataset.save_records_dict_to_file(
+                records=records,
+                save_path=self.search_source.get_corresponding_bib_file(),
+            )
+            return records
+
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for EBSCOHost"""
 
         return record
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/eric.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/taylor_and_francis.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,119 +1,111 @@
 #! /usr/bin/env python
-"""SearchSource: ERIC"""
+"""SearchSource: Taylor and Francis"""
 from __future__ import annotations
 
-import typing
+import re
 from dataclasses import dataclass
 from pathlib import Path
 
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
-import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_bib
 import colrev.ops.search
 import colrev.record
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 
 @zope.interface.implementer(
     colrev.env.package_manager.SearchSourcePackageEndpointInterface
 )
 @dataclass
-class ERICSearchSource(JsonSchemaMixin):
-    """SearchSource for ERIC"""
+class TaylorAndFrancisSearchSource(JsonSchemaMixin):
+    """SearchSource for Taylor and Francis"""
 
     settings_class = colrev.env.package_manager.DefaultSourceSettings
-    source_identifier = "url"
+    source_identifier = "{{doi}}"
     search_type = colrev.settings.SearchType.DB
     api_search_supported = False
     ci_supported: bool = False
-    heuristic_status = colrev.env.package_manager.SearchSourceHeuristicStatus.oni
-    short_name = "ERIC"
+    heuristic_status = colrev.env.package_manager.SearchSourceHeuristicStatus.supported
+    short_name = "Taylor and Francis"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
-        + "colrev/ops/built_in/search_sources/eric.md"
+        + "colrev/ops/built_in/search_sources/taylor_and_francis.md"
     )
 
     def __init__(
         self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
 
-    def validate_source(
-        self,
-        search_operation: colrev.ops.search.Search,
-        source: colrev.settings.SearchSource,
-    ) -> None:
-        """Validate the SearchSource (parameters etc.)"""
-
-        search_operation.review_manager.logger.debug(
-            f"Validate SearchSource {source.filename}"
-        )
-
-        if "query_file" not in source.search_parameters:
-            raise colrev_exceptions.InvalidQueryException(
-                f"Source missing query_file search_parameter ({source.filename})"
-            )
-
-        if not Path(source.search_parameters["query_file"]).is_file():
-            raise colrev_exceptions.InvalidQueryException(
-                f"File does not exist: query_file {source.search_parameters['query_file']} "
-                f"for ({source.filename})"
-            )
-
-        search_operation.review_manager.logger.debug(
-            f"SearchSource {source.filename} validated"
-        )
-
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
-        """Source heuristic for ERIC"""
+        """Source heuristic for Taylor and Francis"""
 
         result = {"confidence": 0.0}
 
-        # Note : no features in bib file for identification
+        if data.count("\n@") > 1:
+            if data.count("eprint = { \n    \n    ") >= data.count("\n@"):
+                result["confidence"] = 1.0
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
     ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
         raise NotImplementedError
 
+    def validate_source(
+        self,
+        search_operation: colrev.ops.search.Search,
+        source: colrev.settings.SearchSource,
+    ) -> None:
+        """Validate the SearchSource (parameters etc.)"""
+
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
-        """Run a search of ERIC"""
+        """Run a search of TaylorAndFrancis"""
 
     def get_masterdata(
         self,
         prep_operation: colrev.ops.prep.Prep,
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for ERIC"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
+
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            return records
 
-        return records
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
-        """Source-specific preparation for ERIC"""
+        """Source-specific preparation for Taylor and Francis"""
+
+        # remove eprint and URL fields (they only have dois...)
+        record.remove_field(key="url")
+        record.remove_field(key="eprint")
+        if "note" in record.data and re.match(r"PMID: \d*", record.data["note"]):
+            record.rename_field(key="note", new_key="pmid")
+            record.data["pmid"] = record.data["pmid"][6:]
+        record.remove_field(key="publisher")
 
         return record
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/europe_pmc.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/europe_pmc.py`

 * *Files 2% similar despite different names*

```diff
@@ -20,14 +20,15 @@
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 from defusedxml.ElementTree import fromstring
 from thefuzz import fuzz
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_bib
 import colrev.ops.search
 import colrev.record
 import colrev.settings
 
 # defuse std xml lib
 defusedxml.defuse_stdlib()
 
@@ -63,15 +64,14 @@
         """Settings for EuropePMCSearchSource"""
 
         # pylint: disable=too-many-instance-attributes
         endpoint: str
         filename: Path
         search_type: colrev.settings.SearchType
         search_parameters: dict
-        load_conversion_package_endpoint: dict
         comment: typing.Optional[str]
 
         _details = {
             "search_parameters": {
                 "tooltip": "Currently supports a scope item "
                 "with venue_key and journal_abbreviated fields."
             },
@@ -102,15 +102,14 @@
                 self.search_source = europe_pmc_md_source_l[0]
             else:
                 self.search_source = colrev.settings.SearchSource(
                     endpoint="colrev.europe_pmc",
                     filename=self.__europe_pmc_md_filename,
                     search_type=colrev.settings.SearchType.OTHER,
                     search_parameters={},
-                    load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                     comment="",
                 )
 
             self.europe_pmc_lock = Lock()
 
     # @classmethod
     # def check_status(cls, *, prep_operation: colrev.ops.prep.Prep) -> None:
@@ -418,15 +417,15 @@
                 rerun=rerun,
             )
 
     def __run_parameter_search(
         self,
         *,
         search_operation: colrev.ops.search.Search,
-        europe_pmc_feed: colrev.ops.search.GeneralOriginFeed,
+        europe_pmc_feed: colrev.ops.search_feed.GeneralOriginFeed,
         rerun: bool,
     ) -> None:
         # pylint: disable=too-many-branches
         # pylint: disable=too-many-locals
         # pylint: disable=too-many-nested-blocks
 
         try:
@@ -481,15 +480,15 @@
                     if added:
                         search_operation.review_manager.logger.info(
                             " retrieve europe_pmc_id="
                             + retrieved_record.data["europe_pmc_id"]
                         )
                         europe_pmc_feed.nr_added += 1
                     else:
-                        changed = search_operation.update_existing_record(
+                        changed = europe_pmc_feed.update_existing_record(
                             records=records,
                             record_dict=retrieved_record.data,
                             prev_record_dict_version=prev_record_dict_version,
                             source=self.search_source,
                             update_time_variant_fields=rerun,
                         )
                         if changed:
@@ -544,30 +543,30 @@
                 "https://www.ebi.ac.uk/europepmc/webservices/rest/search?query=" + query
             )
             add_source = colrev.settings.SearchSource(
                 endpoint="colrev.europe_pmc",
                 filename=filename,
                 search_type=colrev.settings.SearchType.DB,
                 search_parameters={"query": query},
-                load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                 comment="",
             )
             return add_source
 
         raise NotImplementedError
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for Europe PMC"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
 
-        return records
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            return records
+
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for Europe PMC"""
         record.data["author"].rstrip(".")
         record.data["title"].rstrip(".")
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/google_scholar.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/google_scholar.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 #! /usr/bin/env python
 """SearchSource: GoogleScholar"""
 from __future__ import annotations
 
-import typing
 from dataclasses import dataclass
 from pathlib import Path
 
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_bib
 import colrev.ops.search
 import colrev.record
 
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
@@ -105,23 +105,24 @@
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for GoogleScholar"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
 
-        return records
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            return records
+
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for GoogleScholar"""
         if "note" in record.data:
             if (
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/ieee.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/wiley.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,56 +1,52 @@
 #! /usr/bin/env python
-"""SearchSource: IEEEXplore"""
+"""SearchSource: Wiley"""
 from __future__ import annotations
 
-import re
-import typing
 from dataclasses import dataclass
 from pathlib import Path
 
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_bib
 import colrev.ops.search
 import colrev.record
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 
 @zope.interface.implementer(
     colrev.env.package_manager.SearchSourcePackageEndpointInterface
 )
 @dataclass
-class IEEEXploreSearchSource(JsonSchemaMixin):
-    """SearchSource for IEEEXplore"""
+class WileyOnlineLibrarySearchSource(JsonSchemaMixin):
+    """SearchSource for Wiley"""
 
     settings_class = colrev.env.package_manager.DefaultSourceSettings
     source_identifier = "url"
     search_type = colrev.settings.SearchType.DB
     api_search_supported = False
     ci_supported: bool = False
     heuristic_status = colrev.env.package_manager.SearchSourceHeuristicStatus.supported
-    short_name = "IEEE Xplore"
+    short_name = "Wiley"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
-        + "colrev/ops/built_in/search_sources/ieee.md"
+        + "colrev/ops/built_in/search_sources/wiley.md"
     )
 
     def __init__(
         self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
 
-    # For run_search, a Python SDK would be available:
-    # https://developer.ieee.org/Python_Software_Development_Kit
-
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
     ) -> None:
         """Validate the SearchSource (parameters etc.)"""
 
@@ -71,59 +67,65 @@
 
         search_operation.review_manager.logger.debug(
             f"SearchSource {source.filename} validated"
         )
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
-        """Source heuristic for IEEEXplore"""
+        """Source heuristic for Wiley"""
 
-        result = {"confidence": 0.1}
+        result = {"confidence": 0.0}
 
-        if "INPROCEEDINGS" in data:
-            if len(re.findall(r"@[A-Z]*\{[0-9]*,\n", data)) >= data.count("\n@"):
-                result["confidence"] = 1.0
-        if all(
-            x in data.splitlines()[0] for x in ["Date Added To Xplore", "IEEE Terms"]
-        ):
-            result["confidence"] = 1.0
+        # Simple heuristic:
+        if "eprint = {https://onlinelibrary.wiley.com/doi/pdf/" in data:
+            result["confidence"] = 0.7
+            return result
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
     ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
         raise NotImplementedError
 
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
-        """Run a search of IEEEXplore"""
+        """Run a search of Wiley"""
 
     def get_masterdata(
         self,
         prep_operation: colrev.ops.prep.Prep,
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for IEEEXplore"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
 
-        return records
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            return records
+
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
-        """Source-specific preparation for IEEEXplore"""
+        """Source-specific preparation for Wiley"""
+
+        record.rename_field(key="eprint", new_key="fulltext")
+
+        if record.data.get("ENTRYTYPE", "") == "inbook":
+            record.rename_field(key="title", new_key="chapter")
+            record.rename_field(key="booktitle", new_key="title")
+
+        record.rename_field(key="eprint", new_key="fulltext")
 
         return record
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/jstor.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/jstor.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 #! /usr/bin/env python
 """SearchSource: JSTOR"""
 from __future__ import annotations
 
-import typing
 from dataclasses import dataclass
 from pathlib import Path
 
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_ris
 import colrev.ops.search
 import colrev.record
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 
@@ -74,14 +74,16 @@
         """Source heuristic for JSTOR"""
 
         result = {"confidence": 0.1}
 
         if "www.jstor.org:" in data:
             if data.count("www.jstor.org") > data.count("\n@"):
                 result["confidence"] = 1.0
+        if data.startswith("Provider: JSTOR http://www.jstor.org"):
+            result["confidence"] = 1.0
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
     ) -> colrev.settings.SearchSource:
@@ -99,23 +101,35 @@
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for JSTOR"""
+    def __ris_fixes(self, *, entries: dict) -> None:
+        for entry in entries:
+            if "title" in entry and "primary_title" not in entry:
+                entry["primary_title"] = entry.pop("title")
+
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
+
+        if self.search_source.filename.suffix == ".ris":
+            ris_entries = colrev.ops.load_utils_ris.load_ris_entries(
+                filename=self.search_source.filename
+            )
+            self.__ris_fixes(entries=ris_entries)
+            records = colrev.ops.load_utils_ris.convert_to_records(ris_entries)
+            load_operation.review_manager.dataset.save_records_dict_to_file(
+                records=records,
+                save_path=self.search_source.get_corresponding_bib_file(),
+            )
+            return records
 
-        return records
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for JSTOR"""
 
         return record
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/local_index.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/local_index.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,14 +14,15 @@
 import git
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_bib
 import colrev.ops.search
 import colrev.record
 import colrev.ui_cli.cli_colors as colors
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
@@ -85,15 +86,14 @@
                 self.search_source = li_md_source_l[0]
             else:
                 self.search_source = colrev.settings.SearchSource(
                     endpoint="colrev.local_index",
                     filename=self.__local_index_md_filename,
                     search_type=colrev.settings.SearchType.OTHER,
                     search_parameters={},
-                    load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                     comment="",
                 )
 
             self.local_index_lock = Lock()
 
         self.origin_prefix = self.search_source.get_origin_prefix()
 
@@ -161,15 +161,15 @@
 
         return records_to_import
 
     def __run_md_search_update(
         self,
         *,
         search_operation: colrev.ops.search.Search,
-        local_index_feed: colrev.ops.search.GeneralOriginFeed,
+        local_index_feed: colrev.ops.search_feed.GeneralOriginFeed,
     ) -> None:
         records = search_operation.review_manager.dataset.load_records_dict()
 
         for feed_record_dict_id in list(local_index_feed.feed_records.keys()):
             feed_record_dict = local_index_feed.feed_records[feed_record_dict_id]
             feed_record = colrev.record.Record(data=feed_record_dict)
 
@@ -191,15 +191,15 @@
                     retrieved_record_dict["ID"]
                 ]
 
             local_index_feed.add_record(
                 record=colrev.record.Record(data=retrieved_record_dict)
             )
 
-            changed = search_operation.update_existing_record(
+            changed = local_index_feed.update_existing_record(
                 records=records,
                 record_dict=retrieved_record_dict,
                 prev_record_dict_version=prev_record_dict_version,
                 source=self.search_source,
                 update_time_variant_fields=True,
             )
             # Note : changed refers to the data/records.bib.
@@ -212,15 +212,15 @@
         search_operation.review_manager.dataset.save_records_dict(records=records)
         search_operation.review_manager.dataset.add_record_changes()
 
     def __run_parameter_search(
         self,
         *,
         search_operation: colrev.ops.search.Search,
-        local_index_feed: colrev.ops.search.GeneralOriginFeed,
+        local_index_feed: colrev.ops.search_feed.GeneralOriginFeed,
         rerun: bool,
     ) -> None:
         records = search_operation.review_manager.dataset.load_records_dict()
 
         for retrieved_record_dict in self.__retrieve_from_index():
             try:
                 local_index_feed.set_id(record_dict=retrieved_record_dict)
@@ -236,15 +236,15 @@
             added = local_index_feed.add_record(
                 record=colrev.record.Record(data=retrieved_record_dict)
             )
             if added:
                 local_index_feed.nr_added += 1
 
             else:
-                changed = search_operation.update_existing_record(
+                changed = local_index_feed.update_existing_record(
                     records=records,
                     record_dict=retrieved_record_dict,
                     prev_record_dict_version=prev_record_dict_version,
                     source=self.search_source,
                     update_time_variant_fields=rerun,
                 )
                 if changed:
@@ -297,28 +297,35 @@
             file_path_string=f"local_index_{query}".replace("%", "").replace("'", "")
         )
         add_source = colrev.settings.SearchSource(
             endpoint="colrev.local_index",
             filename=filename,
             search_type=colrev.settings.SearchType.DB,
             search_parameters={"query": query},
-            load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
             comment="",
         )
         return add_source
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for local-index"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
+
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            for record_id in records:
+                records[record_id] = {
+                    k: v
+                    for k, v in records[record_id].items()
+                    if k not in ["colrev_status", "colrev_masterdata_provenance"]
+                }
+
+            return records
 
-        return records
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for local-index"""
 
         return record
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/open_citations_forward_search.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/open_citations_forward_search.py`

 * *Files 6% similar despite different names*

```diff
@@ -63,15 +63,14 @@
         return colrev.settings.SearchSource(
             endpoint="colrev.open_citations_forward_search",
             filename=Path("data/search/forward_search.bib"),
             search_type=colrev.settings.SearchType.FORWARD_SEARCH,
             search_parameters={
                 "scope": {"colrev_status": "rev_included|rev_synthesized"}
             },
-            load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
             comment="",
         )
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
@@ -194,15 +193,15 @@
                     record=colrev.record.Record(data=new_record),
                 )
 
                 if added:
                     forward_search_feed.nr_added += 1
                 elif rerun:
                     # Note : only re-index/update
-                    changed = search_operation.update_existing_record(
+                    changed = forward_search_feed.update_existing_record(
                         records=records,
                         record_dict=new_record,
                         prev_record_dict_version=prev_record_dict_version,
                         source=self.search_source,
                         update_time_variant_fields=rerun,
                     )
                     if changed:
@@ -238,22 +237,23 @@
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for forward searches (OpenCitations)"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
+
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            return records
 
-        return records
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for forward searches (OpenCitations)"""
         return record
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/open_library.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/open_library.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 #! /usr/bin/env python
 """Connector to OpenLibrary (API)"""
 from __future__ import annotations
 
 import json
-import typing
 from dataclasses import dataclass
 from multiprocessing import Lock
 from pathlib import Path
 from typing import Optional
 from typing import TYPE_CHECKING
 
 import requests
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_bib
 import colrev.record
 
 if TYPE_CHECKING:
     import colrev.ops.prep
 
 # Note: not (yet) implemented as a full search_source
 # (including SearchSourcePackageEndpointInterface, packages_endpoints.json)
@@ -73,15 +73,14 @@
                 self.search_source = open_library_md_source_l[0]
             else:
                 self.search_source = colrev.settings.SearchSource(
                     endpoint="colrev.open_library",
                     filename=self.__open_library_md_filename,
                     search_type=colrev.settings.SearchType.OTHER,
                     search_parameters={},
-                    load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                     comment="",
                 )
 
             self.open_library_lock = Lock()
 
         self.origin_prefix = self.search_source.get_origin_prefix()
         self.review_manager = source_operation.review_manager
@@ -303,23 +302,24 @@
             colrev_exceptions.InvalidMerge,
             colrev_exceptions.NotFeedIdentifiableException,
         ):
             self.open_library_lock.release()
 
         return record
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for OpenLibrary"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
 
-        return records
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            return records
+
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for OpenLibrary"""
 
         return record
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/pdf_backward_search.md` & `colrev-0.9.2/colrev/ops/built_in/search_sources/pdf_backward_search.md`

 * *Files 26% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # SearchSource: PDF Backward Search
 
 Note: This document is currently under development. It will contain the following elements.
 
 - description
 - coverage (disciplines, types of work)
-- supported (details): search updates, get_masterdata, run_search, load_fixes, prep
+- supported (details): run_search (including updates), load,  prep (including get_masterdata)
 
 One strategy could be to start with a relatively high threshold for the number of intext citations and to iteratively decrease it, and update the search:
 colrev search -a colrev.pdf_backward_search:min_intext_citations=2
 
 Citation data is automatically consolidated with open-citations data to improve data quality.
 
 based on [GROBID](https://github.com/kermitt2/grobid)
@@ -16,8 +16,16 @@
 ## Add the search source
 
 ```
 colrev search -a colrev.pdf_backward_search:default
 colrev search -a colrev.pdf_backward_search:min_intext_citations=2
 ```
 
+## Conducting a selective backward search
+
+A selective backward search for a single paper and selected references can be conducted by running
+```
+colrev search -bws record_id
+```
+References can be selected interactively for import.
+
 ## Links
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/pdf_backward_search.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/pdf_backward_search.py`

 * *Files 8% similar despite different names*

```diff
@@ -77,15 +77,14 @@
             endpoint="colrev.pdf_backward_search",
             filename=Path("data/search/pdf_backward_search.bib"),
             search_type=colrev.settings.SearchType.BACKWARD_SEARCH,
             search_parameters={
                 "scope": {"colrev_status": "rev_included|rev_synthesized"},
                 "min_intext_citations": 3,
             },
-            load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
             comment="",
         )
 
     def validate_source(
         self,
         search_operation: colrev.ops.search.Search,
         source: colrev.settings.SearchSource,
@@ -192,15 +191,15 @@
 
         similarity = sum(similarities[g] * weights[g] for g in range(len(similarities)))
         return similarity
 
     def __complement_with_open_citations_data(
         self,
         *,
-        pdf_backward_search_feed: colrev.ops.search.GeneralOriginFeed,
+        pdf_backward_search_feed: colrev.ops.search_feed.GeneralOriginFeed,
         records: dict,
     ) -> None:
         self.review_manager.logger.info("Comparing records with open-citations data")
         for parent_record_id in {
             x["cited_by_ID"] for x in pdf_backward_search_feed.feed_records.values()
         }:
             parent_record = records[parent_record_id]
@@ -235,15 +234,15 @@
                 f" updated {updated}/{overall} records cited by {parent_record_id}"
             )
 
     def __run_backward_search_on_pdf(
         self,
         *,
         record: dict,
-        pdf_backward_search_feed: colrev.ops.search.GeneralOriginFeed,
+        pdf_backward_search_feed: colrev.ops.search_feed.GeneralOriginFeed,
         search_operation: colrev.ops.search.Search,
         records: dict,
         rerun: bool,
     ) -> None:
         # Note: IDs generated by GROBID for cited references
         # may change across grobid versions
         # -> challenge for key-handling/updating searches...
@@ -282,15 +281,15 @@
                 record=colrev.record.Record(data=new_record),
             )
 
             if added:
                 pdf_backward_search_feed.nr_added += 1
             elif rerun:
                 # Note : only re-index/update
-                changed = search_operation.update_existing_record(
+                changed = pdf_backward_search_feed.update_existing_record(
                     records=records,
                     record_dict=new_record,
                     prev_record_dict_version=prev_record_dict_version,
                     source=self.search_source,
                     update_time_variant_fields=rerun,
                 )
                 if changed:
@@ -379,23 +378,24 @@
             source.search_parameters["min_intext_citations"] = int(min_intext_citations)
             return source
 
         raise colrev_exceptions.PackageParameterError(
             f"Cannot add backward_search endpoint with query {query}"
         )
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for PDF backward searches (GROBID)"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
+
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            return records
 
-        return records
+        raise NotImplementedError
 
     def get_masterdata(
         self,
         prep_operation: colrev.ops.prep.Prep,
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/pdfs_dir.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/pdfs_dir.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,25 +3,27 @@
 from __future__ import annotations
 
 import re
 import typing
 from dataclasses import dataclass
 from pathlib import Path
 
+import requests
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 from pdfminer.pdfdocument import PDFDocument
 from pdfminer.pdfinterp import resolve1
 from pdfminer.pdfparser import PDFParser
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
 import colrev.ops.built_in.search_sources.crossref
 import colrev.ops.built_in.search_sources.pdf_backward_search as bws
+import colrev.ops.load_utils_bib
 import colrev.ops.search
 import colrev.qm.checkers.missing_field
 import colrev.qm.colrev_pdf_id
 import colrev.record
 import colrev.ui_cli.cli_colors as colors
 
 # pylint: disable=unused-argument
@@ -288,15 +290,15 @@
             return record_dict
 
         pdf_path = self.review_manager.path / Path(record_dict["file"])
         try:
             tei = self.review_manager.get_tei(
                 pdf_path=pdf_path,
             )
-        except FileNotFoundError:
+        except (FileNotFoundError, requests.exceptions.ReadTimeout):
             return record_dict
 
         for key, val in tei.get_metadata().items():
             if val:
                 record_dict[key] = str(val)
 
         self.__get_missing_fields_from_doc_info(record_dict=record_dict)
@@ -450,15 +452,15 @@
         """Not implemented"""
         return record
 
     def __index_pdf(
         self,
         *,
         pdf_path: Path,
-        pdfs_dir_feed: colrev.ops.search.GeneralOriginFeed,
+        pdfs_dir_feed: colrev.ops.search_feed.GeneralOriginFeed,
         linked_pdf_paths: list,
         local_index: colrev.env.local_index.LocalIndex,
     ) -> dict:
         new_record: dict = {}
 
         if self.__is_broken_filepath(pdf_path=pdf_path):
             return new_record
@@ -543,15 +545,15 @@
         return pdf_batches
 
     def __run_pdfs_dir_search(
         self,
         *,
         search_operation: colrev.ops.search.Search,
         records: dict,
-        pdfs_dir_feed: colrev.ops.search.GeneralOriginFeed,
+        pdfs_dir_feed: colrev.ops.search_feed.GeneralOriginFeed,
         local_index: colrev.env.local_index.LocalIndex,
         linked_pdf_paths: list,
         rerun: bool,
     ) -> None:
         for pdf_batch in self.__get_pdf_batches():
             for record in pdfs_dir_feed.feed_records.values():
                 record = self.__add_md_string(record_dict=record)
@@ -575,15 +577,15 @@
                 )
                 if added:
                     pdfs_dir_feed.nr_added += 1
                     self.__add_doi_from_pdf_if_not_available(record_dict=new_record)
 
                 elif self.review_manager.force_mode:
                     # Note : only re-index/update
-                    if search_operation.update_existing_record(
+                    if pdfs_dir_feed.update_existing_record(
                         records=records,
                         record_dict=new_record,
                         prev_record_dict_version=prev_record_dict_version,
                         source=self.search_source,
                         update_time_variant_fields=rerun,
                     ):
                         pdfs_dir_feed.nr_changed += 1
@@ -671,15 +673,14 @@
         filename = search_operation.get_unique_filename(file_path_string="pdfs")
         # pylint: disable=no-value-for-parameter
         add_source = colrev.settings.SearchSource(
             endpoint="colrev.pdfs_dir",
             filename=filename,
             search_type=colrev.settings.SearchType.PDFS,
             search_parameters={"scope": {"path": "data/pdfs"}},
-            load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
             comment="",
         )
         return add_source
 
     def __update_based_on_doi(self, *, record_dict: dict) -> None:
         if "doi" not in record_dict:
             return
@@ -707,41 +708,43 @@
                 "pages",
             ]:
                 if key in retrieved_record.data:
                     record_dict[key] = retrieved_record.data[key]
         except (colrev_exceptions.RecordNotFoundInPrepSourceException,):
             pass
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for PDF directories (GROBID)"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
 
-        missing_field_checker = colrev.qm.checkers.missing_field.MissingFieldChecker(
-            quality_model=load_operation.review_manager.get_qm()
-        )
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            missing_field_checker = (
+                colrev.qm.checkers.missing_field.MissingFieldChecker(
+                    quality_model=load_operation.review_manager.get_qm()
+                )
+            )
 
-        for record_dict in records.values():
-            if "grobid-version" in record_dict:
-                del record_dict["grobid-version"]
+            for record_dict in records.values():
+                if "grobid-version" in record_dict:
+                    del record_dict["grobid-version"]
 
-            self.__update_based_on_doi(record_dict=record_dict)
+                self.__update_based_on_doi(record_dict=record_dict)
 
-            # Rerun restrictions and __update_fields_based_on_pdf_dirs
-            # because the restrictions/subdir-pattern may change
-            record_dict = self.__update_fields_based_on_pdf_dirs(
-                record_dict=record_dict, params=self.search_source.search_parameters
-            )
-            record = colrev.record.Record(data=record_dict)
-            missing_field_checker.apply_curation_restrictions(record=record)
+                # Rerun restrictions and __update_fields_based_on_pdf_dirs
+                # because the restrictions/subdir-pattern may change
+                record_dict = self.__update_fields_based_on_pdf_dirs(
+                    record_dict=record_dict, params=self.search_source.search_parameters
+                )
+                record = colrev.record.Record(data=record_dict)
+                missing_field_checker.apply_curation_restrictions(record=record)
+            return records
 
-        return records
+        raise NotImplementedError
 
     def __fix_special_chars(self, *, record: colrev.record.Record) -> None:
         # TODO : extract to separate scripts and also apply upon loading tei content
         if "title" in record.data:
             record.data["title"] = (
                 record.data["title"]
                 .replace("n ˜", "ñ")
@@ -779,25 +782,27 @@
 
     def __fix_special_outlets(self, *, record: colrev.record.Record) -> None:
         # Erroneous suffixes in IS conferences
         if record.data.get("booktitle", "") in [
             "Americas Conference on Information Systems",
             "International Conference on Information Systems",
             "European Conference on Information Systems",
+            "Pacific Asia Conference on Information Systems",
         ]:
             for suffix in [
                 "completed research paper",
                 "completed research",
                 "complete research",
                 "full research paper",
                 "research in progress",
+                "(research in progress)",
             ]:
                 if record.data["title"].lower().endswith(suffix):
                     record.data["title"] = record.data["title"][: -len(suffix)].rstrip(
-                        " -"
+                        " -:"
                     )
         # elif ...
 
     def prepare(
         self, record: colrev.record.PrepRecord, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for PDF directories (GROBID)"""
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/psycinfo.py` & `colrev-0.9.2/colrev/template/custom_scripts/custom_search_source_script.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,119 +1,109 @@
 #! /usr/bin/env python
-"""SearchSource: PsycINFO"""
+"""Template for a custom SearchSource PackageEndpoint"""
 from __future__ import annotations
 
-import typing
-from dataclasses import dataclass
 from pathlib import Path
+from typing import TYPE_CHECKING
 
 import zope.interface
 from dacite import from_dict
-from dataclasses_jsonschema import JsonSchemaMixin
 
-import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
-import colrev.ops.search
-import colrev.record
+import colrev.operation
 
-# pylint: disable=unused-argument
-# pylint: disable=duplicate-code
+if TYPE_CHECKING:
+    import colrev.ops.search.Search
 
 
 @zope.interface.implementer(
     colrev.env.package_manager.SearchSourcePackageEndpointInterface
 )
-@dataclass
-class PsycINFOSearchSource(JsonSchemaMixin):
-    """SearchSource for PsycINFO"""
-
-    settings_class = colrev.env.package_manager.DefaultSourceSettings
-    source_identifier = "url"
-    search_type = colrev.settings.SearchType.DB
-    api_search_supported = False
-    ci_supported: bool = False
-    heuristic_status = colrev.env.package_manager.SearchSourceHeuristicStatus.oni
-    short_name = "PsycInfo (APA)"
-    link = (
-        "https://github.com/CoLRev-Environment/colrev/blob/main/"
-        + "colrev/ops/built_in/search_sources/psycinfo.md"
-    )
+class CustomSearch:
+    """Class for custom search scripts"""
+
+    settings_class = colrev.env.package_manager.DefaultSettings
+    source_identifier = "custom"
 
     def __init__(
-        self, *, source_operation: colrev.operation.Operation, settings: dict
+        self,
+        *,
+        source_operation: colrev.ops.search.Search,  # pylint: disable=unused-argument
+        settings: dict,
     ) -> None:
-        self.search_source = from_dict(data_class=self.settings_class, data=settings)
+        self.settings = from_dict(data_class=self.settings_class, data=settings)
 
-    def validate_source(
+    def run_search(
         self,
         search_operation: colrev.ops.search.Search,
-        source: colrev.settings.SearchSource,
+        params: dict,  # pylint: disable=unused-argument
+        feed_file: Path,
     ) -> None:
-        """Validate the SearchSource (parameters etc.)"""
+        """Run the search"""
+
+        max_id = 1
+        if not feed_file.is_file():
+            records = {}
+        else:
+            with open(feed_file, encoding="utf8") as bibtex_file:
+                records = search_operation.review_manager.dataset.load_records_dict(
+                    load_str=bibtex_file.read()
+                )
+
+            max_id = (
+                max([int(x["ID"]) for x in records.values() if x["ID"].isdigit()] + [1])
+                + 1
+            )
 
-        search_operation.review_manager.logger.debug(
-            f"Validate SearchSource {source.filename}"
+        # Add new records to the dictionary:
+        records[max_id] = {
+            "ID": max_id,
+            "ENTRYTYPE": "article",
+            "author": "Smith, M.",
+            "title": "Editorial",
+            "journal": "nature",
+            "year": "2020",
+        }
+
+        feed_file.parents[0].mkdir(parents=True, exist_ok=True)
+        search_operation.review_manager.dataset.save_records_dict_to_file(
+            records=records, save_path=feed_file
         )
 
-        if "query_file" not in source.search_parameters:
+    @classmethod
+    def validate_search_params(cls, query: str) -> None:
+        """Validate the search parameters"""
+
+        if " SCOPE " not in query:
             raise colrev_exceptions.InvalidQueryException(
-                f"Source missing query_file search_parameter ({source.filename})"
+                "CROSSREF queries require a SCOPE section"
             )
 
-        if not Path(source.search_parameters["query_file"]).is_file():
+        scope = query[query.find(" SCOPE ") :]
+        if "journal_issn" not in scope:
             raise colrev_exceptions.InvalidQueryException(
-                f"File does not exist: query_file {source.search_parameters['query_file']} "
-                f"for ({source.filename})"
+                "CROSSREF queries require a journal_issn field in the SCOPE section"
             )
 
-        search_operation.review_manager.logger.debug(
-            f"SearchSource {source.filename} validated"
-        )
-
-    @classmethod
-    def heuristic(cls, filename: Path, data: str) -> dict:
-        """Source heuristic for PsycINFO"""
-
-        result = {"confidence": 0.1}
+    def heuristic(
+        self, filename: Path, data: str  # pylint: disable=unused-argument
+    ) -> dict:
+        """Heuristic to identify the custom source"""
 
-        # Note : no features in bib file for identification
+        result = {"confidence": 0}
 
         return result
 
-    @classmethod
-    def add_endpoint(
-        cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> colrev.settings.SearchSource:
-        """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        raise NotImplementedError
-
-    def run_search(
-        self, search_operation: colrev.ops.search.Search, rerun: bool
-    ) -> None:
-        """Run a search of Psycinfo"""
-
-    def get_masterdata(
-        self,
-        prep_operation: colrev.ops.prep.Prep,
-        record: colrev.record.Record,
-        save_feed: bool = True,
-        timeout: int = 10,
-    ) -> colrev.record.Record:
-        """Not implemented"""
-        return record
-
     def load_fixes(
         self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
+        load_operation: colrev.ops.load.Load,  # pylint: disable=unused-argument
+        source: colrev.settings.SearchSource,  # pylint: disable=unused-argument
+        records: dict,
     ) -> dict:
-        """Load fixes for PsycINFO"""
+        """Load fixes for the custom source"""
 
         return records
 
-    def prepare(
-        self, record: colrev.record.Record, source: colrev.settings.SearchSource
-    ) -> colrev.record.Record:
-        """Source-specific preparation for PsycINFO"""
+    def prepare(self, record: colrev.record.Record) -> colrev.record.Record:
+        """Source-specific preparation for the custom source"""
 
         return record
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/pubmed.md` & `colrev-0.9.2/colrev/ops/built_in/search_sources/pubmed.md`

 * *Files 20% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # SearchSource: Pubmed
 
 Note: This document is currently under development. It will contain the following elements.
 
 - description
 - coverage (disciplines, types of work)
-- supported (details): search updates, get_masterdata, run_search, load_fixes, prep
+- supported (details): run_search (including updates), load,  prep (including get_masterdata)
 
 [Pubmed](https://pubmed.ncbi.nlm.nih.gov/)
 
 ## Add the search source
 
 To add a pubmed API search, enter the query in the [Pubmed web interface](https://pubmed.ncbi.nlm.nih.gov/), run the search, copy the url and run:
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/pubmed.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/pubmed.py`

 * *Files 0% similar despite different names*

```diff
@@ -18,14 +18,15 @@
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 from defusedxml.lxml import fromstring
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_table
 import colrev.ops.search
 import colrev.record
 
 defusedxml.defuse_stdlib()
 
 
 # pylint: disable=unused-argument
@@ -74,15 +75,14 @@
                 self.search_source = pubmed_md_source_l[0]
             else:
                 self.search_source = colrev.settings.SearchSource(
                     endpoint="colrev.pubmed",
                     filename=self.__pubmed_md_filename,
                     search_type=colrev.settings.SearchType.OTHER,
                     search_parameters={},
-                    load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                     comment="",
                 )
 
             self.pubmed_lock = Lock()
 
         self.review_manager = source_operation.review_manager
         self.quality_model = self.review_manager.get_qm()
@@ -127,15 +127,14 @@
                 + query
             )
             add_source = colrev.settings.SearchSource(
                 endpoint="colrev.pubmed",
                 filename=filename,
                 search_type=colrev.settings.SearchType.DB,
                 search_parameters={"query": query},
-                load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
                 comment="",
             )
             return add_source
 
         raise NotImplementedError
 
     def validate_source(
@@ -280,14 +279,19 @@
                 retrieved_record_dict.update(doi=article_id.text.upper())
             else:
                 retrieved_record_dict[id_type] = article_id.text
 
         retrieved_record_dict = {
             k: v for k, v in retrieved_record_dict.items() if v != ""
         }
+        if (
+            retrieved_record_dict.get("pii", "pii").lower()
+            == retrieved_record_dict.get("doi", "doi").lower()
+        ):
+            del retrieved_record_dict["pii"]
 
         return retrieved_record_dict
 
     def __get_pubmed_ids(self, query: str, retstart: int) -> typing.List[str]:
         headers = {"user-agent": f"{__name__} (mailto:{self.email})"}
         session = self.review_manager.get_cached_session()
 
@@ -485,15 +489,15 @@
 
             retstart += 20
 
     def __run_parameter_search(
         self,
         *,
         search_operation: colrev.ops.search.Search,
-        pubmed_feed: colrev.ops.search.GeneralOriginFeed,
+        pubmed_feed: colrev.ops.search_feed.GeneralOriginFeed,
         rerun: bool,
     ) -> None:
         if rerun:
             search_operation.review_manager.logger.info(
                 "Performing a search of the full history (may take time)"
             )
 
@@ -528,15 +532,15 @@
 
                 if added:
                     search_operation.review_manager.logger.info(
                         " retrieve pubmed-id=" + prep_record.data["pubmedid"]
                     )
                     pubmed_feed.nr_added += 1
                 else:
-                    changed = search_operation.update_existing_record(
+                    changed = pubmed_feed.update_existing_record(
                         records=records,
                         record_dict=prep_record.data,
                         prev_record_dict_version=prev_record_dict_version,
                         source=self.search_source,
                         update_time_variant_fields=rerun,
                     )
                     if changed:
@@ -564,15 +568,15 @@
                 f"Crossref (check https://status.crossref.org/) ({exc})"
             )
 
     def __run_md_search_update(
         self,
         *,
         search_operation: colrev.ops.search.Search,
-        pubmed_feed: colrev.ops.search.GeneralOriginFeed,
+        pubmed_feed: colrev.ops.search_feed.GeneralOriginFeed,
     ) -> None:
         records = search_operation.review_manager.dataset.load_records_dict()
 
         for feed_record_dict in pubmed_feed.feed_records.values():
             feed_record = colrev.record.Record(data=feed_record_dict)
 
             try:
@@ -594,15 +598,15 @@
             if retrieved_record["ID"] in pubmed_feed.feed_records:
                 prev_record_dict_version = pubmed_feed.feed_records[
                     retrieved_record["ID"]
                 ]
 
             pubmed_feed.add_record(record=colrev.record.Record(data=retrieved_record))
 
-            changed = search_operation.update_existing_record(
+            changed = pubmed_feed.update_existing_record(
                 records=records,
                 record_dict=retrieved_record,
                 prev_record_dict_version=prev_record_dict_version,
                 source=self.search_source,
                 update_time_variant_fields=True,
             )
             if changed:
@@ -633,20 +637,37 @@
         else:
             self.__run_parameter_search(
                 search_operation=search_operation,
                 pubmed_feed=pubmed_feed,
                 rerun=rerun,
             )
 
-    def load_fixes(
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
+
+        if self.search_source.filename.suffix == ".csv":
+            csv_loader = colrev.ops.load_utils_table.CSVLoader(
+                load_operation=load_operation, settings=self.search_source
+            )
+            records = csv_loader.load()
+            self.__load_fixes(records=records)
+            load_operation.review_manager.dataset.save_records_dict_to_file(
+                records=records,
+                save_path=self.search_source.get_corresponding_bib_file(),
+            )
+            return records
+
+        raise NotImplementedError
+
+    # TODO : csv: parse volume/number/pages from citation field
+
+    def __load_fixes(
         self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
         records: typing.Dict,
-    ) -> dict:
+    ) -> None:
         """Load fixes for Pubmed"""
 
         for record in records.values():
             if "author" in record and record["author"].count(",") >= 1:
                 author_list = record["author"].split(", ")
                 for i, author_part in enumerate(author_list):
                     author_field_parts = author_part.split(" ")
@@ -661,16 +682,16 @@
                 del record["citation"]
             if "create_date" in record:
                 del record["create_date"]
             if record.get("journal", "") != "":
                 record["ENTRYTYPE"] = "article"
             if record.get("pii", "pii").lower() == record.get("doi", "doi").lower():
                 del record["pii"]
-
-        return records
+            if record.get("nihms_id", "") == "nan":
+                del record["nihms_id"]
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for Pubmed"""
 
         if "first_author" in record.data:
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/scopus.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/scopus.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 #! /usr/bin/env python
 """SearchSource: Scopus"""
 from __future__ import annotations
 
-import typing
 from dataclasses import dataclass
 from pathlib import Path
 
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_bib
 import colrev.ops.search
 import colrev.record
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 
@@ -103,23 +103,24 @@
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for Scopus"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
 
-        return records
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            return records
+
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for Scopus"""
 
         if "book" == record.data["ENTRYTYPE"]:
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/springer_link.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/springer_link.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_table
 import colrev.ops.search
 import colrev.record
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 # Note : API requires registration
@@ -77,15 +78,15 @@
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
         """Source heuristic for Springer Link"""
 
         result = {"confidence": 0.0}
 
         if filename.suffix == ".csv":
-            if data.count("http://link.springer.com") == data.count("\n"):
+            if data.count("http://link.springer.com") > data.count("\n") - 2:
                 result["confidence"] = 1.0
                 return result
 
         # Note : no features in bib file for identification
 
         return result
 
@@ -107,29 +108,47 @@
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
-    def load_fixes(
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
+
+        if self.search_source.filename.suffix == ".csv":
+            csv_loader = colrev.ops.load_utils_table.CSVLoader(
+                load_operation=load_operation, settings=self.search_source
+            )
+            records = csv_loader.load()
+            self.__load_fixes(records=records)
+            load_operation.review_manager.dataset.save_records_dict_to_file(
+                records=records,
+                save_path=self.search_source.get_corresponding_bib_file(),
+            )
+            return records
+
+        raise NotImplementedError
+
+    def __load_fixes(
         self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
         records: typing.Dict,
-    ) -> dict:
+    ) -> None:
         """Load fixes for Springer Link"""
 
         # pylint: disable=too-many-branches
 
         for record_dict in records.values():
             if "item_title" in record_dict:
                 record_dict["title"] = record_dict["item_title"]
                 del record_dict["item_title"]
 
+            if record_dict.get("book_series_title", "") == "nan":
+                del record_dict["book_series_title"]
+
             if "content_type" in record_dict:
                 record = colrev.record.Record(data=record_dict)
                 if record_dict["content_type"] == "Article":
                     if "publication_title" in record_dict:
                         record_dict["journal"] = record_dict["publication_title"]
                         del record_dict["publication_title"]
                     record.change_entrytype(
@@ -168,15 +187,13 @@
                 # a-bd-z: do not match McDonald
                 record_dict["author"] = re.sub(
                     r"([a-bd-z]{1})([A-Z]{1})",
                     r"\g<1> and \g<2>",
                     record_dict["author"],
                 )
 
-        return records
-
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for Springer Link"""
 
         return record
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/systematic_review_datasets.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/psycinfo.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,156 +1,169 @@
 #! /usr/bin/env python
-"""SearchSource: systematic-review-datasets"""
+"""SearchSource: PsycINFO"""
 from __future__ import annotations
 
-import typing
+import re
+from copy import deepcopy
 from dataclasses import dataclass
 from pathlib import Path
 
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
+from rispy import BaseParser
+from rispy.config import LIST_TYPE_TAGS
+from rispy.config import TAG_KEY_MAPPING
 
 import colrev.env.package_manager
-import colrev.ops.built_in.search_sources.crossref
+import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_ris
 import colrev.ops.search
 import colrev.record
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 
+class PsycInfoRISParser(BaseParser):
+    """Parser for Psycinfo RIS files."""
+
+    START_TAG = "TY"
+    IGNORE = ["FN", "VR", "EF"]
+    PATTERN = r"^[A-Z][A-Z0-9]+ |^ER\s?|^EF\s?"
+    mapping = deepcopy(TAG_KEY_MAPPING)
+    # mapping["A1"] = "authors"
+    mapping["PM"] = "pubmedid"
+    # mapping["T1"] = "primary_title"
+    # mapping["JF"] = "secondary_title"
+    DEFAULT_MAPPING = mapping
+    DEFAULT_LIST_TAGS = LIST_TYPE_TAGS
+
+    def get_content(self, line: str) -> str:
+        "Get the content from a line."
+        return line[line.find(" - ") + 2 :].strip()
+
+    def is_header(self, line: str) -> bool:
+        "Check whether the line is a header element"
+        return not re.match("[A-Z0-9]+  - ", line)
+
+
 @zope.interface.implementer(
     colrev.env.package_manager.SearchSourcePackageEndpointInterface
 )
 @dataclass
-class SystematicReviewDatasetsSearchSource(JsonSchemaMixin):
-    """SearchSource for systematic-review-datasets
-
-    https://github.com/asreview/systematic-review-datasets
-
-    csv files available in the releases (output directories) are supported:
-    https://github.com/asreview/systematic-review-datasets/tags
-
-    csv files containing article IDs are supported by source-specific preparation.
-    metadata is added based on dois and pubmedid (openalex is not yet supported)
-
-    """
+class PsycINFOSearchSource(JsonSchemaMixin):
+    """SearchSource for PsycINFO"""
 
     settings_class = colrev.env.package_manager.DefaultSourceSettings
-    source_identifier = "{{ID}}"
+    source_identifier = "url"
     search_type = colrev.settings.SearchType.DB
     api_search_supported = False
     ci_supported: bool = False
-    heuristic_status = colrev.env.package_manager.SearchSourceHeuristicStatus.supported
-    short_name = "systematic-review-datasets"
+    heuristic_status = colrev.env.package_manager.SearchSourceHeuristicStatus.oni
+    short_name = "PsycInfo (APA)"
     link = (
         "https://github.com/CoLRev-Environment/colrev/blob/main/"
-        + "colrev/ops/built_in/search_sources/systematic_review_datasets.md"
+        + "colrev/ops/built_in/search_sources/psycinfo.md"
     )
 
     def __init__(
         self, *, source_operation: colrev.operation.Operation, settings: dict
     ) -> None:
         self.search_source = from_dict(data_class=self.settings_class, data=settings)
-        self.crossref_connector = (
-            colrev.ops.built_in.search_sources.crossref.CrossrefSearchSource(
-                source_operation=source_operation
-            )
+
+    def validate_source(
+        self,
+        search_operation: colrev.ops.search.Search,
+        source: colrev.settings.SearchSource,
+    ) -> None:
+        """Validate the SearchSource (parameters etc.)"""
+
+        search_operation.review_manager.logger.debug(
+            f"Validate SearchSource {source.filename}"
         )
-        self.__etiquette = self.crossref_connector.get_etiquette(
-            review_manager=source_operation.review_manager
+
+        if "query_file" not in source.search_parameters:
+            raise colrev_exceptions.InvalidQueryException(
+                f"Source missing query_file search_parameter ({source.filename})"
+            )
+
+        if not Path(source.search_parameters["query_file"]).is_file():
+            raise colrev_exceptions.InvalidQueryException(
+                f"File does not exist: query_file {source.search_parameters['query_file']} "
+                f"for ({source.filename})"
+            )
+
+        search_operation.review_manager.logger.debug(
+            f"SearchSource {source.filename} validated"
         )
-        self.quality_model = source_operation.review_manager.get_qm()
 
     @classmethod
     def heuristic(cls, filename: Path, data: str) -> dict:
-        """Source heuristic for systematic-review-datasets"""
+        """Source heuristic for PsycINFO"""
 
-        result = {"confidence": 0.0}
+        result = {"confidence": 0.1}
 
-        if "doi,pmid,openalex_id,label_included" in data:
-            result["confidence"] = 1.0
+        # Note : no features in bib file for identification
 
-        if '"doi","pmid","openalex_id","label_included"' in data:
-            result["confidence"] = 1.0
-
-        if (
-            "record_id,pubmedID,title,authors,abstract,year,label_included,label_abstract_screening"
-            in data
+        if data.startswith(
+            "Provider: American Psychological Association\nDatabase: PsycINFO"
         ):
             result["confidence"] = 1.0
 
         return result
 
     @classmethod
     def add_endpoint(
         cls, search_operation: colrev.ops.search.Search, query: str
     ) -> colrev.settings.SearchSource:
         """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
         raise NotImplementedError
 
-    def validate_source(
-        self,
-        search_operation: colrev.ops.search.Search,
-        source: colrev.settings.SearchSource,
-    ) -> None:
-        """Validate the SearchSource (parameters etc.)"""
-
     def run_search(
         self, search_operation: colrev.ops.search.Search, rerun: bool
     ) -> None:
-        """Run a search of SystematicReviewDatasets"""
+        """Run a search of Psycinfo"""
 
     def get_masterdata(
         self,
         prep_operation: colrev.ops.prep.Prep,
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for systematic-review-datasets"""
-
-        for record in records.values():
-            if "pmid" in record:
-                record["pubmedid"] = record["pmid"].replace(
-                    "https://pubmed.ncbi.nlm.nih.gov/", ""
-                )
-                del record["pmid"]
+    def __ris_fixes(self, *, entries: dict) -> None:
+        for entry in entries:
+            if "alternate_title3" in entry and entry["type_of_reference"] in ["JOUR"]:
+                entry["secondary_title"] = entry.pop("alternate_title3")
+            if "publication_year" in entry:
+                entry["year"] = entry.pop("publication_year")
+            if "first_authors" in entry and "authors" not in entry:
+                entry["authors"] = entry.pop("first_authors")
+
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
+
+        if self.search_source.filename.suffix == ".ris":
+            ris_entries = colrev.ops.load_utils_ris.load_ris_entries(
+                filename=self.search_source.filename, ris_parser=PsycInfoRISParser
+            )
+            self.__ris_fixes(entries=ris_entries)
+            records = colrev.ops.load_utils_ris.convert_to_records(ris_entries)
+
+            load_operation.review_manager.dataset.save_records_dict_to_file(
+                records=records,
+                save_path=self.search_source.get_corresponding_bib_file(),
+            )
+            return records
 
-        return records
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
-        """Source-specific preparation for systematic-review-datasets"""
-
-        if "doi" in record.data:
-            retrieved_record = self.crossref_connector.query_doi(
-                doi=record.data["doi"], etiquette=self.__etiquette
-            )
-            record.change_entrytype(
-                new_entrytype=retrieved_record.data["ENTRYTYPE"], qm=self.quality_model
-            )
-            for key in [
-                "journal",
-                "booktitle",
-                "volume",
-                "number",
-                "year",
-                "pages",
-                "author",
-                "title",
-            ]:
-                if key in retrieved_record.data:
-                    record.data[key] = retrieved_record.data[key]
+        """Source-specific preparation for PsycINFO"""
 
         return record
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/taylor_and_francis.py` & `colrev-0.9.2/colrev/qm/checkers/inconsistent_with_doi_metadata.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,110 +1,85 @@
 #! /usr/bin/env python
-"""SearchSource: Taylor and Francis"""
+"""Checker for inconsistent-with-doi-metadata."""
 from __future__ import annotations
 
-import re
-import typing
-from dataclasses import dataclass
-from pathlib import Path
-
-import zope.interface
-from dacite import from_dict
-from dataclasses_jsonschema import JsonSchemaMixin
-
-import colrev.env.package_manager
-import colrev.ops.search
-import colrev.record
-
-# pylint: disable=unused-argument
-# pylint: disable=duplicate-code
-
-
-@zope.interface.implementer(
-    colrev.env.package_manager.SearchSourcePackageEndpointInterface
-)
-@dataclass
-class TaylorAndFrancisSearchSource(JsonSchemaMixin):
-    """SearchSource for Taylor and Francis"""
-
-    settings_class = colrev.env.package_manager.DefaultSourceSettings
-    source_identifier = "{{doi}}"
-    search_type = colrev.settings.SearchType.DB
-    api_search_supported = False
-    ci_supported: bool = False
-    heuristic_status = colrev.env.package_manager.SearchSourceHeuristicStatus.supported
-    short_name = "Taylor and Francis"
-    link = (
-        "https://github.com/CoLRev-Environment/colrev/blob/main/"
-        + "colrev/ops/built_in/search_sources/taylor_and_francis.md"
-    )
-
-    def __init__(
-        self, *, source_operation: colrev.operation.Operation, settings: dict
-    ) -> None:
-        self.search_source = from_dict(data_class=self.settings_class, data=settings)
-
-    @classmethod
-    def heuristic(cls, filename: Path, data: str) -> dict:
-        """Source heuristic for Taylor and Francis"""
-
-        result = {"confidence": 0.0}
-
-        if data.count("\n@") > 1:
-            if data.count("eprint = { \n    \n    ") >= data.count("\n@"):
-                result["confidence"] = 1.0
-
-        return result
-
-    @classmethod
-    def add_endpoint(
-        cls, search_operation: colrev.ops.search.Search, query: str
-    ) -> colrev.settings.SearchSource:
-        """Add SearchSource as an endpoint (based on query provided to colrev search -a )"""
-        raise NotImplementedError
-
-    def validate_source(
-        self,
-        search_operation: colrev.ops.search.Search,
-        source: colrev.settings.SearchSource,
-    ) -> None:
-        """Validate the SearchSource (parameters etc.)"""
-
-    def run_search(
-        self, search_operation: colrev.ops.search.Search, rerun: bool
-    ) -> None:
-        """Run a search of TaylorAndFrancis"""
-
-    def get_masterdata(
-        self,
-        prep_operation: colrev.ops.prep.Prep,
-        record: colrev.record.Record,
-        save_feed: bool = True,
-        timeout: int = 10,
-    ) -> colrev.record.Record:
-        """Not implemented"""
-        return record
-
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for Taylor and Francis"""
-
-        return records
-
-    def prepare(
-        self, record: colrev.record.Record, source: colrev.settings.SearchSource
-    ) -> colrev.record.Record:
-        """Source-specific preparation for Taylor and Francis"""
-
-        # remove eprint and URL fields (they only have dois...)
-        record.remove_field(key="url")
-        record.remove_field(key="eprint")
-        if "note" in record.data and re.match(r"PMID: \d*", record.data["note"]):
-            record.rename_field(key="note", new_key="pmid")
-            record.data["pmid"] = record.data["pmid"][6:]
-        record.remove_field(key="publisher")
+import requests.exceptions
+from thefuzz import fuzz
 
-        return record
+import colrev.exceptions as colrev_exceptions
+import colrev.ops.built_in.search_sources.crossref as crossref_connector
+import colrev.qm.quality_model
+
+# pylint: disable=too-few-public-methods
+
+
+class InconsistentWithDOIMetadataChecker:
+    """The InconsistentWithDOIMetadataChecker"""
+
+    msg = "inconsistent-with-doi-metadata"
+    __fields_to_check = ["author", "title", "journal", "year", "volume", "number"]
+
+    def __init__(self, quality_model: colrev.qm.quality_model.QualityModel) -> None:
+        self.quality_model = quality_model
+        self.__etiquette = crossref_connector.CrossrefSearchSource.get_etiquette(
+            review_manager=quality_model.review_manager
+        )
+
+    def run(self, *, record: colrev.record.Record) -> None:
+        """Run the inconsistent-with-doi-metadata checks"""
+
+        if "doi" not in record.data:
+            return
+        if "doi" in record.data.get("colrev_data_provenance", {}):
+            if (
+                "md_curated.bib"
+                in record.data["colrev_data_provenance"]["doi"]["source"]
+            ):
+                return
+
+        if self.__doi_metadata_conflicts(record=record):
+            record.add_masterdata_provenance_note(key="doi", note=self.msg)
+        else:
+            record.remove_masterdata_provenance_note(key="doi", note=self.msg)
+
+    def __doi_metadata_conflicts(self, *, record: colrev.record.Record) -> bool:
+        record_copy = record.copy_prep_rec()
+
+        try:
+            crossref_md = crossref_connector.CrossrefSearchSource.query_doi(
+                doi=record_copy.data["doi"], etiquette=self.__etiquette
+            )
+
+            for key, value in crossref_md.data.items():
+                if key not in self.__fields_to_check:
+                    continue
+                if not isinstance(value, str):
+                    continue
+                if key not in record.data:
+                    continue
+                if record.data[key] == "UNKNOWN":
+                    continue
+                if key not in ["author", "title", "journal"]:
+                    continue
+                if len(crossref_md.data[key]) < 5 or len(record.data[key]) < 5:
+                    continue
+                if (
+                    fuzz.partial_ratio(
+                        record.data[key].lower(), crossref_md.data[key].lower()
+                    )
+                    < 60
+                ):
+                    return True
+
+        except (
+            colrev_exceptions.RecordNotFoundInPrepSourceException,
+            colrev_exceptions.RecordNotParsableException,
+            requests.exceptions.ConnectionError,
+            requests.exceptions.ReadTimeout,
+        ):
+            return False
+        return False
+
+
+def register(quality_model: colrev.qm.quality_model.QualityModel) -> None:
+    """Register the checker"""
+    quality_model.register_checker(InconsistentWithDOIMetadataChecker(quality_model))
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/trid.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/trid.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 #! /usr/bin/env python
 """SearchSource: Transport Research International Documentation"""
 from __future__ import annotations
 
-import typing
 from dataclasses import dataclass
 from pathlib import Path
 
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_ris
 import colrev.ops.search
 import colrev.record
 
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
@@ -99,23 +99,40 @@
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for Transport Research International Documentation"""
+    def __ris_fixes(self, *, entries: dict) -> None:
+        for entry in entries:
+            if "title" in entry and "primary_title" not in entry:
+                entry["primary_title"] = entry.pop("title")
+            if entry["type_of_reference"] in ["JOUR"]:
+                if "journal_name" in entry:
+                    entry["secondary_title"] = entry.pop("journal_name")
+            if "publication_year" in entry:
+                entry["year"] = entry.pop("publication_year")
+
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
+
+        if self.search_source.filename.suffix == ".ris":
+            ris_entries = colrev.ops.load_utils_ris.load_ris_entries(
+                filename=self.search_source.filename
+            )
+            self.__ris_fixes(entries=ris_entries)
+            records = colrev.ops.load_utils_ris.convert_to_records(ris_entries)
+            load_operation.review_manager.dataset.save_records_dict_to_file(
+                records=records,
+                save_path=self.search_source.get_corresponding_bib_file(),
+            )
+            return records
 
-        return records
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for Transport Research International Documentation"""
 
         return record
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/unknown_source.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/unknown_source.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,30 +1,31 @@
 #! /usr/bin/env python
 """SearchSource: Unknown source (default for all other sources)"""
 from __future__ import annotations
 
 import re
-import typing
 from dataclasses import dataclass
 from enum import Enum
 from pathlib import Path
 
 import dacite
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 from thefuzz import fuzz
 
 import colrev.env.language_service
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_bib
+import colrev.ops.load_utils_md
+import colrev.ops.load_utils_ris
 import colrev.ops.search
 import colrev.record
 
-
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 
 @zope.interface.implementer(
     colrev.env.package_manager.SearchSourcePackageEndpointInterface
 )
@@ -108,26 +109,78 @@
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for unknown sources"""
+    def __ris_fixes(self, *, entries: dict) -> None:
+        for entry in entries:
+            if "title" in entry and "primary_title" not in entry:
+                entry["primary_title"] = entry.pop("title")
+
+            if "publication_year" in entry and "year" not in entry:
+                entry["year"] = entry.pop("publication_year")
+
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
+        if self.search_source.filename.suffix == ".ris":
+            colrev.ops.load_utils_ris.apply_ris_fixes(
+                filename=self.search_source.filename
+            )
+            ris_entries = colrev.ops.load_utils_ris.load_ris_entries(
+                filename=self.search_source.filename
+            )
+            self.__ris_fixes(entries=ris_entries)
+            records = colrev.ops.load_utils_ris.convert_to_records(ris_entries)
+            return records
 
-        return records
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            return records
+
+        if self.search_source.filename.suffix == ".csv":
+            csv_loader = colrev.ops.load_utils_table.CSVLoader(
+                load_operation=load_operation, settings=self.search_source
+            )
+            records = csv_loader.load()
+            load_operation.review_manager.dataset.save_records_dict_to_file(
+                records=records,
+                save_path=self.search_source.get_corresponding_bib_file(),
+            )
+            return records
+
+        if self.search_source.filename.suffix in [".xls", ".xlsx"]:
+            excel_loader = colrev.ops.load_utils_table.ExcelLoader(
+                load_operation=load_operation, source=self.search_source
+            )
+            records = excel_loader.load()
+            load_operation.review_manager.dataset.save_records_dict_to_file(
+                records=records,
+                save_path=self.search_source.get_corresponding_bib_file(),
+            )
+            return records
+
+        if self.search_source.filename.suffix == ".md":
+            md_loader = colrev.ops.load_utils_md.MarkdownLoader(
+                load_operation=load_operation, source=self.search_source
+            )
+            records = md_loader.load()
+            load_operation.review_manager.dataset.save_records_dict_to_file(
+                records=records,
+                save_path=self.search_source.get_corresponding_bib_file(),
+            )
+            return records
+
+        raise NotImplementedError
 
     def __heuristically_fix_entrytypes(
-        self, *, record: colrev.record.PrepRecord, source_identifier: str
+        self, *, record: colrev.record.PrepRecord
     ) -> None:
         """Prepare the record by heuristically correcting erroneous ENTRYTYPEs"""
 
         # Journal articles should not have booktitles/series set.
         if record.data["ENTRYTYPE"] == "article":
             if "booktitle" in record.data and "journal" not in record.data:
                 record.update_field(
@@ -140,15 +193,15 @@
                 record.update_field(
                     key="journal",
                     value=record.data["series"],
                     source="unkown_source_prep",
                 )
                 record.remove_field(key="series")
 
-        if source_identifier == "colrev.md_to_bib":
+        if self.search_source.filename.suffix == ".md":
             if record.data["ENTRYTYPE"] == "misc" and "publisher" in record.data:
                 record.update_field(
                     key="ENTRYTYPE", value="book", source="unkown_source_prep"
                 )
             if record.data.get("year", "year") == record.data.get("date", "date"):
                 record.remove_field(key="date")
             if (
@@ -242,17 +295,17 @@
                 source="unkown_source_prep",
                 keep_source_if_equal=True,
             )
 
     def __format_fields(self, *, record: colrev.record.PrepRecord) -> None:
         """Format fields"""
 
-        if record.data.get("entrytype", "") == "inproceedings":
+        if record.data.get("ENTRYTYPE", "") == "inproceedings":
             self.__format_inproceedings(record=record)
-        elif record.data.get("entrytype", "") == "article":
+        elif record.data.get("ENTRYTYPE", "") == "article":
             self.__format_article(record=record)
 
         if record.data.get("author", "UNKNOWN") != "UNKNOWN":
             # fix name format
             if (1 == len(record.data["author"].split(" ")[0])) or (
                 ", " not in record.data["author"]
             ):
@@ -359,15 +412,14 @@
         """Source-specific preparation for unknown sources"""
 
         if not record.has_quality_defects() or record.masterdata_is_curated():
             return record
 
         self.__heuristically_fix_entrytypes(
             record=record,
-            source_identifier=source.load_conversion_package_endpoint["endpoint"],
         )
 
         self.__impute_missing_fields(record=record)
 
         self.__format_fields(record=record)
 
         self.__remove_redundant_fields(record=record)
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/utils.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/utils.py`

 * *Files 2% similar despite different names*

```diff
@@ -62,15 +62,18 @@
     # Note: the format differst between crossref and doi.org
 
     if isinstance(item["title"], list):
         item["title"] = str(item["title"][0])
     assert isinstance(item["title"], str)
 
     if isinstance(item.get("container-title", ""), list):
-        item["container-title"] = item["container-title"][0]
+        if len(item["container-title"]) > 0:
+            item["container-title"] = item["container-title"][0]
+        else:
+            item["container-title"] = ""
     assert isinstance(item.get("container-title", ""), str)
 
     item["ENTRYTYPE"] = "misc"
     if item.get("type", "NA") == "journal-article":
         item.update(ENTRYTYPE="article")
         item.update(journal=item.get("container-title", ""))
     elif item.get("type", "NA") == "proceedings-article":
@@ -115,15 +118,15 @@
         value = html.unescape(value)
         value = re.sub(TAG_RE, " ", value)
         value = value.replace("\n", " ")
         value = re.sub(r"\s+", " ", value).rstrip().lstrip("▪ ")
         if key == "abstract":
             if value.startswith("Abstract "):
                 value = value[8:]
-        record_dict[key] = value
+        record_dict[key] = value.lstrip().rstrip()
 
     return record_dict
 
 
 def __set_forthcoming(*, record_dict: dict) -> dict:
     if not any(x in record_dict for x in ["published-print", "published"]) or not any(
         x in record_dict for x in ["volume", "number"]
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/video_dir.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/video_dir.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 #! /usr/bin/env python
 """SearchSource: directory containing video files"""
 from __future__ import annotations
 
-import typing
 from dataclasses import dataclass
 from multiprocessing import Lock
 from pathlib import Path
 
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
 import colrev.ops.built_in.search_sources.website as website_connector
+import colrev.ops.load_utils_bib
 import colrev.ops.search
 import colrev.record
 import colrev.ui_cli.cli_colors as colors
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
@@ -152,23 +152,24 @@
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for video directories"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
 
-        return records
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            return records
+
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.Record, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for video directories"""
 
         if "url" in record.data:
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/web_of_science.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/web_of_science.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 #! /usr/bin/env python
 """SearchSource: Web of Science"""
 from __future__ import annotations
 
-import typing
 from dataclasses import dataclass
 from pathlib import Path
 
 import zope.interface
 from dacite import from_dict
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
+import colrev.ops.load_utils_bib
 import colrev.ops.search
 import colrev.record
 
 # pylint: disable=unused-argument
 # pylint: disable=duplicate-code
 
 
@@ -49,17 +49,14 @@
     def heuristic(cls, filename: Path, data: str) -> dict:
         """Source heuristic for Web of Science"""
 
         result = {"confidence": 0.0}
 
         if data.count("UT WOS:") > 0.4 * data.count("TI "):
             result["confidence"] = 0.7
-            result["load_conversion_package_endpoint"] = {  # type: ignore
-                "endpoint": "colrev.zotero_translate"
-            }
             return result
 
         if "Unique-ID = {WOS:" in data:
             result["confidence"] = 0.7
             return result
         if "UT_(Unique_WOS_ID) = {WOS:" in data:
             result["confidence"] = 0.7
@@ -120,23 +117,24 @@
         record: colrev.record.Record,
         save_feed: bool = True,
         timeout: int = 10,
     ) -> colrev.record.Record:
         """Not implemented"""
         return record
 
-    def load_fixes(
-        self,
-        load_operation: colrev.ops.load.Load,
-        source: colrev.settings.SearchSource,
-        records: typing.Dict,
-    ) -> dict:
-        """Load fixes for Web of Science"""
+    def load(self, load_operation: colrev.ops.load.Load) -> dict:
+        """Load the records from the SearchSource file"""
 
-        return records
+        if self.search_source.filename.suffix == ".bib":
+            records = colrev.ops.load_utils_bib.load_bib_file(
+                load_operation=load_operation, source=self.search_source
+            )
+            return records
+
+        raise NotImplementedError
 
     def prepare(
         self, record: colrev.record.PrepRecord, source: colrev.settings.SearchSource
     ) -> colrev.record.Record:
         """Source-specific preparation for Web of Science"""
 
         record.format_if_mostly_upper(key="title", case="sentence")
```

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/website.py` & `colrev-0.9.2/colrev/ops/built_in/search_sources/website.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/built_in/search_sources/wiley.md` & `colrev-0.9.2/colrev/ops/built_in/search_sources/wiley.md`

 * *Files 23% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # SearchSource: Wiley
 
 Note: This document is currently under development. It will contain the following elements.
 
 - description
 - coverage (disciplines, types of work)
-- supported (details): search updates, get_masterdata, run_search, load_fixes, prep
+- supported (details): run_search (including updates), load,  prep (including get_masterdata)
 
 [Wiley](https://onlinelibrary.wiley.com/)
 [Wiley text and data mining resources](https://onlinelibrary.wiley.com/library-info/resources/text-and-datamining)
 
 ## Add the search source
 
 Download search results and store in `data/search/` directory. API-access not yet available.
```

### Comparing `colrev-0.9.0/colrev/ops/clone.py` & `colrev-0.9.2/colrev/ops/clone.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/commit.py` & `colrev-0.9.2/colrev/ops/commit.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/data.py` & `colrev-0.9.2/colrev/ops/data.py`

 * *Files 0% similar despite different names*

```diff
@@ -128,14 +128,15 @@
                 ID
                 for ID, record in records.items()
                 if record["colrev_status"]
                 in [
                     colrev.record.RecordState.rev_synthesized,
                     colrev.record.RecordState.rev_included,
                 ]
+                and record.get("year", "UNKNOWN").isdigit()
             ]
             observations = prepared_records_df[
                 prepared_records_df["ID"].isin(included_papers)
             ].copy()
             observations.year = observations.year.astype(int)
             missing_outlet = observations[observations["outlet"].isnull()][
                 "ID"
@@ -312,14 +313,15 @@
         if not silent_mode:
             self.review_manager.logger.info(
                 f"{colors.GREEN}Completed data operation{colors.END}"
             )
         if self.review_manager.in_ci_environment():
             print("\n\n")
 
+    @colrev.operation.Operation.decorate()
     def main(
         self,
         *,
         selection_list: Optional[list] = None,
         records: Optional[dict] = None,
         silent_mode: bool = False,
     ) -> dict:
```

### Comparing `colrev-0.9.0/colrev/ops/dedupe.py` & `colrev-0.9.2/colrev/ops/dedupe.py`

 * *Files 0% similar despite different names*

```diff
@@ -402,17 +402,17 @@
 
         return is_cross_level_merge_attempt
 
     def __gids_conflict(
         self, *, main_record: colrev.record.Record, dupe_record: colrev.record.Record
     ) -> bool:
         gid_conflict = False
-
-        if main_record.data.get("doi", "doi") != dupe_record.data.get("doi", "doi"):
-            gid_conflict = True
+        if "doi" in main_record.data and "doi" in dupe_record.data:
+            if main_record.data.get("doi", "doi") != dupe_record.data.get("doi", "doi"):
+                gid_conflict = True
 
         return gid_conflict
 
     def __print_merge_stats(
         self,
         *,
         records: dict,
@@ -887,14 +887,15 @@
                 f"run colrev merge -gid{colors.END}"
             )
             print()
 
         else:
             print()
 
+    @colrev.operation.Operation.decorate()
     def main(self) -> None:
         """Dedupe records (main entrypoint)"""
 
         self.review_manager.logger.info("Dedupe")
         self.review_manager.logger.info(
             "Identifies duplicate records and merges them (keeping traces to their origins)."
         )
@@ -962,10 +963,7 @@
                     record.set_status(
                         target_state=colrev.record.RecordState.rev_prescreen_included
                     )
 
             self.review_manager.dataset.save_records_dict(records=records)
             self.review_manager.dataset.add_record_changes()
             self.review_manager.create_commit(msg="Skip prescreen/include all")
-
-        if self.review_manager.in_ci_environment():
-            print("\n\n")
```

### Comparing `colrev-0.9.0/colrev/ops/distribute.py` & `colrev-0.9.2/colrev/ops/distribute.py`

 * *Files 2% similar despite different names*

```diff
@@ -31,14 +31,15 @@
         environment_manager = self.review_manager.get_environment_manager()
         return [
             x
             for x in environment_manager.local_repos()
             if "curated_metadata/" not in x["repo_source_path"]
         ]
 
+    @colrev.operation.Operation.decorate()
     def main(self, *, path: Path, target: Path) -> None:
         """Distribute records to other CoLRev repositories (main entrypoint)"""
 
         # if no options are given, take the current path/repo
         # optional: target-repo-path
         # path_str: could also be a url
         # option: chdir (to target repo)?
@@ -91,15 +92,14 @@
                     import_records = []
 
                     new_source = colrev.settings.SearchSource(
                         endpoint="colrev.unknown_source",
                         filename=Path("search") / target_bib_file.name,
                         search_type=colrev.settings.SearchType.OTHER,
                         search_parameters={},
-                        load_conversion_package_endpoint={},
                         comment="",
                     )
 
                     self.review_manager.settings.sources.append(new_source)
                     self.review_manager.save_settings()
 
                 if 0 != len(import_records):
```

### Comparing `colrev-0.9.0/colrev/ops/init.py` & `colrev-0.9.2/colrev/ops/init.py`

 * *Files 1% similar despite different names*

```diff
@@ -105,15 +105,17 @@
             "%sCompleted init operation%s", colors.GREEN, colors.END
         )
 
     def __check_init_precondition(self) -> None:
         cur_content = [
             str(x.relative_to(self.target_path)) for x in self.target_path.glob("**/*")
         ]
-        cur_content = [x for x in cur_content if not x.startswith("venv")]
+        cur_content = [
+            x for x in cur_content if not x.startswith("venv") and x != ".history"
+        ]
 
         if str(colrev.review_manager.ReviewManager.REPORT_RELATIVE) in cur_content:
             cur_content.remove(str(colrev.review_manager.ReviewManager.REPORT_RELATIVE))
         if cur_content:
             raise colrev_exceptions.NonEmptyDirectoryError(
                 filepath=self.target_path, content=cur_content
             )
```

### Comparing `colrev-0.9.0/colrev/ops/load.py` & `colrev-0.9.2/colrev/ops/prep.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,1024 +1,1204 @@
 #! /usr/bin/env python
-"""CoLRev load operation: Load records from search sources into references.bib."""
+"""CoLRev prep operation: Prepare record metadata."""
 from __future__ import annotations
 
-import html
-import itertools
-import re
-import string
+import inspect
+import logging
+import multiprocessing as mp
+import random
+import time
 import typing
+from copy import deepcopy
+from datetime import datetime
+from datetime import timedelta
+from multiprocessing import Value
+from multiprocessing.pool import ThreadPool as Pool
 from pathlib import Path
+from typing import Optional
 
-import colrev.env.language_service
+from requests.exceptions import ConnectionError as requests_ConnectionError
+from requests.exceptions import ReadTimeout
+
+import colrev.env.utils
 import colrev.exceptions as colrev_exceptions
 import colrev.operation
 import colrev.record
 import colrev.settings
 import colrev.ui_cli.cli_colors as colors
 
 # pylint: disable=too-many-lines
 
+# logging.getLogger("urllib3").setLevel(logging.ERROR)
+logging.getLogger("requests_cache").setLevel(logging.ERROR)
+
+PREP_COUNTER = Value("i", 0)
+
+
+class Prep(colrev.operation.Operation):
+    """Prepare records (metadata)"""
+
+    # pylint: disable=too-many-instance-attributes
+
+    timeout = 30
+    max_retries_on_error = 3
 
-class Load(colrev.operation.Operation):
-    """Load the records"""
+    retrieval_similarity: float
 
-    # Note : PDFs should be stored in the pdfs directory
-    # They should be included through colrev search
+    first_round: bool
+    last_round: bool
 
-    supported_extensions: typing.List[str]
+    debug_mode: bool
 
-    __LATEX_SPECIAL_CHAR_MAPPING = {
-        '\\"u': "ü",
-        "\\&": "&",
-        '\\"o': "ö",
-        '\\"a': "ä",
-        '\\"A': "Ä",
-        '\\"O': "Ö",
-        '\\"U': "Ü",
-        "\\textendash": "–",
-        "\\textemdash": "—",
-        "\\~a": "ã",
-        "\\'o": "ó",
+    pad: int
+
+    polish: bool
+
+    prep_package_endpoints: dict[str, typing.Any]
+
+    requests_headers = {
+        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) "
+        "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36"
     }
 
+    # pylint: disable=duplicate-code
+    fields_to_keep = [
+        "ID",
+        "ENTRYTYPE",
+        "colrev_status",
+        "colrev_origin",
+        "colrev_masterdata_provenance",
+        "colrev_data_provenance",
+        "colrev_pid",
+        "author",
+        "year",
+        "title",
+        "journal",
+        "booktitle",
+        "chapter",
+        "series",
+        "volume",
+        "number",
+        "pages",
+        "doi",
+        "abstract",
+        "school",
+        "editor",
+        "book-group-author",
+        "book-author",
+        "keywords",
+        "file",
+        "fulltext",
+        "publisher",
+        "dblp_key",
+        "sem_scholar_id",
+        "url",
+        "isbn",
+        "address",
+        "edition",
+        "warning",
+        "crossref",
+        "date",
+        "wos_accession_number",
+        "link",
+        "url",
+        "crossmark",
+        "warning",
+        "note",
+        "issn",
+        "language",
+        "howpublished",
+        "cited_by",
+        "cited_by_file",
+    ]
+
+    __cpu = 1
+    __prep_commit_id = "HEAD"
+
     def __init__(
         self,
         *,
         review_manager: colrev.review_manager.ReviewManager,
         notify_state_transition_operation: bool = True,
-        hide_load_explanation: bool = False,
+        retrieval_similarity: float = 1.0,
     ) -> None:
         super().__init__(
             review_manager=review_manager,
-            operations_type=colrev.operation.OperationsType.load,
+            operations_type=colrev.operation.OperationsType.prep,
             notify_state_transition_operation=notify_state_transition_operation,
         )
+        self.notify_state_transition_operation = notify_state_transition_operation
 
+        self.fields_to_keep += self.review_manager.settings.prep.fields_to_keep
+
+        self.retrieval_similarity = retrieval_similarity
         self.quality_model = review_manager.get_qm()
-        self.package_manager = self.review_manager.get_package_manager()
-        self.language_service = colrev.env.language_service.LanguageService()
 
-        if not hide_load_explanation:
-            self.review_manager.logger.info("Load")
-            self.review_manager.logger.info(
-                "Load converts search results and adds them to the shared data/records.bib."
+        self.polish = False
+        self.debug_mode = False
+        self.pad = 0
+        self.__stats: typing.Dict[str, typing.List[timedelta]] = {}
+
+    def __add_stats(
+        self, *, prep_round_package_endpoint: dict, start_time: datetime
+    ) -> None:
+        if prep_round_package_endpoint["endpoint"] not in self.__stats:
+            self.__stats[prep_round_package_endpoint["endpoint"]] = [
+                datetime.now() - start_time
+            ]
+        else:
+            self.__stats[prep_round_package_endpoint["endpoint"]].append(
+                datetime.now() - start_time
             )
+
+    def __print_stats(self) -> None:
+        if self.review_manager.verbose_mode:
+            print("Runtime statistics (averages)")
+            averaged_list = [
+                {
+                    "script": script,
+                    "average": sum(deltalist, timedelta(0)) / len(deltalist),
+                }
+                for script, deltalist in self.__stats.items()
+            ]
+            for item in sorted(
+                averaged_list,
+                key=lambda k: k["average"],  # type: ignore
+                reverse=True,
+            ):
+                average_time_str = (
+                    f"{item['average'].seconds}."  # type: ignore
+                    f"{item['average'].microseconds}"  # type: ignore
+                )
+                average_time = float(average_time_str)
+                average_time = round(average_time, 2)
+                average_time_str = f"{average_time:.2f}"
+                print(
+                    f"{item['script']} ".ljust(50, " ")
+                    + ":"
+                    + f"{average_time_str} s".rjust(10, " ")
+                )
+            print()
+
+    def __print_diffs_for_debug(
+        self,
+        *,
+        prior: colrev.record.PrepRecord,
+        preparation_record: colrev.record.PrepRecord,
+        prep_package_endpoint: colrev.env.package_manager.PrepPackageEndpointInterface,
+    ) -> None:
+        if not self.debug_mode:
+            return
+
+        diffs = prior.get_diff(other_record=preparation_record)
+        if diffs:
+            change_report = (
+                f"{prep_package_endpoint}"
+                f' on {preparation_record.data["ID"]}'
+                " changed:\n"
+                f"{colors.ORANGE}{self.review_manager.p_printer.pformat(diffs)}{colors.END}\n"
+            )
+
+            self.review_manager.logger.info(change_report)
             self.review_manager.logger.info(
-                "Original records (search results) are stored in the directory data/search"
+                "To correct errors in the endpoint,"
+                " open an issue at "
+                "https://github.com/CoLRev-Environment/colrev/issues"
             )
             self.review_manager.logger.info(
-                "See https://colrev.readthedocs.io/en/latest/manual/metadata_retrieval/load.html"
+                "To correct potential errors at source,"
+                f" {prep_package_endpoint.source_correction_hint}"
             )
+            input("Press Enter to continue")
+            print("\n")
+        else:
+            self.review_manager.logger.debug(
+                f"{prep_package_endpoint}"
+                f' on {preparation_record.data["ID"]}'
+                " changed: -"
+            )
+            print("\n")
+            time.sleep(0.1)
 
-    def __get_new_search_files(self) -> list[Path]:
-        """Retrieve new search files (not yet registered in settings)"""
+    def __package_prep(
+        self,
+        prep_round_package_endpoint: dict,
+        record: colrev.record.PrepRecord,
+        preparation_record: colrev.record.PrepRecord,
+    ) -> None:
+        try:
+            if (
+                prep_round_package_endpoint["endpoint"].lower()
+                not in self.prep_package_endpoints
+            ):
+                return
+            endpoint = self.prep_package_endpoints[
+                prep_round_package_endpoint["endpoint"].lower()
+            ]
 
-        if not self.review_manager.search_dir.is_dir():
-            return []
+            if self.debug_mode:
+                self.review_manager.logger.info(
+                    f"{endpoint.settings.endpoint}(...) called"
+                )
 
-        files = [
-            f.relative_to(self.review_manager.path)
-            for f in self.review_manager.search_dir.glob("**/*")
-        ]
+            prior = preparation_record.copy_prep_rec()
 
-        # Only files that are not yet registered
-        # (also exclude bib files corresponding to a registered file)
-        files = [
-            f
-            for f in files
-            if str(f.with_suffix(".bib"))
-            not in [
-                str(s.filename.with_suffix(".bib"))
-                for s in self.review_manager.settings.sources
-            ]
-        ]
+            start_time = datetime.now()
+            preparation_record = endpoint.prepare(self, preparation_record)
+            self.__add_stats(
+                start_time=start_time,
+                prep_round_package_endpoint=prep_round_package_endpoint,
+            )
 
-        return sorted(list(set(files)))
+            self.__print_diffs_for_debug(
+                prior=prior,
+                preparation_record=preparation_record,
+                prep_package_endpoint=endpoint,
+            )
 
-    def __get_currently_imported_origin_list(self) -> list:
-        records_headers = self.review_manager.dataset.load_records_dict(
-            header_only=True
-        )
-        record_header_list = list(records_headers.values())
-        imported_origins = [
-            item for x in record_header_list for item in x["colrev_origin"]
-        ]
-        return imported_origins
+            if endpoint.always_apply_changes:
+                record.update_by_record(update_record=preparation_record)
 
-    def __get_load_conversion_package_endpoint(
-        self, *, filepath: Path, load_conversion: dict
-    ) -> dict:
-        filetype = filepath.suffix.replace(".", "")
+            if preparation_record.preparation_save_condition():
+                record.update_by_record(update_record=preparation_record)
 
-        for (
-            package_identifier,
-            selected_package,
-        ) in load_conversion.items():
-            if filetype in selected_package.supported_extensions:  # type: ignore
-                return {"endpoint": package_identifier}
+            if preparation_record.preparation_break_condition() and not self.polish:
+                record.update_by_record(update_record=preparation_record)
+                raise colrev_exceptions.PreparationBreak
+        except ReadTimeout:
+            self.__add_stats(
+                start_time=start_time,
+                prep_round_package_endpoint=prep_round_package_endpoint,
+            )
+            if self.review_manager.verbose_mode:
+                self.review_manager.logger.error(
+                    f" {colors.RED}{record.data['ID']}".ljust(45)
+                    + f"{endpoint.settings.endpoint}(...) timed out{colors.END}{colors.END}"
+                )
 
-        raise colrev_exceptions.UnsupportedImportFormatError(filepath)
+        except colrev_exceptions.ServiceNotAvailableException as exc:
+            if self.review_manager.force_mode:
+                self.__add_stats(
+                    start_time=start_time,
+                    prep_round_package_endpoint=prep_round_package_endpoint,
+                )
+                self.review_manager.logger.error(exc)
+            else:
+                raise exc
 
-    def __get_heuristics_results_list(
+    def __print_post_package_prep_polish_info(
         self,
         *,
-        filepath: Path,
-        search_sources: dict,
-        load_conversion: dict,
-        data: str,
-    ) -> list:
-        results_list = []
-        for (
-            endpoint,
-            endpoint_class,
-        ) in search_sources.items():
-            # pylint: disable=no-member
-            has_heuristic = getattr(endpoint_class, "heuristic", None)
-            if not has_heuristic:
-                self.review_manager.logger.debug(f"- {endpoint}: no heuristic")
-                continue
-            res = endpoint_class.heuristic(filepath, data)  # type: ignore
-            self.review_manager.logger.debug(f"- {endpoint}: {res['confidence']}")
-            if res["confidence"] == 0.0:
-                continue
-            try:
-                result_item = {}
+        record: colrev.record.PrepRecord,
+        prior_state: colrev.record.RecordState,
+        progress: str,
+    ) -> None:
+        # records in post_md_prepared remain in that state (in polish mode)
+        if (
+            record.data["colrev_status"]
+            in colrev.record.RecordState.get_post_x_states(
+                state=colrev.record.RecordState.md_prepared
+            )
+            and prior_state != colrev.record.RecordState.md_needs_manual_preparation
+        ) or (
+            prior_state == colrev.record.RecordState.md_needs_manual_preparation
+            and record.data["colrev_status"]
+            == colrev.record.RecordState.md_needs_manual_preparation
+        ):
+            self.review_manager.logger.info(
+                f" {record.data['ID']}".ljust(41) + f"{progress} - "
+            )
+        elif (
+            record.data["colrev_status"]
+            == colrev.record.RecordState.rev_prescreen_excluded
+        ):
+            self.review_manager.logger.info(
+                f" {colors.RED}{record.data['ID']}".ljust(46)
+                + f"{progress}{prior_state} →  {record.data['colrev_status']}"
+                + f"{colors.END}"
+            )
+        elif (
+            record.data["colrev_status"]
+            == colrev.record.RecordState.md_needs_manual_preparation
+        ):
+            self.review_manager.logger.info(
+                f" {colors.ORANGE}{record.data['ID']}".ljust(46)
+                + f"{progress}{prior_state} →  {record.data['colrev_status']}{colors.END}"
+            )
+        elif record.data["colrev_status"] == colrev.record.RecordState.md_prepared:
+            curation_addition = "   "
+            if record.masterdata_is_curated():
+                curation_addition = " ✔ "
+            self.review_manager.logger.info(
+                f" {colors.GREEN}{record.data['ID']}".ljust(46)
+                + f"{progress}{prior_state} →  "
+                f"{record.data['colrev_status']}{colors.END}{curation_addition}"
+            )
 
-                res["endpoint"] = endpoint
+        elif (
+            record.data["colrev_status"]
+            == colrev.record.RecordState.md_needs_manual_preparation
+        ):
+            self.review_manager.logger.info(
+                f" {colors.ORANGE}{record.data['ID']}".ljust(46)
+                + f"{progress}{prior_state} →  {record.data['colrev_status']}{colors.END}"
+            )
 
-                search_type = endpoint_class.search_type
-                # Note : as the identifier, we use the filename
-                # (if search results are added by file/not via the API)
-
-                # Correct the file extension if necessary
-                if re.findall(r"^%0", data, re.MULTILINE) and filepath.suffix not in [
-                    ".enl"
-                ]:
-                    new_filename = filepath.with_suffix(".enl")
+    def __print_post_package_prep_info(
+        self,
+        record: colrev.record.PrepRecord,
+        item: dict,
+        prior_state: colrev.record.RecordState,
+    ) -> None:
+        # pylint: disable=redefined-outer-name,invalid-name
+        with PREP_COUNTER.get_lock():
+            PREP_COUNTER.value += 1  # type: ignore
+        progress = ""
+        if item["nr_items"] > 100:
+            progress = f"({PREP_COUNTER.value}/{item['nr_items']}) ".rjust(  # type: ignore
+                12, " "
+            )
+
+        if self.polish:
+            self.__print_post_package_prep_polish_info(
+                record=record, prior_state=prior_state, progress=progress
+            )
+        else:
+            if record.preparation_break_condition():
+                if (
+                    colrev.record.RecordState.rev_prescreen_excluded
+                    == record.data["colrev_status"]
+                ):
+                    if self.review_manager.verbose_mode:
+                        self.review_manager.logger.info(
+                            f" {colors.RED}{record.data['ID']}".ljust(46)
+                            + f"Detected: {record.data.get('prescreen_exclusion', 'NA')}"
+                            + f"{colors.END}"
+                        )
+                    target_state = colrev.record.RecordState.rev_prescreen_excluded
                     self.review_manager.logger.info(
-                        f"{colors.GREEN}Rename to {new_filename} "
-                        f"(because the format is .enl){colors.END}"
+                        f" {colors.RED}{record.data['ID']}".ljust(46)
+                        + f"{progress}{prior_state} →  {target_state}"
+                        + f"{colors.END}"
                     )
-                    filepath.rename(new_filename)
-                    self.review_manager.dataset.add_changes(path=filepath, remove=True)
-                    filepath = new_filename
-                    res["filename"] = filepath
-                    self.review_manager.dataset.add_changes(path=new_filename)
-                    self.review_manager.create_commit(msg=f"Rename {filepath}")
-
-                if re.findall(r"^TI ", data, re.MULTILINE) and filepath.suffix not in [
-                    ".ris"
-                ]:
-                    new_filename = filepath.with_suffix(".ris")
+                else:
+                    target_state = colrev.record.RecordState.md_needs_manual_preparation
                     self.review_manager.logger.info(
-                        f"{colors.GREEN}Rename to {new_filename} "
-                        f"(because the format is .ris){colors.END}"
-                    )
-                    filepath.rename(new_filename)
-                    self.review_manager.dataset.add_changes(path=filepath, remove=True)
-                    filepath = new_filename
-                    res["filename"] = filepath
-                    self.review_manager.dataset.add_changes(path=new_filename)
-                    self.review_manager.create_commit(msg=f"Rename {filepath}")
-
-                if "load_conversion_package_endpoint" not in res:
-                    res[
-                        "load_conversion_package_endpoint"
-                    ] = self.__get_load_conversion_package_endpoint(
-                        filepath=filepath, load_conversion=load_conversion
+                        f" {colors.ORANGE}{record.data['ID']}".ljust(46)
+                        + f"{progress}{prior_state} →  {target_state}{colors.END}"
                     )
 
-                source_candidate = colrev.settings.SearchSource(
-                    endpoint=endpoint,
-                    filename=filepath,
-                    search_type=search_type,
-                    search_parameters={},
-                    load_conversion_package_endpoint=res[
-                        "load_conversion_package_endpoint"
-                    ],
-                    comment="",
+            elif record.preparation_save_condition():
+                curation_addition = "   "
+                if record.masterdata_is_curated():
+                    curation_addition = " ✔ "
+                target_state = colrev.record.RecordState.md_prepared
+                self.review_manager.logger.info(
+                    f" {colors.GREEN}{record.data['ID']}".ljust(46)
+                    + f"{progress}{prior_state} →  {target_state}{colors.END}{curation_addition}"
+                )
+            else:
+                target_state = colrev.record.RecordState.md_needs_manual_preparation
+                self.review_manager.logger.info(
+                    f" {colors.ORANGE}{record.data['ID']}".ljust(46)
+                    + f"{progress}{prior_state} →  {target_state}{colors.END}"
                 )
 
-                result_item["source_candidate"] = source_candidate
-                result_item["confidence"] = res["confidence"]
-
-                results_list.append(result_item)
-            except colrev_exceptions.UnsupportedImportFormatError:
-                continue
-        return results_list
-
-    def __apply_source_heuristics(
+    def __post_package_prep(
         self,
-        *,
-        filepath: Path,
-        search_sources: dict,
-        load_conversion: dict,
-    ) -> list[typing.Dict]:
-        """Apply heuristics to identify source"""
-
-        data = ""
-        try:
-            data = filepath.read_text()
-        except UnicodeDecodeError:
-            pass
-
-        results_list = self.__get_heuristics_results_list(
-            filepath=filepath,
-            search_sources=search_sources,
-            load_conversion=load_conversion,
-            data=data,
-        )
-
-        # Reduce the results_list when there are results with very high confidence
-        if [r for r in results_list if r["confidence"] > 0.95]:
-            results_list = [r for r in results_list if r["confidence"] > 0.8]
-
-        return results_list
-
-    def __select_source(self, *, heuristic_result_list: list, skip_query: bool) -> dict:
-        if not skip_query:
-            print(f"{colors.ORANGE}Select search source{colors.END}:")
-            for i, heuristic_source in enumerate(heuristic_result_list):
-                highlight_color = ""
-                if heuristic_source["confidence"] >= 0.7:
-                    highlight_color = colors.GREEN
-                elif heuristic_source["confidence"] >= 0.5:
-                    highlight_color = colors.ORANGE
-                print(
-                    f"{highlight_color}{i+1} "
-                    f"(confidence: {round(heuristic_source['confidence'], 2)}):"
-                    f" {heuristic_source['source_candidate'].endpoint}{colors.END}"
+        record: colrev.record.PrepRecord,
+        preparation_record: colrev.record.PrepRecord,
+        item: dict,
+        prior_state: colrev.record.RecordState,
+    ) -> None:
+        if self.last_round and not self.polish:
+            if record.status_to_prepare():
+                for key in list(record.data.keys()):
+                    if key not in self.fields_to_keep:
+                        record.remove_field(key=key)
+                    elif record.data[key] in ["", "NA"]:
+                        record.remove_field(key=key)
+                record.update_by_record(update_record=preparation_record)
+                # Note: update_masterdata_provenance sets to md_needs_manual_preparation
+                record.update_masterdata_provenance(
+                    qm=self.quality_model, set_prepared=True
                 )
 
-        while True:
-            if skip_query:
-                # Use the last / unknown_source
-                max_conf = 0.0
-                best_candidate_pos = 0
-                for i, heuristic_candidate in enumerate(heuristic_result_list):
-                    if heuristic_candidate["confidence"] > max_conf:
-                        best_candidate_pos = i + 1
-                        max_conf = heuristic_candidate["confidence"]
-                if not any(c["confidence"] > 0.1 for c in heuristic_result_list):
-                    return [
-                        x
-                        for x in heuristic_result_list
-                        if x["source_candidate"].endpoint == "colrev.unknown_source"
-                    ][0]
-                selection = str(best_candidate_pos)
+        if self.polish:
+            errors_prior = {
+                k: y
+                for k, v in record.data.get("colrev_masterdata_provenance", {}).items()
+                for y in v["note"].split(",")
+                if y not in ["not-missing", "forthcoming"]
+            }
+            record.update_masterdata_provenance(qm=self.quality_model)
+            errors_post = {
+                k: y
+                for k, v in record.data.get("colrev_masterdata_provenance", {}).items()
+                for y in v["note"].split(",")
+                if y not in ["not-missing", "forthcoming"]
+            }
+            additional_errors = set(errors_post.items()) - set(errors_prior.items())
+            if (
+                additional_errors
+                and prior_state != colrev.record.RecordState.rev_prescreen_excluded
+            ):
+                record.set_status(
+                    target_state=colrev.record.RecordState.md_needs_manual_preparation,
+                    force=True,
+                )
+            elif prior_state == colrev.record.RecordState.md_needs_manual_preparation:
+                record.set_status(target_state=colrev.record.RecordState.md_prepared)
             else:
-                selection = input("select nr")
-            if not selection.isdigit():
-                continue
-            if int(selection) in range(1, len(heuristic_result_list) + 1):
-                heuristic_source = heuristic_result_list[int(selection) - 1]
-                return heuristic_source
-
-    def __heuristics_check(
-        self, *, heuristic_result_list: list, skip_query: bool
-    ) -> colrev.settings.SearchSource:
-        if 1 == len(heuristic_result_list):
-            heuristic_source = heuristic_result_list[0]
-        else:
-            heuristic_source = self.__select_source(
-                heuristic_result_list=heuristic_result_list, skip_query=skip_query
+                record.set_status(target_state=prior_state, force=True)
+
+        if not self.review_manager.verbose_mode:
+            self.__print_post_package_prep_info(
+                record=record, item=item, prior_state=prior_state
             )
 
-        if "colrev.unknown_source" == heuristic_source["source_candidate"].endpoint:
-            cmd = "Enter the search query (or NA)".ljust(25, " ") + ": "
-            query_input = ""
-            if not skip_query:
-                query_input = input(cmd)
-            if query_input not in ["", "NA"]:
-                heuristic_source["source_candidate"].search_parameters = {
-                    "query": query_input
-                }
-            else:
-                heuristic_source["source_candidate"].search_parameters = {}
+    # Note : no named arguments for multiprocessing
+    def prepare(self, item: dict) -> dict:
+        """Prepare a record (based on package_endpoints in the settings)"""
 
-        self.review_manager.logger.info(
-            f"Source name: {heuristic_source['source_candidate'].endpoint}"
-        )
+        record: colrev.record.PrepRecord = item["record"]
 
-        heuristic_source["source_candidate"].comment = None
+        if not record.status_to_prepare() and not self.polish:
+            return record.get_data()
 
-        if {} == heuristic_source["source_candidate"].load_conversion_package_endpoint:
-            custom_load_conversion_package_endpoint = input(
-                "provide custom load_conversion_package_endpoint [or NA]:"
-            )
-            if "NA" == custom_load_conversion_package_endpoint:
-                heuristic_source[
-                    "source_candidate"
-                ].load_conversion_package_endpoint = {}
-            else:
-                heuristic_source[
-                    "source_candidate"
-                ].load_conversion_package_endpoint = {
-                    "endpoint": custom_load_conversion_package_endpoint
-                }
+        if self.review_manager.verbose_mode:
+            self.review_manager.logger.info(" prep " + record.data["ID"])
 
-        return heuristic_source["source_candidate"]
+        # preparation_record changes with each endpoint and
+        # eventually replaces record (if md_prepared or endpoint.always_apply_changes)
+        preparation_record = record.copy_prep_rec()
+        prior_state = record.data["colrev_status"]
 
-    def get_new_sources(
-        self, *, skip_query: bool = False
-    ) -> typing.List[colrev.settings.SearchSource]:
-        """Get new SearchSources"""
+        for prep_round_package_endpoint in deepcopy(
+            item["prep_round_package_endpoints"]
+        ):
+            try:
+                self.__package_prep(
+                    prep_round_package_endpoint,
+                    record,
+                    preparation_record,
+                )
+            except colrev_exceptions.PreparationBreak:
+                break
 
-        # pylint: disable=redefined-outer-name
+        self.__post_package_prep(
+            record=record,
+            preparation_record=preparation_record,
+            item=item,
+            prior_state=prior_state,
+        )
 
-        new_search_files = self.__get_new_search_files()
-        if not new_search_files:
-            self.review_manager.logger.info("No new search files...")
-            return []
+        return record.get_data()
 
-        self.review_manager.logger.debug("Load available search_source endpoints...")
+    def __select_record_list_for_reset(self, *, record_list: list[dict]) -> list[dict]:
+        record_list = [
+            rec
+            for rec in record_list
+            if str(rec["colrev_status"])
+            in [
+                str(colrev.record.RecordState.md_prepared),
+                str(colrev.record.RecordState.md_needs_manual_preparation),
+            ]
+        ]
 
-        search_source_identifiers = self.package_manager.discover_packages(
-            package_type=colrev.env.package_manager.PackageEndpointType.search_source,
-            installed_only=True,
-        )
+        for rec in [
+            rec
+            for rec in record_list
+            if str(rec["colrev_status"])
+            not in [
+                str(colrev.record.RecordState.md_prepared),
+                str(colrev.record.RecordState.md_needs_manual_preparation),
+            ]
+        ]:
+            msg = (
+                f"{rec['ID']}: status must be md_prepared/md_needs_manual_preparation "
+                + f'(is {rec["colrev_status"]})'
+            )
+            self.review_manager.logger.error(msg)
+            self.review_manager.report_logger.error(msg)
+        return record_list
 
-        search_sources = self.package_manager.load_packages(
-            package_type=colrev.env.package_manager.PackageEndpointType.search_source,
-            selected_packages=[{"endpoint": p} for p in search_source_identifiers],
-            operation=self,
-            instantiate_objects=False,
+    def __get_revlist_for_reset(self) -> typing.Iterator[tuple]:
+        git_repo = self.review_manager.dataset.get_repo()
+        revlist = (
+            (
+                commit.hexsha,
+                commit.message,
+                (commit.tree / "data" / "records.bib").data_stream.read(),
+            )
+            for commit in git_repo.iter_commits(
+                paths=str(self.review_manager.dataset.RECORDS_FILE_RELATIVE)
+            )
         )
+        return revlist
 
-        self.review_manager.logger.debug("Load available load_conversion endpoints...")
-        load_conversion_package_identifiers = self.package_manager.discover_packages(
-            package_type=colrev.env.package_manager.PackageEndpointType.load_conversion,
-            installed_only=True,
-        )
+    def __reset(self, *, record_list: list[dict]) -> None:
+        record_list = self.__select_record_list_for_reset(record_list=record_list)
+        revlist = self.__get_revlist_for_reset()
+
+        record_reset_list = [[record, deepcopy(record)] for record in record_list]
+
+        for commit_id, cmsg, filecontents in list(revlist):
+            cmsg_l1 = str(cmsg).split("\n", maxsplit=1)[0]
+            if "colrev load" not in cmsg:
+                print(f"Skip {str(commit_id)} (non-load commit) - {str(cmsg_l1)}")
+                continue
+            print(f"Check {str(commit_id)} - {str(cmsg_l1)}")
 
-        load_conversion_packages = self.package_manager.load_packages(
-            package_type=colrev.env.package_manager.PackageEndpointType.load_conversion,
-            selected_packages=[
-                {"endpoint": p} for p in load_conversion_package_identifiers
-            ],
-            operation=self,
-        )
+            prior_records_dict = self.review_manager.dataset.load_records_dict(
+                load_str=filecontents.decode("utf-8")
+            )
+            for prior_record in prior_records_dict.values():
+                if str(prior_record["colrev_status"]) != str(
+                    colrev.record.RecordState.md_imported
+                ):
+                    continue
+                for record_to_unmerge, record in record_reset_list:
+                    if any(
+                        o in prior_record["colrev_origin"]
+                        for o in record["colrev_origin"]
+                    ):
+                        self.review_manager.report_logger.info(
+                            f'reset({record["ID"]}) to'
+                            f"\n{self.review_manager.p_printer.pformat(prior_record)}\n\n"
+                        )
+                        # Note : we don't want to restore the old ID...
+                        current_id = record_to_unmerge["ID"]
+                        record_to_unmerge.clear()
+                        for key, value in prior_record.items():
+                            record_to_unmerge[key] = value
+                        record_to_unmerge["ID"] = current_id
+                        break
+                # Stop if all original records have been found
+                if (
+                    len(
+                        [
+                            x["colrev_status"] != "md_imported"
+                            for x, y in record_reset_list
+                        ]
+                    )
+                    == 0
+                ):
+                    break
 
-        self.supported_extensions = [
-            item
-            for sublist in [
-                e.supported_extensions  # type: ignore
-                for _, e in load_conversion_packages.items()
-            ]
-            for item in sublist
-        ]
+        for record_to_unmerge, record in record_reset_list:
+            record_to_unmerge.update(
+                colrev_status=colrev.record.RecordState.md_needs_manual_preparation
+            )
 
-        new_sources = []
-        for sfp in new_search_files:
-            sfp_name = sfp
-            if sfp_name in [
-                str(source.filename) for source in self.review_manager.settings.sources
-            ]:
-                continue
+    def reset_records(self, *, reset_ids: list) -> None:
+        """Reset records based on IDs"""
+        # Note: entrypoint for CLI
 
-            if not self.review_manager.high_level_operation:
-                print()
-            self.review_manager.logger.info(f"Discover new source: {sfp_name}")
+        records = self.review_manager.dataset.load_records_dict()
+        records_to_reset = []
+        for reset_id in reset_ids:
+            if reset_id in records:
+                records_to_reset.append(records[reset_id])
+            else:
+                print(f"Error: record not found (ID={reset_id})")
 
-            # Assuming that all other search types are added by query
-            # search_type_input = "NA"
-            # while search_type_input not in SearchType.get_options():
-            #     print(f"Search type options: {SearchType.get_options()}")
-            #     cmd = "Enter search type".ljust(25, " ") + ": "
-            #     search_type_input = input(cmd)
+        self.__reset(record_list=records_to_reset)
 
-            heuristic_result_list = self.__apply_source_heuristics(
-                filepath=sfp,
-                search_sources=search_sources,
-                load_conversion=load_conversion_packages,
+        self.review_manager.dataset.save_records_dict(records=records)
+        self.review_manager.dataset.add_record_changes()
+        self.review_manager.create_commit(
+            msg="Reset metadata for manual preparation",
+        )
+
+    def set_ids(self) -> None:
+        """Set IDs (regenerate). In force-mode, all IDs are regenerated and PDFs are renamed"""
+        self.review_manager.logger.info("Set IDs")
+        records = self.review_manager.dataset.load_records_dict()
+        self.review_manager.dataset.set_ids(records=records, selected_ids=list(records))
+        for record_dict in records.values():
+            if "file" not in record_dict:
+                continue
+
+            if str(Path(record_dict["file"]).name) == f'{record_dict["ID"]}.pdf':
+                continue
+
+            old_filename = record_dict["file"]
+            new_filename = Path(record_dict["file"]).parent / Path(
+                f'{record_dict["ID"]}.pdf'
             )
-            # print(heuristic_result_list) #can be deleted mail?
+            try:
+                Path(record_dict["file"]).rename(new_filename)
+            except FileNotFoundError:
+                print(f"rename error: {record_dict['file']}")
+                continue
+            record_dict["file"] = str(new_filename)
+            if "colrev_data_provenance" in record_dict:
+                for value in record_dict["colrev_data_provenance"].values():
+                    if value["source"] == old_filename:
+                        value["source"] = value["source"].replace(
+                            old_filename, str(new_filename)
+                        )
+            if "colrev_masterdata_provenance" in record_dict:
+                for value in record_dict["colrev_masterdata_provenance"].values():
+                    if value["source"] == old_filename:
+                        value["source"] = value["source"].replace(
+                            old_filename, str(new_filename)
+                        )
+
+            # simple heuristic:
+            pdfs_origin_file = Path("data/search/pdfs.bib")
+            if pdfs_origin_file.is_file():
+                colrev.env.utils.inplace_change(
+                    filename=pdfs_origin_file,
+                    old_string=old_filename,
+                    new_string=str(new_filename),
+                )
+                self.review_manager.dataset.add_changes(path=pdfs_origin_file)
 
-            # turn following Code into function due to too many nested block warnings
+        self.review_manager.dataset.save_records_dict(records=records)
+        self.review_manager.dataset.add_record_changes()
 
-        # immediatley execute code from function above
-        new_source = self.__heuristics_check(
-            heuristic_result_list=heuristic_result_list, skip_query=skip_query
+        self.review_manager.create_commit(
+            msg="Set IDs",
         )
 
-        new_sources.append(new_source)
+    def reset_ids(self) -> None:
+        """Reset the IDs of records"""
+        # Note: entrypoint for CLI
 
-        return new_sources
+        records = self.review_manager.dataset.load_records_dict()
+        try:
+            prior_records_dict = next(
+                self.review_manager.dataset.load_records_from_history()
+            )
 
-    def __check_bib_file(
-        self, *, source: colrev.settings.SearchSource, records: dict
-    ) -> None:
-        if len(records.items()) <= 3:
-            return
-        if not any("author" in r for ID, r in records.items()):
-            raise colrev_exceptions.ImportException(
-                f"Import failed (no record with author field): {source.filename.name}"
-            )
-
-        if not any("title" in r for ID, r in records.items()):
-            raise colrev_exceptions.ImportException(
-                f"Import failed (no record with title field): {source.filename.name}"
-            )
-
-    def __resolve_non_unique_ids(self, *, source: colrev.settings.SearchSource) -> None:
-        def get_unique_id(*, non_unique_id: str, id_list: list[str]) -> str:
-            order = 0
-            letters = list(string.ascii_lowercase)
-            temp_id = non_unique_id
-            next_unique_id = temp_id
-            appends: list = []
-            while next_unique_id in id_list:
-                if len(appends) == 0:
-                    order += 1
-                    appends = list(itertools.product(letters, repeat=order))
-                next_unique_id = temp_id + "".join(list(appends.pop(0)))
-
-            return next_unique_id
-
-        def inplace_change_second(
-            *, filename: Path, old_string: str, new_string: str
-        ) -> None:
-            new_file_lines = []
-            with open(filename, encoding="utf8") as file:
-                first_read = False
-                replaced = False
-                for line in file.readlines():
-                    if old_string in line and not first_read:
-                        first_read = True
-                    if old_string in line and first_read and not replaced:
-                        line = line.replace(old_string, new_string)
-                        replaced = True
-                    new_file_lines.append(line)
-
-                # s = f.read()
-                # if old_string not in s:
-                #     return
-            with open(filename, "w", encoding="utf8") as file:
-                for new_file_line in new_file_lines:
-                    file.write(new_file_line)
+            for record in records.values():
+                prior_record_l = [
+                    x
+                    for x in prior_records_dict.values()
+                    if x["colrev_origin"] == record["colrev_origin"]
+                ]
+                if len(prior_record_l) != 1:
+                    continue
+                prior_record = prior_record_l[0]
+                record["ID"] = prior_record["ID"]
 
-        if not source.get_corresponding_bib_file().is_file():
-            return
+            self.review_manager.dataset.save_records_dict(records=records)
+        except StopIteration:
+            self.review_manager.logger.info("No prior records")
 
-        with open(source.get_corresponding_bib_file(), encoding="utf8") as bibtex_file:
-            cr_dict = self.review_manager.dataset.load_records_dict(
-                load_str=bibtex_file.read()
-            )
-
-        ids_to_update = []
-        current_ids = list(cr_dict.keys())
-        for record in cr_dict.values():
-            if len([x for x in current_ids if x == record["ID"]]) > 1:
-                new_id = get_unique_id(non_unique_id=record["ID"], id_list=current_ids)
-                ids_to_update.append([record["ID"], new_id])
-                current_ids.append(new_id)
-
-        if len(ids_to_update) > 0:
-            self.review_manager.dataset.add_changes(
-                path=source.get_corresponding_bib_file()
-            )
-            self.review_manager.create_commit(
-                msg=f"Save original search file: {source.get_corresponding_bib_file().name}",
-            )
+    def setup_custom_script(self) -> None:
+        """Setup a custom prep script"""
 
-            for old_id, new_id in ids_to_update:
-                self.review_manager.logger.info(
-                    f"Resolve ID to ensure unique colrev_origins: {old_id} -> {new_id}"
-                )
-                self.review_manager.report_logger.info(
-                    f"Resolve ID to ensure unique colrev_origins: {old_id} -> {new_id}"
-                )
-                inplace_change_second(
-                    filename=source.get_corresponding_bib_file(),
-                    old_string=f"{old_id},",
-                    new_string=f"{new_id},",
-                )
-            self.review_manager.dataset.add_changes(
-                path=source.get_corresponding_bib_file()
-            )
-            self.review_manager.create_commit(
-                msg=f"Resolve non-unique IDs in {source.get_corresponding_bib_file().name}"
-            )
+        filedata = colrev.env.utils.get_package_file_content(
+            file_path=Path("template/custom_scripts/custom_prep_script.py")
+        )
+        if filedata:
+            with open("custom_prep_script.py", "w", encoding="utf-8") as file:
+                file.write(filedata.decode("utf-8"))
 
-    def __getbib(self, *, file: Path) -> list[dict]:
-        with open(file, encoding="utf8") as bibtex_file:
-            contents = bibtex_file.read()
-            bib_r = re.compile(r"@.*{.*,", re.M)
-            if len(re.findall(bib_r, contents)) == 0:
-                self.review_manager.logger.error(f"Not a bib file? {file.name}")
+        self.review_manager.dataset.add_changes(path=Path("custom_prep_script.py"))
 
-        with open(file, encoding="utf8") as bibtex_file:
-            search_records_dict = self.review_manager.dataset.load_records_dict(
-                load_str=bibtex_file.read()
-            )
-        return list(search_records_dict.values())
+        prep_round = self.review_manager.settings.prep.prep_rounds[-1]
+        prep_round.prep_package_endpoints.append({"endpoint": "custom_prep_script"})
+        self.review_manager.save_settings()
+
+    def __load_prep_data(self, *, polish: bool = False) -> dict:
+        records_headers = self.review_manager.dataset.load_records_dict(
+            header_only=True
+        )
+        record_header_list = list(records_headers.values())
 
-    def __unescape_latex(self, *, input_str: str) -> str:
-        # Based on
-        # https://en.wikibooks.org/wiki/LaTeX/Special_Characters
+        pad = (
+            35
+            if (0 == len(record_header_list))
+            else min((max(len(x["ID"]) for x in record_header_list) + 2), 35)
+        )
 
-        for latex_char, repl_char in self.__LATEX_SPECIAL_CHAR_MAPPING.items():
-            input_str = input_str.replace(latex_char, repl_char)
+        r_states_to_prepare = [
+            colrev.record.RecordState.md_imported,
+            colrev.record.RecordState.md_needs_manual_preparation,
+        ]
+        if polish:
+            r_states_to_prepare = list(colrev.record.RecordState)
 
-        input_str = input_str.replace("\\emph", "")
-        input_str = input_str.replace("\\textit", "")
+        items = list(
+            self.review_manager.dataset.read_next_record(
+                conditions=[{"colrev_status": s} for s in r_states_to_prepare]
+            )
+        )
+        if polish and self.review_manager.in_ci_environment() and len(items) > 2000:
+            items = random.choices(items, k=2000)  # nosec
 
-        return input_str
+        prep_data = {
+            "nr_tasks": len(items),
+            "PAD": pad,
+            "items": list(items),
+        }
 
-    def __unescape_html(self, *, input_str: str) -> str:
-        input_str = html.unescape(input_str)
-        if "<" in input_str:
-            input_str = re.sub(r"<.*?>", "", input_str)
-        return input_str
+        return prep_data
 
-    def import_provenance(
+    def __get_preparation_data(
         self,
         *,
-        record: colrev.record.Record,
-    ) -> None:
-        """Set the provenance for an imported record"""
+        prep_round: colrev.settings.PrepRound,
+        debug_file: Optional[Path] = None,
+        debug_ids: str,
+        polish: bool = False,
+    ) -> list:
+        if self.debug_mode:
+            prepare_data = self.__load_prep_data_for_debug(
+                debug_ids=debug_ids, debug_file=debug_file
+            )
+            if prepare_data["nr_tasks"] == 0:
+                print("ID not found in history.")
+        else:
+            prepare_data = self.__load_prep_data(polish=polish)
 
-        def set_initial_import_provenance(*, record: colrev.record.Record) -> None:
-            # Initialize colrev_masterdata_provenance
-            colrev_masterdata_provenance, colrev_data_provenance = {}, {}
-
-            for key in record.data.keys():
-                if key in colrev.record.Record.identifying_field_keys:
-                    if key not in colrev_masterdata_provenance:
-                        colrev_masterdata_provenance[key] = {
-                            "source": record.data["colrev_origin"][0],
-                            "note": "",
-                        }
-                elif key not in colrev.record.Record.provenance_keys and key not in [
-                    "colrev_source_identifier",
-                    "ID",
-                    "ENTRYTYPE",
-                ]:
-                    colrev_data_provenance[key] = {
-                        "source": record.data["colrev_origin"][0],
-                        "note": "",
-                    }
+        if self.debug_mode:
+            self.review_manager.logger.info(
+                "In this round, we set the similarity "
+                f"threshold ({self.retrieval_similarity})"
+            )
+            input("Press Enter to continue")
+            self.review_manager.logger.info(
+                f"prepare_data: "
+                f"{self.review_manager.p_printer.pformat(prepare_data)}"
+            )
+        self.pad = prepare_data["PAD"]
+        items = prepare_data["items"]
+        prep_data = []
+        nr_items = len(items)
+        for item in items:
+            prep_data.append(
+                {
+                    "record": colrev.record.PrepRecord(data=item),
+                    "nr_items": nr_items,
+                    # Note : we cannot load endpoints here
+                    # because pathos/multiprocessing
+                    # does not support functions as parameters
+                    "prep_round_package_endpoints": prep_round.prep_package_endpoints,
+                    "prep_round": prep_round.name,
+                }
+            )
+        return prep_data
 
-            record.data["colrev_data_provenance"] = colrev_data_provenance
-            record.data["colrev_masterdata_provenance"] = colrev_masterdata_provenance
+    def __retrieve_records_from_history(
+        self,
+        *,
+        original_records: list[dict],
+        condition_state: colrev.record.RecordState,
+    ) -> list:
+        retrieved, prior_records = [], []
+        for (
+            prior_records_dict
+        ) in self.review_manager.dataset.load_records_from_history():
+            for prior_record in prior_records_dict.values():
+                if prior_record.get("colrev_status", "NA") != condition_state:
+                    continue
+                for original_record in original_records:
+                    if any(
+                        o in prior_record["colrev_origin"]
+                        for o in original_record["colrev_origin"]
+                    ):
+                        prior_records.append(prior_record)
+                        # only take the latest version (i.e., drop the record)
+                        # Note: only append the first one if origins were in
+                        # different records (after deduplication)
+                        retrieved.append(original_record["ID"])
+                original_records = [
+                    orec for orec in original_records if orec["ID"] not in retrieved
+                ]
 
-        if not record.masterdata_is_curated():
-            set_initial_import_provenance(record=record)
-            record.update_masterdata_provenance(qm=self.quality_model)
+        return prior_records
 
-    def __import_format_fields(self, *, record: colrev.record.Record) -> None:
-        # pylint: disable=duplicate-code
-        # For better readability of the git diff:
-        fields_to_process = [
-            "author",
-            "year",
-            "title",
-            "journal",
-            "booktitle",
-            "series",
-            "volume",
-            "number",
-            "pages",
-            "doi",
-            "abstract",
-        ]
+    def __load_prep_data_for_debug(
+        self, *, debug_ids: str, debug_file: Optional[Path] = None
+    ) -> dict:
+        if debug_file:
+            with open(debug_file, encoding="utf8") as target_db:
+                records_dict = self.review_manager.dataset.load_records_dict(
+                    load_str=target_db.read()
+                )
 
-        for field in fields_to_process:
-            if field in record.data:
-                if "\\" in record.data[field]:
-                    record.data[field] = self.__unescape_latex(
-                        input_str=record.data[field]
+            for record_dict in records_dict.values():
+                if colrev.record.RecordState.md_imported != record_dict.get(
+                    "state", ""
+                ):
+                    self.review_manager.logger.info(
+                        f"Setting colrev_status to md_imported {record_dict['ID']}"
                     )
-
-                if "<" in record.data[field]:
-                    record.data[field] = self.__unescape_html(
-                        input_str=record.data[field]
+                    record = colrev.record.Record(data=record_dict)
+                    record.set_status(
+                        target_state=colrev.record.RecordState.md_imported
                     )
+            debug_ids_list = list(records_dict.keys())
+            debug_ids = ",".join(debug_ids_list)
+            self.review_manager.logger.info("Imported record (retrieved from file)")
 
-                record.data[field] = (
-                    record.data[field]
-                    .replace("\n", " ")
-                    .rstrip()
-                    .lstrip()
-                    .replace("{", "")
-                    .replace("}", "")
+        else:
+            records = []
+            debug_ids_list = debug_ids.split(",")
+            original_records = list(
+                self.review_manager.dataset.read_next_record(
+                    conditions=[{"ID": ID} for ID in debug_ids_list]
                 )
-        if record.data.get("title", "UNKNOWN") != "UNKNOWN":
-            record.data["title"] = re.sub(r"\s+", " ", record.data["title"]).rstrip(".")
+            )
+            # self.review_manager.logger.info("Current record")
+            # self.review_manager.p_printer.pprint(original_records)
+            records = self.__retrieve_records_from_history(
+                original_records=original_records,
+                condition_state=colrev.record.RecordState.md_imported,
+            )
 
-        if "year" in record.data:
-            if str(record.data["year"]).endswith(".0"):
-                record.data["year"] = str(record.data["year"])[:-2]
-
-        if "pages" in record.data:
-            record.data["pages"] = record.data["pages"].replace("–", "--")
-            if record.data["pages"].count("-") == 1:
-                record.data["pages"] = record.data["pages"].replace("-", "--")
-            if record.data["pages"].lower() == "n.pag":
-                del record.data["pages"]
-
-    def __import_process_fields(self, *, record: colrev.record.Record) -> None:
-        # Consistently set keys to lower case
-        lower_keys = [k.lower() for k in list(record.data.keys())]
-        for key, n_key in zip(list(record.data.keys()), lower_keys):
-            if key not in ["ID", "ENTRYTYPE"]:
-                record.data[n_key] = record.data.pop(key)
-
-        self.__import_format_fields(record=record)
-
-        if "number" not in record.data and "issue" in record.data:
-            record.data.update(number=record.data["issue"])
-            del record.data["issue"]
-
-        if record.data.get("volume", "") == "ahead-of-print":
-            del record.data["volume"]
-        if record.data.get("number", "") == "ahead-of-print":
-            del record.data["number"]
-
-        if "language" in record.data:
-            if len(record.data["language"]) != 3:
-                self.language_service.unify_to_iso_639_3_language_codes(record=record)
-
-        if "url" in record.data:
-            if "login?url=https" in record.data["url"]:
-                record.data["url"] = record.data["url"][
-                    record.data["url"].find("login?url=https") + 10 :
-                ]
+        if len(records) == 0:
+            prep_data = {"nr_tasks": 0, "PAD": 0, "items": []}
+        else:
+            prep_data = {
+                "nr_tasks": len(debug_ids_list),
+                "PAD": len(debug_ids),
+                "items": records,
+            }
+        return prep_data
 
-    def __import_record(self, *, record_dict: dict) -> dict:
-        self.review_manager.logger.debug(
-            f'import_record {record_dict["ID"]}: '
-            # f"\n{self.review_manager.p_printer.pformat(record_dict)}\n\n"
-        )
+    def __setup_prep_round(
+        self, *, i: int, prep_round: colrev.settings.PrepRound
+    ) -> None:
+        # pylint: disable=redefined-outer-name,invalid-name
+        PREP_COUNTER = Value("i", 0)
+        with PREP_COUNTER.get_lock():
+            PREP_COUNTER.value = 0  # type: ignore
 
-        record = colrev.record.Record(data=record_dict)
-        if record.data["colrev_status"] == colrev.record.RecordState.md_retrieved:
-            self.__import_process_fields(record=record)
+        self.first_round = bool(i == 0)
 
-        if "doi" in record.data:
-            record.data.update(
-                doi=record.data["doi"].replace("http://dx.doi.org/", "").upper()
-            )
-        self.import_provenance(
-            record=record,
+        self.last_round = bool(
+            i == len(self.review_manager.settings.prep.prep_rounds) - 1
         )
 
-        if record.data["colrev_status"] in [
-            colrev.record.RecordState.md_retrieved,
-            colrev.record.RecordState.md_needs_manual_preparation,
-        ]:
-            record.set_status(target_state=colrev.record.RecordState.md_imported)
-
-        if record.check_potential_retracts():
-            self.review_manager.logger.info(
-                f"{colors.GREEN}Found paper retract: "
-                f"{record.data['ID']}{colors.END}"
+        # Note : we add the endpoint automatically (not as part of the settings.json)
+        # because it must always be executed at the end
+        if prep_round.name not in ["source_specific_prep", "exclusion"]:
+            prep_round.prep_package_endpoints.append(
+                {"endpoint": "colrev.update_metadata_status"}
             )
 
-        return record.get_data()
-
-    def __prep_records_for_import(
-        self, *, source: colrev.settings.SearchSource, search_records: list
-    ) -> list:
-        record_list = []
-        origin_prefix = source.get_origin_prefix()
-        for record in search_records:
-            for key in colrev.record.Record.provenance_keys + [
-                "screening_criteria",
-            ]:
-                if key == "colrev_status":
-                    continue
-                if key in record:
-                    del record[key]
+        if self.debug_mode:
+            print("\n\n")
 
-            record.update(colrev_origin=[f"{origin_prefix}/{record['ID']}"])
+        if len(self.review_manager.settings.prep.prep_rounds) > 1:
+            self.review_manager.logger.info(f"Prepare ({prep_round.name})")
 
-            # Drop empty fields
-            record = {k: v for k, v in record.items() if v}
+        self.retrieval_similarity = prep_round.similarity  # type: ignore
+        self.review_manager.report_logger.debug(
+            f"Set retrieval_similarity={self.retrieval_similarity}"
+        )
 
-            if source.endpoint == "colrev.local_index":
-                # Note : when importing a record, it always needs to be
-                # deduplicated against the other records in the repository
-                record.update(colrev_status=colrev.record.RecordState.md_prepared)
-                if "curation_ID" in record:
-                    record.update(
-                        colrev_masterdata_provenance={
-                            "CURATED": {
-                                "source": record["curation_ID"].split("#")[0],
-                                "note": "",
-                            }
-                        }
-                    )
-            else:
-                record.update(colrev_status=colrev.record.RecordState.md_retrieved)
+        required_prep_package_endpoints = list(prep_round.prep_package_endpoints)
+        required_prep_package_endpoints.append(
+            {"endpoint": "colrev.update_metadata_status"}
+        )
 
-            if "doi" in record:
-                formatted_doi = (
-                    record["doi"]
-                    .lower()
-                    .replace("https://", "http://")
-                    .replace("dx.doi.org", "doi.org")
-                    .replace("http://doi.org/", "")
-                    .upper()
+        package_manager = self.review_manager.get_package_manager()
+        self.prep_package_endpoints: dict[
+            str, typing.Any
+        ] = package_manager.load_packages(
+            package_type=colrev.env.package_manager.PackageEndpointType.prep,
+            selected_packages=required_prep_package_endpoints,
+            operation=self,
+            only_ci_supported=self.review_manager.in_ci_environment(),
+        )
+        non_available_endpoints = [
+            x["endpoint"].lower()
+            for x in required_prep_package_endpoints
+            if x["endpoint"].lower() not in self.prep_package_endpoints
+        ]
+        if non_available_endpoints:
+            if self.review_manager.in_ci_environment():
+                raise colrev_exceptions.ServiceNotAvailableException(
+                    dep=f"colrev prep ({','.join(non_available_endpoints)})",
+                    detailed_trace="prep not available in ci environment",
                 )
-                record.update(doi=formatted_doi)
-
-            self.review_manager.logger.debug(
-                f'append record {record["ID"]} '
-                # f"\n{self.review_manager.p_printer.pformat(record)}\n\n"
+            raise colrev_exceptions.ServiceNotAvailableException(
+                dep="colrev prep", detailed_trace="prep not available"
             )
-            record_list.append(record)
-        return record_list
 
-    def __get_search_records(self, *, source: colrev.settings.SearchSource) -> list:
-        search_records = []
-        if source.get_corresponding_bib_file().is_file():
-            search_records = self.__getbib(file=source.get_corresponding_bib_file())
-            self.review_manager.logger.debug(
-                f"Loaded {source.get_corresponding_bib_file().name} "
-                f"with {len(search_records)} records"
-            )
-        else:
-            self.review_manager.logger.debug(
-                f"Did not find bib file {source.get_corresponding_bib_file().name} "
-            )
-            return []
+        for endpoint_name, endpoint in self.prep_package_endpoints.items():
+            check_function = getattr(endpoint, "check_availability", None)
+            if callable(check_function):
+                self.review_manager.logger.debug(
+                    f"Check availability of {endpoint_name}"
+                )
+                endpoint.check_availability(source_operation=self)  # type: ignore
 
-        if len(search_records) == 0:
-            self.review_manager.logger.info(
-                f"{colors.GREEN}No records to load{colors.END}"
+    def __log_record_change_scores(
+        self, *, preparation_data: list, prepared_records: list
+    ) -> None:
+        for previous_record_item in preparation_data:
+            previous_record = previous_record_item["record"]
+            prepared_record = [
+                r for r in prepared_records if r["ID"] == previous_record.data["ID"]
+            ][0]
+
+            change = colrev.record.Record.get_record_change_score(
+                record_a=colrev.record.Record(data=prepared_record),
+                record_b=previous_record,
             )
-            return search_records
+            if change > 0.05:
+                self.review_manager.report_logger.info(
+                    f' {prepared_record["ID"]} ' + f"Change score: {round(change, 2)}"
+                )
 
-        nr_in_bib = self.review_manager.dataset.get_nr_in_bib(
-            file_path=source.get_corresponding_bib_file()
+    def __log_details(self, *, prepared_records: list) -> None:
+        nr_recs = len(
+            [
+                record
+                for record in prepared_records
+                if "CURATED" in record["colrev_masterdata_provenance"]
+            ]
         )
-        if len(search_records) < nr_in_bib:
-            self.review_manager.logger.error(
-                "broken bib file (not imported all records)"
-            )
-            with open(source.get_corresponding_bib_file(), encoding="utf8") as file:
-                line = file.readline()
-                while line:
-                    if "@" in line[:3]:
-                        record_id = line[line.find("{") + 1 : line.rfind(",")]
-                        if record_id not in [x["ID"] for x in search_records]:
-                            self.review_manager.logger.error(
-                                f"{record_id} not imported"
-                            )
-                    line = file.readline()
-        return search_records
-
-    def __load_source_records(
-        self, *, source: colrev.settings.SearchSource, keep_ids: bool
-    ) -> None:
-        search_records = self.__get_search_records(source=source)
 
-        record_list = self.__prep_records_for_import(
-            source=source, search_records=search_records
+        self.review_manager.logger.info(
+            "Overall curated (✔)".ljust(29)
+            + f"{colors.GREEN}{nr_recs}{colors.END}".rjust(20, " ")
+            + " records"
         )
 
-        imported_origins = self.__get_currently_imported_origin_list()
-        record_list = [
-            x for x in record_list if x["colrev_origin"][0] not in imported_origins
-        ]
-        source.setup_for_load(
-            record_list=record_list, imported_origins=imported_origins
+        nr_recs = len(
+            [
+                record
+                for record in prepared_records
+                if record["colrev_status"] == colrev.record.RecordState.md_prepared
+            ]
         )
-        if len(search_records) == 0:
-            return
 
-        records = self.review_manager.dataset.load_records_dict()
-        for source_record in source.source_records_list:
-            source_record = self.__import_record(record_dict=source_record)
+        self.review_manager.logger.info(
+            "Overall md_prepared".ljust(29)
+            + f"{colors.GREEN}{nr_recs}{colors.END}".rjust(20, " ")
+            + " records"
+        )
 
-            # Make sure IDs are unique / do not replace existing records
-            order = 0
-            letters = list(string.ascii_lowercase)
-            next_unique_id = source_record["ID"]
-            appends: list = []
-            while next_unique_id in records:
-                if len(appends) == 0:
-                    order += 1
-                    appends = list(itertools.product(letters, repeat=order))
-                next_unique_id = source_record["ID"] + "".join(list(appends.pop(0)))
-            source_record["ID"] = next_unique_id
-            records[source_record["ID"]] = source_record
+        nr_recs = len(
+            [
+                record
+                for record in prepared_records
+                if record["colrev_status"]
+                == colrev.record.RecordState.md_needs_manual_preparation
+            ]
+        )
+        if nr_recs > 0:
+            self.review_manager.logger.info(
+                "To prepare manually".ljust(29)
+                + f"{colors.ORANGE}{nr_recs}{colors.END}".rjust(20, " ")
+                + " records"
+            )
 
+        nr_recs = len(
+            [
+                record
+                for record in prepared_records
+                if record["colrev_status"]
+                == colrev.record.RecordState.rev_prescreen_excluded
+            ]
+        )
+        if nr_recs > 0:
             self.review_manager.logger.info(
-                f" {colors.GREEN}{source_record['ID']}".ljust(46)
-                + f"md_retrieved →  {source_record['colrev_status']}{colors.END}"
+                "Records prescreen-excluded".ljust(29)
+                + f"{colors.RED}{nr_recs}{colors.END}".rjust(20, " ")
             )
 
-        self.__check_bib_file(source=source, records=records)
+    def skip_prep(self) -> None:
+        """Skip the preparation"""
+
+        records = self.review_manager.dataset.load_records_dict()
+
+        for record_dict in records.values():
+            if colrev.record.RecordState.md_imported == record_dict["colrev_status"]:
+                record = colrev.record.Record(data=record_dict)
+                record.set_status(target_state=colrev.record.RecordState.md_prepared)
         self.review_manager.dataset.save_records_dict(records=records)
+        self.review_manager.dataset.add_record_changes()
+        self.review_manager.create_commit(msg="Skip prep")
 
-        if keep_ids:
-            self.review_manager.logger.warning(
-                "Not yet fully implemented. Need to check/resolve ID duplicates."
-            )
+    def __initialize_prep(self, *, polish: bool, debug_ids: str, cpu: int) -> None:
+        if not polish:
+            self.review_manager.logger.info("Prep")
         else:
-            self.review_manager.logger.debug("Set IDs")
-            records = self.review_manager.dataset.set_ids(
-                records=records,
-                selected_ids=[r["ID"] for r in source.source_records_list],
+            self.review_manager.logger.info("Prep (polish mode)")
+        self.review_manager.logger.info(
+            "Prep completes and corrects record metadata based on APIs and preparation rules."
+        )
+        self.polish = polish
+        if self.polish:
+            self.review_manager.logger.info(
+                "Polish mode: consider all records but prevent state transitions."
             )
+        self.review_manager.logger.info(
+            "See https://colrev.readthedocs.io/en/latest/manual/metadata_retrieval/prep.html"
+        )
 
+        if self.debug_mode:
+            print("\n\n\n")
+            self.review_manager.logger.info("Start debug prep\n")
+            self.review_manager.logger.info(
+                "The debugger will replay the preparation procedures"
+                " step-by-step, allow you to identify potential errors, trace them to "
+                "their colrev_origin and correct them."
+            )
+            input("\nPress Enter to continue")
+            print("\n\n")
+
+        if debug_ids != "NA":
+            self.debug_mode = True
+
+        self.__cpu = cpu
+
+        # Note: for unit testing, we use a simple loop (instead of parallel)
+        # to ensure that the IDs of feed records don't change
+        unit_testing = "test_prep" == inspect.stack()[1][3]
+        if unit_testing or self.debug_mode:
+            self.__cpu = 1
+
+    def __prep_packages_ram_heavy(self, prep_round: colrev.settings.PrepRound) -> bool:
+        prep_pe_names = [r["endpoint"] for r in prep_round.prep_package_endpoints]
+        ram_reavy = "colrev.exclude_languages" in prep_pe_names  # type: ignore
         self.review_manager.logger.info(
-            "New records loaded".ljust(38) + f"{source.to_import} records"
+            "Info: The language detector requires RAM and may take longer"
         )
+        return ram_reavy
 
-        self.review_manager.dataset.add_setting_changes()
-        self.review_manager.dataset.add_changes(
-            path=source.get_corresponding_bib_file()
+    def __get_prep_pool(
+        self, *, prep_round: colrev.settings.PrepRound
+    ) -> mp.pool.ThreadPool:
+        if self.__prep_packages_ram_heavy(prep_round=prep_round):
+            pool = Pool(mp.cpu_count() // 2)
+        else:
+            # Note : if we use too many CPUS,
+            # a "too many open files" exception is thrown
+            pool = Pool(self.__cpu)
+        self.review_manager.logger.info(
+            "Info: ✔ = quality-assured by CoLRev community curators"
         )
-        self.review_manager.dataset.add_changes(path=source.filename)
-        self.review_manager.dataset.add_record_changes()
+        return pool
 
-    def __validate_load(self, *, source: colrev.settings.SearchSource) -> None:
-        imported_origins = self.__get_currently_imported_origin_list()
-        imported = len(imported_origins) - source.len_before
-
-        if imported != source.to_import:
-            # Note : for diagnostics, it is easier if we complete the process
-            # and create the commit (instead of raising an exception)
-            self.review_manager.logger.error(f"len_before: {source.len_before}")
-            self.review_manager.logger.error(f"len_after: {len(imported_origins)}")
+    def __create_prep_commit(
+        self,
+        *,
+        previous_preparation_data: list,
+        prepared_records: list,
+        prep_round: colrev.settings.PrepRound,
+    ) -> None:
+        self.__log_record_change_scores(
+            preparation_data=previous_preparation_data,
+            prepared_records=prepared_records,
+        )
 
-            origins_to_import = [o["colrev_origin"] for o in source.source_records_list]
-            if source.to_import - imported > 0:
-                self.review_manager.logger.error(
-                    f"{colors.RED}PROBLEM: delta: "
-                    f"{source.to_import - imported} records missing{colors.END}"
-                )
+        if not self.debug_mode:
+            self.review_manager.dataset.save_records_dict(
+                records={r["ID"]: r for r in prepared_records}, partial=True
+            )
 
-                missing_origins = [
-                    o for o in origins_to_import if o not in imported_origins
-                ]
-                self.review_manager.logger.error(
-                    f"{colors.RED}Records not yet imported: {missing_origins}{colors.END}"
-                )
-            else:
-                self.review_manager.logger.error(
-                    f"{colors.RED}PROBLEM: "
-                    f"{source.to_import - imported} records too much{colors.END}"
-                )
+            self.__log_details(prepared_records=prepared_records)
 
-    def __save_records(self, *, records: dict, corresponding_bib_file: Path) -> None:
-        def fix_keys(*, records: dict) -> dict:
-            for record in records.values():
-                record = {
-                    re.sub("[0-9a-zA-Z_]+", "1", k.replace(" ", "_")): v
-                    for k, v in record.items()
-                }
-            return records
-
-        def set_incremental_ids(*, records: dict) -> dict:
-            # if IDs to set for some records
-            if 0 != len([r for r in records if "ID" not in r]):
-                i = 1
-                for record in records.values():
-                    if "ID" not in record:
-                        if "UT_(Unique_WOS_ID)" in record:
-                            record["ID"] = record["UT_(Unique_WOS_ID)"].replace(
-                                ":", "_"
-                            )
-                        else:
-                            record["ID"] = f"{i+1}".rjust(10, "0")
-                        i += 1
-            return records
-
-        def drop_empty_fields(*, records: dict) -> dict:
-            for record_id in records:
-                records[record_id] = {
-                    k: v for k, v in records[record_id].items() if v is not None
-                }
-                records[record_id] = {
-                    k: v for k, v in records[record_id].items() if v != "nan"
-                }
-            return records
+            self.review_manager.create_commit(
+                msg=f"Prepare records ({prep_round.name})",
+            )
+            self.__prep_commit_id = (
+                self.review_manager.dataset.get_repo().head.commit.hexsha
+            )
+            if not self.review_manager.high_level_operation:
+                print()
+        self.review_manager.reset_report_logger()
 
-        def drop_fields(*, records: dict) -> dict:
-            for record_id in records:
-                records[record_id] = {
-                    k: v
-                    for k, v in records[record_id].items()
-                    if k not in ["colrev_status", "colrev_masterdata_provenance"]
-                }
-            return records
+        self.__print_stats()
 
-        if len(records) == 0:
-            self.review_manager.report_logger.debug("No records loaded")
-            self.review_manager.logger.debug("No records loaded")
-            return
+    def __post_prep(self) -> None:
+        if not self.review_manager.high_level_operation:
+            print()
 
-        records = fix_keys(records=records)
-        records = set_incremental_ids(records=records)
-        records = drop_empty_fields(records=records)
-        records = drop_fields(records=records)
+        self.review_manager.logger.info("To validate the changes, use")
 
-        self.review_manager.dataset.save_records_dict_to_file(
-            records=records, save_path=corresponding_bib_file
+        self.review_manager.logger.info(
+            f"{colors.ORANGE}colrev validate {self.__prep_commit_id}{colors.END}"
         )
+        if not self.review_manager.high_level_operation:
+            print()
 
-    def __load_active_sources(
-        self, *, new_sources: typing.List[colrev.settings.SearchSource]
-    ) -> list:
-        checker = self.review_manager.get_checker()
-        checker.check_sources()
-        sources = []
-        for source in self.review_manager.settings.sources:
-            sources.append(source)
-        for source in new_sources:
-            if source.filename not in [s.filename for s in sources]:
-                sources.append(source)
-        return sources
+        self.review_manager.logger.info(
+            f"{colors.GREEN}Completed prep operation{colors.END}"
+        )
+        if self.review_manager.in_ci_environment():
+            print("\n\n")
 
+    @colrev.operation.Operation.decorate()
     def main(
         self,
         *,
-        new_sources: typing.List[colrev.settings.SearchSource],
         keep_ids: bool = False,
-        combine_commits: bool = False,
+        debug_ids: str = "NA",
+        debug_file: Optional[Path] = None,
+        cpu: int = 4,
+        polish: bool = False,
     ) -> None:
-        """Load records (main entrypoint)"""
+        """Preparation of records (main entrypoint)"""
 
-        if not self.review_manager.high_level_operation:
-            print()
-        git_repo = self.review_manager.dataset.get_repo()
-        part_exact_call = self.review_manager.exact_call
-        for source in self.__load_active_sources(new_sources=new_sources):
-            try:
-                self.review_manager.logger.info(f"Load {source.filename}")
+        self.__initialize_prep(polish=polish, debug_ids=debug_ids, cpu=cpu)
 
-                # Add to settings (if new filename)
-                if source.filename not in [
-                    s.filename for s in self.review_manager.settings.sources
-                ]:
-                    self.review_manager.settings.sources.append(source)
-                    self.review_manager.save_settings()
-                    # Add files that were renamed (removed)
-                    for obj in git_repo.index.diff(None).iter_change_type("D"):
-                        if source.filename.stem in obj.b_path:
-                            self.review_manager.dataset.add_changes(
-                                path=Path(obj.b_path), remove=True
-                            )
-
-                # 1. convert to bib and fix format (if necessary)
-                load_conversion_package_endpoint_dict = self.package_manager.load_packages(
-                    package_type=colrev.env.package_manager.PackageEndpointType.load_conversion,
-                    selected_packages=[source.load_conversion_package_endpoint],
-                    operation=self,
-                )
-
-                load_conversion_package_endpoint = (
-                    load_conversion_package_endpoint_dict[
-                        source.load_conversion_package_endpoint["endpoint"]
-                    ]
-                )
-                records = load_conversion_package_endpoint.load(self, source)  # type: ignore
-                self.__save_records(
-                    records=records,
-                    corresponding_bib_file=source.get_corresponding_bib_file(),
+        try:
+            for i, prep_round in enumerate(
+                self.review_manager.settings.prep.prep_rounds
+            ):
+                self.__setup_prep_round(i=i, prep_round=prep_round)
+
+                preparation_data = self.__get_preparation_data(
+                    prep_round=prep_round,
+                    debug_file=debug_file,
+                    debug_ids=debug_ids,
+                    polish=polish,
                 )
+                previous_preparation_data = deepcopy(preparation_data)
 
-                # 2. resolve non-unique IDs (if any)
-                self.__resolve_non_unique_ids(source=source)
-
-                # 3. load and add records to data/records.bib
-                self.__load_source_records(source=source, keep_ids=keep_ids)
-                if (
-                    0 == getattr(source, "to_import", 0)
-                    and not self.review_manager.high_level_operation
-                ):
+                if len(preparation_data) == 0:
+                    self.review_manager.logger.info("No records to prepare.")
                     print()
+                    return
 
-                # 4. validate load
-                self.__validate_load(source=source)
-
-                stashed = "No local changes to save" != git_repo.git.stash(
-                    "push", "--keep-index"
+                if self.__cpu == 1:
+                    # Note: preparation_data is not turned into a list of records.
+                    prepared_records = []
+                    for item in preparation_data:
+                        record = self.prepare(item)
+                        prepared_records.append(record)
+                else:
+                    pool = self.__get_prep_pool(prep_round=prep_round)
+                    prepared_records = pool.map(self.prepare, preparation_data)
+                    pool.close()
+                    pool.join()
+
+                self.__create_prep_commit(
+                    previous_preparation_data=previous_preparation_data,
+                    prepared_records=prepared_records,
+                    prep_round=prep_round,
                 )
 
-                if not combine_commits:
-                    self.review_manager.exact_call = (
-                        f"{part_exact_call} -s {source.filename.name}"
-                    )
-                    self.review_manager.create_commit(
-                        msg=f"Load {source.filename.name}",
-                    )
-                if stashed:
-                    git_repo.git.stash("pop")
-                if not self.review_manager.high_level_operation:
-                    print()
-            except colrev_exceptions.ImportException as exc:
-                print(exc)
-
-        if combine_commits and self.review_manager.dataset.has_changes():
-            self.review_manager.create_commit(msg="Load (multiple)")
+        except requests_ConnectionError as exc:
+            if "OSError(24, 'Too many open files" in str(exc):
+                raise colrev_exceptions.ServiceNotAvailableException(
+                    "Too many files opened (OSError, Errno24). "
+                    "To use a smaller number of parallel processes, run colrev prep --cpu 1"
+                ) from exc
+            raise exc
+
+        except OSError as exc:
+            if 24 == exc.errno:
+                raise colrev_exceptions.ServiceNotAvailableException(
+                    "Too many files opened (OSError, Errno24). "
+                    "To use a smaller number of parallel processes, run colrev prep --cpu 1"
+                ) from exc
+            raise exc
+
+        if not keep_ids and not self.debug_mode and not self.polish:
+            self.review_manager.logger.info("Set record IDs")
+            self.review_manager.dataset.set_ids()
+            self.review_manager.create_commit(msg="Set IDs")
 
-        self.review_manager.logger.info(
-            f"{colors.GREEN}Completed load operation{colors.END}"
-        )
-        if self.review_manager.in_ci_environment():
-            print("\n\n")
+        self.__post_prep()
```

### Comparing `colrev-0.9.0/colrev/ops/merge.py` & `colrev-0.9.2/colrev/ops/merge.py`

 * *Files 1% similar despite different names*

```diff
@@ -80,14 +80,15 @@
                 )
                 changed_records.append(f"{current_record_id}: " f"{comparison_diff}")
         if changed_records:
             non_status_changes.append({"changed record fields:": changed_records})
 
         return non_status_changes
 
+    @colrev.operation.Operation.decorate()
     def main(self, *, branch: str) -> None:
         """Merge branches of a CoLRev project (main entrypoint)"""
 
         # pylint: disable=too-many-locals
         # pylint: disable=too-many-statements
 
         git_repo = self.review_manager.dataset.get_repo()
```

### Comparing `colrev-0.9.0/colrev/ops/pdf_get.py` & `colrev-0.9.2/colrev/ops/pdf_get.py`

 * *Files 1% similar despite different names*

```diff
@@ -51,43 +51,43 @@
 
     def copy_pdfs_to_repo(self) -> None:
         """Copy the PDFs to the repository"""
         self.review_manager.logger.info("Copy PDFs to dir")
         records = self.review_manager.dataset.load_records_dict()
 
         for record_dict in records.values():
-            if "file" in record_dict:
-                fpath = Path(record_dict["file"])
-                new_fpath = fpath.absolute()
-                if fpath.is_symlink():
-                    linked_file = fpath.resolve()
-                    if linked_file.is_file():
-                        fpath.unlink()
-                        shutil.copyfile(linked_file, new_fpath)
-                        self.review_manager.logger.info(
-                            f' {colors.GREEN}copied PDF for {record_dict["ID"]} {colors.END}'
-                        )
+            if "file" not in record_dict:
+                continue
+            fpath = Path(record_dict["file"])
+            new_fpath = fpath.absolute()
+            if fpath.is_symlink():
+                linked_file = fpath.resolve()
+                if linked_file.is_file():
+                    fpath.unlink()
+                    shutil.copyfile(linked_file, new_fpath)
+                    self.review_manager.logger.info(
+                        f' {colors.GREEN}copied PDF for {record_dict["ID"]} {colors.END}'
+                    )
 
-                elif new_fpath.is_file():
-                    if self.review_manager.verbose_mode:
-                        self.review_manager.logger.info(
-                            f'No need to copy PDF - already exits ({record_dict["ID"]})'
-                        )
+            elif new_fpath.is_file() and self.review_manager.verbose_mode:
+                self.review_manager.logger.info(
+                    f'No need to copy PDF - already exits ({record_dict["ID"]})'
+                )
 
     def link_pdf(self, *, record: colrev.record.Record) -> colrev.record.Record:
         """Link the PDF in its record (should be {ID}.pdf)"""
 
         pdf_filepath = self.review_manager.PDF_DIR_RELATIVE / Path(
             f"{record.data['ID']}.pdf"
         )
         if pdf_filepath.is_file() and str(pdf_filepath) != record.data.get(
             "file", "NA"
         ):
             record.update_field(key="file", value=str(pdf_filepath), source="link_pdf")
-            self.import_file(record=record)
+            self.import_pdf(record=record)
             if (
                 colrev.record.RecordState.rev_prescreen_included
                 == record.data["colrev_status"]
             ):
                 record.set_status(target_state=colrev.record.RecordState.pdf_imported)
 
         return record
@@ -113,35 +113,33 @@
         else:
             target_filepath = self.review_manager.PDF_DIR_RELATIVE / Path(
                 f"{record.data['ID']}.pdf"
             )
 
         return target_filepath
 
-    def import_file(self, *, record: colrev.record.Record) -> None:
+    def import_pdf(self, *, record: colrev.record.Record) -> None:
         """Import a file (PDF) and copy/symlink it"""
         # self.review_manager.pdf_dir.mkdir(exist_ok=True)
         # new_fp = self.review_manager.PDF_DIR_RELATIVE / Path(record.data["ID"] + ".pdf").name
         new_fp = self.get_target_filepath(record=record)
         original_fp = Path(record.data["file"])
 
-        if new_fp != original_fp:
+        if new_fp != original_fp and not new_fp.is_file():
             new_fp.parents[0].mkdir(exist_ok=True, parents=True)
             if (
                 colrev.settings.PDFPathType.symlink
                 == self.review_manager.settings.pdf_get.pdf_path_type
             ):
-                if not new_fp.is_file():
-                    new_fp.symlink_to(original_fp)
+                new_fp.symlink_to(original_fp)
             elif (
                 colrev.settings.PDFPathType.copy
                 == self.review_manager.settings.pdf_get.pdf_path_type
             ):
-                if not new_fp.is_file():
-                    shutil.copyfile(original_fp, new_fp.resolve())
+                shutil.copyfile(original_fp, new_fp.resolve())
             # Note : else: leave absolute paths
 
         record.data["file"] = str(new_fp)
 
     # Note : no named arguments (multiprocessing)
     def get_pdf(self, item: dict) -> dict:
         """Get PDFs (based on the package endpoints in the settings)"""
@@ -210,15 +208,15 @@
                 + f"rev_prescreen_included → pdf_prepared{colors.END}"
             )
 
             record.data.update(colrev_status=colrev.record.RecordState.pdf_prepared)
 
         return record.get_data()
 
-    def __relink_pdf_files(
+    def __relink_pdfs(
         self,
         *,
         records: typing.Dict[str, typing.Dict],
     ) -> typing.Dict[str, typing.Dict]:
         # pylint: disable=too-many-branches
 
         # Relink files in source file
@@ -296,22 +294,22 @@
                     records=source_records_dict, save_path=source.filename
                 )
 
             self.review_manager.dataset.add_changes(path=source.filename)
 
         return records
 
-    def relink_files(self) -> None:
+    def relink_pdfs(self) -> None:
         """Relink record files to the corresponding PDFs (if available)"""
 
         self.review_manager.logger.info(
             "Checking PDFs in same directory to reassig when the cpid is identical"
         )
         records = self.review_manager.dataset.load_records_dict()
-        records = self.__relink_pdf_files(records=records)
+        records = self.__relink_pdfs(records=records)
 
         self.review_manager.dataset.save_records_dict(records=records)
 
         self.review_manager.dataset.add_record_changes()
         self.review_manager.create_commit(msg="Relink PDFs")
 
     def check_existing_unlinked_pdfs(
@@ -369,15 +367,15 @@
 
                         record = colrev.record.Record(data=max_sim_record)
                         record.update_field(
                             key="file",
                             value=str(file),
                             source="linking-available-files",
                         )
-                        self.import_file(record=record)
+                        self.import_pdf(record=record)
                         if (
                             colrev.record.RecordState.rev_prescreen_included
                             == record.data["colrev_status"]
                         ):
                             record.set_status(
                                 target_state=colrev.record.RecordState.pdf_imported
                             )
@@ -552,15 +550,15 @@
             not_retrieved_string += f"{colors.ORANGE}"
             not_retrieved_string += f"{self.not_retrieved}".rjust(6, " ")
             not_retrieved_string += f"{colors.END} PDFs"
 
         self.review_manager.logger.info(retrieved_string)
         self.review_manager.logger.info(not_retrieved_string)
 
-    def __set_status_if_file_linked(self, *, records: dict) -> dict:
+    def __set_status_if_pdf_linked(self, *, records: dict) -> dict:
         for record_dict in records.values():
             if record_dict["colrev_status"] in [
                 colrev.record.RecordState.rev_prescreen_included,
                 colrev.record.RecordState.pdf_needs_manual_retrieval,
             ]:
                 record = colrev.record.Record(data=record_dict)
                 if "file" in record_dict:
@@ -600,14 +598,15 @@
 
         self.review_manager.settings.pdf_get.pdf_get_man_package_endpoints.append(
             {"endpoint": "custom_pdf_get_script"}
         )
 
         self.review_manager.save_settings()
 
+    @colrev.operation.Operation.decorate()
     def main(self) -> None:
         """Get PDFs (main entrypoint)"""
 
         if self.review_manager.in_ci_environment():
             raise colrev_exceptions.ServiceNotAvailableException(
                 dep="colrev pdf-prep",
                 detailed_trace="pdf-prep not available in ci environment",
@@ -622,15 +621,15 @@
             f"({colors.ORANGE}colrev pdfs --dir{colors.END})"
         )
         self.review_manager.logger.info(
             "See https://colrev.readthedocs.io/en/latest/manual/pdf_retrieval/pdf_get.html"
         )
 
         records = self.review_manager.dataset.load_records_dict()
-        records = self.__set_status_if_file_linked(records=records)
+        records = self.__set_status_if_pdf_linked(records=records)
         records = self.check_existing_unlinked_pdfs(records=records)
 
         pdf_get_data = self.__get_data()
 
         if pdf_get_data["nr_tasks"] == 0:
             self.review_manager.logger.info("No additional pdfs to retrieve")
         else:
```

### Comparing `colrev-0.9.0/colrev/ops/pdf_get_man.py` & `colrev-0.9.2/colrev/ops/pdf_get_man.py`

 * *Files 1% similar despite different names*

```diff
@@ -181,14 +181,15 @@
 
         record_dict = record.get_data()
         self.review_manager.dataset.save_records_dict(
             records={record_dict["ID"]: record_dict}, partial=True
         )
         self.review_manager.dataset.add_record_changes()
 
+    @colrev.operation.Operation.decorate()
     def main(self) -> None:
         """Get PDFs manually (main entrypoint)"""
 
         if self.review_manager.in_ci_environment():
             raise colrev_exceptions.ServiceNotAvailableException(
                 dep="colrev pdf-get-man",
                 detailed_trace="pdf-get-man not available in ci environment",
```

### Comparing `colrev-0.9.0/colrev/ops/pdf_prep.py` & `colrev-0.9.2/colrev/ops/pdf_prep.py`

 * *Files 1% similar despite different names*

```diff
@@ -367,19 +367,20 @@
                     pdf_prep_operation=self,
                     record=colrev.record.Record(data=record_dict),
                     pad=0,
                 )
             except colrev_exceptions.TEIException:
                 self.review_manager.logger.error("Eror generating TEI")
 
+    @colrev.operation.Operation.decorate()
     def main(
         self,
         *,
         reprocess: bool = False,
-        batch_size: int,
+        batch_size: int = 0,
     ) -> None:
         """Prepare PDFs (main entrypoint)"""
 
         if self.review_manager.in_ci_environment():
             raise colrev_exceptions.ServiceNotAvailableException(
                 dep="colrev pdf-prep",
                 detailed_trace="pdf-prep not available in ci environment",
```

### Comparing `colrev-0.9.0/colrev/ops/pdf_prep_man.py` & `colrev-0.9.2/colrev/ops/pdf_prep_man.py`

 * *Files 1% similar despite different names*

```diff
@@ -321,14 +321,15 @@
         self.review_manager.dataset.save_records_dict(
             records={record_dict["ID"]: record_dict}, partial=True
         )
         self.review_manager.dataset.add_changes(
             path=self.review_manager.dataset.RECORDS_FILE_RELATIVE
         )
 
+    @colrev.operation.Operation.decorate()
     def main(self) -> None:
         """Prepare PDFs manually (main entrypoint)"""
 
         if self.review_manager.in_ci_environment():
             raise colrev_exceptions.ServiceNotAvailableException(
                 dep="colrev pdf-prep-man",
                 detailed_trace="pdf-prep-man not available in ci environment",
```

### Comparing `colrev-0.9.0/colrev/ops/prep_man.py` & `colrev-0.9.2/colrev/ops/prep_man.py`

 * *Files 0% similar despite different names*

```diff
@@ -257,14 +257,15 @@
         record_dict = record.get_data()
 
         self.review_manager.dataset.save_records_dict(
             records={record_dict["ID"]: record_dict}, partial=True
         )
         self.review_manager.dataset.add_record_changes()
 
+    @colrev.operation.Operation.decorate()
     def main(self) -> None:
         """Manually prepare records (main entrypoint)"""
 
         if self.review_manager.in_ci_environment():
             raise colrev_exceptions.ServiceNotAvailableException(
                 dep="colrev prep-man",
                 detailed_trace="prep-man not available in ci environment",
```

### Comparing `colrev-0.9.0/colrev/ops/prescreen.py` & `colrev-0.9.2/colrev/ops/prescreen.py`

 * *Files 9% similar despite different names*

```diff
@@ -73,14 +73,15 @@
                     f"{colors.ORANGE}colrev screen --include_all{colors.END} instead"
                 )
             else:
                 self.review_manager.logger.warning("No records to prescreen.")
             return False
         return True
 
+    @colrev.operation.Operation.decorate()
     def include_all_in_prescreen(self, *, persist: bool) -> None:
         """Include all records in the prescreen"""
 
         if persist:
             self.review_manager.settings.prescreen.prescreen_package_endpoints = []
             self.review_manager.save_settings()
 
@@ -304,15 +305,37 @@
             )
             self.review_manager.dataset.save_records_dict(
                 records={record.data["ID"]: record.get_data()}, partial=True
             )
 
         self.review_manager.dataset.add_record_changes()
 
-    def main(self, *, split_str: str) -> None:
+    def __auto_include(self, *, records: dict) -> list:
+        selected_auto_include_ids = [
+            r["ID"]
+            for r in records.values()
+            if colrev.record.RecordState.md_processed == r["colrev_status"]
+            and r.get("include_flag", "0") == "1"
+        ]
+        if not selected_auto_include_ids:
+            return selected_auto_include_ids
+        self.review_manager.logger.info(
+            f"{colors.GREEN}Automatically including records with include_flag{colors.END}"
+        )
+        for record_dict in records.values():
+            if record_dict["ID"] not in selected_auto_include_ids:
+                continue
+            self.prescreen(
+                record=colrev.record.Record(data=record_dict),
+                prescreen_inclusion=True,
+            )
+        return selected_auto_include_ids
+
+    @colrev.operation.Operation.decorate()
+    def main(self, *, split_str: str = "NA") -> None:
         """Prescreen records (main entrypoint)"""
 
         # pylint: disable=duplicate-code
         split = []
         if split_str != "NA":
             split = split_str.split(",")
             if "" in split:
@@ -355,17 +378,20 @@
 
             endpoint = endpoint_dict[prescreen_package_endpoint["endpoint"]]
 
             selected_record_ids = [
                 r["ID"]
                 for r in records.values()
                 if colrev.record.RecordState.md_processed == r["colrev_status"]
+                and not r.get("include_flag", "0") == "1"
             ]
             endpoint.run_prescreen(self, records, split)  # type: ignore
 
-            self.__print_stats(selected_record_ids=selected_record_ids)
+            selected_auto_include_ids = self.__auto_include(records=records)
+
+            self.__print_stats(
+                selected_record_ids=selected_record_ids + selected_auto_include_ids
+            )
 
         self.review_manager.logger.info(
             "%sCompleted prescreen operation%s", colors.GREEN, colors.END
         )
-        if self.review_manager.in_ci_environment():
-            print("\n\n")
```

### Comparing `colrev-0.9.0/colrev/ops/pull.py` & `colrev-0.9.2/colrev/ops/pull.py`

 * *Files 6% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 
     def __init__(self, *, review_manager: colrev.review_manager.ReviewManager) -> None:
         super().__init__(
             review_manager=review_manager,
             operations_type=colrev.operation.OperationsType.format,
         )
 
+    @colrev.operation.Operation.decorate()
     def main(self) -> None:
         """Pull the CoLRev project and records (main entrypoint)"""
 
         self.__pull_project()
 
     def __pull_project(self) -> None:
         try:
```

### Comparing `colrev-0.9.0/colrev/ops/push.py` & `colrev-0.9.2/colrev/ops/push.py`

 * *Files 1% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 
     def __init__(self, *, review_manager: colrev.review_manager.ReviewManager) -> None:
         super().__init__(
             review_manager=review_manager,
             operations_type=colrev.operation.OperationsType.check,
         )
 
+    @colrev.operation.Operation.decorate()
     def main(
         self,
         *,
         records_only: bool = False,
         project_only: bool = False,
         all_records: bool = False,
     ) -> None:
```

### Comparing `colrev-0.9.0/colrev/ops/remove.py` & `colrev-0.9.2/colrev/ops/remove.py`

 * *Files 5% similar despite different names*

```diff
@@ -25,14 +25,15 @@
     ) -> None:
         super().__init__(
             review_manager=review_manager,
             operations_type=colrev.operation.OperationsType.check,
             notify_state_transition_operation=False,
         )
 
+    @colrev.operation.Operation.decorate()
     def remove_records(self, *, ids: str) -> None:
         """Remove records from CoLRev project."""
 
         records = self.review_manager.dataset.load_records_dict()
 
         for record_id in ids.split(","):
             if record_id in records:
```

### Comparing `colrev-0.9.0/colrev/ops/repare.py` & `colrev-0.9.2/colrev/ops/repare.py`

 * *Files 1% similar despite different names*

```diff
@@ -51,15 +51,15 @@
             if "file" in retrieved_record:
                 record.update_field(
                     key="file",
                     value=str(retrieved_record["file"]),
                     source="local_index",
                     append_edit=False,
                 )
-                self.pdf_get_operation.import_file(record=record)
+                self.pdf_get_operation.import_pdf(record=record)
                 if "fulltext" in retrieved_record:
                     del retrieved_record["fulltext"]
                 self.review_manager.logger.info(
                     f" fix broken symlink: {record.data['ID']}"
                 )
             else:
                 self.review_manager.logger.debug(
@@ -336,14 +336,15 @@
                         del curation_recs[record_id]
 
             self.review_manager.dataset.save_records_dict_to_file(
                 records=curation_recs, save_path=search_source.filename
             )
             self.review_manager.dataset.add_changes(path=search_source.filename)
 
+    @colrev.operation.Operation.decorate()
     def main(self) -> None:
         """Repare a CoLRev project (main entrypoint)"""
 
         # Try: open settings, except: notify & start repare
 
         # ...
```

### Comparing `colrev-0.9.0/colrev/ops/review_types.py` & `colrev-0.9.2/colrev/ops/review_types.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/screen.py` & `colrev-0.9.2/colrev/ops/screen.py`

 * *Files 4% similar despite different names*

```diff
@@ -340,35 +340,74 @@
         record: colrev.record.Record,
         screen_inclusion: bool,
         screening_criteria: str,
         PAD: int = 40,
     ) -> None:
         """Save the screen decision"""
 
-        record.data["screening_criteria"] = screening_criteria
         PAD = 40
         if screen_inclusion:
+            screening_criteria_list = self.get_screening_criteria()
+            if len(screening_criteria_list) == 0:
+                record.data.update(screening_criteria="NA")
+            else:
+                record.data.update(
+                    screening_criteria=";".join(
+                        [e + "=in" for e in screening_criteria_list]
+                    )
+                )
             record.set_status(target_state=colrev.record.RecordState.rev_included)
 
             self.review_manager.report_logger.info(
                 f" {record.data['ID']}".ljust(PAD, " ") + "Included in screen"
             )
         else:
+            record.data["screening_criteria"] = screening_criteria
             record.set_status(target_state=colrev.record.RecordState.rev_excluded)
             self.review_manager.report_logger.info(
                 f" {record.data['ID']}".ljust(PAD, " ") + "Excluded in screen"
             )
 
         record_dict = record.get_data()
         self.review_manager.dataset.save_records_dict(
             records={record_dict["ID"]: record_dict}, partial=True
         )
         self.review_manager.dataset.add_record_changes()
 
-    def main(self, *, split_str: str) -> None:
+    def __auto_include(self, *, records: dict) -> list:
+        selected_auto_include_ids = [
+            r["ID"]
+            for r in records.values()
+            if colrev.record.RecordState.pdf_prepared == r["colrev_status"]
+            and r.get("include_flag", "0") == "1"
+        ]
+        if not selected_auto_include_ids:
+            return selected_auto_include_ids
+        self.review_manager.logger.info(
+            f"{colors.GREEN}Automatically including records with include_flag{colors.END}"
+        )
+
+        for record_dict in records.values():
+            if record_dict["ID"] not in selected_auto_include_ids:
+                continue
+            record = colrev.record.Record(data=record_dict)
+            self.screen(
+                record=record,
+                screen_inclusion=True,
+                screening_criteria="",
+            )
+            record.remove_field(key="include_flag")
+
+        self.review_manager.create_commit(
+            msg="Include records (include_flag)", manual_author=True
+        )
+        return selected_auto_include_ids
+
+    @colrev.operation.Operation.decorate()
+    def main(self, *, split_str: str = "NA") -> None:
         """Screen records for inclusion (main entrypoint)"""
 
         self.review_manager.logger.info("Screen")
         self.review_manager.logger.info(
             "In the screen, records are included or excluded "
             "based on the PDFs and screening criteria."
         )
@@ -411,21 +450,27 @@
                     )
                 raise colrev_exceptions.ServiceNotAvailableException(
                     dep="colrev sceen", detailed_trace="sceen not available"
                 )
 
             endpoint = endpoint_dict[screen_package_endpoint["endpoint"]]
 
+            selected_auto_include_ids = self.__auto_include(records=records)
+
             selected_record_ids = [
                 r["ID"]
                 for r in records.values()
                 if colrev.record.RecordState.pdf_prepared == r["colrev_status"]
+                and not r.get("include_flag", "0") == "1"
             ]
-            endpoint.run_screen(self, records, split)  # type: ignore
+            if split:
+                split = [x for x in selected_record_ids if x in split]
+
+            endpoint.run_screen(self, records, selected_record_ids)  # type: ignore
 
-            self.__print_stats(selected_record_ids=selected_record_ids)
+            self.__print_stats(
+                selected_record_ids=selected_record_ids + selected_auto_include_ids
+            )
 
         self.review_manager.logger.info(
             f"{colors.GREEN}Completed screen operation{colors.END}"
         )
-        if self.review_manager.in_ci_environment():
-            print("\n\n")
```

### Comparing `colrev-0.9.0/colrev/ops/search.py` & `colrev-0.9.2/colrev/ops/search_feed.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,135 +1,198 @@
 #! /usr/bin/env python
-"""CoLRev search operation: Search for relevant records."""
+"""CoLRev search feed: store and update origin records and update main records."""
 from __future__ import annotations
 
 import json
 import time
 from copy import deepcopy
-from pathlib import Path
 from random import randint
-from typing import Optional
 
 from pybtex.database.input import bibtex
 
 import colrev.exceptions as colrev_exceptions
 import colrev.operation
 import colrev.settings
 import colrev.ui_cli.cli_colors as colors
 
 
-class Search(colrev.operation.Operation):
-    """Search for new records"""
+# Keep in mind the need for lock-mechanisms, e.g., in concurrent prep operations
+class GeneralOriginFeed:
+    """A general-purpose Origin feed"""
+
+    # pylint: disable=too-many-instance-attributes
+
+    nr_added: int = 0
+    nr_changed: int = 0
 
     def __init__(
         self,
         *,
         review_manager: colrev.review_manager.ReviewManager,
-        notify_state_transition_operation: bool = True,
-    ) -> None:
-        super().__init__(
-            review_manager=review_manager,
-            operations_type=colrev.operation.OperationsType.search,
-            notify_state_transition_operation=notify_state_transition_operation,
-        )
+        search_source: colrev.settings.SearchSource,
+        source_identifier: str,
+        update_only: bool,
+    ):
+        self.source = search_source
+        self.feed_file = search_source.get_corresponding_bib_file()
 
-        self.sources = review_manager.settings.sources
+        # Note: the source_identifier identifies records in the search feed.
+        # This could be a doi or link or database-specific ID (like WOS accession numbers)
+        # The source_identifier can be stored in the main records.bib (it does not have to)
+        # The record source_identifier (feed-specific) is used in search
+        # or other operations (like prep)
+        # In search operations, records are added/updated based on available_ids
+        # (which maps source_identifiers to IDs used to generate the colrev_origin)
+        # In other operations, records are linked through colrev_origins,
+        # i.e., there is no need to store the source_identifier in the main records (redundantly)
+        self.source_identifier = source_identifier
 
-    def get_unique_filename(self, file_path_string: str, suffix: str = ".bib") -> Path:
-        """Get a unique filename for a (new) SearchSource"""
+        # Note: corresponds to rerun (in search.main() and run_search())
+        self.update_only = update_only
+        self.review_manager = review_manager
+        self.origin_prefix = self.source.get_origin_prefix()
 
-        file_path_string = file_path_string.replace("+", "_").replace(" ", "_")
+        self.__available_ids = {}
+        self.__max_id = 1
+        if not self.feed_file.is_file():
+            self.feed_records = {}
+        else:
+            with open(self.feed_file, encoding="utf8") as bibtex_file:
+                self.feed_records = self.review_manager.dataset.load_records_dict(
+                    load_str=bibtex_file.read()
+                )
 
-        if file_path_string.endswith(suffix):
-            file_path_string = file_path_string.rstrip(suffix)
-            # suffix = ""
-        filename = Path(f"data/search/{file_path_string}{suffix}")
-        existing_filenames = [x.filename for x in self.sources]
-        if filename not in existing_filenames:
-            return filename
-
-        i = 1
-        while filename in existing_filenames:
-            filename = Path(f"data/search/{file_path_string}_{i}{suffix}")
-            i += 1
-
-        return filename
-
-    def add_source(self, *, add_source: colrev.settings.SearchSource) -> None:
-        """Add a new source"""
-
-        package_manager = self.review_manager.get_package_manager()
-        endpoint_dict = package_manager.load_packages(
-            package_type=colrev.env.package_manager.PackageEndpointType.search_source,
-            selected_packages=[add_source.get_dict()],
-            operation=self,
-        )
-        endpoint = endpoint_dict[add_source.endpoint.lower()]
-        endpoint.validate_source(search_operation=self, source=add_source)  # type: ignore
+            self.__available_ids = {
+                x[self.source_identifier]: x["ID"]
+                for x in self.feed_records.values()
+                if self.source_identifier in x
+            }
+            self.__max_id = (
+                max(
+                    [
+                        int(x["ID"])
+                        for x in self.feed_records.values()
+                        if x["ID"].isdigit()
+                    ]
+                    + [1]
+                )
+                + 1
+            )
 
-        self.review_manager.logger.info(f"{colors.GREEN}Add source:{colors.END}")
-        print(add_source)
-        self.review_manager.settings.sources.append(add_source)
-        self.review_manager.save_settings()
-
-        print()
-
-        self.main(selection_str=str(add_source.filename), rerun=False, skip_commit=True)
-        fname = add_source.filename
-        if fname.is_absolute():
-            fname = add_source.filename.relative_to(self.review_manager.path)
-        self.review_manager.create_commit(
-            msg=f"Add search source {fname}",
-        )
+    def set_id(self, *, record_dict: dict) -> dict:
+        """Set incremental record ID
+        If self.source_identifier is in record_dict, it is updated, otherwise added as a new record.
+        """
+
+        if self.source_identifier not in record_dict:
+            raise colrev_exceptions.NotFeedIdentifiableException()
+
+        if record_dict[self.source_identifier] in self.__available_ids:
+            record_dict["ID"] = self.__available_ids[
+                record_dict[self.source_identifier]
+            ]
+        else:
+            record_dict["ID"] = str(self.__max_id).rjust(6, "0")
+
+        return record_dict
+
+    def add_record(self, *, record: colrev.record.Record) -> bool:
+        """Add a record to the feed and set its colrev_origin"""
+
+        # Feed:
+        feed_record_dict = record.data.copy()
+        added_new = True
+        if feed_record_dict[self.source_identifier] in self.__available_ids:
+            added_new = False
+        else:
+            self.__max_id += 1
+
+        if "colrev_data_provenance" in feed_record_dict:
+            del feed_record_dict["colrev_data_provenance"]
+        if "colrev_masterdata_provenance" in feed_record_dict:
+            del feed_record_dict["colrev_masterdata_provenance"]
+        if "colrev_status" in feed_record_dict:
+            del feed_record_dict["colrev_status"]
+
+        self.__available_ids[
+            feed_record_dict[self.source_identifier]
+        ] = feed_record_dict["ID"]
+
+        if self.update_only:
+            # ignore time_variant_fields
+            # (otherwise, fields in recent records would be more up-to-date)
+            for key in colrev.record.Record.time_variant_fields:
+                if feed_record_dict["ID"] in self.feed_records:
+                    if key in self.feed_records[feed_record_dict["ID"]]:
+                        feed_record_dict[key] = self.feed_records[
+                            feed_record_dict["ID"]
+                        ][key]
+                    else:
+                        if key in feed_record_dict:
+                            del feed_record_dict[key]
+
+        self.feed_records[feed_record_dict["ID"]] = feed_record_dict
+
+        # Original record
+        colrev_origin = f"{self.origin_prefix}/{record.data['ID']}"
+        record.data["colrev_origin"] = [colrev_origin]
+        record.add_provenance_all(source=colrev_origin)
 
-    def __remove_forthcoming(self, *, source: colrev.settings.SearchSource) -> None:
-        with open(source.get_corresponding_bib_file(), encoding="utf8") as bibtex_file:
-            records = self.review_manager.dataset.load_records_dict(
-                load_str=bibtex_file.read()
+        return added_new
+
+    def print_post_run_search_infos(self, *, records: dict) -> None:
+        """Print the search infos (after running the search)"""
+        if self.nr_added > 0:
+            self.review_manager.logger.info(
+                f"{colors.GREEN}Retrieved {self.nr_added} records{colors.END}"
+            )
+        else:
+            self.review_manager.logger.info(
+                f"{colors.GREEN}No additional records retrieved{colors.END}"
             )
 
-            record_list = list(records.values())
-            before = len(record_list)
-            record_list = [r for r in record_list if "forthcoming" != r.get("year", "")]
-            changed = len(record_list) - before
-            if changed > 0:
+        if self.nr_changed > 0:
+            self.review_manager.logger.info(
+                f"{colors.GREEN}Updated {self.nr_changed} records{colors.END}"
+            )
+        else:
+            if records:
                 self.review_manager.logger.info(
-                    f"{colors.GREEN}Removed {changed} forthcoming{colors.END}"
+                    f"{colors.GREEN}Records (data/records.bib) up-to-date{colors.END}"
                 )
-            else:
-                self.review_manager.logger.info(f"Removed {changed} forthcoming")
 
-            records = {r["ID"]: r for r in record_list}
+    def save_feed_file(self) -> None:
+        """Save the feed file"""
 
+        search_operation = self.review_manager.get_search_operation()
+        if len(self.feed_records) > 0:
+            self.feed_file.parents[0].mkdir(parents=True, exist_ok=True)
             self.review_manager.dataset.save_records_dict_to_file(
-                records=records, save_path=source.get_corresponding_bib_file()
+                records=self.feed_records, save_path=self.feed_file
             )
 
-    def __get_search_sources(
-        self, *, selection_str: Optional[str] = None
-    ) -> list[colrev.settings.SearchSource]:
-        sources_selected = self.sources
-        if selection_str:
-            if selection_str != "all":
-                sources_selected = [
-                    f
-                    for f in self.sources
-                    if str(f.filename) in selection_str.split(",")
-                ]
-            if len(sources_selected) == 0:
-                available_options = [str(f.filename) for f in self.sources]
-                raise colrev_exceptions.ParameterError(
-                    parameter="selection_str",
-                    value=selection_str,
-                    options=available_options,
-                )
+            while True:
+                try:
+                    search_operation.review_manager.load_settings()
+                    if self.source.filename.name not in [
+                        s.filename.name
+                        for s in search_operation.review_manager.settings.sources
+                    ]:
+                        search_operation.review_manager.settings.sources.append(
+                            self.source
+                        )
+                        search_operation.review_manager.save_settings()
 
-        for source in sources_selected:
-            source.filename = self.review_manager.path / Path(source.filename)
-        return sources_selected
+                    search_operation.review_manager.dataset.add_changes(
+                        path=self.feed_file
+                    )
+                    break
+                except (FileExistsError, OSError, json.decoder.JSONDecodeError):
+                    search_operation.review_manager.logger.debug("Wait for git")
+                    time.sleep(randint(1, 15))  # nosec
 
     def __have_changed(self, *, record_a_orig: dict, record_b_orig: dict) -> bool:
         # To ignore changes introduced by saving/loading the feed-records,
         # we parse and load them in the following.
         record_a = deepcopy(record_a_orig)
         record_b = deepcopy(record_b_orig)
 
@@ -259,14 +322,26 @@
                     key=key,
                     value=value,
                     source=origin,
                     keep_source_if_equal=True,
                     append_edit=False,
                 )
 
+    def __forthcoming_published(self, *, record_dict: dict, prev_record: dict) -> bool:
+        # Forthcoming paper published if volume and number are assigned
+        # i.e., no longer UNKNOWN
+        if (
+            record_dict.get("volume", "") != "UNKNOWN"
+            and prev_record.get("volume", "UNKNOWN") == "UNKNOWN"
+            and record_dict.get("number", "") != "UNKNOWN"
+            and prev_record.get("volume", "UNKNOWN") == "UNKNOWN"
+        ):
+            return True
+        return False
+
     def update_existing_record(
         self,
         *,
         records: dict,
         record_dict: dict,
         prev_record_dict_version: dict,
         source: colrev.settings.SearchSource,
@@ -318,308 +393,26 @@
 
         if self.__have_changed(
             record_a_orig=main_record_dict, record_b_orig=prev_record_dict_version
         ) or self.__have_changed(  # Note : not (yet) in the main records but changed
             record_a_orig=record_dict, record_b_orig=prev_record_dict_version
         ):
             changed = True
-            if similarity_score > 0.98:
+            if self.__forthcoming_published(
+                record_dict=record_dict, prev_record=prev_record_dict_version
+            ):
+                self.review_manager.logger.info(
+                    f" {colors.GREEN}forthcoming paper published: "
+                    f"{main_record_dict['ID']}{colors.END}"
+                )
+            elif similarity_score > 0.98:
                 self.review_manager.logger.info(f" check/update {origin}")
             else:
                 self.review_manager.logger.info(
                     f" {colors.RED} check/update {origin} leads to substantial changes "
                     f"({similarity_score}) in {main_record_dict['ID']}:{colors.END}"
                 )
                 self.review_manager.p_printer.pprint(
                     [x for x in dict_diff if "change" == x[0]]
                 )
 
         return changed
-
-    def main(
-        self,
-        *,
-        selection_str: Optional[str] = None,
-        rerun: bool,
-        skip_commit: bool = False,
-    ) -> None:
-        """Search for records (main entrypoint)"""
-
-        if selection_str:
-            if Path(selection_str) not in [
-                s.filename for s in self.review_manager.settings.sources
-            ]:
-                raise colrev_exceptions.ParameterError(
-                    parameter="select",
-                    value=selection_str,
-                    options=[
-                        str(s.filename) for s in self.review_manager.settings.sources
-                    ],
-                )
-
-        self.review_manager.logger.info("Search")
-        self.review_manager.logger.info(
-            "Retrieve new records from an API or files (search sources)."
-        )
-        self.review_manager.logger.info(
-            "See https://colrev.readthedocs.io/en/latest/manual/metadata_retrieval/search.html"
-        )
-
-        # Reload the settings because the search sources may have been updated
-        self.review_manager.settings = self.review_manager.load_settings()
-
-        package_manager = self.review_manager.get_package_manager()
-
-        for source in self.__get_search_sources(selection_str=selection_str):
-            endpoint_dict = package_manager.load_packages(
-                package_type=colrev.env.package_manager.PackageEndpointType.search_source,
-                selected_packages=[source.get_dict()],
-                operation=self,
-                only_ci_supported=self.review_manager.in_ci_environment(),
-            )
-            if source.endpoint.lower() not in endpoint_dict:
-                continue
-            endpoint = endpoint_dict[source.endpoint.lower()]
-            endpoint.validate_source(search_operation=self, source=source)  # type: ignore
-
-            run_search_function = getattr(endpoint, "run_search", None)
-            if not callable(run_search_function):
-                # Some sources do not support automated searches (e.g., unknown sources)
-                continue
-
-            if not self.review_manager.high_level_operation:
-                print()
-            self.review_manager.logger.info(
-                f"search [{source.endpoint} > data/search/{source.filename.name}]"
-            )
-
-            try:
-                endpoint.run_search(search_operation=self, rerun=rerun)  # type: ignore
-            except colrev.exceptions.ServiceNotAvailableException as exc:
-                # requests.exceptions.ConnectionError,
-                if not self.review_manager.force_mode:
-                    raise colrev_exceptions.ServiceNotAvailableException(
-                        source.endpoint
-                    ) from exc
-                self.review_manager.logger.warning("ServiceNotAvailableException")
-
-            if source.filename.is_file():
-                if not self.review_manager.settings.search.retrieve_forthcoming:
-                    self.__remove_forthcoming(source=source)
-
-                self.review_manager.dataset.format_records_file()
-                self.review_manager.dataset.add_record_changes()
-                self.review_manager.dataset.add_changes(path=source.filename)
-                if not skip_commit:
-                    self.review_manager.create_commit(msg="Run search")
-
-        if self.review_manager.in_ci_environment():
-            print("\n\n")
-
-    def setup_custom_script(self) -> None:
-        """Setup a custom search script"""
-
-        filedata = colrev.env.utils.get_package_file_content(
-            file_path=Path("template/custom_scripts/custom_search_source_script.py")
-        )
-
-        if filedata:
-            with open("custom_search_source_script.py", "w", encoding="utf-8") as file:
-                file.write(filedata.decode("utf-8"))
-
-        self.review_manager.dataset.add_changes(
-            path=Path("custom_search_source_script.py")
-        )
-
-        new_source = colrev.settings.SearchSource(
-            endpoint="custom_search_source_script",
-            filename=Path("data/search/custom_search.bib"),
-            search_type=colrev.settings.SearchType.DB,
-            search_parameters={},
-            load_conversion_package_endpoint={"endpoint": "colrev.bibtex"},
-            comment="",
-        )
-
-        self.review_manager.settings.sources.append(new_source)
-        self.review_manager.save_settings()
-
-    def view_sources(self) -> None:
-        """View the sources info"""
-
-        for source in self.sources:
-            self.review_manager.p_printer.pprint(source)
-
-
-# Keep in mind the need for lock-mechanisms, e.g., in concurrent prep operations
-class GeneralOriginFeed:
-    """A general-purpose Origin feed"""
-
-    # pylint: disable=too-many-instance-attributes
-
-    nr_added: int = 0
-    nr_changed: int = 0
-
-    def __init__(
-        self,
-        *,
-        review_manager: colrev.review_manager.ReviewManager,
-        search_source: colrev.settings.SearchSource,
-        source_identifier: str,
-        update_only: bool,
-    ):
-        self.source = search_source
-        self.feed_file = search_source.get_corresponding_bib_file()
-
-        # Note: the source_identifier identifies records in the search feed.
-        # This could be a doi or link or database-specific ID (like WOS accession numbers)
-        # The source_identifier can be stored in the main records.bib (it does not have to)
-        # The record source_identifier (feed-specific) is used in search
-        # or other operations (like prep)
-        # In search operations, records are added/updated based on available_ids
-        # (which maps source_identifiers to IDs used to generate the colrev_origin)
-        # In other operations, records are linked through colrev_origins,
-        # i.e., there is no need to store the source_identifier in the main records (redundantly)
-        self.source_identifier = source_identifier
-
-        # Note: corresponds to rerun (in search.main() and run_search())
-        self.update_only = update_only
-        self.review_manager = review_manager
-        self.origin_prefix = self.source.get_origin_prefix()
-
-        self.__available_ids = {}
-        self.__max_id = 1
-        if not self.feed_file.is_file():
-            self.feed_records = {}
-        else:
-            with open(self.feed_file, encoding="utf8") as bibtex_file:
-                self.feed_records = self.review_manager.dataset.load_records_dict(
-                    load_str=bibtex_file.read()
-                )
-
-            self.__available_ids = {
-                x[self.source_identifier]: x["ID"]
-                for x in self.feed_records.values()
-                if self.source_identifier in x
-            }
-            self.__max_id = (
-                max(
-                    [
-                        int(x["ID"])
-                        for x in self.feed_records.values()
-                        if x["ID"].isdigit()
-                    ]
-                    + [1]
-                )
-                + 1
-            )
-
-    def set_id(self, *, record_dict: dict) -> dict:
-        """Set incremental record ID
-        If self.source_identifier is in record_dict, it is updated, otherwise added as a new record.
-        """
-
-        if self.source_identifier not in record_dict:
-            raise colrev_exceptions.NotFeedIdentifiableException()
-
-        if record_dict[self.source_identifier] in self.__available_ids:
-            record_dict["ID"] = self.__available_ids[
-                record_dict[self.source_identifier]
-            ]
-        else:
-            record_dict["ID"] = str(self.__max_id).rjust(6, "0")
-
-        return record_dict
-
-    def add_record(self, *, record: colrev.record.Record) -> bool:
-        """Add a record to the feed and set its colrev_origin"""
-
-        # Feed:
-        feed_record_dict = record.data.copy()
-        added_new = True
-        if feed_record_dict[self.source_identifier] in self.__available_ids:
-            added_new = False
-        else:
-            self.__max_id += 1
-
-        if "colrev_data_provenance" in feed_record_dict:
-            del feed_record_dict["colrev_data_provenance"]
-        if "colrev_masterdata_provenance" in feed_record_dict:
-            del feed_record_dict["colrev_masterdata_provenance"]
-        if "colrev_status" in feed_record_dict:
-            del feed_record_dict["colrev_status"]
-
-        self.__available_ids[
-            feed_record_dict[self.source_identifier]
-        ] = feed_record_dict["ID"]
-
-        if self.update_only:
-            # ignore time_variant_fields
-            # (otherwise, fields in recent records would be more up-to-date)
-            for key in colrev.record.Record.time_variant_fields:
-                if feed_record_dict["ID"] in self.feed_records:
-                    if key in self.feed_records[feed_record_dict["ID"]]:
-                        feed_record_dict[key] = self.feed_records[
-                            feed_record_dict["ID"]
-                        ][key]
-                    else:
-                        if key in feed_record_dict:
-                            del feed_record_dict[key]
-
-        self.feed_records[feed_record_dict["ID"]] = feed_record_dict
-
-        # Original record
-        colrev_origin = f"{self.origin_prefix}/{record.data['ID']}"
-        record.data["colrev_origin"] = [colrev_origin]
-        record.add_provenance_all(source=colrev_origin)
-
-        return added_new
-
-    def print_post_run_search_infos(self, *, records: dict) -> None:
-        """Print the search infos (after running the search)"""
-        if self.nr_added > 0:
-            self.review_manager.logger.info(
-                f"{colors.GREEN}Retrieved {self.nr_added} records{colors.END}"
-            )
-        else:
-            self.review_manager.logger.info(
-                f"{colors.GREEN}No additional records retrieved{colors.END}"
-            )
-
-        if self.nr_changed > 0:
-            self.review_manager.logger.info(
-                f"{colors.GREEN}Updated {self.nr_changed} records{colors.END}"
-            )
-        else:
-            if records:
-                self.review_manager.logger.info(
-                    f"{colors.GREEN}Records (data/records.bib) up-to-date{colors.END}"
-                )
-
-    def save_feed_file(self) -> None:
-        """Save the feed file"""
-
-        search_operation = self.review_manager.get_search_operation()
-        if len(self.feed_records) > 0:
-            self.feed_file.parents[0].mkdir(parents=True, exist_ok=True)
-            self.review_manager.dataset.save_records_dict_to_file(
-                records=self.feed_records, save_path=self.feed_file
-            )
-
-            while True:
-                try:
-                    search_operation.review_manager.load_settings()
-                    if self.source.filename.name not in [
-                        s.filename.name
-                        for s in search_operation.review_manager.settings.sources
-                    ]:
-                        search_operation.review_manager.settings.sources.append(
-                            self.source
-                        )
-                        search_operation.review_manager.save_settings()
-
-                    search_operation.review_manager.dataset.add_changes(
-                        path=self.feed_file
-                    )
-                    break
-                except (FileExistsError, OSError, json.decoder.JSONDecodeError):
-                    search_operation.review_manager.logger.debug("Wait for git")
-                    time.sleep(randint(1, 15))  # nosec
```

### Comparing `colrev-0.9.0/colrev/ops/search_sources.py` & `colrev-0.9.2/colrev/ops/search_sources.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ops/status.py` & `colrev-0.9.2/colrev/ops/status.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,11 @@
 #! /usr/bin/env python3
 """CoLRev status operation: Display the project status."""
 from __future__ import annotations
 
-import csv
 import io
 import typing
 from dataclasses import dataclass
 from pathlib import Path
 from typing import Optional
 
 import yaml
@@ -51,29 +50,30 @@
                 # (to create a general-purpose status analyzer)
                 # -> flatten nested structures (e.g., overall/currently)
                 # -> integrate with get_status (current data) -
                 # and get_prior? (levels: aggregated_statistics vs. record-level?)
 
                 data_loaded = yaml.safe_load(var_t)
                 analytics_dict[len(revlist) - ind] = {
+                    "atomic_steps": data_loaded["atomic_steps"],
+                    "completed_atomic_steps": data_loaded["completed_atomic_steps"],
                     "commit_id": commit_id,
                     "commit_author": commit_author,
                     "committed_date": committed_date,
                     "search": data_loaded["overall"]["md_retrieved"],
                     "included": data_loaded["overall"]["rev_included"],
                 }
-            except (IndexError, KeyError) as exc:
-                print(exc)
+            except (IndexError, KeyError):
+                pass
 
-        keys = list(analytics_dict.values())[0].keys()
-
-        with open("analytics.csv", "w", newline="", encoding="utf8") as output_file:
-            dict_writer = csv.DictWriter(output_file, keys)
-            dict_writer.writeheader()
-            dict_writer.writerows(reversed(analytics_dict.values()))
+        # keys = list(analytics_dict.values())[0].keys()
+        # with open("analytics.csv", "w", newline="", encoding="utf8") as output_file:
+        #     dict_writer = csv.DictWriter(output_file, keys)
+        #     dict_writer.writeheader()
+        #     dict_writer.writerows(reversed(analytics_dict.values()))
 
         return analytics_dict
 
     def get_review_status_report(
         self, *, records: Optional[dict] = None, colors: bool = True
     ) -> str:
         """Get the review status report"""
```

### Comparing `colrev-0.9.0/colrev/ops/sync.py` & `colrev-0.9.2/colrev/ops/sync.py`

 * *Files 11% similar despite different names*

```diff
@@ -20,14 +20,15 @@
     cited_papers: list
 
     def __init__(self) -> None:
         self.records_to_import: typing.List[colrev.record.Record] = []
         self.non_unique_for_import: typing.List[typing.Dict] = []
 
         self.logger = self.__setup_logger(level=logging.DEBUG)
+        self.paper_md = self.__get_md_file()
 
     def __setup_logger(self, *, level: int = logging.INFO) -> logging.Logger:
         """Setup the sync logger"""
         # pylint: disable=duplicate-code
 
         # for logger debugging:
         # from logging_tree import printout
@@ -48,27 +49,31 @@
         handler.setLevel(level)
 
         logger.addHandler(handler)
         logger.propagate = False
 
         return logger
 
-    def __get_cited_papers_citation_keys(self) -> list:
+    def __get_md_file(self) -> Path:
+        paper_md = Path("")
         if Path("paper.md").is_file():
             paper_md = Path("paper.md")
         if Path("data/paper.md").is_file():
             paper_md = Path("data/paper.md")
         elif Path("review.md").is_file():
             paper_md = Path("review.md")
+        return paper_md
+
+    def __get_cited_papers_citation_keys(self) -> list:
         rst_files = list(Path.cwd().rglob("*.rst"))
 
         citation_keys = []
-        if paper_md.is_file():
+        if self.paper_md.is_file():
             self.logger.info("Load cited references from paper.md")
-            content = paper_md.read_text(encoding="utf-8")
+            content = self.paper_md.read_text(encoding="utf-8")
             res = re.findall(r"(^|\s|\[|;)(@[a-zA-Z0-9_]+)+", content)
             citation_keys = list({r[1].replace("@", "") for r in res})
             if "fig" in citation_keys:
                 citation_keys.remove("fig")
             self.logger.info("Citations in paper.md: %s", len(citation_keys))
             self.cited_papers = citation_keys
 
@@ -84,14 +89,42 @@
             self.logger.info("Citations in *.rst: %s", len(citation_keys))
             self.cited_papers = citation_keys
 
         else:
             print("Not found paper.md or *.rst")
         return citation_keys
 
+    def get_cited_papers_from_source(self, *, src: Path) -> None:
+        """Get the cited papers from a source file"""
+
+        citation_keys = self.__get_cited_papers_citation_keys()
+
+        ids_in_bib = self.__get_ids_in_paper()
+        self.logger.info("References in bib: %s", len(ids_in_bib))
+
+        if src.suffix == ".bib":
+            parser = bibtex.Parser()
+            bib_data = parser.parse_file(str(src))
+            refs_in_src = colrev.dataset.Dataset.parse_records_dict(
+                records_dict=bib_data.entries
+            )
+        else:
+            print("Format not supported")
+            return
+
+        for citation_key in citation_keys:
+            if citation_key in ids_in_bib:
+                continue
+            if citation_key not in refs_in_src:
+                print(f"{citation_key} not in {src}")
+                continue
+            self.records_to_import.append(
+                colrev.record.Record(data=refs_in_src[citation_key])
+            )
+
     def get_cited_papers(self) -> None:
         """Get the cited papers"""
 
         citation_keys = self.__get_cited_papers_citation_keys()
 
         ids_in_bib = self.__get_ids_in_paper()
         self.logger.info("References in bib: %s", len(ids_in_bib))
@@ -203,14 +236,38 @@
 
         with open(save_path, "w", encoding="utf-8") as out:
             out.write(bibtex_str)
 
     def add_to_bib(self) -> None:
         """Add records to the bibliography"""
 
+        if not self.paper_md.is_file():
+            return
+
+        if self.paper_md.read_text(encoding="utf-8").startswith("---"):
+            self.__export_to_bib()
+
+        else:
+            # Append to # References if no header (mardown with linked)
+            self.__append_as_citations()
+
+    def __append_as_citations(self) -> None:
+        if "# References" in self.paper_md.read_text(encoding="utf-8"):
+            print("Already contains a reference section.")
+            return
+
+        with open(self.paper_md, "a", encoding="utf-8") as file:
+            file.write("\n# References\n\n")
+            ref_list = [
+                record_to_import.format_bib_style()
+                for record_to_import in self.records_to_import
+            ]
+            file.write("\n".join(sorted(ref_list)))
+
+    def __export_to_bib(self) -> None:
         pybtex.errors.set_strict_mode(False)
 
         references_file = Path("references.bib")
         if not references_file.is_file():
             records = []
         else:
             parser = bibtex.Parser()
```

### Comparing `colrev-0.9.0/colrev/ops/trace.py` & `colrev-0.9.2/colrev/ops/trace.py`

 * *Files 2% similar despite different names*

```diff
@@ -80,14 +80,15 @@
                         )
                         + colors.END
                     )
 
         prev_record = record
         return prev_record
 
+    @colrev.operation.Operation.decorate()
     def main(self, *, record_id: str) -> None:
         """Trace a record (main entrypoint)"""
 
         self.review_manager.logger.info(f"Trace record by ID: {record_id}")
 
         revlist = self.review_manager.dataset.get_repo().iter_commits()
```

### Comparing `colrev-0.9.0/colrev/ops/upgrade.py` & `colrev-0.9.2/colrev/ops/upgrade.py`

 * *Files 2% similar despite different names*

```diff
@@ -123,14 +123,20 @@
             },
             {
                 "version": CoLRevVersion("0.8.4"),
                 "target_version": CoLRevVersion("0.9.0"),
                 "script": self.__migrate_0_8_4,
                 "released": True,
             },
+            {
+                "version": CoLRevVersion("0.9.0"),
+                "target_version": CoLRevVersion("0.9.1"),
+                "script": self.__migrate_0_9_1,
+                "released": True,
+            },
         ]
 
         # Note: we should always update the colrev_version in settings.json because the
         # checker.__check_software requires the settings version and
         # the installed version to be identical
 
         # skipping_versions_before_settings_version = True
@@ -370,21 +376,30 @@
     def __migrate_0_8_4(self) -> bool:
         records = self.review_manager.dataset.load_records_dict()
         for record in records.values():
             if "editor" not in record.get("colrev_data_provenance", {}):
                 continue
             ed_val = record["colrev_data_provenance"]["editor"]
             del record["colrev_data_provenance"]["editor"]
-            record["colrev_masterdata_provenance"]["editor"] = ed_val
+            if "CURATED" not in record["colrev_masterdata_provenance"]:
+                record["colrev_masterdata_provenance"]["editor"] = ed_val
 
         self.review_manager.dataset.save_records_dict(records=records)
         self.review_manager.dataset.add_record_changes()
 
         return self.repo.is_dirty()
 
+    def __migrate_0_9_1(self) -> bool:
+        settings = self.__load_settings_dict()
+        for source in settings["sources"]:
+            if "load_conversion_package_endpoint" in source:
+                del source["load_conversion_package_endpoint"]
+        self.__save_settings(settings)
+        return self.repo.is_dirty()
+
 
 # Note: we can ask users to make decisions (when defaults are not clear)
 # via input() or simply cancel the process (raise a CoLrevException)
 
 
 class CoLRevVersion:
     """Class for handling the CoLRev version"""
```

### Comparing `colrev-0.9.0/colrev/ops/validate.py` & `colrev-0.9.2/colrev/ops/validate.py`

 * *Files 1% similar despite different names*

```diff
@@ -510,14 +510,15 @@
         for commit in git_repo.iter_commits():
             if target_commit == commit.hexsha:
                 return f"HEAD~{relative_to_head}"
             relative_to_head += 1
 
         return target_commit
 
+    @colrev.operation.Operation.decorate()
     def main(
         self,
         *,
         scope: str,
         filter_setting: str,
         properties: bool = False,
     ) -> dict:
```

### Comparing `colrev-0.9.0/colrev/qm/checkers/container_title_abbreviated.py` & `colrev-0.9.2/colrev/qm/checkers/container_title_abbreviated.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/checkers/doi_not_matching_pattern.py` & `colrev-0.9.2/colrev/qm/checkers/doi_not_matching_pattern.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/checkers/erroneous_symbol_in_field.py` & `colrev-0.9.2/colrev/qm/checkers/erroneous_symbol_in_field.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/checkers/erroneous_term_in_field.py` & `colrev-0.9.2/colrev/qm/checkers/erroneous_term_in_field.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/checkers/erroneous_title_field.py` & `colrev-0.9.2/colrev/qm/checkers/erroneous_title_field.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/checkers/identical_values_between_title_and_container.py` & `colrev-0.9.2/colrev/qm/checkers/identical_values_between_title_and_container.py`

 * *Files 9% similar despite different names*

```diff
@@ -22,24 +22,28 @@
             record.add_masterdata_provenance_note(key="title", note=self.msg)
         else:
             record.remove_masterdata_provenance_note(key="title", note=self.msg)
 
     def __identical_values_between_title_and_container(
         self, *, record: colrev.record.Record
     ) -> bool:
+        if record.data.get("title", "UNKNOWN") == "UNKNOWN":
+            return False
         if (
             "booktitle" in record.data
             and "title" in record.data
-            and record.data["title"].lower() == record.data["booktitle"].lower()
+            and record.data["title"].lower().replace("the ", "")
+            == record.data["booktitle"].lower().replace("the ", "")
         ):
             return True
         if (
             "journal" in record.data
             and "title" in record.data
-            and record.data["title"].lower() == record.data["journal"].lower()
+            and record.data["title"].lower().replace("the ", "")
+            == record.data["journal"].lower().replace("the ", "")
         ):
             return True
         return False
 
 
 def register(quality_model: colrev.qm.quality_model.QualityModel) -> None:
     """Register the checker"""
```

### Comparing `colrev-0.9.0/colrev/qm/checkers/incomplete_field.py` & `colrev-0.9.2/colrev/qm/checkers/incomplete_field.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/checkers/inconsistent_content.py` & `colrev-0.9.2/colrev/qm/checkers/inconsistent_content.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/checkers/inconsistent_with_doi_metadata.py` & `colrev-0.9.2/colrev/qm/checkers/inconsistent_with_url_metadata.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,85 +1,65 @@
 #! /usr/bin/env python
-"""Checker for inconsistent-with-doi-metadata."""
+"""Checker for inconsistent-with-url-metadata."""
 from __future__ import annotations
 
-import requests.exceptions
 from thefuzz import fuzz
 
-import colrev.exceptions as colrev_exceptions
-import colrev.ops.built_in.search_sources.crossref as crossref_connector
+import colrev.ops.built_in.search_sources.website as website_connector
 import colrev.qm.quality_model
 
 # pylint: disable=too-few-public-methods
 
 
-class InconsistentWithDOIMetadataChecker:
-    """The InconsistentWithDOIMetadataChecker"""
+class InconsistentWithURLMetadataChecker:
+    """The InconsistentWithURLMetadataChecker"""
 
-    msg = "inconsistent-with-doi-metadata"
+    msg = "inconsistent-with-url-metadata"
     __fields_to_check = ["author", "title", "journal", "year", "volume", "number"]
 
     def __init__(self, quality_model: colrev.qm.quality_model.QualityModel) -> None:
         self.quality_model = quality_model
-        self.__etiquette = crossref_connector.CrossrefSearchSource.get_etiquette(
+
+        self.__url_connector = website_connector.WebsiteConnector(
             review_manager=quality_model.review_manager
         )
 
     def run(self, *, record: colrev.record.Record) -> None:
-        """Run the inconsistent-with-doi-metadata checks"""
+        """Run the inconsistent-with-url-metadata checks"""
 
-        if "doi" not in record.data:
+        if "url" not in record.data:
+            return
+        if any(x in record.data["url"] for x in ["search.ebscohost.com/login"]):
+            return
+        if "md_curated.bib" in record.data["colrev_data_provenance"]["url"]["source"]:
             return
-        if "doi" in record.data.get("colrev_data_provenance", {}):
-            if (
-                "md_curated.bib"
-                in record.data["colrev_data_provenance"]["doi"]["source"]
-            ):
-                return
 
-        if self.__doi_metadata_conflicts(record=record):
-            record.add_masterdata_provenance_note(key="doi", note=self.msg)
+        if self.__url_metadata_conflicts(record=record):
+            record.add_masterdata_provenance_note(key="url", note=self.msg)
         else:
-            record.remove_masterdata_provenance_note(key="doi", note=self.msg)
-
-    def __doi_metadata_conflicts(self, *, record: colrev.record.Record) -> bool:
-        record_copy = record.copy_prep_rec()
-
-        try:
-            crossref_md = crossref_connector.CrossrefSearchSource.query_doi(
-                doi=record_copy.data["doi"], etiquette=self.__etiquette
-            )
+            record.remove_masterdata_provenance_note(key="url", note=self.msg)
 
-            for key, value in crossref_md.data.items():
-                if key not in self.__fields_to_check:
-                    continue
-                if not isinstance(value, str):
-                    continue
-                if key not in record.data:
-                    continue
-                if record.data[key] == "UNKNOWN":
-                    continue
-                if key not in ["author", "title", "journal"]:
-                    continue
-                if len(crossref_md.data[key]) < 5 or len(record.data[key]) < 5:
+    def __url_metadata_conflicts(self, *, record: colrev.record.Record) -> bool:
+        url_record = record.copy_prep_rec()
+        self.__url_connector.retrieve_md_from_website(record=url_record)
+        for key, value in url_record.data.items():
+            if key not in self.__fields_to_check:
+                continue
+            if not isinstance(value, str):
+                continue
+            if key in record.data:
+                if len(url_record.data[key]) < 5 or len(record.data[key]) < 5:
                     continue
                 if (
                     fuzz.partial_ratio(
-                        record.data[key].lower(), crossref_md.data[key].lower()
+                        record.data[key].lower(), url_record.data[key].lower()
                     )
-                    < 60
+                    < 70
                 ):
                     return True
 
-        except (
-            colrev_exceptions.RecordNotFoundInPrepSourceException,
-            colrev_exceptions.RecordNotParsableException,
-            requests.exceptions.ConnectionError,
-            requests.exceptions.ReadTimeout,
-        ):
-            return False
         return False
 
 
 def register(quality_model: colrev.qm.quality_model.QualityModel) -> None:
     """Register the checker"""
-    quality_model.register_checker(InconsistentWithDOIMetadataChecker(quality_model))
+    quality_model.register_checker(InconsistentWithURLMetadataChecker(quality_model))
```

### Comparing `colrev-0.9.0/colrev/qm/checkers/inconsistent_with_entrytype.py` & `colrev-0.9.2/colrev/qm/checkers/inconsistent_with_entrytype.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/checkers/isbn_not_matching_pattern.py` & `colrev-0.9.2/colrev/qm/checkers/isbn_not_matching_pattern.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/checkers/language_format_error.py` & `colrev-0.9.2/colrev/qm/checkers/language_format_error.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/checkers/missing_field.py` & `colrev-0.9.2/colrev/qm/checkers/missing_field.py`

 * *Files 2% similar despite different names*

```diff
@@ -118,19 +118,21 @@
             record.remove_masterdata_provenance_note(key="number", note="forthcoming")
             return
         source = "NA"
         if "year" in record.data["colrev_masterdata_provenance"]:
             source = record.data["colrev_masterdata_provenance"]["year"]["source"]
         if record.data.get("volume", "") in ["", "UNKNOWN"]:
             record.remove_masterdata_provenance_note(key="volume", note="missing")
+            record.remove_masterdata_provenance_note(key="volume", note="not-missing")
             record.add_masterdata_provenance(
                 key="volume", source=source, note="forthcoming"
             )
         if record.data.get("number", "") in ["", "UNKNOWN"]:
             record.remove_masterdata_provenance_note(key="number", note="missing")
+            record.remove_masterdata_provenance_note(key="number", note="not-missing")
             record.add_masterdata_provenance(
                 key="number", source=source, note="forthcoming"
             )
 
     def __check_completeness(
         self, *, record: colrev.record.Record, curation_restrictions: bool = False
     ) -> None:
```

### Comparing `colrev-0.9.0/colrev/qm/checkers/mostly_all_caps.py` & `colrev-0.9.2/colrev/qm/checkers/mostly_all_caps.py`

 * *Files 24% similar despite different names*

```diff
@@ -20,14 +20,21 @@
         """Run the mostly-all-caps checks"""
         for key in ["author", "title", "journal", "booktitle", "editor"]:
             if key not in record.data:
                 continue
             if record.data[key] == "UNKNOWN":
                 continue
             if (
+                record.data["ENTRYTYPE"] == "online"
+                and key == "title"
+                and len(record.data["title"]) < 10
+            ):
+                # Online sources/software can be short/have caps
+                continue
+            if (
                 colrev.env.utils.percent_upper_chars(
                     record.data[key].replace(" and ", "")
                 )
                 < 0.7
             ):
                 record.remove_masterdata_provenance_note(key=key, note=self.msg)
                 continue
```

### Comparing `colrev-0.9.0/colrev/qm/checkers/name_abbreviated.py` & `colrev-0.9.2/colrev/qm/checkers/name_abbreviated.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/checkers/name_format_separators.py` & `colrev-0.9.2/colrev/qm/checkers/name_format_separators.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/checkers/name_format_titles.py` & `colrev-0.9.2/colrev/qm/checkers/name_format_titles.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/checkers/record_not_in_toc.py` & `colrev-0.9.2/colrev/qm/checkers/record_not_in_toc.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/checkers/thesis_with_multiple_authors.py` & `colrev-0.9.2/colrev/qm/checkers/thesis_with_multiple_authors.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/checkers/year_format.py` & `colrev-0.9.2/colrev/qm/checkers/year_format.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/colrev_id.py` & `colrev-0.9.2/colrev/qm/colrev_id.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 
 import re
 from typing import TYPE_CHECKING
 
 from nameparser import HumanName
 
 import colrev.exceptions as colrev_exceptions
-import colrev.record
+import colrev.record  # pylint: disable=cyclic-import
 
 if TYPE_CHECKING:
     import colrev.review_manager
 
 
 def __format_author_field_for_cid(input_string: str) -> str:
     input_string = input_string.replace("\n", " ").replace("'", "")
```

### Comparing `colrev-0.9.0/colrev/qm/colrev_pdf_id.py` & `colrev-0.9.2/colrev/qm/colrev_pdf_id.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/quality_model.py` & `colrev-0.9.2/colrev/qm/quality_model.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/qm/readme.md` & `colrev-0.9.2/colrev/qm/readme.md`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/record.py` & `colrev-0.9.2/colrev/record.py`

 * *Files 1% similar despite different names*

```diff
@@ -771,4884 +771,4953 @@
 00003020: 6579 5d20 3d20 7661 6c75 650a 0a20 2020  ey] = value..   
 00003030: 2064 6566 2072 656e 616d 655f 6669 656c   def rename_fiel
 00003040: 6428 7365 6c66 2c20 2a2c 206b 6579 3a20  d(self, *, key: 
 00003050: 7374 722c 206e 6577 5f6b 6579 3a20 7374  str, new_key: st
 00003060: 7229 202d 3e20 4e6f 6e65 3a0a 2020 2020  r) -> None:.    
 00003070: 2020 2020 2222 2252 656e 616d 6520 6120      """Rename a 
 00003080: 6669 656c 6422 2222 0a20 2020 2020 2020  field""".       
-00003090: 2076 616c 7565 203d 2073 656c 662e 6461   value = self.da
-000030a0: 7461 5b6b 6579 5d0a 2020 2020 2020 2020  ta[key].        
-000030b0: 7365 6c66 2e64 6174 615b 6e65 775f 6b65  self.data[new_ke
-000030c0: 795d 203d 2076 616c 7565 0a0a 2020 2020  y] = value..    
-000030d0: 2020 2020 6966 206b 6579 2069 6e20 7365      if key in se
-000030e0: 6c66 2e69 6465 6e74 6966 7969 6e67 5f66  lf.identifying_f
-000030f0: 6965 6c64 5f6b 6579 733a 0a20 2020 2020  ield_keys:.     
-00003100: 2020 2020 2020 2076 616c 7565 5f70 726f         value_pro
-00003110: 7665 6e61 6e63 6520 3d20 7365 6c66 2e64  venance = self.d
-00003120: 6174 615b 2263 6f6c 7265 765f 6d61 7374  ata["colrev_mast
-00003130: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
-00003140: 6522 5d5b 6b65 795d 0a20 2020 2020 2020  e"][key].       
-00003150: 2020 2020 2069 6620 2273 6f75 7263 6522       if "source"
-00003160: 2069 6e20 7661 6c75 655f 7072 6f76 656e   in value_proven
-00003170: 616e 6365 3a0a 2020 2020 2020 2020 2020  ance:.          
-00003180: 2020 2020 2020 7661 6c75 655f 7072 6f76        value_prov
-00003190: 656e 616e 6365 5b22 736f 7572 6365 225d  enance["source"]
-000031a0: 202b 3d20 6622 7c72 656e 616d 652d 6672   += f"|rename-fr
-000031b0: 6f6d 3a7b 6b65 797d 220a 2020 2020 2020  om:{key}".      
-000031c0: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
-000031d0: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
-000031e0: 7461 5f70 726f 7665 6e61 6e63 6522 5d5b  ta_provenance"][
-000031f0: 6e65 775f 6b65 795d 203d 2076 616c 7565  new_key] = value
-00003200: 5f70 726f 7665 6e61 6e63 650a 2020 2020  _provenance.    
-00003210: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00003220: 2020 2020 2020 6966 2022 636f 6c72 6576        if "colrev
-00003230: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
-00003240: 2220 6e6f 7420 696e 2073 656c 662e 6461  " not in self.da
-00003250: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
-00003260: 2020 2020 7365 6c66 2e64 6174 615b 2263      self.data["c
-00003270: 6f6c 7265 765f 6461 7461 5f70 726f 7665  olrev_data_prove
-00003280: 6e61 6e63 6522 5d20 3d20 7b7d 0a20 2020  nance"] = {}.   
-00003290: 2020 2020 2020 2020 2069 6620 6b65 7920           if key 
-000032a0: 696e 2073 656c 662e 6461 7461 5b22 636f  in self.data["co
-000032b0: 6c72 6576 5f64 6174 615f 7072 6f76 656e  lrev_data_proven
-000032c0: 616e 6365 225d 3a0a 2020 2020 2020 2020  ance"]:.        
-000032d0: 2020 2020 2020 2020 7661 6c75 655f 7072          value_pr
-000032e0: 6f76 656e 616e 6365 203d 2073 656c 662e  ovenance = self.
-000032f0: 6461 7461 5b22 636f 6c72 6576 5f64 6174  data["colrev_dat
-00003300: 615f 7072 6f76 656e 616e 6365 225d 5b6b  a_provenance"][k
-00003310: 6579 5d0a 2020 2020 2020 2020 2020 2020  ey].            
-00003320: 2020 2020 6966 2022 736f 7572 6365 2220      if "source" 
-00003330: 696e 2076 616c 7565 5f70 726f 7665 6e61  in value_provena
-00003340: 6e63 653a 0a20 2020 2020 2020 2020 2020  nce:.           
-00003350: 2020 2020 2020 2020 2076 616c 7565 5f70           value_p
-00003360: 726f 7665 6e61 6e63 655b 2273 6f75 7263  rovenance["sourc
-00003370: 6522 5d20 2b3d 2066 227c 7265 6e61 6d65  e"] += f"|rename
-00003380: 2d66 726f 6d3a 7b6b 6579 7d22 0a20 2020  -from:{key}".   
-00003390: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-000033a0: 2020 2020 2020 2020 2020 2020 2020 2076                 v
-000033b0: 616c 7565 5f70 726f 7665 6e61 6e63 6520  alue_provenance 
-000033c0: 3d20 7b22 736f 7572 6365 223a 2066 227c  = {"source": f"|
-000033d0: 7265 6e61 6d65 2d66 726f 6d3a 7b6b 6579  rename-from:{key
-000033e0: 7d22 2c20 226e 6f74 6522 3a20 2222 7d0a  }", "note": ""}.
-000033f0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00003400: 2e64 6174 615b 2263 6f6c 7265 765f 6461  .data["colrev_da
-00003410: 7461 5f70 726f 7665 6e61 6e63 6522 5d5b  ta_provenance"][
-00003420: 6e65 775f 6b65 795d 203d 2076 616c 7565  new_key] = value
-00003430: 5f70 726f 7665 6e61 6e63 650a 0a20 2020  _provenance..   
-00003440: 2020 2020 2073 656c 662e 7265 6d6f 7665       self.remove
-00003450: 5f66 6965 6c64 286b 6579 3d6b 6579 290a  _field(key=key).
-00003460: 0a20 2020 2064 6566 2063 6861 6e67 655f  .    def change_
-00003470: 656e 7472 7974 7970 6528 0a20 2020 2020  entrytype(.     
-00003480: 2020 2073 656c 662c 0a20 2020 2020 2020     self,.       
-00003490: 202a 2c0a 2020 2020 2020 2020 6e65 775f   *,.        new_
-000034a0: 656e 7472 7974 7970 653a 2073 7472 2c0a  entrytype: str,.
-000034b0: 2020 2020 2020 2020 716d 3a20 636f 6c72          qm: colr
-000034c0: 6576 2e71 6d2e 7175 616c 6974 795f 6d6f  ev.qm.quality_mo
-000034d0: 6465 6c2e 5175 616c 6974 794d 6f64 656c  del.QualityModel
-000034e0: 2c0a 2020 2020 2920 2d3e 204e 6f6e 653a  ,.    ) -> None:
-000034f0: 0a20 2020 2020 2020 2022 2222 4368 616e  .        """Chan
-00003500: 6765 2074 6865 2045 4e54 5259 5459 5045  ge the ENTRYTYPE
-00003510: 2222 220a 2020 2020 2020 2020 666f 7220  """.        for 
-00003520: 7661 6c75 6520 696e 2073 656c 662e 6461  value in self.da
-00003530: 7461 2e67 6574 2822 636f 6c72 6576 5f6d  ta.get("colrev_m
-00003540: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
-00003550: 616e 6365 222c 207b 7d29 2e76 616c 7565  ance", {}).value
-00003560: 7328 293a 0a20 2020 2020 2020 2020 2020  s():.           
-00003570: 2069 6620 2269 6e63 6f6e 7369 7374 656e   if "inconsisten
-00003580: 742d 7769 7468 2d65 6e74 7279 7479 7065  t-with-entrytype
-00003590: 2220 696e 2076 616c 7565 5b22 6e6f 7465  " in value["note
-000035a0: 225d 3a0a 2020 2020 2020 2020 2020 2020  "]:.            
-000035b0: 2020 2020 7661 6c75 655b 226e 6f74 6522      value["note"
-000035c0: 5d20 3d20 2222 0a20 2020 2020 2020 2020  ] = "".         
-000035d0: 2020 2069 6620 226d 6973 7369 6e67 2220     if "missing" 
-000035e0: 696e 2076 616c 7565 5b22 6e6f 7465 225d  in value["note"]
-000035f0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00003600: 2020 7661 6c75 655b 226e 6f74 6522 5d20    value["note"] 
-00003610: 3d20 2222 0a20 2020 2020 2020 206d 6973  = "".        mis
-00003620: 7369 6e67 5f66 6965 6c64 7320 3d20 5b6b  sing_fields = [k
-00003630: 2066 6f72 206b 2c20 7620 696e 2073 656c   for k, v in sel
-00003640: 662e 6461 7461 2e69 7465 6d73 2829 2069  f.data.items() i
-00003650: 6620 7620 3d3d 2022 554e 4b4e 4f57 4e22  f v == "UNKNOWN"
-00003660: 5d0a 2020 2020 2020 2020 666f 7220 6d69  ].        for mi
-00003670: 7373 696e 675f 6669 656c 6420 696e 206d  ssing_field in m
-00003680: 6973 7369 6e67 5f66 6965 6c64 733a 0a20  issing_fields:. 
-00003690: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-000036a0: 7265 6d6f 7665 5f66 6965 6c64 286b 6579  remove_field(key
-000036b0: 3d6d 6973 7369 6e67 5f66 6965 6c64 290a  =missing_field).
-000036c0: 0a20 2020 2020 2020 2073 656c 662e 6461  .        self.da
-000036d0: 7461 5b22 454e 5452 5954 5950 4522 5d20  ta["ENTRYTYPE"] 
-000036e0: 3d20 6e65 775f 656e 7472 7974 7970 650a  = new_entrytype.
-000036f0: 2020 2020 2020 2020 6966 206e 6577 5f65          if new_e
-00003700: 6e74 7279 7479 7065 2069 6e20 5b22 696e  ntrytype in ["in
-00003710: 7072 6f63 6565 6469 6e67 7322 2c20 2270  proceedings", "p
-00003720: 726f 6365 6564 696e 6773 225d 3a0a 2020  roceedings"]:.  
-00003730: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
-00003740: 662e 6461 7461 2e67 6574 2822 766f 6c75  f.data.get("volu
-00003750: 6d65 222c 2022 2229 203d 3d20 2255 4e4b  me", "") == "UNK
-00003760: 4e4f 574e 223a 0a20 2020 2020 2020 2020  NOWN":.         
-00003770: 2020 2020 2020 2073 656c 662e 7265 6d6f         self.remo
-00003780: 7665 5f66 6965 6c64 286b 6579 3d22 766f  ve_field(key="vo
-00003790: 6c75 6d65 2229 0a20 2020 2020 2020 2020  lume").         
-000037a0: 2020 2069 6620 7365 6c66 2e64 6174 612e     if self.data.
-000037b0: 6765 7428 226e 756d 6265 7222 2c20 2222  get("number", ""
-000037c0: 2920 3d3d 2022 554e 4b4e 4f57 4e22 3a0a  ) == "UNKNOWN":.
-000037d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000037e0: 7365 6c66 2e72 656d 6f76 655f 6669 656c  self.remove_fiel
-000037f0: 6428 6b65 793d 226e 756d 6265 7222 290a  d(key="number").
-00003800: 2020 2020 2020 2020 2020 2020 6966 2022              if "
-00003810: 6a6f 7572 6e61 6c22 2069 6e20 7365 6c66  journal" in self
-00003820: 2e64 6174 6120 616e 6420 2262 6f6f 6b74  .data and "bookt
-00003830: 6974 6c65 2220 6e6f 7420 696e 2073 656c  itle" not in sel
-00003840: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
-00003850: 2020 2020 2020 2020 7365 6c66 2e72 656e          self.ren
-00003860: 616d 655f 6669 656c 6428 6b65 793d 226a  ame_field(key="j
-00003870: 6f75 726e 616c 222c 206e 6577 5f6b 6579  ournal", new_key
-00003880: 3d22 626f 6f6b 7469 746c 6522 290a 2020  ="booktitle").  
-00003890: 2020 2020 2020 656c 6966 206e 6577 5f65        elif new_e
-000038a0: 6e74 7279 7479 7065 203d 3d20 2261 7274  ntrytype == "art
-000038b0: 6963 6c65 223a 0a20 2020 2020 2020 2020  icle":.         
-000038c0: 2020 2069 6620 2262 6f6f 6b74 6974 6c65     if "booktitle
-000038d0: 2220 696e 2073 656c 662e 6461 7461 3a0a  " in self.data:.
-000038e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000038f0: 7365 6c66 2e72 656e 616d 655f 6669 656c  self.rename_fiel
-00003900: 6428 6b65 793d 2262 6f6f 6b74 6974 6c65  d(key="booktitle
-00003910: 222c 206e 6577 5f6b 6579 3d22 6a6f 7572  ", new_key="jour
-00003920: 6e61 6c22 290a 2020 2020 2020 2020 656c  nal").        el
-00003930: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00003940: 7261 6973 6520 636f 6c72 6576 5f65 7863  raise colrev_exc
-00003950: 6570 7469 6f6e 732e 4d69 7373 696e 6752  eptions.MissingR
-00003960: 6563 6f72 6451 7561 6c69 7479 5275 6c65  ecordQualityRule
-00003970: 5370 6563 6966 6963 6174 696f 6e28 0a20  Specification(. 
-00003980: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00003990: 224e 6f20 454e 5452 5954 5950 4520 7370  "No ENTRYTYPE sp
-000039a0: 6563 6966 6963 6174 696f 6e20 287b 6e65  ecification ({ne
-000039b0: 775f 656e 7472 7974 7970 657d 2922 0a20  w_entrytype})". 
-000039c0: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
-000039d0: 2020 2020 2020 7365 6c66 2e75 7064 6174        self.updat
-000039e0: 655f 6d61 7374 6572 6461 7461 5f70 726f  e_masterdata_pro
-000039f0: 7665 6e61 6e63 6528 716d 3d71 6d29 0a0a  venance(qm=qm)..
-00003a00: 2020 2020 6465 6620 7265 6d6f 7665 5f66      def remove_f
-00003a10: 6965 6c64 280a 2020 2020 2020 2020 7365  ield(.        se
-00003a20: 6c66 2c20 2a2c 206b 6579 3a20 7374 722c  lf, *, key: str,
-00003a30: 206e 6f74 5f6d 6973 7369 6e67 5f6e 6f74   not_missing_not
-00003a40: 653a 2062 6f6f 6c20 3d20 4661 6c73 652c  e: bool = False,
-00003a50: 2073 6f75 7263 653a 2073 7472 203d 2022   source: str = "
-00003a60: 220a 2020 2020 2920 2d3e 204e 6f6e 653a  ".    ) -> None:
-00003a70: 0a20 2020 2020 2020 2022 2222 5265 6d6f  .        """Remo
-00003a80: 7665 2061 2066 6965 6c64 2222 220a 0a20  ve a field""".. 
-00003a90: 2020 2020 2020 2069 6620 6b65 7920 696e         if key in
-00003aa0: 2073 656c 662e 6461 7461 3a0a 2020 2020   self.data:.    
-00003ab0: 2020 2020 2020 2020 6465 6c20 7365 6c66          del self
-00003ac0: 2e64 6174 615b 6b65 795d 0a0a 2020 2020  .data[key]..    
-00003ad0: 2020 2020 6966 2022 636f 6c72 6576 5f6d      if "colrev_m
-00003ae0: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
-00003af0: 616e 6365 2220 6e6f 7420 696e 2073 656c  ance" not in sel
-00003b00: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
-00003b10: 2020 2020 7365 6c66 2e64 6174 615b 2263      self.data["c
-00003b20: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
-00003b30: 5f70 726f 7665 6e61 6e63 6522 5d20 3d20  _provenance"] = 
-00003b40: 7b7d 0a0a 2020 2020 2020 2020 6966 206e  {}..        if n
-00003b50: 6f74 5f6d 6973 7369 6e67 5f6e 6f74 6520  ot_missing_note 
-00003b60: 616e 6420 6b65 7920 696e 2073 656c 662e  and key in self.
-00003b70: 6964 656e 7469 6679 696e 675f 6669 656c  identifying_fiel
-00003b80: 645f 6b65 7973 3a0a 2020 2020 2020 2020  d_keys:.        
-00003b90: 2020 2020 2320 4578 616d 706c 653a 206a      # Example: j
-00003ba0: 6f75 726e 616c 2077 6974 686f 7574 206e  ournal without n
-00003bb0: 756d 6265 720a 2020 2020 2020 2020 2020  umber.          
-00003bc0: 2020 2320 7765 2073 686f 756c 6420 6b65    # we should ke
-00003bd0: 6570 2074 6861 7420 696e 666f 726d 6174  ep that informat
-00003be0: 696f 6e20 7468 6174 2061 2070 6172 7469  ion that a parti
-00003bf0: 6375 6c61 7220 6d61 7374 6572 6461 7461  cular masterdata
-00003c00: 0a20 2020 2020 2020 2020 2020 2023 2066  .            # f
-00003c10: 6965 6c64 2069 7320 6e6f 7420 7265 7175  ield is not requ
-00003c20: 6972 6564 0a20 2020 2020 2020 2020 2020  ired.           
-00003c30: 2069 6620 6b65 7920 6e6f 7420 696e 2073   if key not in s
-00003c40: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
-00003c50: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
-00003c60: 656e 616e 6365 225d 3a0a 2020 2020 2020  enance"]:.      
-00003c70: 2020 2020 2020 2020 2020 7365 6c66 2e64            self.d
-00003c80: 6174 615b 2263 6f6c 7265 765f 6d61 7374  ata["colrev_mast
-00003c90: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
-00003ca0: 6522 5d5b 6b65 795d 203d 207b 7d0a 2020  e"][key] = {}.  
-00003cb0: 2020 2020 2020 2020 2020 7365 6c66 2e64            self.d
-00003cc0: 6174 615b 2263 6f6c 7265 765f 6d61 7374  ata["colrev_mast
-00003cd0: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
-00003ce0: 6522 5d5b 6b65 795d 5b22 6e6f 7465 225d  e"][key]["note"]
-00003cf0: 203d 2022 6e6f 742d 6d69 7373 696e 6722   = "not-missing"
-00003d00: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00003d10: 736f 7572 6365 2021 3d20 2222 3a0a 2020  source != "":.  
-00003d20: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00003d30: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
-00003d40: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
-00003d50: 6e61 6e63 6522 5d5b 6b65 795d 5b22 736f  nance"][key]["so
-00003d60: 7572 6365 225d 203d 2073 6f75 7263 650a  urce"] = source.
-00003d70: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00003d80: 2020 2020 2020 2020 2020 6966 206b 6579            if key
-00003d90: 2069 6e20 7365 6c66 2e69 6465 6e74 6966   in self.identif
-00003da0: 7969 6e67 5f66 6965 6c64 5f6b 6579 733a  ying_field_keys:
-00003db0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003dc0: 2069 6620 6b65 7920 696e 2073 656c 662e   if key in self.
-00003dd0: 6461 7461 2e67 6574 2822 636f 6c72 6576  data.get("colrev
-00003de0: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
-00003df0: 656e 616e 6365 222c 207b 7d29 3a0a 2020  enance", {}):.  
-00003e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003e10: 2020 6465 6c20 7365 6c66 2e64 6174 615b    del self.data[
-00003e20: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
-00003e30: 7461 5f70 726f 7665 6e61 6e63 6522 5d5b  ta_provenance"][
-00003e40: 6b65 795d 0a20 2020 2020 2020 2020 2020  key].           
-00003e50: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00003e60: 2020 2020 2020 2069 6620 6b65 7920 696e         if key in
-00003e70: 2073 656c 662e 6461 7461 2e67 6574 2822   self.data.get("
-00003e80: 636f 6c72 6576 5f64 6174 615f 7072 6f76  colrev_data_prov
-00003e90: 656e 616e 6365 222c 207b 7d29 3a0a 2020  enance", {}):.  
-00003ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003eb0: 2020 6465 6c20 7365 6c66 2e64 6174 615b    del self.data[
-00003ec0: 2263 6f6c 7265 765f 6461 7461 5f70 726f  "colrev_data_pro
-00003ed0: 7665 6e61 6e63 6522 5d5b 6b65 795d 0a0a  venance"][key]..
-00003ee0: 2020 2020 6465 6620 7365 745f 6d61 7374      def set_mast
-00003ef0: 6572 6461 7461 5f63 6f6d 706c 6574 6528  erdata_complete(
-00003f00: 0a20 2020 2020 2020 2073 656c 662c 202a  .        self, *
-00003f10: 2c20 736f 7572 6365 3a20 7374 722c 206d  , source: str, m
-00003f20: 6173 7465 7264 6174 615f 7265 706f 7369  asterdata_reposi
-00003f30: 746f 7279 3a20 626f 6f6c 2c20 7265 706c  tory: bool, repl
-00003f40: 6163 655f 736f 7572 6365 3a20 626f 6f6c  ace_source: bool
-00003f50: 203d 2054 7275 650a 2020 2020 2920 2d3e   = True.    ) ->
-00003f60: 204e 6f6e 653a 0a20 2020 2020 2020 2022   None:.        "
-00003f70: 2222 5365 7420 7468 6520 6d61 7374 6572  ""Set the master
-00003f80: 6461 7461 2074 6f20 636f 6d70 6c65 7465  data to complete
-00003f90: 2222 220a 2020 2020 2020 2020 2320 7079  """.        # py
-00003fa0: 6c69 6e74 3a20 6469 7361 626c 653d 746f  lint: disable=to
-00003fb0: 6f2d 6d61 6e79 2d62 7261 6e63 6865 730a  o-many-branches.
-00003fc0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-00003fd0: 6d61 7374 6572 6461 7461 5f69 735f 6375  masterdata_is_cu
-00003fe0: 7261 7465 6428 2920 6f72 206d 6173 7465  rated() or maste
-00003ff0: 7264 6174 615f 7265 706f 7369 746f 7279  rdata_repository
-00004000: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00004010: 7475 726e 0a0a 2020 2020 2020 2020 6966  turn..        if
-00004020: 2022 636f 6c72 6576 5f6d 6173 7465 7264   "colrev_masterd
-00004030: 6174 615f 7072 6f76 656e 616e 6365 2220  ata_provenance" 
-00004040: 6e6f 7420 696e 2073 656c 662e 6461 7461  not in self.data
-00004050: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
-00004060: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
-00004070: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
-00004080: 6e61 6e63 6522 5d20 3d20 7b7d 0a20 2020  nance"] = {}.   
-00004090: 2020 2020 206d 645f 705f 6469 6374 203d       md_p_dict =
-000040a0: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
-000040b0: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
-000040c0: 6f76 656e 616e 6365 225d 0a0a 2020 2020  ovenance"]..    
-000040d0: 2020 2020 666f 7220 6964 656e 7469 6679      for identify
-000040e0: 696e 675f 6669 656c 645f 6b65 7920 696e  ing_field_key in
-000040f0: 2073 656c 662e 6964 656e 7469 6679 696e   self.identifyin
-00004100: 675f 6669 656c 645f 6b65 7973 3a0a 2020  g_field_keys:.  
-00004110: 2020 2020 2020 2020 2020 6966 2069 6465            if ide
-00004120: 6e74 6966 7969 6e67 5f66 6965 6c64 5f6b  ntifying_field_k
-00004130: 6579 2069 6e20 5b22 6175 7468 6f72 222c  ey in ["author",
-00004140: 2022 7469 746c 6522 2c20 2279 6561 7222   "title", "year"
-00004150: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
-00004160: 2020 2063 6f6e 7469 6e75 650a 2020 2020     continue.    
-00004170: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-00004180: 6461 7461 2e67 6574 2869 6465 6e74 6966  data.get(identif
-00004190: 7969 6e67 5f66 6965 6c64 5f6b 6579 2c20  ying_field_key, 
-000041a0: 224e 4122 2920 3d3d 2022 554e 4b4e 4f57  "NA") == "UNKNOW
-000041b0: 4e22 3a0a 2020 2020 2020 2020 2020 2020  N":.            
-000041c0: 2020 2020 6465 6c20 7365 6c66 2e64 6174      del self.dat
-000041d0: 615b 6964 656e 7469 6679 696e 675f 6669  a[identifying_fi
-000041e0: 656c 645f 6b65 795d 0a20 2020 2020 2020  eld_key].       
-000041f0: 2020 2020 2069 6620 6964 656e 7469 6679       if identify
-00004200: 696e 675f 6669 656c 645f 6b65 7920 696e  ing_field_key in
-00004210: 206d 645f 705f 6469 6374 3a0a 2020 2020   md_p_dict:.    
-00004220: 2020 2020 2020 2020 2020 2020 6e6f 7465              note
-00004230: 203d 206d 645f 705f 6469 6374 5b69 6465   = md_p_dict[ide
-00004240: 6e74 6966 7969 6e67 5f66 6965 6c64 5f6b  ntifying_field_k
-00004250: 6579 5d5b 226e 6f74 6522 5d0a 2020 2020  ey]["note"].    
-00004260: 2020 2020 2020 2020 2020 2020 6966 2022              if "
-00004270: 6d69 7373 696e 6722 2069 6e20 6e6f 7465  missing" in note
-00004280: 2061 6e64 2022 6e6f 742d 6d69 7373 696e   and "not-missin
-00004290: 6722 206e 6f74 2069 6e20 6e6f 7465 3a0a  g" not in note:.
-000042a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000042b0: 2020 2020 6d64 5f70 5f64 6963 745b 6964      md_p_dict[id
-000042c0: 656e 7469 6679 696e 675f 6669 656c 645f  entifying_field_
-000042d0: 6b65 795d 5b22 6e6f 7465 225d 203d 206e  key]["note"] = n
-000042e0: 6f74 652e 7265 706c 6163 6528 0a20 2020  ote.replace(.   
-000042f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004300: 2020 2020 2022 6d69 7373 696e 6722 2c20       "missing", 
-00004310: 2222 0a20 2020 2020 2020 2020 2020 2020  "".             
-00004320: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
-00004330: 2020 6966 2073 656c 662e 6461 7461 5b22    if self.data["
-00004340: 454e 5452 5954 5950 4522 5d20 3d3d 2022  ENTRYTYPE"] == "
-00004350: 6172 7469 636c 6522 3a0a 2020 2020 2020  article":.      
-00004360: 2020 2020 2020 6966 2022 766f 6c75 6d65        if "volume
-00004370: 2220 6e6f 7420 696e 2073 656c 662e 6461  " not in self.da
-00004380: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
-00004390: 2020 2020 6966 2022 766f 6c75 6d65 2220      if "volume" 
-000043a0: 696e 2073 656c 662e 6461 7461 5b22 636f  in self.data["co
-000043b0: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
-000043c0: 7072 6f76 656e 616e 6365 225d 3a0a 2020  provenance"]:.  
-000043d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000043e0: 2020 7365 6c66 2e64 6174 615b 2263 6f6c    self.data["col
-000043f0: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
-00004400: 726f 7665 6e61 6e63 6522 5d5b 2276 6f6c  rovenance"]["vol
-00004410: 756d 6522 5d5b 0a20 2020 2020 2020 2020  ume"][.         
-00004420: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00004430: 6e6f 7465 220a 2020 2020 2020 2020 2020  note".          
-00004440: 2020 2020 2020 2020 2020 5d20 3d20 226e            ] = "n
-00004450: 6f74 2d6d 6973 7369 6e67 220a 2020 2020  ot-missing".    
-00004460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004470: 6966 2072 6570 6c61 6365 5f73 6f75 7263  if replace_sourc
-00004480: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00004490: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-000044a0: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
-000044b0: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-000044c0: 6365 225d 5b22 766f 6c75 6d65 225d 5b0a  ce"]["volume"][.
-000044d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000044e0: 2020 2020 2020 2020 2020 2020 2273 6f75              "sou
-000044f0: 7263 6522 0a20 2020 2020 2020 2020 2020  rce".           
-00004500: 2020 2020 2020 2020 2020 2020 205d 203d               ] =
-00004510: 2073 6f75 7263 650a 2020 2020 2020 2020   source.        
-00004520: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00004530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004540: 2020 7365 6c66 2e64 6174 615b 2263 6f6c    self.data["col
-00004550: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
-00004560: 726f 7665 6e61 6e63 6522 5d5b 2276 6f6c  rovenance"]["vol
-00004570: 756d 6522 5d20 3d20 7b0a 2020 2020 2020  ume"] = {.      
-00004580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004590: 2020 2273 6f75 7263 6522 3a20 736f 7572    "source": sour
-000045a0: 6365 2c0a 2020 2020 2020 2020 2020 2020  ce,.            
-000045b0: 2020 2020 2020 2020 2020 2020 226e 6f74              "not
-000045c0: 6522 3a20 226e 6f74 2d6d 6973 7369 6e67  e": "not-missing
-000045d0: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
-000045e0: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
-000045f0: 2020 2020 2020 6966 2022 6e75 6d62 6572        if "number
-00004600: 2220 6e6f 7420 696e 2073 656c 662e 6461  " not in self.da
-00004610: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
-00004620: 2020 2020 6966 2022 6e75 6d62 6572 2220      if "number" 
-00004630: 696e 2073 656c 662e 6461 7461 5b22 636f  in self.data["co
-00004640: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
-00004650: 7072 6f76 656e 616e 6365 225d 3a0a 2020  provenance"]:.  
-00004660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004670: 2020 7365 6c66 2e64 6174 615b 2263 6f6c    self.data["col
-00004680: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
-00004690: 726f 7665 6e61 6e63 6522 5d5b 226e 756d  rovenance"]["num
-000046a0: 6265 7222 5d5b 0a20 2020 2020 2020 2020  ber"][.         
-000046b0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-000046c0: 6e6f 7465 220a 2020 2020 2020 2020 2020  note".          
-000046d0: 2020 2020 2020 2020 2020 5d20 3d20 226e            ] = "n
-000046e0: 6f74 2d6d 6973 7369 6e67 220a 2020 2020  ot-missing".    
-000046f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004700: 6966 2072 6570 6c61 6365 5f73 6f75 7263  if replace_sourc
-00004710: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00004720: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00004730: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
-00004740: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-00004750: 6365 225d 5b22 6e75 6d62 6572 225d 5b0a  ce"]["number"][.
+00003090: 2069 6620 6b65 7920 6e6f 7420 696e 2073   if key not in s
+000030a0: 656c 662e 6461 7461 3a0a 2020 2020 2020  elf.data:.      
+000030b0: 2020 2020 2020 7265 7475 726e 0a20 2020        return.   
+000030c0: 2020 2020 2076 616c 7565 203d 2073 656c       value = sel
+000030d0: 662e 6461 7461 5b6b 6579 5d0a 2020 2020  f.data[key].    
+000030e0: 2020 2020 7365 6c66 2e64 6174 615b 6e65      self.data[ne
+000030f0: 775f 6b65 795d 203d 2076 616c 7565 0a0a  w_key] = value..
+00003100: 2020 2020 2020 2020 6966 206b 6579 2069          if key i
+00003110: 6e20 7365 6c66 2e69 6465 6e74 6966 7969  n self.identifyi
+00003120: 6e67 5f66 6965 6c64 5f6b 6579 733a 0a20  ng_field_keys:. 
+00003130: 2020 2020 2020 2020 2020 2069 6620 2263             if "c
+00003140: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
+00003150: 5f70 726f 7665 6e61 6e63 6522 206e 6f74  _provenance" not
+00003160: 2069 6e20 7365 6c66 2e64 6174 613a 0a20   in self.data:. 
+00003170: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00003180: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
+00003190: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
+000031a0: 656e 616e 6365 225d 203d 207b 7d0a 2020  enance"] = {}.  
+000031b0: 2020 2020 2020 2020 2020 6966 206b 6579            if key
+000031c0: 2069 6e20 7365 6c66 2e64 6174 615b 2263   in self.data["c
+000031d0: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
+000031e0: 5f70 726f 7665 6e61 6e63 6522 5d3a 0a20  _provenance"]:. 
+000031f0: 2020 2020 2020 2020 2020 2020 2020 2076                 v
+00003200: 616c 7565 5f70 726f 7665 6e61 6e63 6520  alue_provenance 
+00003210: 3d20 7365 6c66 2e64 6174 615b 2263 6f6c  = self.data["col
+00003220: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
+00003230: 726f 7665 6e61 6e63 6522 5d5b 6b65 795d  rovenance"][key]
+00003240: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003250: 2069 6620 2273 6f75 7263 6522 2069 6e20   if "source" in 
+00003260: 7661 6c75 655f 7072 6f76 656e 616e 6365  value_provenance
+00003270: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00003280: 2020 2020 2020 7661 6c75 655f 7072 6f76        value_prov
+00003290: 656e 616e 6365 5b22 736f 7572 6365 225d  enance["source"]
+000032a0: 202b 3d20 6622 7c72 656e 616d 652d 6672   += f"|rename-fr
+000032b0: 6f6d 3a7b 6b65 797d 220a 2020 2020 2020  om:{key}".      
+000032c0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+000032d0: 2020 2020 2020 2020 2020 2020 7661 6c75              valu
+000032e0: 655f 7072 6f76 656e 616e 6365 203d 207b  e_provenance = {
+000032f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003300: 2020 2020 2022 736f 7572 6365 223a 2066       "source": f
+00003310: 227c 7265 6e61 6d65 2d66 726f 6d3a 7b6b  "|rename-from:{k
+00003320: 6579 7d22 2c0a 2020 2020 2020 2020 2020  ey}",.          
+00003330: 2020 2020 2020 2020 2020 226e 6f74 6522            "note"
+00003340: 3a20 2222 2c0a 2020 2020 2020 2020 2020  : "",.          
+00003350: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
+00003360: 2020 2020 7365 6c66 2e64 6174 615b 2263      self.data["c
+00003370: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
+00003380: 5f70 726f 7665 6e61 6e63 6522 5d5b 6e65  _provenance"][ne
+00003390: 775f 6b65 795d 203d 2076 616c 7565 5f70  w_key] = value_p
+000033a0: 726f 7665 6e61 6e63 650a 2020 2020 2020  rovenance.      
+000033b0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+000033c0: 2020 2020 6966 2022 636f 6c72 6576 5f64      if "colrev_d
+000033d0: 6174 615f 7072 6f76 656e 616e 6365 2220  ata_provenance" 
+000033e0: 6e6f 7420 696e 2073 656c 662e 6461 7461  not in self.data
+000033f0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00003400: 2020 7365 6c66 2e64 6174 615b 2263 6f6c    self.data["col
+00003410: 7265 765f 6461 7461 5f70 726f 7665 6e61  rev_data_provena
+00003420: 6e63 6522 5d20 3d20 7b7d 0a20 2020 2020  nce"] = {}.     
+00003430: 2020 2020 2020 2069 6620 6b65 7920 696e         if key in
+00003440: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
+00003450: 6576 5f64 6174 615f 7072 6f76 656e 616e  ev_data_provenan
+00003460: 6365 225d 3a0a 2020 2020 2020 2020 2020  ce"]:.          
+00003470: 2020 2020 2020 7661 6c75 655f 7072 6f76        value_prov
+00003480: 656e 616e 6365 203d 2073 656c 662e 6461  enance = self.da
+00003490: 7461 5b22 636f 6c72 6576 5f64 6174 615f  ta["colrev_data_
+000034a0: 7072 6f76 656e 616e 6365 225d 5b6b 6579  provenance"][key
+000034b0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+000034c0: 2020 6966 2022 736f 7572 6365 2220 696e    if "source" in
+000034d0: 2076 616c 7565 5f70 726f 7665 6e61 6e63   value_provenanc
+000034e0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+000034f0: 2020 2020 2020 2076 616c 7565 5f70 726f         value_pro
+00003500: 7665 6e61 6e63 655b 2273 6f75 7263 6522  venance["source"
+00003510: 5d20 2b3d 2066 227c 7265 6e61 6d65 2d66  ] += f"|rename-f
+00003520: 726f 6d3a 7b6b 6579 7d22 0a20 2020 2020  rom:{key}".     
+00003530: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00003540: 2020 2020 2020 2020 2020 2020 2076 616c               val
+00003550: 7565 5f70 726f 7665 6e61 6e63 6520 3d20  ue_provenance = 
+00003560: 7b22 736f 7572 6365 223a 2066 227c 7265  {"source": f"|re
+00003570: 6e61 6d65 2d66 726f 6d3a 7b6b 6579 7d22  name-from:{key}"
+00003580: 2c20 226e 6f74 6522 3a20 2222 7d0a 2020  , "note": ""}.  
+00003590: 2020 2020 2020 2020 2020 7365 6c66 2e64            self.d
+000035a0: 6174 615b 2263 6f6c 7265 765f 6461 7461  ata["colrev_data
+000035b0: 5f70 726f 7665 6e61 6e63 6522 5d5b 6e65  _provenance"][ne
+000035c0: 775f 6b65 795d 203d 2076 616c 7565 5f70  w_key] = value_p
+000035d0: 726f 7665 6e61 6e63 650a 0a20 2020 2020  rovenance..     
+000035e0: 2020 2073 656c 662e 7265 6d6f 7665 5f66     self.remove_f
+000035f0: 6965 6c64 286b 6579 3d6b 6579 290a 0a20  ield(key=key).. 
+00003600: 2020 2064 6566 2063 6861 6e67 655f 656e     def change_en
+00003610: 7472 7974 7970 6528 0a20 2020 2020 2020  trytype(.       
+00003620: 2073 656c 662c 0a20 2020 2020 2020 202a   self,.        *
+00003630: 2c0a 2020 2020 2020 2020 6e65 775f 656e  ,.        new_en
+00003640: 7472 7974 7970 653a 2073 7472 2c0a 2020  trytype: str,.  
+00003650: 2020 2020 2020 716d 3a20 636f 6c72 6576        qm: colrev
+00003660: 2e71 6d2e 7175 616c 6974 795f 6d6f 6465  .qm.quality_mode
+00003670: 6c2e 5175 616c 6974 794d 6f64 656c 2c0a  l.QualityModel,.
+00003680: 2020 2020 2920 2d3e 204e 6f6e 653a 0a20      ) -> None:. 
+00003690: 2020 2020 2020 2022 2222 4368 616e 6765         """Change
+000036a0: 2074 6865 2045 4e54 5259 5459 5045 2222   the ENTRYTYPE""
+000036b0: 220a 2020 2020 2020 2020 666f 7220 7661  ".        for va
+000036c0: 6c75 6520 696e 2073 656c 662e 6461 7461  lue in self.data
+000036d0: 2e67 6574 2822 636f 6c72 6576 5f6d 6173  .get("colrev_mas
+000036e0: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
+000036f0: 6365 222c 207b 7d29 2e76 616c 7565 7328  ce", {}).values(
+00003700: 293a 0a20 2020 2020 2020 2020 2020 2069  ):.            i
+00003710: 6620 2269 6e63 6f6e 7369 7374 656e 742d  f "inconsistent-
+00003720: 7769 7468 2d65 6e74 7279 7479 7065 2220  with-entrytype" 
+00003730: 696e 2076 616c 7565 5b22 6e6f 7465 225d  in value["note"]
+00003740: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00003750: 2020 7661 6c75 655b 226e 6f74 6522 5d20    value["note"] 
+00003760: 3d20 2222 0a20 2020 2020 2020 2020 2020  = "".           
+00003770: 2069 6620 226d 6973 7369 6e67 2220 696e   if "missing" in
+00003780: 2076 616c 7565 5b22 6e6f 7465 225d 3a0a   value["note"]:.
+00003790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000037a0: 7661 6c75 655b 226e 6f74 6522 5d20 3d20  value["note"] = 
+000037b0: 2222 0a20 2020 2020 2020 206d 6973 7369  "".        missi
+000037c0: 6e67 5f66 6965 6c64 7320 3d20 5b6b 2066  ng_fields = [k f
+000037d0: 6f72 206b 2c20 7620 696e 2073 656c 662e  or k, v in self.
+000037e0: 6461 7461 2e69 7465 6d73 2829 2069 6620  data.items() if 
+000037f0: 7620 3d3d 2022 554e 4b4e 4f57 4e22 5d0a  v == "UNKNOWN"].
+00003800: 2020 2020 2020 2020 666f 7220 6d69 7373          for miss
+00003810: 696e 675f 6669 656c 6420 696e 206d 6973  ing_field in mis
+00003820: 7369 6e67 5f66 6965 6c64 733a 0a20 2020  sing_fields:.   
+00003830: 2020 2020 2020 2020 2073 656c 662e 7265           self.re
+00003840: 6d6f 7665 5f66 6965 6c64 286b 6579 3d6d  move_field(key=m
+00003850: 6973 7369 6e67 5f66 6965 6c64 290a 0a20  issing_field).. 
+00003860: 2020 2020 2020 2073 656c 662e 6461 7461         self.data
+00003870: 5b22 454e 5452 5954 5950 4522 5d20 3d20  ["ENTRYTYPE"] = 
+00003880: 6e65 775f 656e 7472 7974 7970 650a 2020  new_entrytype.  
+00003890: 2020 2020 2020 6966 206e 6577 5f65 6e74        if new_ent
+000038a0: 7279 7479 7065 2069 6e20 5b22 696e 7072  rytype in ["inpr
+000038b0: 6f63 6565 6469 6e67 7322 2c20 2270 726f  oceedings", "pro
+000038c0: 6365 6564 696e 6773 225d 3a0a 2020 2020  ceedings"]:.    
+000038d0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+000038e0: 6461 7461 2e67 6574 2822 766f 6c75 6d65  data.get("volume
+000038f0: 222c 2022 2229 203d 3d20 2255 4e4b 4e4f  ", "") == "UNKNO
+00003900: 574e 223a 0a20 2020 2020 2020 2020 2020  WN":.           
+00003910: 2020 2020 2073 656c 662e 7265 6d6f 7665       self.remove
+00003920: 5f66 6965 6c64 286b 6579 3d22 766f 6c75  _field(key="volu
+00003930: 6d65 2229 0a20 2020 2020 2020 2020 2020  me").           
+00003940: 2069 6620 7365 6c66 2e64 6174 612e 6765   if self.data.ge
+00003950: 7428 226e 756d 6265 7222 2c20 2222 2920  t("number", "") 
+00003960: 3d3d 2022 554e 4b4e 4f57 4e22 3a0a 2020  == "UNKNOWN":.  
+00003970: 2020 2020 2020 2020 2020 2020 2020 7365                se
+00003980: 6c66 2e72 656d 6f76 655f 6669 656c 6428  lf.remove_field(
+00003990: 6b65 793d 226e 756d 6265 7222 290a 2020  key="number").  
+000039a0: 2020 2020 2020 2020 2020 6966 2022 6a6f            if "jo
+000039b0: 7572 6e61 6c22 2069 6e20 7365 6c66 2e64  urnal" in self.d
+000039c0: 6174 6120 616e 6420 2262 6f6f 6b74 6974  ata and "booktit
+000039d0: 6c65 2220 6e6f 7420 696e 2073 656c 662e  le" not in self.
+000039e0: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
+000039f0: 2020 2020 2020 7365 6c66 2e72 656e 616d        self.renam
+00003a00: 655f 6669 656c 6428 6b65 793d 226a 6f75  e_field(key="jou
+00003a10: 726e 616c 222c 206e 6577 5f6b 6579 3d22  rnal", new_key="
+00003a20: 626f 6f6b 7469 746c 6522 290a 2020 2020  booktitle").    
+00003a30: 2020 2020 656c 6966 206e 6577 5f65 6e74      elif new_ent
+00003a40: 7279 7479 7065 203d 3d20 2261 7274 6963  rytype == "artic
+00003a50: 6c65 223a 0a20 2020 2020 2020 2020 2020  le":.           
+00003a60: 2069 6620 2262 6f6f 6b74 6974 6c65 2220   if "booktitle" 
+00003a70: 696e 2073 656c 662e 6461 7461 3a0a 2020  in self.data:.  
+00003a80: 2020 2020 2020 2020 2020 2020 2020 7365                se
+00003a90: 6c66 2e72 656e 616d 655f 6669 656c 6428  lf.rename_field(
+00003aa0: 6b65 793d 2262 6f6f 6b74 6974 6c65 222c  key="booktitle",
+00003ab0: 206e 6577 5f6b 6579 3d22 6a6f 7572 6e61   new_key="journa
+00003ac0: 6c22 290a 2020 2020 2020 2020 656c 6966  l").        elif
+00003ad0: 206e 6577 5f65 6e74 7279 7479 7065 2069   new_entrytype i
+00003ae0: 6e20 5b0a 2020 2020 2020 2020 2020 2020  n [.            
+00003af0: 2269 6e62 6f6f 6b22 2c0a 2020 2020 2020  "inbook",.      
+00003b00: 2020 2020 2020 2262 6f6f 6b22 2c0a 2020        "book",.  
+00003b10: 2020 2020 2020 2020 2020 2269 6e63 6f6c            "incol
+00003b20: 6c65 6374 696f 6e22 2c0a 2020 2020 2020  lection",.      
+00003b30: 2020 2020 2020 2270 6864 7468 6573 6973        "phdthesis
+00003b40: 222c 0a20 2020 2020 2020 2020 2020 2022  ",.            "
+00003b50: 7468 6573 6973 222c 0a20 2020 2020 2020  thesis",.       
+00003b60: 2020 2020 2022 6d61 7374 6572 7468 6573       "masterthes
+00003b70: 6973 222c 0a20 2020 2020 2020 2020 2020  is",.           
+00003b80: 2022 6261 6368 656c 6f72 7468 6573 6973   "bachelorthesis
+00003b90: 222c 0a20 2020 2020 2020 2020 2020 2022  ",.            "
+00003ba0: 7465 6368 7265 706f 7274 222c 0a20 2020  techreport",.   
+00003bb0: 2020 2020 2020 2020 2022 756e 7075 626c           "unpubl
+00003bc0: 6973 6865 6422 2c0a 2020 2020 2020 2020  ished",.        
+00003bd0: 2020 2020 226d 6973 6322 2c0a 2020 2020      "misc",.    
+00003be0: 2020 2020 2020 2020 2273 6f66 7477 6172          "softwar
+00003bf0: 6522 2c0a 2020 2020 2020 2020 2020 2020  e",.            
+00003c00: 226f 6e6c 696e 6522 2c0a 2020 2020 2020  "online",.      
+00003c10: 2020 5d3a 0a20 2020 2020 2020 2020 2020    ]:.           
+00003c20: 2070 6173 730a 2020 2020 2020 2020 656c   pass.        el
+00003c30: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00003c40: 7261 6973 6520 636f 6c72 6576 5f65 7863  raise colrev_exc
+00003c50: 6570 7469 6f6e 732e 4d69 7373 696e 6752  eptions.MissingR
+00003c60: 6563 6f72 6451 7561 6c69 7479 5275 6c65  ecordQualityRule
+00003c70: 5370 6563 6966 6963 6174 696f 6e28 0a20  Specification(. 
+00003c80: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00003c90: 224e 6f20 454e 5452 5954 5950 4520 7370  "No ENTRYTYPE sp
+00003ca0: 6563 6966 6963 6174 696f 6e20 287b 6e65  ecification ({ne
+00003cb0: 775f 656e 7472 7974 7970 657d 2922 0a20  w_entrytype})". 
+00003cc0: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
+00003cd0: 2020 2020 2020 7365 6c66 2e75 7064 6174        self.updat
+00003ce0: 655f 6d61 7374 6572 6461 7461 5f70 726f  e_masterdata_pro
+00003cf0: 7665 6e61 6e63 6528 716d 3d71 6d29 0a0a  venance(qm=qm)..
+00003d00: 2020 2020 6465 6620 7265 6d6f 7665 5f66      def remove_f
+00003d10: 6965 6c64 280a 2020 2020 2020 2020 7365  ield(.        se
+00003d20: 6c66 2c20 2a2c 206b 6579 3a20 7374 722c  lf, *, key: str,
+00003d30: 206e 6f74 5f6d 6973 7369 6e67 5f6e 6f74   not_missing_not
+00003d40: 653a 2062 6f6f 6c20 3d20 4661 6c73 652c  e: bool = False,
+00003d50: 2073 6f75 7263 653a 2073 7472 203d 2022   source: str = "
+00003d60: 220a 2020 2020 2920 2d3e 204e 6f6e 653a  ".    ) -> None:
+00003d70: 0a20 2020 2020 2020 2022 2222 5265 6d6f  .        """Remo
+00003d80: 7665 2061 2066 6965 6c64 2222 220a 0a20  ve a field""".. 
+00003d90: 2020 2020 2020 2069 6620 6b65 7920 696e         if key in
+00003da0: 2073 656c 662e 6461 7461 3a0a 2020 2020   self.data:.    
+00003db0: 2020 2020 2020 2020 6465 6c20 7365 6c66          del self
+00003dc0: 2e64 6174 615b 6b65 795d 0a0a 2020 2020  .data[key]..    
+00003dd0: 2020 2020 6966 2022 636f 6c72 6576 5f6d      if "colrev_m
+00003de0: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
+00003df0: 616e 6365 2220 6e6f 7420 696e 2073 656c  ance" not in sel
+00003e00: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
+00003e10: 2020 2020 7365 6c66 2e64 6174 615b 2263      self.data["c
+00003e20: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
+00003e30: 5f70 726f 7665 6e61 6e63 6522 5d20 3d20  _provenance"] = 
+00003e40: 7b7d 0a0a 2020 2020 2020 2020 6966 206e  {}..        if n
+00003e50: 6f74 5f6d 6973 7369 6e67 5f6e 6f74 6520  ot_missing_note 
+00003e60: 616e 6420 6b65 7920 696e 2073 656c 662e  and key in self.
+00003e70: 6964 656e 7469 6679 696e 675f 6669 656c  identifying_fiel
+00003e80: 645f 6b65 7973 3a0a 2020 2020 2020 2020  d_keys:.        
+00003e90: 2020 2020 2320 4578 616d 706c 653a 206a      # Example: j
+00003ea0: 6f75 726e 616c 2077 6974 686f 7574 206e  ournal without n
+00003eb0: 756d 6265 720a 2020 2020 2020 2020 2020  umber.          
+00003ec0: 2020 2320 7765 2073 686f 756c 6420 6b65    # we should ke
+00003ed0: 6570 2074 6861 7420 696e 666f 726d 6174  ep that informat
+00003ee0: 696f 6e20 7468 6174 2061 2070 6172 7469  ion that a parti
+00003ef0: 6375 6c61 7220 6d61 7374 6572 6461 7461  cular masterdata
+00003f00: 0a20 2020 2020 2020 2020 2020 2023 2066  .            # f
+00003f10: 6965 6c64 2069 7320 6e6f 7420 7265 7175  ield is not requ
+00003f20: 6972 6564 0a20 2020 2020 2020 2020 2020  ired.           
+00003f30: 2069 6620 6b65 7920 6e6f 7420 696e 2073   if key not in s
+00003f40: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
+00003f50: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
+00003f60: 656e 616e 6365 225d 3a0a 2020 2020 2020  enance"]:.      
+00003f70: 2020 2020 2020 2020 2020 7365 6c66 2e64            self.d
+00003f80: 6174 615b 2263 6f6c 7265 765f 6d61 7374  ata["colrev_mast
+00003f90: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
+00003fa0: 6522 5d5b 6b65 795d 203d 207b 7d0a 2020  e"][key] = {}.  
+00003fb0: 2020 2020 2020 2020 2020 7365 6c66 2e64            self.d
+00003fc0: 6174 615b 2263 6f6c 7265 765f 6d61 7374  ata["colrev_mast
+00003fd0: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
+00003fe0: 6522 5d5b 6b65 795d 5b22 6e6f 7465 225d  e"][key]["note"]
+00003ff0: 203d 2022 6e6f 742d 6d69 7373 696e 6722   = "not-missing"
+00004000: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00004010: 736f 7572 6365 2021 3d20 2222 3a0a 2020  source != "":.  
+00004020: 2020 2020 2020 2020 2020 2020 2020 7365                se
+00004030: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
+00004040: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
+00004050: 6e61 6e63 6522 5d5b 6b65 795d 5b22 736f  nance"][key]["so
+00004060: 7572 6365 225d 203d 2073 6f75 7263 650a  urce"] = source.
+00004070: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00004080: 2020 2020 2020 2020 2020 6966 206b 6579            if key
+00004090: 2069 6e20 7365 6c66 2e69 6465 6e74 6966   in self.identif
+000040a0: 7969 6e67 5f66 6965 6c64 5f6b 6579 733a  ying_field_keys:
+000040b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000040c0: 2069 6620 6b65 7920 696e 2073 656c 662e   if key in self.
+000040d0: 6461 7461 2e67 6574 2822 636f 6c72 6576  data.get("colrev
+000040e0: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
+000040f0: 656e 616e 6365 222c 207b 7d29 3a0a 2020  enance", {}):.  
+00004100: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004110: 2020 6465 6c20 7365 6c66 2e64 6174 615b    del self.data[
+00004120: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
+00004130: 7461 5f70 726f 7665 6e61 6e63 6522 5d5b  ta_provenance"][
+00004140: 6b65 795d 0a20 2020 2020 2020 2020 2020  key].           
+00004150: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00004160: 2020 2020 2020 2069 6620 6b65 7920 696e         if key in
+00004170: 2073 656c 662e 6461 7461 2e67 6574 2822   self.data.get("
+00004180: 636f 6c72 6576 5f64 6174 615f 7072 6f76  colrev_data_prov
+00004190: 656e 616e 6365 222c 207b 7d29 3a0a 2020  enance", {}):.  
+000041a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000041b0: 2020 6465 6c20 7365 6c66 2e64 6174 615b    del self.data[
+000041c0: 2263 6f6c 7265 765f 6461 7461 5f70 726f  "colrev_data_pro
+000041d0: 7665 6e61 6e63 6522 5d5b 6b65 795d 0a0a  venance"][key]..
+000041e0: 2020 2020 6465 6620 7365 745f 6d61 7374      def set_mast
+000041f0: 6572 6461 7461 5f63 6f6d 706c 6574 6528  erdata_complete(
+00004200: 0a20 2020 2020 2020 2073 656c 662c 202a  .        self, *
+00004210: 2c20 736f 7572 6365 3a20 7374 722c 206d  , source: str, m
+00004220: 6173 7465 7264 6174 615f 7265 706f 7369  asterdata_reposi
+00004230: 746f 7279 3a20 626f 6f6c 2c20 7265 706c  tory: bool, repl
+00004240: 6163 655f 736f 7572 6365 3a20 626f 6f6c  ace_source: bool
+00004250: 203d 2054 7275 650a 2020 2020 2920 2d3e   = True.    ) ->
+00004260: 204e 6f6e 653a 0a20 2020 2020 2020 2022   None:.        "
+00004270: 2222 5365 7420 7468 6520 6d61 7374 6572  ""Set the master
+00004280: 6461 7461 2074 6f20 636f 6d70 6c65 7465  data to complete
+00004290: 2222 220a 2020 2020 2020 2020 2320 7079  """.        # py
+000042a0: 6c69 6e74 3a20 6469 7361 626c 653d 746f  lint: disable=to
+000042b0: 6f2d 6d61 6e79 2d62 7261 6e63 6865 730a  o-many-branches.
+000042c0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+000042d0: 6d61 7374 6572 6461 7461 5f69 735f 6375  masterdata_is_cu
+000042e0: 7261 7465 6428 2920 6f72 206d 6173 7465  rated() or maste
+000042f0: 7264 6174 615f 7265 706f 7369 746f 7279  rdata_repository
+00004300: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00004310: 7475 726e 0a0a 2020 2020 2020 2020 6966  turn..        if
+00004320: 2022 636f 6c72 6576 5f6d 6173 7465 7264   "colrev_masterd
+00004330: 6174 615f 7072 6f76 656e 616e 6365 2220  ata_provenance" 
+00004340: 6e6f 7420 696e 2073 656c 662e 6461 7461  not in self.data
+00004350: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+00004360: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
+00004370: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
+00004380: 6e61 6e63 6522 5d20 3d20 7b7d 0a20 2020  nance"] = {}.   
+00004390: 2020 2020 206d 645f 705f 6469 6374 203d       md_p_dict =
+000043a0: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
+000043b0: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
+000043c0: 6f76 656e 616e 6365 225d 0a0a 2020 2020  ovenance"]..    
+000043d0: 2020 2020 666f 7220 6964 656e 7469 6679      for identify
+000043e0: 696e 675f 6669 656c 645f 6b65 7920 696e  ing_field_key in
+000043f0: 2073 656c 662e 6964 656e 7469 6679 696e   self.identifyin
+00004400: 675f 6669 656c 645f 6b65 7973 3a0a 2020  g_field_keys:.  
+00004410: 2020 2020 2020 2020 2020 6966 2069 6465            if ide
+00004420: 6e74 6966 7969 6e67 5f66 6965 6c64 5f6b  ntifying_field_k
+00004430: 6579 2069 6e20 5b22 6175 7468 6f72 222c  ey in ["author",
+00004440: 2022 7469 746c 6522 2c20 2279 6561 7222   "title", "year"
+00004450: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
+00004460: 2020 2063 6f6e 7469 6e75 650a 2020 2020     continue.    
+00004470: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+00004480: 6461 7461 2e67 6574 2869 6465 6e74 6966  data.get(identif
+00004490: 7969 6e67 5f66 6965 6c64 5f6b 6579 2c20  ying_field_key, 
+000044a0: 224e 4122 2920 3d3d 2022 554e 4b4e 4f57  "NA") == "UNKNOW
+000044b0: 4e22 3a0a 2020 2020 2020 2020 2020 2020  N":.            
+000044c0: 2020 2020 6465 6c20 7365 6c66 2e64 6174      del self.dat
+000044d0: 615b 6964 656e 7469 6679 696e 675f 6669  a[identifying_fi
+000044e0: 656c 645f 6b65 795d 0a20 2020 2020 2020  eld_key].       
+000044f0: 2020 2020 2069 6620 6964 656e 7469 6679       if identify
+00004500: 696e 675f 6669 656c 645f 6b65 7920 696e  ing_field_key in
+00004510: 206d 645f 705f 6469 6374 3a0a 2020 2020   md_p_dict:.    
+00004520: 2020 2020 2020 2020 2020 2020 6e6f 7465              note
+00004530: 203d 206d 645f 705f 6469 6374 5b69 6465   = md_p_dict[ide
+00004540: 6e74 6966 7969 6e67 5f66 6965 6c64 5f6b  ntifying_field_k
+00004550: 6579 5d5b 226e 6f74 6522 5d0a 2020 2020  ey]["note"].    
+00004560: 2020 2020 2020 2020 2020 2020 6966 2022              if "
+00004570: 6d69 7373 696e 6722 2069 6e20 6e6f 7465  missing" in note
+00004580: 2061 6e64 2022 6e6f 742d 6d69 7373 696e   and "not-missin
+00004590: 6722 206e 6f74 2069 6e20 6e6f 7465 3a0a  g" not in note:.
+000045a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000045b0: 2020 2020 6d64 5f70 5f64 6963 745b 6964      md_p_dict[id
+000045c0: 656e 7469 6679 696e 675f 6669 656c 645f  entifying_field_
+000045d0: 6b65 795d 5b22 6e6f 7465 225d 203d 206e  key]["note"] = n
+000045e0: 6f74 652e 7265 706c 6163 6528 0a20 2020  ote.replace(.   
+000045f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004600: 2020 2020 2022 6d69 7373 696e 6722 2c20       "missing", 
+00004610: 2222 0a20 2020 2020 2020 2020 2020 2020  "".             
+00004620: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
+00004630: 2020 6966 2073 656c 662e 6461 7461 5b22    if self.data["
+00004640: 454e 5452 5954 5950 4522 5d20 3d3d 2022  ENTRYTYPE"] == "
+00004650: 6172 7469 636c 6522 3a0a 2020 2020 2020  article":.      
+00004660: 2020 2020 2020 6966 2022 766f 6c75 6d65        if "volume
+00004670: 2220 6e6f 7420 696e 2073 656c 662e 6461  " not in self.da
+00004680: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
+00004690: 2020 2020 6966 2022 766f 6c75 6d65 2220      if "volume" 
+000046a0: 696e 2073 656c 662e 6461 7461 5b22 636f  in self.data["co
+000046b0: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
+000046c0: 7072 6f76 656e 616e 6365 225d 3a0a 2020  provenance"]:.  
+000046d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000046e0: 2020 7365 6c66 2e64 6174 615b 2263 6f6c    self.data["col
+000046f0: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
+00004700: 726f 7665 6e61 6e63 6522 5d5b 2276 6f6c  rovenance"]["vol
+00004710: 756d 6522 5d5b 0a20 2020 2020 2020 2020  ume"][.         
+00004720: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+00004730: 6e6f 7465 220a 2020 2020 2020 2020 2020  note".          
+00004740: 2020 2020 2020 2020 2020 5d20 3d20 226e            ] = "n
+00004750: 6f74 2d6d 6973 7369 6e67 220a 2020 2020  ot-missing".    
 00004760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004770: 2020 2020 2020 2020 2020 2020 2273 6f75              "sou
-00004780: 7263 6522 0a20 2020 2020 2020 2020 2020  rce".           
-00004790: 2020 2020 2020 2020 2020 2020 205d 203d               ] =
-000047a0: 2073 6f75 7263 650a 2020 2020 2020 2020   source.        
-000047b0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-000047c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000047d0: 2020 7365 6c66 2e64 6174 615b 2263 6f6c    self.data["col
-000047e0: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
-000047f0: 726f 7665 6e61 6e63 6522 5d5b 226e 756d  rovenance"]["num
-00004800: 6265 7222 5d20 3d20 7b0a 2020 2020 2020  ber"] = {.      
-00004810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004820: 2020 2273 6f75 7263 6522 3a20 736f 7572    "source": sour
-00004830: 6365 2c0a 2020 2020 2020 2020 2020 2020  ce,.            
-00004840: 2020 2020 2020 2020 2020 2020 226e 6f74              "not
-00004850: 6522 3a20 226e 6f74 2d6d 6973 7369 6e67  e": "not-missing
-00004860: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
-00004870: 2020 2020 2020 207d 0a0a 2020 2020 6465         }..    de
-00004880: 6620 7365 745f 6d61 7374 6572 6461 7461  f set_masterdata
-00004890: 5f63 6f6e 7369 7374 656e 7428 7365 6c66  _consistent(self
-000048a0: 2920 2d3e 204e 6f6e 653a 0a20 2020 2020  ) -> None:.     
-000048b0: 2020 2022 2222 5365 7420 7468 6520 6d61     """Set the ma
-000048c0: 7374 6572 6461 7461 2074 6f20 636f 6e73  sterdata to cons
-000048d0: 6973 7465 6e74 2222 220a 2020 2020 2020  istent""".      
-000048e0: 2020 6966 2022 636f 6c72 6576 5f6d 6173    if "colrev_mas
-000048f0: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-00004900: 6365 2220 6e6f 7420 696e 2073 656c 662e  ce" not in self.
-00004910: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
-00004920: 2020 7365 6c66 2e64 6174 615b 2263 6f6c    self.data["col
-00004930: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
-00004940: 726f 7665 6e61 6e63 6522 5d20 3d20 7b7d  rovenance"] = {}
-00004950: 0a20 2020 2020 2020 206d 645f 705f 6469  .        md_p_di
-00004960: 6374 203d 2073 656c 662e 6461 7461 5b22  ct = self.data["
-00004970: 636f 6c72 6576 5f6d 6173 7465 7264 6174  colrev_masterdat
-00004980: 615f 7072 6f76 656e 616e 6365 225d 0a0a  a_provenance"]..
-00004990: 2020 2020 2020 2020 666f 7220 6964 656e          for iden
-000049a0: 7469 6679 696e 675f 6669 656c 645f 6b65  tifying_field_ke
-000049b0: 7920 696e 2073 656c 662e 6964 656e 7469  y in self.identi
-000049c0: 6679 696e 675f 6669 656c 645f 6b65 7973  fying_field_keys
-000049d0: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-000049e0: 2069 6465 6e74 6966 7969 6e67 5f66 6965   identifying_fie
-000049f0: 6c64 5f6b 6579 2069 6e20 6d64 5f70 5f64  ld_key in md_p_d
-00004a00: 6963 743a 0a20 2020 2020 2020 2020 2020  ict:.           
-00004a10: 2020 2020 206e 6f74 6520 3d20 6d64 5f70       note = md_p
-00004a20: 5f64 6963 745b 6964 656e 7469 6679 696e  _dict[identifyin
-00004a30: 675f 6669 656c 645f 6b65 795d 5b22 6e6f  g_field_key]["no
-00004a40: 7465 225d 0a20 2020 2020 2020 2020 2020  te"].           
-00004a50: 2020 2020 2069 6620 2269 6e63 6f6e 7369       if "inconsi
-00004a60: 7374 656e 742d 7769 7468 2d65 6e74 7279  stent-with-entry
-00004a70: 7479 7065 2220 696e 206e 6f74 653a 0a20  type" in note:. 
-00004a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004a90: 2020 206d 645f 705f 6469 6374 5b69 6465     md_p_dict[ide
-00004aa0: 6e74 6966 7969 6e67 5f66 6965 6c64 5f6b  ntifying_field_k
-00004ab0: 6579 5d5b 226e 6f74 6522 5d20 3d20 6e6f  ey]["note"] = no
-00004ac0: 7465 2e72 6570 6c61 6365 280a 2020 2020  te.replace(.    
-00004ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004ae0: 2020 2020 2269 6e63 6f6e 7369 7374 656e      "inconsisten
-00004af0: 742d 7769 7468 2d65 6e74 7279 7479 7065  t-with-entrytype
-00004b00: 222c 2022 220a 2020 2020 2020 2020 2020  ", "".          
-00004b10: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
-00004b20: 2064 6566 2072 6573 6574 5f70 6466 5f70   def reset_pdf_p
-00004b30: 726f 7665 6e61 6e63 655f 6e6f 7465 7328  rovenance_notes(
-00004b40: 7365 6c66 2920 2d3e 204e 6f6e 653a 0a20  self) -> None:. 
-00004b50: 2020 2020 2020 2022 2222 5265 7365 7420         """Reset 
-00004b60: 7468 6520 5044 4620 2866 696c 6529 2070  the PDF (file) p
-00004b70: 726f 7665 6e61 6e63 6520 6e6f 7465 7322  rovenance notes"
-00004b80: 2222 0a20 2020 2020 2020 2069 6620 2263  "".        if "c
-00004b90: 6f6c 7265 765f 6461 7461 5f70 726f 7665  olrev_data_prove
-00004ba0: 6e61 6e63 6522 206e 6f74 2069 6e20 7365  nance" not in se
-00004bb0: 6c66 2e64 6174 613a 0a20 2020 2020 2020  lf.data:.       
-00004bc0: 2020 2020 2073 656c 662e 6164 645f 6461       self.add_da
-00004bd0: 7461 5f70 726f 7665 6e61 6e63 655f 6e6f  ta_provenance_no
-00004be0: 7465 286b 6579 3d22 6669 6c65 222c 206e  te(key="file", n
-00004bf0: 6f74 653d 2222 290a 2020 2020 2020 2020  ote="").        
-00004c00: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00004c10: 2020 6966 2022 6669 6c65 2220 696e 2073    if "file" in s
-00004c20: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
-00004c30: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
-00004c40: 225d 3a0a 2020 2020 2020 2020 2020 2020  "]:.            
-00004c50: 2020 2020 7365 6c66 2e64 6174 615b 2263      self.data["c
-00004c60: 6f6c 7265 765f 6461 7461 5f70 726f 7665  olrev_data_prove
-00004c70: 6e61 6e63 6522 5d5b 2266 696c 6522 5d5b  nance"]["file"][
-00004c80: 226e 6f74 6522 5d20 3d20 2222 0a20 2020  "note"] = "".   
-00004c90: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-00004ca0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00004cb0: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
-00004cc0: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
-00004cd0: 225d 5b22 6669 6c65 225d 203d 207b 0a20  "]["file"] = {. 
-00004ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004cf0: 2020 2022 736f 7572 6365 223a 2022 4e41     "source": "NA
-00004d00: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
-00004d10: 2020 2020 2020 2022 6e6f 7465 223a 2022         "note": "
-00004d20: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
-00004d30: 2020 207d 0a0a 2020 2020 6465 6620 5f5f     }..    def __
-00004d40: 6d65 7267 655f 6f72 6967 696e 7328 7365  merge_origins(se
-00004d50: 6c66 2c20 2a2c 206d 6572 6769 6e67 5f72  lf, *, merging_r
-00004d60: 6563 6f72 643a 2052 6563 6f72 6429 202d  ecord: Record) -
-00004d70: 3e20 4e6f 6e65 3a0a 2020 2020 2020 2020  > None:.        
-00004d80: 2222 224d 6572 6765 2074 6865 206f 7269  """Merge the ori
-00004d90: 6769 6e73 2077 6974 6820 7468 6f73 6520  gins with those 
-00004da0: 6f66 2074 6865 206d 6572 6769 6e67 5f72  of the merging_r
-00004db0: 6563 6f72 6422 2222 0a0a 2020 2020 2020  ecord"""..      
-00004dc0: 2020 6966 2022 636f 6c72 6576 5f6f 7269    if "colrev_ori
-00004dd0: 6769 6e22 2069 6e20 6d65 7267 696e 675f  gin" in merging_
-00004de0: 7265 636f 7264 2e64 6174 613a 0a20 2020  record.data:.   
-00004df0: 2020 2020 2020 2020 206f 7269 6769 6e73           origins
-00004e00: 203d 2073 656c 662e 6461 7461 5b22 636f   = self.data["co
-00004e10: 6c72 6576 5f6f 7269 6769 6e22 5d20 2b20  lrev_origin"] + 
-00004e20: 6d65 7267 696e 675f 7265 636f 7264 2e64  merging_record.d
-00004e30: 6174 615b 2263 6f6c 7265 765f 6f72 6967  ata["colrev_orig
-00004e40: 696e 225d 0a20 2020 2020 2020 2020 2020  in"].           
-00004e50: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
-00004e60: 6576 5f6f 7269 6769 6e22 5d20 3d20 736f  ev_origin"] = so
-00004e70: 7274 6564 286c 6973 7428 7365 7428 6f72  rted(list(set(or
-00004e80: 6967 696e 7329 2929 0a0a 2020 2020 6465  igins)))..    de
-00004e90: 6620 5f5f 6d65 7267 655f 7374 6174 7573  f __merge_status
-00004ea0: 2873 656c 662c 202a 2c20 6d65 7267 696e  (self, *, mergin
-00004eb0: 675f 7265 636f 7264 3a20 5265 636f 7264  g_record: Record
-00004ec0: 2920 2d3e 204e 6f6e 653a 0a20 2020 2020  ) -> None:.     
-00004ed0: 2020 2022 2222 4d65 7267 6520 7468 6520     """Merge the 
-00004ee0: 7374 6174 7573 2077 6974 6820 7468 6520  status with the 
-00004ef0: 6d65 7267 696e 675f 7265 636f 7264 2222  merging_record""
-00004f00: 220a 0a20 2020 2020 2020 2069 6620 2263  "..        if "c
-00004f10: 6f6c 7265 765f 7374 6174 7573 2220 696e  olrev_status" in
-00004f20: 206d 6572 6769 6e67 5f72 6563 6f72 642e   merging_record.
-00004f30: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
-00004f40: 2020 2320 5365 7420 626f 7468 2073 7461    # Set both sta
-00004f50: 7475 7320 746f 2074 6865 206c 6174 7465  tus to the latte
-00004f60: 7220 696e 2074 6865 2073 7461 7465 206d  r in the state m
-00004f70: 6f64 656c 0a20 2020 2020 2020 2020 2020  odel.           
-00004f80: 2069 6620 7365 6c66 2e64 6174 615b 2263   if self.data["c
-00004f90: 6f6c 7265 765f 7374 6174 7573 225d 203c  olrev_status"] <
-00004fa0: 206d 6572 6769 6e67 5f72 6563 6f72 642e   merging_record.
-00004fb0: 6461 7461 5b22 636f 6c72 6576 5f73 7461  data["colrev_sta
-00004fc0: 7475 7322 5d3a 0a20 2020 2020 2020 2020  tus"]:.         
-00004fd0: 2020 2020 2020 2073 656c 662e 7365 745f         self.set_
-00004fe0: 7374 6174 7573 2874 6172 6765 745f 7374  status(target_st
-00004ff0: 6174 653d 6d65 7267 696e 675f 7265 636f  ate=merging_reco
-00005000: 7264 2e64 6174 615b 2263 6f6c 7265 765f  rd.data["colrev_
-00005010: 7374 6174 7573 225d 290a 2020 2020 2020  status"]).      
-00005020: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00005030: 2020 2020 2020 2020 2020 2020 6d65 7267              merg
-00005040: 696e 675f 7265 636f 7264 2e73 6574 5f73  ing_record.set_s
-00005050: 7461 7475 7328 7461 7267 6574 5f73 7461  tatus(target_sta
-00005060: 7465 3d73 656c 662e 6461 7461 5b22 636f  te=self.data["co
-00005070: 6c72 6576 5f73 7461 7475 7322 5d29 0a0a  lrev_status"])..
-00005080: 2020 2020 6465 6620 5f5f 6765 745f 6d65      def __get_me
-00005090: 7267 696e 675f 7661 6c28 7365 6c66 2c20  rging_val(self, 
-000050a0: 2a2c 206d 6572 6769 6e67 5f72 6563 6f72  *, merging_recor
-000050b0: 643a 2052 6563 6f72 642c 206b 6579 3a20  d: Record, key: 
-000050c0: 7374 7229 202d 3e20 7374 723a 0a20 2020  str) -> str:.   
-000050d0: 2020 2020 2076 616c 203d 206d 6572 6769       val = mergi
-000050e0: 6e67 5f72 6563 6f72 642e 6461 7461 2e67  ng_record.data.g
-000050f0: 6574 286b 6579 2c20 2222 290a 0a20 2020  et(key, "")..   
-00005100: 2020 2020 2069 6620 7661 6c20 3d3d 2022       if val == "
-00005110: 223a 0a20 2020 2020 2020 2020 2020 2072  ":.            r
-00005120: 6574 7572 6e20 2222 0a20 2020 2020 2020  eturn "".       
-00005130: 2069 6620 6e6f 7420 7661 6c3a 0a20 2020   if not val:.   
-00005140: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00005150: 2222 0a0a 2020 2020 2020 2020 2320 646f  ""..        # do
-00005160: 206e 6f74 206f 7665 7272 6964 6520 7072   not override pr
-00005170: 6f76 656e 616e 6365 2c20 4944 2c20 2e2e  ovenance, ID, ..
-00005180: 2e20 6669 656c 6473 0a20 2020 2020 2020  . fields.       
-00005190: 2069 6620 6b65 7920 696e 205b 0a20 2020   if key in [.   
-000051a0: 2020 2020 2020 2020 2022 4944 222c 0a20           "ID",. 
-000051b0: 2020 2020 2020 2020 2020 2022 636f 6c72             "colr
-000051c0: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
-000051d0: 6f76 656e 616e 6365 222c 0a20 2020 2020  ovenance",.     
-000051e0: 2020 2020 2020 2022 636f 6c72 6576 5f64         "colrev_d
-000051f0: 6174 615f 7072 6f76 656e 616e 6365 222c  ata_provenance",
-00005200: 0a20 2020 2020 2020 2020 2020 2022 636f  .            "co
-00005210: 6c72 6576 5f69 6422 2c0a 2020 2020 2020  lrev_id",.      
-00005220: 2020 2020 2020 2263 6f6c 7265 765f 7374        "colrev_st
-00005230: 6174 7573 222c 0a20 2020 2020 2020 2020  atus",.         
-00005240: 2020 2022 636f 6c72 6576 5f6f 7269 6769     "colrev_origi
-00005250: 6e22 2c0a 2020 2020 2020 2020 2020 2020  n",.            
-00005260: 224d 4f56 4544 5f44 5550 455f 4944 222c  "MOVED_DUPE_ID",
-00005270: 0a20 2020 2020 2020 205d 3a0a 2020 2020  .        ]:.    
-00005280: 2020 2020 2020 2020 7265 7475 726e 2022          return "
-00005290: 220a 0a20 2020 2020 2020 2072 6574 7572  "..        retur
-000052a0: 6e20 7661 6c0a 0a20 2020 2064 6566 205f  n val..    def _
-000052b0: 5f70 7265 7665 6e74 5f69 6e76 616c 6964  _prevent_invalid
-000052c0: 5f6d 6572 6765 7328 7365 6c66 2c20 2a2c  _merges(self, *,
-000052d0: 206d 6572 6769 6e67 5f72 6563 6f72 643a   merging_record:
-000052e0: 2052 6563 6f72 6429 202d 3e20 4e6f 6e65   Record) -> None
-000052f0: 3a0a 2020 2020 2020 2020 2222 2250 7265  :.        """Pre
-00005300: 7665 6e74 7320 696e 7661 6c69 6420 6d65  vents invalid me
-00005310: 7267 6573 206c 696b 6520 2e2e 2e20 7061  rges like ... pa
-00005320: 7274 2031 202f 202e 2e2e 2070 6172 7420  rt 1 / ... part 
-00005330: 3222 2222 0a0a 2020 2020 2020 2020 6c6f  2"""..        lo
-00005340: 7765 725f 7469 746c 655f 6120 3d20 7365  wer_title_a = se
-00005350: 6c66 2e64 6174 612e 6765 7428 2274 6974  lf.data.get("tit
-00005360: 6c65 222c 2022 2229 2e6c 6f77 6572 2829  le", "").lower()
-00005370: 0a20 2020 2020 2020 206c 6f77 6572 5f74  .        lower_t
-00005380: 6974 6c65 5f62 203d 206d 6572 6769 6e67  itle_b = merging
-00005390: 5f72 6563 6f72 642e 6461 7461 2e67 6574  _record.data.get
-000053a0: 2822 7469 746c 6522 2c20 2222 292e 6c6f  ("title", "").lo
-000053b0: 7765 7228 290a 0a20 2020 2020 2020 2070  wer()..        p
-000053c0: 6172 745f 6d61 7463 685f 6120 3d20 7265  art_match_a = re
-000053d0: 2e66 696e 6461 6c6c 2872 2270 6172 7420  .findall(r"part 
-000053e0: 5b41 2d5a 612d 7a30 2d39 5d2b 2422 2c20  [A-Za-z0-9]+$", 
-000053f0: 6c6f 7765 725f 7469 746c 655f 6129 0a20  lower_title_a). 
-00005400: 2020 2020 2020 2070 6172 745f 6d61 7463         part_matc
-00005410: 685f 6220 3d20 7265 2e66 696e 6461 6c6c  h_b = re.findall
-00005420: 2872 2270 6172 7420 5b41 2d5a 612d 7a30  (r"part [A-Za-z0
-00005430: 2d39 5d2b 2422 2c20 6c6f 7765 725f 7469  -9]+$", lower_ti
-00005440: 746c 655f 6229 0a0a 2020 2020 2020 2020  tle_b)..        
-00005450: 6966 2070 6172 745f 6d61 7463 685f 6120  if part_match_a 
-00005460: 213d 2070 6172 745f 6d61 7463 685f 623a  != part_match_b:
-00005470: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
-00005480: 7365 2063 6f6c 7265 765f 6578 6365 7074  se colrev_except
-00005490: 696f 6e73 2e49 6e76 616c 6964 4d65 7267  ions.InvalidMerg
-000054a0: 6528 7265 636f 7264 5f61 3d73 656c 662c  e(record_a=self,
-000054b0: 2072 6563 6f72 645f 623d 6d65 7267 696e   record_b=mergin
-000054c0: 675f 7265 636f 7264 290a 0a20 2020 2020  g_record)..     
-000054d0: 2020 2074 6572 6d73 5f72 6571 7569 7265     terms_require
-000054e0: 645f 746f 5f6d 6174 6368 203d 205b 0a20  d_to_match = [. 
-000054f0: 2020 2020 2020 2020 2020 2022 6572 7261             "erra
-00005500: 7475 6d22 2c0a 2020 2020 2020 2020 2020  tum",.          
-00005510: 2020 2263 6f72 7265 6374 696f 6e22 2c0a    "correction",.
-00005520: 2020 2020 2020 2020 2020 2020 2263 6f72              "cor
-00005530: 7269 6765 6e64 756d 222c 0a20 2020 2020  rigendum",.     
-00005540: 2020 2020 2020 2022 636f 6d6d 656e 7422         "comment"
-00005550: 2c0a 2020 2020 2020 2020 2020 2020 2263  ,.            "c
-00005560: 6f6d 6d65 6e74 6172 7922 2c0a 2020 2020  ommentary",.    
-00005570: 2020 2020 2020 2020 2272 6573 706f 6e73          "respons
-00005580: 6522 2c0a 2020 2020 2020 2020 5d0a 2020  e",.        ].  
-00005590: 2020 2020 2020 7465 726d 735f 696e 5f61        terms_in_a
-000055a0: 203d 205b 7420 666f 7220 7420 696e 2074   = [t for t in t
-000055b0: 6572 6d73 5f72 6571 7569 7265 645f 746f  erms_required_to
-000055c0: 5f6d 6174 6368 2069 6620 7420 696e 206c  _match if t in l
-000055d0: 6f77 6572 5f74 6974 6c65 5f61 5d0a 2020  ower_title_a].  
-000055e0: 2020 2020 2020 7465 726d 735f 696e 5f62        terms_in_b
-000055f0: 203d 205b 7420 666f 7220 7420 696e 2074   = [t for t in t
-00005600: 6572 6d73 5f72 6571 7569 7265 645f 746f  erms_required_to
-00005610: 5f6d 6174 6368 2069 6620 7420 696e 206c  _match if t in l
-00005620: 6f77 6572 5f74 6974 6c65 5f62 5d0a 0a20  ower_title_b].. 
-00005630: 2020 2020 2020 2069 6620 7465 726d 735f         if terms_
-00005640: 696e 5f61 2021 3d20 7465 726d 735f 696e  in_a != terms_in
-00005650: 5f62 3a0a 2020 2020 2020 2020 2020 2020  _b:.            
-00005660: 7261 6973 6520 636f 6c72 6576 5f65 7863  raise colrev_exc
-00005670: 6570 7469 6f6e 732e 496e 7661 6c69 644d  eptions.InvalidM
-00005680: 6572 6765 2872 6563 6f72 645f 613d 7365  erge(record_a=se
-00005690: 6c66 2c20 7265 636f 7264 5f62 3d6d 6572  lf, record_b=mer
-000056a0: 6769 6e67 5f72 6563 6f72 6429 0a0a 2020  ging_record)..  
-000056b0: 2020 6465 6620 6d65 7267 6528 0a20 2020    def merge(.   
-000056c0: 2020 2020 2073 656c 662c 0a20 2020 2020       self,.     
-000056d0: 2020 202a 2c0a 2020 2020 2020 2020 6d65     *,.        me
-000056e0: 7267 696e 675f 7265 636f 7264 3a20 5265  rging_record: Re
-000056f0: 636f 7264 2c0a 2020 2020 2020 2020 6465  cord,.        de
-00005700: 6661 756c 745f 736f 7572 6365 3a20 7374  fault_source: st
-00005710: 722c 0a20 2020 2020 2020 2070 7265 6665  r,.        prefe
-00005720: 7272 6564 5f6d 6173 7465 7264 6174 615f  rred_masterdata_
-00005730: 736f 7572 6365 5f70 7265 6669 7865 733a  source_prefixes:
-00005740: 204f 7074 696f 6e61 6c5b 6c69 7374 5d20   Optional[list] 
-00005750: 3d20 4e6f 6e65 2c0a 2020 2020 2920 2d3e  = None,.    ) ->
-00005760: 204e 6f6e 653a 0a20 2020 2020 2020 2022   None:.        "
-00005770: 2222 4765 6e65 7261 6c2d 7075 7270 6f73  ""General-purpos
-00005780: 6520 7265 636f 7264 206d 6572 6769 6e67  e record merging
-00005790: 0a20 2020 2020 2020 2066 6f72 2070 7265  .        for pre
-000057a0: 7061 7261 7469 6f6e 2c20 6375 7261 7465  paration, curate
-000057b0: 642f 6e6f 6e2d 6375 7261 7465 6420 7265  d/non-curated re
-000057c0: 636f 7264 7320 616e 6420 7265 636f 7264  cords and record
-000057d0: 7320 7769 7468 206f 7269 6769 6e73 0a0a  s with origins..
-000057e0: 0a20 2020 2020 2020 2041 7070 6c79 2068  .        Apply h
-000057f0: 6575 7269 7374 6963 7320 746f 2063 7265  euristics to cre
-00005800: 6174 6520 6120 6675 7369 6f6e 206f 6620  ate a fusion of 
-00005810: 7468 6520 6265 7374 2066 6965 6c64 7320  the best fields 
-00005820: 6261 7365 6420 6f6e 0a20 2020 2020 2020  based on.       
-00005830: 2071 7561 6c69 7479 2068 6575 7269 7374   quality heurist
-00005840: 6963 7322 2222 0a0a 2020 2020 2020 2020  ics"""..        
-00005850: 2320 7079 6c69 6e74 3a20 6469 7361 626c  # pylint: disabl
-00005860: 653d 746f 6f2d 6d61 6e79 2d62 7261 6e63  e=too-many-branc
-00005870: 6865 730a 0a20 2020 2020 2020 206d 6572  hes..        mer
-00005880: 6769 6e67 5f72 6563 6f72 645f 7072 6566  ging_record_pref
-00005890: 6572 7265 6420 3d20 4661 6c73 650a 2020  erred = False.  
-000058a0: 2020 2020 2020 6966 2070 7265 6665 7272        if preferr
-000058b0: 6564 5f6d 6173 7465 7264 6174 615f 736f  ed_masterdata_so
-000058c0: 7572 6365 5f70 7265 6669 7865 733a 0a20  urce_prefixes:. 
-000058d0: 2020 2020 2020 2020 2020 2069 6620 616e             if an
-000058e0: 7928 0a20 2020 2020 2020 2020 2020 2020  y(.             
-000058f0: 2020 2061 6e79 2870 7320 696e 206f 7269     any(ps in ori
-00005900: 6769 6e20 666f 7220 7073 2069 6e20 7072  gin for ps in pr
-00005910: 6566 6572 7265 645f 6d61 7374 6572 6461  eferred_masterda
-00005920: 7461 5f73 6f75 7263 655f 7072 6566 6978  ta_source_prefix
-00005930: 6573 290a 2020 2020 2020 2020 2020 2020  es).            
-00005940: 2020 2020 666f 7220 6f72 6967 696e 2069      for origin i
-00005950: 6e20 6d65 7267 696e 675f 7265 636f 7264  n merging_record
-00005960: 2e64 6174 615b 2263 6f6c 7265 765f 6f72  .data["colrev_or
-00005970: 6967 696e 225d 0a20 2020 2020 2020 2020  igin"].         
-00005980: 2020 2029 3a0a 2020 2020 2020 2020 2020     ):.          
-00005990: 2020 2020 2020 6d65 7267 696e 675f 7265        merging_re
-000059a0: 636f 7264 5f70 7265 6665 7272 6564 203d  cord_preferred =
-000059b0: 2054 7275 650a 0a20 2020 2020 2020 2073   True..        s
-000059c0: 656c 662e 5f5f 7072 6576 656e 745f 696e  elf.__prevent_in
-000059d0: 7661 6c69 645f 6d65 7267 6573 286d 6572  valid_merges(mer
-000059e0: 6769 6e67 5f72 6563 6f72 643d 6d65 7267  ging_record=merg
-000059f0: 696e 675f 7265 636f 7264 290a 2020 2020  ing_record).    
-00005a00: 2020 2020 7365 6c66 2e5f 5f6d 6572 6765      self.__merge
-00005a10: 5f6f 7269 6769 6e73 286d 6572 6769 6e67  _origins(merging
-00005a20: 5f72 6563 6f72 643d 6d65 7267 696e 675f  _record=merging_
-00005a30: 7265 636f 7264 290a 2020 2020 2020 2020  record).        
-00005a40: 7365 6c66 2e5f 5f6d 6572 6765 5f73 7461  self.__merge_sta
-00005a50: 7475 7328 6d65 7267 696e 675f 7265 636f  tus(merging_reco
-00005a60: 7264 3d6d 6572 6769 6e67 5f72 6563 6f72  rd=merging_recor
-00005a70: 6429 0a0a 2020 2020 2020 2020 6966 206e  d)..        if n
-00005a80: 6f74 2073 656c 662e 6d61 7374 6572 6461  ot self.masterda
-00005a90: 7461 5f69 735f 6375 7261 7465 6428 2920  ta_is_curated() 
-00005aa0: 616e 6420 6d65 7267 696e 675f 7265 636f  and merging_reco
-00005ab0: 7264 2e6d 6173 7465 7264 6174 615f 6973  rd.masterdata_is
-00005ac0: 5f63 7572 6174 6564 2829 3a0a 2020 2020  _curated():.    
-00005ad0: 2020 2020 2020 2020 7365 6c66 2e64 6174          self.dat
-00005ae0: 615b 2263 6f6c 7265 765f 6d61 7374 6572  a["colrev_master
-00005af0: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
-00005b00: 5d20 3d20 6d65 7267 696e 675f 7265 636f  ] = merging_reco
-00005b10: 7264 2e64 6174 615b 0a20 2020 2020 2020  rd.data[.       
-00005b20: 2020 2020 2020 2020 2022 636f 6c72 6576           "colrev
-00005b30: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
-00005b40: 656e 616e 6365 220a 2020 2020 2020 2020  enance".        
-00005b50: 2020 2020 5d0a 2020 2020 2020 2020 2020      ].          
-00005b60: 2020 2320 4e6f 7465 203a 2072 656d 6f76    # Note : remov
-00005b70: 6520 616c 6c20 6d61 7374 6572 6461 7461  e all masterdata
-00005b80: 2066 6965 6c64 730a 2020 2020 2020 2020   fields.        
-00005b90: 2020 2020 2320 6265 6361 7573 6520 7468      # because th
-00005ba0: 6520 6375 7261 7465 6420 7265 636f 7264  e curated record
-00005bb0: 206d 6179 2068 6176 6520 6665 7765 7220   may have fewer 
-00005bc0: 6d61 7374 6572 6461 7461 2066 6965 6c64  masterdata field
-00005bd0: 730a 2020 2020 2020 2020 2020 2020 2320  s.            # 
-00005be0: 616e 6420 7765 2069 7465 7261 7465 206f  and we iterate o
-00005bf0: 7665 7220 7468 6520 6375 7261 7465 6420  ver the curated 
-00005c00: 7265 636f 7264 2028 6d65 7267 696e 675f  record (merging_
-00005c10: 7265 636f 7264 2920 696e 2074 6865 206e  record) in the n
-00005c20: 6578 7420 7374 6570 0a20 2020 2020 2020  ext step.       
-00005c30: 2020 2020 2066 6f72 206b 2069 6e20 6c69       for k in li
-00005c40: 7374 2873 656c 662e 6461 7461 2e6b 6579  st(self.data.key
-00005c50: 7328 2929 3a0a 2020 2020 2020 2020 2020  s()):.          
-00005c60: 2020 2020 2020 6966 206b 2069 6e20 5265        if k in Re
-00005c70: 636f 7264 2e69 6465 6e74 6966 7969 6e67  cord.identifying
-00005c80: 5f66 6965 6c64 5f6b 6579 7320 616e 6420  _field_keys and 
-00005c90: 6b20 213d 2022 7061 6765 7322 3a0a 2020  k != "pages":.  
-00005ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005cb0: 2020 6465 6c20 7365 6c66 2e64 6174 615b    del self.data[
-00005cc0: 6b5d 0a0a 2020 2020 2020 2020 666f 7220  k]..        for 
-00005cd0: 6b65 7920 696e 206c 6973 7428 6d65 7267  key in list(merg
-00005ce0: 696e 675f 7265 636f 7264 2e64 6174 612e  ing_record.data.
-00005cf0: 6b65 7973 2829 293a 0a20 2020 2020 2020  keys()):.       
-00005d00: 2020 2020 2076 616c 203d 2073 656c 662e       val = self.
-00005d10: 5f5f 6765 745f 6d65 7267 696e 675f 7661  __get_merging_va
-00005d20: 6c28 6d65 7267 696e 675f 7265 636f 7264  l(merging_record
-00005d30: 3d6d 6572 6769 6e67 5f72 6563 6f72 642c  =merging_record,
-00005d40: 206b 6579 3d6b 6579 290a 2020 2020 2020   key=key).      
-00005d50: 2020 2020 2020 6966 2076 616c 203d 3d20        if val == 
-00005d60: 2222 3a0a 2020 2020 2020 2020 2020 2020  "":.            
-00005d70: 2020 2020 636f 6e74 696e 7565 0a0a 2020      continue..  
-00005d80: 2020 2020 2020 2020 2020 6669 656c 645f            field_
-00005d90: 7072 6f76 656e 616e 6365 203d 206d 6572  provenance = mer
-00005da0: 6769 6e67 5f72 6563 6f72 642e 6765 745f  ging_record.get_
-00005db0: 6669 656c 645f 7072 6f76 656e 616e 6365  field_provenance
-00005dc0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00005dd0: 2020 6b65 793d 6b65 792c 2064 6566 6175    key=key, defau
-00005de0: 6c74 5f73 6f75 7263 653d 6465 6661 756c  lt_source=defaul
-00005df0: 745f 736f 7572 6365 0a20 2020 2020 2020  t_source.       
-00005e00: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-00005e10: 2020 2073 6f75 7263 6520 3d20 6669 656c     source = fiel
-00005e20: 645f 7072 6f76 656e 616e 6365 5b22 736f  d_provenance["so
-00005e30: 7572 6365 225d 0a20 2020 2020 2020 2020  urce"].         
-00005e40: 2020 206e 6f74 6520 3d20 6669 656c 645f     note = field_
-00005e50: 7072 6f76 656e 616e 6365 5b22 6e6f 7465  provenance["note
-00005e60: 225d 0a0a 2020 2020 2020 2020 2020 2020  "]..            
-00005e70: 2320 416c 7761 7973 2075 7064 6174 6520  # Always update 
-00005e80: 6672 6f6d 2063 7572 6174 6564 206d 6572  from curated mer
-00005e90: 6769 6e67 5f72 6563 6f72 6473 0a20 2020  ging_records.   
-00005ea0: 2020 2020 2020 2020 2069 6620 6d65 7267           if merg
-00005eb0: 696e 675f 7265 636f 7264 2e6d 6173 7465  ing_record.maste
-00005ec0: 7264 6174 615f 6973 5f63 7572 6174 6564  rdata_is_curated
-00005ed0: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
-00005ee0: 2020 2020 7365 6c66 2e64 6174 615b 6b65      self.data[ke
-00005ef0: 795d 203d 206d 6572 6769 6e67 5f72 6563  y] = merging_rec
-00005f00: 6f72 642e 6461 7461 5b6b 6579 5d0a 2020  ord.data[key].  
-00005f10: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00005f20: 206b 6579 206e 6f74 2069 6e20 5265 636f   key not in Reco
-00005f30: 7264 2e69 6465 6e74 6966 7969 6e67 5f66  rd.identifying_f
-00005f40: 6965 6c64 5f6b 6579 7320 2b20 5b22 454e  ield_keys + ["EN
-00005f50: 5452 5954 5950 4522 5d3a 0a20 2020 2020  TRYTYPE"]:.     
-00005f60: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00005f70: 656c 662e 6164 645f 6461 7461 5f70 726f  elf.add_data_pro
-00005f80: 7665 6e61 6e63 6528 6b65 793d 6b65 792c  venance(key=key,
-00005f90: 2073 6f75 7263 653d 736f 7572 6365 2c20   source=source, 
-00005fa0: 6e6f 7465 3d6e 6f74 6529 0a0a 2020 2020  note=note)..    
-00005fb0: 2020 2020 2020 2020 2320 446f 206e 6f74          # Do not
-00005fc0: 2063 6861 6e67 6520 6966 204d 4552 4749   change if MERGI
-00005fd0: 4e47 5f52 4543 4f52 4420 6973 206e 6f74  NG_RECORD is not
-00005fe0: 2063 7572 6174 6564 0a20 2020 2020 2020   curated.       
-00005ff0: 2020 2020 2065 6c69 6620 280a 2020 2020       elif (.    
-00006000: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00006010: 2e6d 6173 7465 7264 6174 615f 6973 5f63  .masterdata_is_c
-00006020: 7572 6174 6564 2829 0a20 2020 2020 2020  urated().       
-00006030: 2020 2020 2020 2020 2061 6e64 206e 6f74           and not
-00006040: 206d 6572 6769 6e67 5f72 6563 6f72 642e   merging_record.
-00006050: 6d61 7374 6572 6461 7461 5f69 735f 6375  masterdata_is_cu
-00006060: 7261 7465 6428 290a 2020 2020 2020 2020  rated().        
-00006070: 2020 2020 293a 0a20 2020 2020 2020 2020      ):.         
-00006080: 2020 2020 2020 2063 6f6e 7469 6e75 650a         continue.
-00006090: 0a20 2020 2020 2020 2020 2020 2023 2050  .            # P
-000060a0: 6172 7420 313a 2069 6465 6e74 6966 7969  art 1: identifyi
-000060b0: 6e67 2066 6965 6c64 730a 2020 2020 2020  ng fields.      
-000060c0: 2020 2020 2020 6966 206b 6579 2069 6e20        if key in 
-000060d0: 5265 636f 7264 2e69 6465 6e74 6966 7969  Record.identifyi
-000060e0: 6e67 5f66 6965 6c64 5f6b 6579 733a 0a20  ng_field_keys:. 
-000060f0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00006100: 6620 7072 6566 6572 7265 645f 6d61 7374  f preferred_mast
-00006110: 6572 6461 7461 5f73 6f75 7263 655f 7072  erdata_source_pr
-00006120: 6566 6978 6573 3a0a 2020 2020 2020 2020  efixes:.        
-00006130: 2020 2020 2020 2020 2020 2020 6966 206d              if m
-00006140: 6572 6769 6e67 5f72 6563 6f72 645f 7072  erging_record_pr
-00006150: 6566 6572 7265 643a 0a20 2020 2020 2020  eferred:.       
-00006160: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006170: 2073 656c 662e 7570 6461 7465 5f66 6965   self.update_fie
-00006180: 6c64 280a 2020 2020 2020 2020 2020 2020  ld(.            
-00006190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000061a0: 6b65 793d 6b65 792c 2076 616c 7565 3d73  key=key, value=s
-000061b0: 7472 2876 616c 292c 2073 6f75 7263 653d  tr(val), source=
-000061c0: 736f 7572 6365 2c20 6170 7065 6e64 5f65  source, append_e
-000061d0: 6469 743d 4661 6c73 650a 2020 2020 2020  dit=False.      
-000061e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000061f0: 2020 290a 0a20 2020 2020 2020 2020 2020    )..           
-00006200: 2020 2020 2023 2046 7573 6520 6265 7374       # Fuse best
-00006210: 2066 6965 6c64 7320 6966 206e 6f6e 6520   fields if none 
-00006220: 6973 2063 7572 6174 6564 0a20 2020 2020  is curated.     
-00006230: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-00006240: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00006250: 2020 2020 2073 656c 662e 5f5f 6675 7365       self.__fuse
-00006260: 5f62 6573 745f 6669 656c 6428 0a20 2020  _best_field(.   
-00006270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006280: 2020 2020 206d 6572 6769 6e67 5f72 6563       merging_rec
-00006290: 6f72 643d 6d65 7267 696e 675f 7265 636f  ord=merging_reco
-000062a0: 7264 2c0a 2020 2020 2020 2020 2020 2020  rd,.            
-000062b0: 2020 2020 2020 2020 2020 2020 6b65 793d              key=
-000062c0: 6b65 792c 0a20 2020 2020 2020 2020 2020  key,.           
-000062d0: 2020 2020 2020 2020 2020 2020 2076 616c               val
-000062e0: 3d73 7472 2876 616c 292c 0a20 2020 2020  =str(val),.     
-000062f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006300: 2020 2073 6f75 7263 653d 736f 7572 6365     source=source
-00006310: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00006320: 2020 2020 2020 2020 2020 6e6f 7465 3d6e            note=n
-00006330: 6f74 652c 0a20 2020 2020 2020 2020 2020  ote,.           
-00006340: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
-00006350: 2020 2020 2020 2020 2320 5061 7274 2032          # Part 2
-00006360: 3a20 6f74 6865 7220 6669 656c 6473 0a20  : other fields. 
-00006370: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-00006380: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00006390: 2023 206b 6565 7020 6578 6973 7469 6e67   # keep existing
-000063a0: 2076 616c 7565 7320 7065 7220 6465 6661   values per defa
-000063b0: 756c 740a 2020 2020 2020 2020 2020 2020  ult.            
-000063c0: 2020 2020 6966 206b 6579 2069 6e20 7365      if key in se
-000063d0: 6c66 2e64 6174 613a 0a20 2020 2020 2020  lf.data:.       
-000063e0: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
-000063f0: 7469 6e75 650a 2020 2020 2020 2020 2020  tinue.          
-00006400: 2020 2020 2020 7365 6c66 2e75 7064 6174        self.updat
-00006410: 655f 6669 656c 6428 0a20 2020 2020 2020  e_field(.       
-00006420: 2020 2020 2020 2020 2020 2020 206b 6579               key
-00006430: 3d6b 6579 2c0a 2020 2020 2020 2020 2020  =key,.          
-00006440: 2020 2020 2020 2020 2020 7661 6c75 653d            value=
-00006450: 7374 7228 7661 6c29 2c0a 2020 2020 2020  str(val),.      
-00006460: 2020 2020 2020 2020 2020 2020 2020 736f                so
-00006470: 7572 6365 3d73 6f75 7263 652c 0a20 2020  urce=source,.   
-00006480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006490: 206e 6f74 653d 6e6f 7465 2c0a 2020 2020   note=note,.    
-000064a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000064b0: 6b65 6570 5f73 6f75 7263 655f 6966 5f65  keep_source_if_e
-000064c0: 7175 616c 3d54 7275 652c 0a20 2020 2020  qual=True,.     
-000064d0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-000064e0: 7070 656e 645f 6564 6974 3d46 616c 7365  ppend_edit=False
-000064f0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00006500: 2020 290a 0a20 2020 2040 636c 6173 736d    )..    @classm
-00006510: 6574 686f 640a 2020 2020 6465 6620 5f5f  ethod.    def __
-00006520: 7365 6c65 6374 5f62 6573 745f 6175 7468  select_best_auth
-00006530: 6f72 280a 2020 2020 2020 2020 636c 732c  or(.        cls,
-00006540: 202a 2c20 7265 636f 7264 3a20 5265 636f   *, record: Reco
-00006550: 7264 2c20 6d65 7267 696e 675f 7265 636f  rd, merging_reco
-00006560: 7264 3a20 5265 636f 7264 2c20 7072 6566  rd: Record, pref
-00006570: 6572 7265 645f 736f 7572 6365 733a 206c  erred_sources: l
-00006580: 6973 740a 2020 2020 2920 2d3e 2073 7472  ist.    ) -> str
-00006590: 3a0a 2020 2020 2020 2020 2320 7079 6c69  :.        # pyli
-000065a0: 6e74 3a20 6469 7361 626c 653d 746f 6f2d  nt: disable=too-
-000065b0: 6d61 6e79 2d72 6574 7572 6e2d 7374 6174  many-return-stat
-000065c0: 656d 656e 7473 0a20 2020 2020 2020 2069  ements.        i
-000065d0: 6620 2263 6f6c 7265 765f 6d61 7374 6572  f "colrev_master
-000065e0: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
-000065f0: 206e 6f74 2069 6e20 7265 636f 7264 2e64   not in record.d
-00006600: 6174 613a 0a20 2020 2020 2020 2020 2020  ata:.           
-00006610: 2072 6563 6f72 642e 6461 7461 5b22 636f   record.data["co
-00006620: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
-00006630: 7072 6f76 656e 616e 6365 225d 203d 207b  provenance"] = {
-00006640: 7d0a 2020 2020 2020 2020 7265 636f 7264  }.        record
-00006650: 5f61 5f70 726f 7620 3d20 7265 636f 7264  _a_prov = record
-00006660: 2e64 6174 615b 2263 6f6c 7265 765f 6d61  .data["colrev_ma
-00006670: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
-00006680: 6e63 6522 5d0a 0a20 2020 2020 2020 2069  nce"]..        i
-00006690: 6620 2263 6f6c 7265 765f 6d61 7374 6572  f "colrev_master
-000066a0: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
-000066b0: 206e 6f74 2069 6e20 6d65 7267 696e 675f   not in merging_
-000066c0: 7265 636f 7264 2e64 6174 613a 0a20 2020  record.data:.   
-000066d0: 2020 2020 2020 2020 206d 6572 6769 6e67           merging
-000066e0: 5f72 6563 6f72 642e 6461 7461 5b22 636f  _record.data["co
-000066f0: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
-00006700: 7072 6f76 656e 616e 6365 225d 203d 207b  provenance"] = {
-00006710: 7d0a 2020 2020 2020 2020 6d65 7267 696e  }.        mergin
-00006720: 675f 7265 636f 7264 5f61 5f70 726f 7620  g_record_a_prov 
-00006730: 3d20 6d65 7267 696e 675f 7265 636f 7264  = merging_record
-00006740: 2e64 6174 615b 2263 6f6c 7265 765f 6d61  .data["colrev_ma
-00006750: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
-00006760: 6e63 6522 5d0a 0a20 2020 2020 2020 2069  nce"]..        i
-00006770: 6620 2261 7574 686f 7222 2069 6e20 7265  f "author" in re
-00006780: 636f 7264 5f61 5f70 726f 7620 616e 6420  cord_a_prov and 
-00006790: 2261 7574 686f 7222 206e 6f74 2069 6e20  "author" not in 
-000067a0: 6d65 7267 696e 675f 7265 636f 7264 5f61  merging_record_a
-000067b0: 5f70 726f 763a 0a20 2020 2020 2020 2020  _prov:.         
-000067c0: 2020 2023 2050 7265 6665 7220 6e6f 6e2d     # Prefer non-
-000067d0: 6465 6665 6374 2076 6572 7369 6f6e 0a20  defect version. 
-000067e0: 2020 2020 2020 2020 2020 2069 6620 2271             if "q
-000067f0: 7561 6c69 7479 5f64 6566 6563 7422 2069  uality_defect" i
-00006800: 6e20 7265 636f 7264 5f61 5f70 726f 765b  n record_a_prov[
-00006810: 2261 7574 686f 7222 5d2e 6765 7428 226e  "author"].get("n
-00006820: 6f74 6522 2c20 2222 293a 0a20 2020 2020  ote", ""):.     
-00006830: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00006840: 6e20 6d65 7267 696e 675f 7265 636f 7264  n merging_record
-00006850: 2e64 6174 615b 2261 7574 686f 7222 5d0a  .data["author"].
-00006860: 2020 2020 2020 2020 2020 2020 2320 5072              # Pr
-00006870: 6566 6572 2063 6f6d 706c 6574 6520 7665  efer complete ve
-00006880: 7273 696f 6e0a 2020 2020 2020 2020 2020  rsion.          
-00006890: 2020 6966 2022 696e 636f 6d70 6c65 7465    if "incomplete
-000068a0: 2220 696e 2072 6563 6f72 645f 615f 7072  " in record_a_pr
-000068b0: 6f76 5b22 6175 7468 6f72 225d 2e67 6574  ov["author"].get
-000068c0: 2822 6e6f 7465 222c 2022 2229 3a0a 2020  ("note", ""):.  
-000068d0: 2020 2020 2020 2020 2020 2020 2020 7265                re
-000068e0: 7475 726e 206d 6572 6769 6e67 5f72 6563  turn merging_rec
-000068f0: 6f72 642e 6461 7461 5b22 6175 7468 6f72  ord.data["author
-00006900: 225d 0a20 2020 2020 2020 2065 6c69 6620  "].        elif 
-00006910: 2261 7574 686f 7222 2069 6e20 7265 636f  "author" in reco
-00006920: 7264 5f61 5f70 726f 7620 616e 6420 2261  rd_a_prov and "a
-00006930: 7574 686f 7222 2069 6e20 6d65 7267 696e  uthor" in mergin
-00006940: 675f 7265 636f 7264 5f61 5f70 726f 763a  g_record_a_prov:
-00006950: 0a20 2020 2020 2020 2020 2020 2023 2050  .            # P
-00006960: 7265 6665 7220 6e6f 6e2d 6465 6665 6374  refer non-defect
-00006970: 2076 6572 7369 6f6e 0a20 2020 2020 2020   version.       
-00006980: 2020 2020 2069 6620 2271 7561 6c69 7479       if "quality
-00006990: 5f64 6566 6563 7422 2069 6e20 7265 636f  _defect" in reco
-000069a0: 7264 5f61 5f70 726f 765b 2261 7574 686f  rd_a_prov["autho
-000069b0: 7222 5d2e 6765 7428 0a20 2020 2020 2020  r"].get(.       
-000069c0: 2020 2020 2020 2020 2022 6e6f 7465 222c           "note",
-000069d0: 2022 220a 2020 2020 2020 2020 2020 2020   "".            
-000069e0: 2920 616e 6420 2271 7561 6c69 7479 5f64  ) and "quality_d
-000069f0: 6566 6563 7422 206e 6f74 2069 6e20 6d65  efect" not in me
-00006a00: 7267 696e 675f 7265 636f 7264 5f61 5f70  rging_record_a_p
-00006a10: 726f 765b 2261 7574 686f 7222 5d2e 6765  rov["author"].ge
-00006a20: 7428 0a20 2020 2020 2020 2020 2020 2020  t(.             
-00006a30: 2020 2022 6e6f 7465 222c 2022 220a 2020     "note", "".  
-00006a40: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
-00006a50: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-00006a60: 7572 6e20 6d65 7267 696e 675f 7265 636f  urn merging_reco
-00006a70: 7264 2e64 6174 615b 2261 7574 686f 7222  rd.data["author"
-00006a80: 5d0a 0a20 2020 2020 2020 2020 2020 2023  ]..            #
-00006a90: 2050 7265 6665 7220 636f 6d70 6c65 7465   Prefer complete
-00006aa0: 2076 6572 7369 6f6e 0a20 2020 2020 2020   version.       
-00006ab0: 2020 2020 2069 6620 2269 6e63 6f6d 706c       if "incompl
-00006ac0: 6574 6522 2069 6e20 7265 636f 7264 5f61  ete" in record_a
-00006ad0: 5f70 726f 765b 2261 7574 686f 7222 5d2e  _prov["author"].
-00006ae0: 6765 7428 0a20 2020 2020 2020 2020 2020  get(.           
-00006af0: 2020 2020 2022 6e6f 7465 222c 2022 220a       "note", "".
-00006b00: 2020 2020 2020 2020 2020 2020 2920 616e              ) an
-00006b10: 6420 2269 6e63 6f6d 706c 6574 6522 206e  d "incomplete" n
-00006b20: 6f74 2069 6e20 6d65 7267 696e 675f 7265  ot in merging_re
-00006b30: 636f 7264 5f61 5f70 726f 765b 2261 7574  cord_a_prov["aut
-00006b40: 686f 7222 5d2e 6765 7428 226e 6f74 6522  hor"].get("note"
-00006b50: 2c20 2222 293a 0a20 2020 2020 2020 2020  , ""):.         
-00006b60: 2020 2020 2020 2072 6574 7572 6e20 6d65         return me
-00006b70: 7267 696e 675f 7265 636f 7264 2e64 6174  rging_record.dat
-00006b80: 615b 2261 7574 686f 7222 5d0a 0a20 2020  a["author"]..   
-00006b90: 2020 2020 2069 6620 6c65 6e28 7265 636f       if len(reco
-00006ba0: 7264 2e64 6174 615b 2261 7574 686f 7222  rd.data["author"
-00006bb0: 5d29 203e 2030 2061 6e64 206c 656e 286d  ]) > 0 and len(m
-00006bc0: 6572 6769 6e67 5f72 6563 6f72 642e 6461  erging_record.da
-00006bd0: 7461 5b22 6175 7468 6f72 225d 2920 3e20  ta["author"]) > 
-00006be0: 303a 0a20 2020 2020 2020 2020 2020 2064  0:.            d
-00006bf0: 6566 6175 6c74 5f6d 6f73 746c 795f 7570  efault_mostly_up
-00006c00: 7065 7220 3d20 280a 2020 2020 2020 2020  per = (.        
-00006c10: 2020 2020 2020 2020 636f 6c72 6576 2e65          colrev.e
-00006c20: 6e76 2e75 7469 6c73 2e70 6572 6365 6e74  nv.utils.percent
-00006c30: 5f75 7070 6572 5f63 6861 7273 2872 6563  _upper_chars(rec
-00006c40: 6f72 642e 6461 7461 5b22 6175 7468 6f72  ord.data["author
-00006c50: 225d 2920 3e20 302e 380a 2020 2020 2020  "]) > 0.8.      
-00006c60: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-00006c70: 2020 2020 6361 6e64 6964 6174 655f 6d6f      candidate_mo
-00006c80: 7374 6c79 5f75 7070 6572 203d 2028 0a20  stly_upper = (. 
-00006c90: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00006ca0: 6f6c 7265 762e 656e 762e 7574 696c 732e  olrev.env.utils.
-00006cb0: 7065 7263 656e 745f 7570 7065 725f 6368  percent_upper_ch
-00006cc0: 6172 7328 6d65 7267 696e 675f 7265 636f  ars(merging_reco
-00006cd0: 7264 2e64 6174 615b 2261 7574 686f 7222  rd.data["author"
-00006ce0: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
-00006cf0: 2020 203e 2030 2e38 0a20 2020 2020 2020     > 0.8.       
-00006d00: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
-00006d10: 2020 2020 2320 5072 6566 6572 2074 6974      # Prefer tit
-00006d20: 6c65 2063 6173 6520 286e 6f74 2061 6c6c  le case (not all
-00006d30: 2d63 6170 7329 0a20 2020 2020 2020 2020  -caps).         
-00006d40: 2020 2069 6620 6465 6661 756c 745f 6d6f     if default_mo
-00006d50: 7374 6c79 5f75 7070 6572 2061 6e64 206e  stly_upper and n
-00006d60: 6f74 2063 616e 6469 6461 7465 5f6d 6f73  ot candidate_mos
-00006d70: 746c 795f 7570 7065 723a 0a20 2020 2020  tly_upper:.     
-00006d80: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00006d90: 6e20 6d65 7267 696e 675f 7265 636f 7264  n merging_record
-00006da0: 2e64 6174 615b 2261 7574 686f 7222 5d0a  .data["author"].
-00006db0: 0a20 2020 2020 2020 2023 2050 7265 6665  .        # Prefe
-00006dc0: 7220 736f 7572 6365 730a 2020 2020 2020  r sources.      
-00006dd0: 2020 6966 2022 6175 7468 6f72 2220 696e    if "author" in
-00006de0: 206d 6572 6769 6e67 5f72 6563 6f72 645f   merging_record_
-00006df0: 615f 7072 6f76 3a0a 2020 2020 2020 2020  a_prov:.        
-00006e00: 2020 2020 6966 2061 6e79 280a 2020 2020      if any(.    
-00006e10: 2020 2020 2020 2020 2020 2020 7820 696e              x in
-00006e20: 206d 6572 6769 6e67 5f72 6563 6f72 645f   merging_record_
-00006e30: 615f 7072 6f76 5b22 6175 7468 6f72 225d  a_prov["author"]
-00006e40: 5b22 736f 7572 6365 225d 0a20 2020 2020  ["source"].     
-00006e50: 2020 2020 2020 2020 2020 2066 6f72 2078             for x
-00006e60: 2069 6e20 7072 6566 6572 7265 645f 736f   in preferred_so
-00006e70: 7572 6365 730a 2020 2020 2020 2020 2020  urces.          
-00006e80: 2020 293a 0a20 2020 2020 2020 2020 2020    ):.           
-00006e90: 2020 2020 2072 6574 7572 6e20 6d65 7267       return merg
-00006ea0: 696e 675f 7265 636f 7264 2e64 6174 615b  ing_record.data[
-00006eb0: 2261 7574 686f 7222 5d0a 2020 2020 2020  "author"].      
-00006ec0: 2020 7265 7475 726e 2072 6563 6f72 642e    return record.
-00006ed0: 6461 7461 5b22 6175 7468 6f72 225d 0a0a  data["author"]..
-00006ee0: 2020 2020 4063 6c61 7373 6d65 7468 6f64      @classmethod
-00006ef0: 0a20 2020 2064 6566 205f 5f73 656c 6563  .    def __selec
-00006f00: 745f 6265 7374 5f70 6167 6573 280a 2020  t_best_pages(.  
-00006f10: 2020 2020 2020 636c 732c 0a20 2020 2020        cls,.     
-00006f20: 2020 202a 2c0a 2020 2020 2020 2020 7265     *,.        re
-00006f30: 636f 7264 3a20 5265 636f 7264 2c0a 2020  cord: Record,.  
-00006f40: 2020 2020 2020 6d65 7267 696e 675f 7265        merging_re
-00006f50: 636f 7264 3a20 5265 636f 7264 2c0a 2020  cord: Record,.  
-00006f60: 2020 2020 2020 7072 6566 6572 7265 645f        preferred_
-00006f70: 736f 7572 6365 733a 206c 6973 742c 2020  sources: list,  
-00006f80: 2320 7079 6c69 6e74 3a20 6469 7361 626c  # pylint: disabl
-00006f90: 653d 756e 7573 6564 2d61 7267 756d 656e  e=unused-argumen
-00006fa0: 740a 2020 2020 2920 2d3e 2073 7472 3a0a  t.    ) -> str:.
-00006fb0: 2020 2020 2020 2020 6265 7374 5f70 6167          best_pag
-00006fc0: 6573 203d 2072 6563 6f72 642e 6461 7461  es = record.data
-00006fd0: 5b22 7061 6765 7322 5d0a 2020 2020 2020  ["pages"].      
-00006fe0: 2020 6966 2022 2d2d 2220 696e 206d 6572    if "--" in mer
-00006ff0: 6769 6e67 5f72 6563 6f72 642e 6461 7461  ging_record.data
-00007000: 5b22 7061 6765 7322 5d20 616e 6420 222d  ["pages"] and "-
-00007010: 2d22 206e 6f74 2069 6e20 7265 636f 7264  -" not in record
-00007020: 2e64 6174 615b 2270 6167 6573 225d 3a0a  .data["pages"]:.
-00007030: 2020 2020 2020 2020 2020 2020 6265 7374              best
-00007040: 5f70 6167 6573 203d 206d 6572 6769 6e67  _pages = merging
-00007050: 5f72 6563 6f72 642e 6461 7461 5b22 7061  _record.data["pa
-00007060: 6765 7322 5d0a 2020 2020 2020 2020 7265  ges"].        re
-00007070: 7475 726e 2062 6573 745f 7061 6765 730a  turn best_pages.
-00007080: 0a20 2020 2040 636c 6173 736d 6574 686f  .    @classmetho
-00007090: 640a 2020 2020 6465 6620 5f5f 7365 6c65  d.    def __sele
-000070a0: 6374 5f62 6573 745f 7469 746c 6528 0a20  ct_best_title(. 
-000070b0: 2020 2020 2020 2063 6c73 2c0a 2020 2020         cls,.    
-000070c0: 2020 2020 2a2c 0a20 2020 2020 2020 2072      *,.        r
-000070d0: 6563 6f72 643a 2052 6563 6f72 642c 0a20  ecord: Record,. 
-000070e0: 2020 2020 2020 206d 6572 6769 6e67 5f72         merging_r
-000070f0: 6563 6f72 643a 2052 6563 6f72 642c 0a20  ecord: Record,. 
-00007100: 2020 2020 2020 2070 7265 6665 7272 6564         preferred
-00007110: 5f73 6f75 7263 6573 3a20 6c69 7374 2c20  _sources: list, 
-00007120: 2023 2070 796c 696e 743a 2064 6973 6162   # pylint: disab
-00007130: 6c65 3d75 6e75 7365 642d 6172 6775 6d65  le=unused-argume
-00007140: 6e74 0a20 2020 2029 202d 3e20 7374 723a  nt.    ) -> str:
-00007150: 0a20 2020 2020 2020 2064 6566 6175 6c74  .        default
-00007160: 203d 2072 6563 6f72 642e 6461 7461 5b22   = record.data["
-00007170: 7469 746c 6522 5d0a 2020 2020 2020 2020  title"].        
-00007180: 6361 6e64 6964 6174 6520 3d20 6d65 7267  candidate = merg
-00007190: 696e 675f 7265 636f 7264 2e64 6174 615b  ing_record.data[
-000071a0: 2274 6974 6c65 225d 0a20 2020 2020 2020  "title"].       
-000071b0: 2062 6573 745f 7469 746c 6520 3d20 7265   best_title = re
-000071c0: 636f 7264 2e64 6174 615b 2274 6974 6c65  cord.data["title
-000071d0: 225d 0a0a 2020 2020 2020 2020 2320 4e6f  "]..        # No
-000071e0: 7465 203a 2061 766f 6964 2073 7769 7463  te : avoid switc
-000071f0: 6869 6e67 2074 6974 6c65 730a 2020 2020  hing titles.    
-00007200: 2020 2020 6966 2064 6566 6175 6c74 2e72      if default.r
-00007210: 6570 6c61 6365 2822 202d 2022 2c20 223a  eplace(" - ", ":
-00007220: 2022 2920 3d3d 2063 616e 6469 6461 7465   ") == candidate
-00007230: 2e72 6570 6c61 6365 2822 202d 2022 2c20  .replace(" - ", 
-00007240: 223a 2022 293a 0a20 2020 2020 2020 2020  ": "):.         
-00007250: 2020 2072 6574 7572 6e20 6465 6661 756c     return defaul
-00007260: 740a 0a20 2020 2020 2020 2064 6566 6175  t..        defau
-00007270: 6c74 5f75 7070 6572 203d 2063 6f6c 7265  lt_upper = colre
-00007280: 762e 656e 762e 7574 696c 732e 7065 7263  v.env.utils.perc
-00007290: 656e 745f 7570 7065 725f 6368 6172 7328  ent_upper_chars(
-000072a0: 6465 6661 756c 7429 0a20 2020 2020 2020  default).       
-000072b0: 2063 616e 6469 6461 7465 5f75 7070 6572   candidate_upper
-000072c0: 203d 2063 6f6c 7265 762e 656e 762e 7574   = colrev.env.ut
-000072d0: 696c 732e 7065 7263 656e 745f 7570 7065  ils.percent_uppe
-000072e0: 725f 6368 6172 7328 6361 6e64 6964 6174  r_chars(candidat
-000072f0: 6529 0a0a 2020 2020 2020 2020 6966 2063  e)..        if c
-00007300: 616e 6469 6461 7465 5b2d 315d 206e 6f74  andidate[-1] not
-00007310: 2069 6e20 5b22 2a22 2c20 2231 222c 2022   in ["*", "1", "
-00007320: 3222 5d3a 0a20 2020 2020 2020 2020 2020  2"]:.           
-00007330: 2023 2052 656c 6174 6976 656c 7920 7369   # Relatively si
-00007340: 6d70 6c65 2072 756c 652e 2e2e 0a20 2020  mple rule....   
-00007350: 2020 2020 2020 2020 2023 2063 6174 6368           # catch
-00007360: 6573 2063 6173 6573 2077 6865 6e20 6465  es cases when de
-00007370: 6661 756c 7420 6973 2061 6c6c 2075 7070  fault is all upp
-00007380: 6572 206f 7220 7469 746c 6520 6361 7365  er or title case
-00007390: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-000073a0: 6465 6661 756c 745f 7570 7065 7220 3e20  default_upper > 
-000073b0: 6361 6e64 6964 6174 655f 7570 7065 723a  candidate_upper:
-000073c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000073d0: 2062 6573 745f 7469 746c 6520 3d20 6361   best_title = ca
-000073e0: 6e64 6964 6174 650a 2020 2020 2020 2020  ndidate.        
-000073f0: 7265 7475 726e 2062 6573 745f 7469 746c  return best_titl
-00007400: 650a 0a20 2020 2040 636c 6173 736d 6574  e..    @classmet
-00007410: 686f 640a 2020 2020 6465 6620 5f5f 7365  hod.    def __se
-00007420: 6c65 6374 5f62 6573 745f 6a6f 7572 6e61  lect_best_journa
-00007430: 6c28 0a20 2020 2020 2020 2063 6c73 2c0a  l(.        cls,.
-00007440: 2020 2020 2020 2020 2a2c 0a20 2020 2020          *,.     
-00007450: 2020 2072 6563 6f72 643a 2052 6563 6f72     record: Recor
-00007460: 642c 0a20 2020 2020 2020 206d 6572 6769  d,.        mergi
-00007470: 6e67 5f72 6563 6f72 643a 2052 6563 6f72  ng_record: Recor
-00007480: 642c 0a20 2020 2020 2020 2070 7265 6665  d,.        prefe
-00007490: 7272 6564 5f73 6f75 7263 6573 3a20 6c69  rred_sources: li
-000074a0: 7374 2c20 2023 2070 796c 696e 743a 2064  st,  # pylint: d
-000074b0: 6973 6162 6c65 3d75 6e75 7365 642d 6172  isable=unused-ar
-000074c0: 6775 6d65 6e74 0a20 2020 2029 202d 3e20  gument.    ) -> 
-000074d0: 7374 723a 0a20 2020 2020 2020 2072 6574  str:.        ret
-000074e0: 7572 6e20 636c 732e 5f5f 7365 6c65 6374  urn cls.__select
-000074f0: 5f62 6573 745f 636f 6e74 6169 6e65 725f  _best_container_
-00007500: 7469 746c 6528 0a20 2020 2020 2020 2020  title(.         
-00007510: 2020 2064 6566 6175 6c74 3d72 6563 6f72     default=recor
-00007520: 642e 6461 7461 5b22 6a6f 7572 6e61 6c22  d.data["journal"
-00007530: 5d2c 2063 616e 6469 6461 7465 3d6d 6572  ], candidate=mer
-00007540: 6769 6e67 5f72 6563 6f72 642e 6461 7461  ging_record.data
-00007550: 5b22 6a6f 7572 6e61 6c22 5d0a 2020 2020  ["journal"].    
-00007560: 2020 2020 290a 0a20 2020 2040 636c 6173      )..    @clas
-00007570: 736d 6574 686f 640a 2020 2020 6465 6620  smethod.    def 
-00007580: 5f5f 7365 6c65 6374 5f62 6573 745f 626f  __select_best_bo
-00007590: 6f6b 7469 746c 6528 0a20 2020 2020 2020  oktitle(.       
-000075a0: 2063 6c73 2c0a 2020 2020 2020 2020 2a2c   cls,.        *,
-000075b0: 0a20 2020 2020 2020 2072 6563 6f72 643a  .        record:
-000075c0: 2052 6563 6f72 642c 0a20 2020 2020 2020   Record,.       
-000075d0: 206d 6572 6769 6e67 5f72 6563 6f72 643a   merging_record:
-000075e0: 2052 6563 6f72 642c 0a20 2020 2020 2020   Record,.       
-000075f0: 2070 7265 6665 7272 6564 5f73 6f75 7263   preferred_sourc
-00007600: 6573 3a20 6c69 7374 2c20 2023 2070 796c  es: list,  # pyl
-00007610: 696e 743a 2064 6973 6162 6c65 3d75 6e75  int: disable=unu
-00007620: 7365 642d 6172 6775 6d65 6e74 0a20 2020  sed-argument.   
-00007630: 2029 202d 3e20 7374 723a 0a20 2020 2020   ) -> str:.     
-00007640: 2020 2072 6574 7572 6e20 636c 732e 5f5f     return cls.__
-00007650: 7365 6c65 6374 5f62 6573 745f 636f 6e74  select_best_cont
-00007660: 6169 6e65 725f 7469 746c 6528 0a20 2020  ainer_title(.   
-00007670: 2020 2020 2020 2020 2064 6566 6175 6c74           default
-00007680: 3d72 6563 6f72 642e 6461 7461 5b22 626f  =record.data["bo
-00007690: 6f6b 7469 746c 6522 5d2c 2063 616e 6469  oktitle"], candi
-000076a0: 6461 7465 3d6d 6572 6769 6e67 5f72 6563  date=merging_rec
-000076b0: 6f72 642e 6461 7461 5b22 626f 6f6b 7469  ord.data["bookti
-000076c0: 746c 6522 5d0a 2020 2020 2020 2020 290a  tle"].        ).
-000076d0: 0a20 2020 2040 636c 6173 736d 6574 686f  .    @classmetho
-000076e0: 640a 2020 2020 6465 6620 5f5f 7365 6c65  d.    def __sele
-000076f0: 6374 5f62 6573 745f 636f 6e74 6169 6e65  ct_best_containe
-00007700: 725f 7469 746c 6528 636c 732c 202a 2c20  r_title(cls, *, 
-00007710: 6465 6661 756c 743a 2073 7472 2c20 6361  default: str, ca
-00007720: 6e64 6964 6174 653a 2073 7472 2920 2d3e  ndidate: str) ->
-00007730: 2073 7472 3a0a 2020 2020 2020 2020 6265   str:.        be
-00007740: 7374 5f6a 6f75 726e 616c 203d 2064 6566  st_journal = def
-00007750: 6175 6c74 0a0a 2020 2020 2020 2020 6465  ault..        de
-00007760: 6661 756c 745f 7570 7065 7220 3d20 636f  fault_upper = co
-00007770: 6c72 6576 2e65 6e76 2e75 7469 6c73 2e70  lrev.env.utils.p
-00007780: 6572 6365 6e74 5f75 7070 6572 5f63 6861  ercent_upper_cha
-00007790: 7273 2864 6566 6175 6c74 290a 2020 2020  rs(default).    
-000077a0: 2020 2020 6361 6e64 6964 6174 655f 7570      candidate_up
-000077b0: 7065 7220 3d20 636f 6c72 6576 2e65 6e76  per = colrev.env
-000077c0: 2e75 7469 6c73 2e70 6572 6365 6e74 5f75  .utils.percent_u
-000077d0: 7070 6572 5f63 6861 7273 2863 616e 6469  pper_chars(candi
-000077e0: 6461 7465 290a 0a20 2020 2020 2020 2023  date)..        #
-000077f0: 2053 696d 706c 6520 6865 7572 6973 7469   Simple heuristi
-00007800: 6320 746f 2061 766f 6964 2061 6262 7265  c to avoid abbre
-00007810: 7669 6174 696f 6e73 0a20 2020 2020 2020  viations.       
-00007820: 2069 6620 222e 2220 696e 2064 6566 6175   if "." in defau
-00007830: 6c74 2061 6e64 2022 2e22 206e 6f74 2069  lt and "." not i
-00007840: 6e20 6361 6e64 6964 6174 653a 0a20 2020  n candidate:.   
-00007850: 2020 2020 2020 2020 2062 6573 745f 6a6f           best_jo
-00007860: 7572 6e61 6c20 3d20 6361 6e64 6964 6174  urnal = candidat
-00007870: 650a 2020 2020 2020 2020 2320 5265 6c61  e.        # Rela
-00007880: 7469 7665 6c79 2073 696d 706c 6520 7275  tively simple ru
-00007890: 6c65 2e2e 2e0a 2020 2020 2020 2020 2320  le....        # 
-000078a0: 6361 7463 6865 7320 6361 7365 7320 7768  catches cases wh
-000078b0: 656e 2064 6566 6175 6c74 2069 7320 616c  en default is al
-000078c0: 6c20 7570 7065 7220 6f72 2074 6974 6c65  l upper or title
-000078d0: 2063 6173 650a 2020 2020 2020 2020 6966   case.        if
-000078e0: 2064 6566 6175 6c74 5f75 7070 6572 203e   default_upper >
-000078f0: 2063 616e 6469 6461 7465 5f75 7070 6572   candidate_upper
-00007900: 3a0a 2020 2020 2020 2020 2020 2020 6265  :.            be
-00007910: 7374 5f6a 6f75 726e 616c 203d 2063 616e  st_journal = can
-00007920: 6469 6461 7465 0a20 2020 2020 2020 2072  didate.        r
-00007930: 6574 7572 6e20 6265 7374 5f6a 6f75 726e  eturn best_journ
-00007940: 616c 0a0a 2020 2020 6465 6620 5f5f 6675  al..    def __fu
-00007950: 7365 5f62 6573 745f 6669 656c 6428 0a20  se_best_field(. 
-00007960: 2020 2020 2020 2073 656c 662c 0a20 2020         self,.   
-00007970: 2020 2020 202a 2c0a 2020 2020 2020 2020       *,.        
-00007980: 6d65 7267 696e 675f 7265 636f 7264 3a20  merging_record: 
-00007990: 5265 636f 7264 2c0a 2020 2020 2020 2020  Record,.        
-000079a0: 6b65 793a 2073 7472 2c0a 2020 2020 2020  key: str,.      
-000079b0: 2020 7661 6c3a 2073 7472 2c0a 2020 2020    val: str,.    
-000079c0: 2020 2020 736f 7572 6365 3a20 7374 722c      source: str,
-000079d0: 0a20 2020 2020 2020 206e 6f74 653a 2073  .        note: s
-000079e0: 7472 2c20 2023 2070 796c 696e 743a 2064  tr,  # pylint: d
-000079f0: 6973 6162 6c65 3d75 6e75 7365 642d 6172  isable=unused-ar
-00007a00: 6775 6d65 6e74 0a20 2020 2029 202d 3e20  gument.    ) -> 
-00007a10: 4e6f 6e65 3a0a 2020 2020 2020 2020 2320  None:.        # 
-00007a20: 4e6f 7465 203a 2074 6865 2061 7373 756d  Note : the assum
-00007a30: 7074 696f 6e20 6973 2074 6861 7420 7765  ption is that we
-00007a40: 206e 6565 6420 6d61 7374 6572 6461 7461   need masterdata
-00007a50: 5f70 726f 7665 6e61 6e63 6520 6e6f 7465  _provenance note
-00007a60: 730a 2020 2020 2020 2020 2320 6f6e 6c79  s.        # only
-00007a70: 2066 6f72 2061 7574 686f 7273 0a0a 2020   for authors..  
-00007a80: 2020 2020 2020 6375 7374 6f6d 5f66 6965        custom_fie
-00007a90: 6c64 5f73 656c 6563 746f 7273 203d 207b  ld_selectors = {
-00007aa0: 0a20 2020 2020 2020 2020 2020 2022 6175  .            "au
-00007ab0: 7468 6f72 223a 2073 656c 662e 5f5f 7365  thor": self.__se
-00007ac0: 6c65 6374 5f62 6573 745f 6175 7468 6f72  lect_best_author
-00007ad0: 2c0a 2020 2020 2020 2020 2020 2020 2270  ,.            "p
-00007ae0: 6167 6573 223a 2073 656c 662e 5f5f 7365  ages": self.__se
-00007af0: 6c65 6374 5f62 6573 745f 7061 6765 732c  lect_best_pages,
-00007b00: 0a20 2020 2020 2020 2020 2020 2022 7469  .            "ti
-00007b10: 746c 6522 3a20 7365 6c66 2e5f 5f73 656c  tle": self.__sel
-00007b20: 6563 745f 6265 7374 5f74 6974 6c65 2c0a  ect_best_title,.
-00007b30: 2020 2020 2020 2020 2020 2020 226a 6f75              "jou
-00007b40: 726e 616c 223a 2073 656c 662e 5f5f 7365  rnal": self.__se
-00007b50: 6c65 6374 5f62 6573 745f 6a6f 7572 6e61  lect_best_journa
-00007b60: 6c2c 0a20 2020 2020 2020 2020 2020 2022  l,.            "
-00007b70: 626f 6f6b 7469 746c 6522 3a20 7365 6c66  booktitle": self
-00007b80: 2e5f 5f73 656c 6563 745f 6265 7374 5f62  .__select_best_b
-00007b90: 6f6f 6b74 6974 6c65 2c0a 2020 2020 2020  ooktitle,.      
-00007ba0: 2020 7d0a 0a20 2020 2020 2020 2069 6620    }..        if 
-00007bb0: 6b65 7920 696e 2063 7573 746f 6d5f 6669  key in custom_fi
-00007bc0: 656c 645f 7365 6c65 6374 6f72 733a 0a20  eld_selectors:. 
-00007bd0: 2020 2020 2020 2020 2020 2069 6620 6b65             if ke
-00007be0: 7920 696e 2073 656c 662e 6461 7461 3a0a  y in self.data:.
-00007bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007c00: 6265 7374 5f76 616c 7565 203d 2063 7573  best_value = cus
-00007c10: 746f 6d5f 6669 656c 645f 7365 6c65 6374  tom_field_select
-00007c20: 6f72 735b 6b65 795d 280a 2020 2020 2020  ors[key](.      
-00007c30: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00007c40: 636f 7264 3d73 656c 662c 0a20 2020 2020  cord=self,.     
-00007c50: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-00007c60: 6572 6769 6e67 5f72 6563 6f72 643d 6d65  erging_record=me
-00007c70: 7267 696e 675f 7265 636f 7264 2c0a 2020  rging_record,.  
-00007c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007c90: 2020 7072 6566 6572 7265 645f 736f 7572    preferred_sour
-00007ca0: 6365 733d 7365 6c66 2e70 7265 6665 7272  ces=self.preferr
-00007cb0: 6564 5f73 6f75 7263 6573 2c0a 2020 2020  ed_sources,.    
-00007cc0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-00007cd0: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00007ce0: 2073 656c 662e 6461 7461 5b6b 6579 5d20   self.data[key] 
-00007cf0: 213d 2062 6573 745f 7661 6c75 653a 0a20  != best_value:. 
-00007d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007d10: 2020 2073 656c 662e 7570 6461 7465 5f66     self.update_f
-00007d20: 6965 6c64 280a 2020 2020 2020 2020 2020  ield(.          
-00007d30: 2020 2020 2020 2020 2020 2020 2020 6b65                ke
-00007d40: 793d 6b65 792c 2076 616c 7565 3d62 6573  y=key, value=bes
-00007d50: 745f 7661 6c75 652c 2073 6f75 7263 653d  t_value, source=
-00007d60: 736f 7572 6365 2c20 6170 7065 6e64 5f65  source, append_e
-00007d70: 6469 743d 4661 6c73 650a 2020 2020 2020  dit=False.      
-00007d80: 2020 2020 2020 2020 2020 2020 2020 290a                ).
-00007d90: 2020 2020 2020 2020 2020 2020 656c 7365              else
-00007da0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00007db0: 2020 7365 6c66 2e75 7064 6174 655f 6669    self.update_fi
-00007dc0: 656c 6428 6b65 793d 6b65 792c 2076 616c  eld(key=key, val
-00007dd0: 7565 3d76 616c 2c20 736f 7572 6365 3d73  ue=val, source=s
-00007de0: 6f75 7263 652c 2061 7070 656e 645f 6564  ource, append_ed
-00007df0: 6974 3d46 616c 7365 290a 0a20 2020 2020  it=False)..     
-00007e00: 2020 2065 6c69 6620 6b65 7920 3d3d 2022     elif key == "
-00007e10: 6669 6c65 223a 0a20 2020 2020 2020 2020  file":.         
-00007e20: 2020 2069 6620 6b65 7920 696e 2073 656c     if key in sel
-00007e30: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
-00007e40: 2020 2020 2020 2020 7365 6c66 2e64 6174          self.dat
-00007e50: 615b 6b65 795d 203d 2073 656c 662e 6461  a[key] = self.da
-00007e60: 7461 5b6b 6579 5d20 2b20 223b 2220 2b20  ta[key] + ";" + 
-00007e70: 6d65 7267 696e 675f 7265 636f 7264 2e64  merging_record.d
-00007e80: 6174 612e 6765 7428 6b65 792c 2022 2229  ata.get(key, "")
-00007e90: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-00007ea0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00007eb0: 2020 2073 656c 662e 6461 7461 5b6b 6579     self.data[key
-00007ec0: 5d20 3d20 6d65 7267 696e 675f 7265 636f  ] = merging_reco
-00007ed0: 7264 2e64 6174 615b 6b65 795d 0a20 2020  rd.data[key].   
-00007ee0: 2020 2020 2065 6c69 6620 6b65 7920 696e       elif key in
-00007ef0: 205b 2275 726c 222c 2022 6c69 6e6b 225d   ["url", "link"]
-00007f00: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-00007f10: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
-00007f20: 2020 206b 6579 2069 6e20 7365 6c66 2e64     key in self.d
-00007f30: 6174 610a 2020 2020 2020 2020 2020 2020  ata.            
-00007f40: 2020 2020 616e 6420 7365 6c66 2e64 6174      and self.dat
-00007f50: 615b 6b65 795d 2e72 7374 7269 7028 222f  a[key].rstrip("/
-00007f60: 2229 2021 3d20 6d65 7267 696e 675f 7265  ") != merging_re
-00007f70: 636f 7264 2e64 6174 615b 6b65 795d 2e72  cord.data[key].r
-00007f80: 7374 7269 7028 222f 2229 0a20 2020 2020  strip("/").     
-00007f90: 2020 2020 2020 2020 2020 2061 6e64 2022             and "
-00007fa0: 6874 7470 7322 206e 6f74 2069 6e20 7365  https" not in se
-00007fb0: 6c66 2e64 6174 615b 6b65 795d 0a20 2020  lf.data[key].   
-00007fc0: 2020 2020 2020 2020 2029 3a0a 2020 2020           ):.    
-00007fd0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00007fe0: 2e75 7064 6174 655f 6669 656c 6428 6b65  .update_field(ke
-00007ff0: 793d 6b65 792c 2076 616c 7565 3d76 616c  y=key, value=val
-00008000: 2c20 736f 7572 6365 3d73 6f75 7263 652c  , source=source,
-00008010: 2061 7070 656e 645f 6564 6974 3d46 616c   append_edit=Fal
-00008020: 7365 290a 0a20 2020 2020 2020 2065 6c69  se)..        eli
-00008030: 6620 2255 4e4b 4e4f 574e 2220 3d3d 2073  f "UNKNOWN" == s
-00008040: 656c 662e 6461 7461 2e67 6574 280a 2020  elf.data.get(.  
-00008050: 2020 2020 2020 2020 2020 6b65 792c 2022            key, "
-00008060: 220a 2020 2020 2020 2020 2920 616e 6420  ".        ) and 
-00008070: 2255 4e4b 4e4f 574e 2220 213d 206d 6572  "UNKNOWN" != mer
-00008080: 6769 6e67 5f72 6563 6f72 642e 6461 7461  ging_record.data
-00008090: 2e67 6574 286b 6579 2c20 2222 293a 0a20  .get(key, ""):. 
-000080a0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-000080b0: 6461 7461 5b6b 6579 5d20 3d20 6d65 7267  data[key] = merg
-000080c0: 696e 675f 7265 636f 7264 2e64 6174 615b  ing_record.data[
-000080d0: 6b65 795d 0a20 2020 2020 2020 2020 2020  key].           
-000080e0: 2069 6620 6b65 7920 696e 2073 656c 662e   if key in self.
-000080f0: 6964 656e 7469 6679 696e 675f 6669 656c  identifying_fiel
-00008100: 645f 6b65 7973 3a0a 2020 2020 2020 2020  d_keys:.        
-00008110: 2020 2020 2020 2020 7365 6c66 2e61 6464          self.add
-00008120: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
-00008130: 656e 616e 6365 286b 6579 3d6b 6579 2c20  enance(key=key, 
-00008140: 736f 7572 6365 3d73 6f75 7263 6529 0a20  source=source). 
-00008150: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-00008160: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008170: 2073 656c 662e 6164 645f 6461 7461 5f70   self.add_data_p
-00008180: 726f 7665 6e61 6e63 6528 6b65 793d 6b65  rovenance(key=ke
-00008190: 792c 2073 6f75 7263 653d 736f 7572 6365  y, source=source
-000081a0: 290a 0a20 2020 2020 2020 2023 2065 6c69  )..        # eli
-000081b0: 6620 6d65 7267 696e 675f 7265 636f 7264  f merging_record
-000081c0: 2e64 6174 612e 6765 7428 6b65 792c 2022  .data.get(key, "
-000081d0: 554e 4b4e 4f57 4e22 2920 3d3d 2022 554e  UNKNOWN") == "UN
-000081e0: 4b4e 4f57 4e22 3a0a 2020 2020 2020 2020  KNOWN":.        
-000081f0: 2320 2020 2020 7061 7373 0a20 2020 2020  #     pass.     
-00008200: 2020 2023 204e 6f74 6520 3a20 7468 6520     # Note : the 
-00008210: 666f 6c6c 6f77 696e 6720 6973 2064 6561  following is dea
-00008220: 6374 6976 6174 6564 2074 6f20 6176 6f69  ctivated to avoi
-00008230: 6420 6672 6571 7565 6e74 2063 6861 6e67  d frequent chang
-00008240: 6573 2069 6e20 6d65 7267 6564 2072 6563  es in merged rec
-00008250: 6f72 6473 0a20 2020 2020 2020 2023 2065  ords.        # e
-00008260: 6c73 653a 0a20 2020 2020 2020 2023 2020  lse:.        #  
-00008270: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
-00008280: 2320 2020 2020 2020 2020 6966 206b 6579  #         if key
-00008290: 2069 6e20 7365 6c66 2e69 6465 6e74 6966   in self.identif
-000082a0: 7969 6e67 5f66 6965 6c64 5f6b 6579 733a  ying_field_keys:
-000082b0: 0a20 2020 2020 2020 2023 2020 2020 2020  .        #      
-000082c0: 2020 2020 2020 2073 6f75 7263 6520 3d20         source = 
-000082d0: 6d65 7267 696e 675f 7265 636f 7264 2e64  merging_record.d
-000082e0: 6174 615b 2263 6f6c 7265 765f 6d61 7374  ata["colrev_mast
-000082f0: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
-00008300: 6522 5d5b 6b65 795d 5b0a 2020 2020 2020  e"][key][.      
-00008310: 2020 2320 2020 2020 2020 2020 2020 2020    #             
-00008320: 2020 2020 2273 6f75 7263 6522 0a20 2020      "source".   
-00008330: 2020 2020 2023 2020 2020 2020 2020 2020       #          
-00008340: 2020 205d 0a20 2020 2020 2020 2023 2020     ].        #  
-00008350: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00008360: 2020 2020 2023 2020 2020 2020 2020 2020       #          
-00008370: 2020 2073 6f75 7263 6520 3d20 6d65 7267     source = merg
-00008380: 696e 675f 7265 636f 7264 2e64 6174 615b  ing_record.data[
-00008390: 2263 6f6c 7265 765f 6461 7461 5f70 726f  "colrev_data_pro
-000083a0: 7665 6e61 6e63 6522 5d5b 6b65 795d 5b0a  venance"][key][.
-000083b0: 2020 2020 2020 2020 2320 2020 2020 2020          #       
-000083c0: 2020 2020 2020 2020 2020 2273 6f75 7263            "sourc
-000083d0: 6522 0a20 2020 2020 2020 2023 2020 2020  e".        #    
-000083e0: 2020 2020 2020 2020 205d 0a20 2020 2020           ].     
-000083f0: 2020 2023 2020 2020 2065 7863 6570 7420     #     except 
-00008400: 4b65 7945 7272 6f72 3a0a 2020 2020 2020  KeyError:.      
-00008410: 2020 2320 2020 2020 2020 2020 7061 7373    #         pass
-00008420: 0a20 2020 2020 2020 2023 2069 6620 7661  .        # if va
-00008430: 6c20 213d 2073 7472 286d 6572 6769 6e67  l != str(merging
-00008440: 5f72 6563 6f72 642e 6461 7461 5b6b 6579  _record.data[key
-00008450: 5d29 3a0a 2020 2020 2020 2020 2320 2020  ]):.        #   
-00008460: 2020 7365 6c66 2e75 7064 6174 655f 6669    self.update_fi
-00008470: 656c 6428 0a20 2020 2020 2020 2023 2020  eld(.        #  
-00008480: 2020 2020 2020 206b 6579 3d6b 6579 2c0a         key=key,.
-00008490: 2020 2020 2020 2020 2320 2020 2020 2020          #       
-000084a0: 2020 7661 6c75 653d 7374 7228 6d65 7267    value=str(merg
-000084b0: 696e 675f 7265 636f 7264 2e64 6174 615b  ing_record.data[
-000084c0: 6b65 795d 292c 0a20 2020 2020 2020 2023  key]),.        #
-000084d0: 2020 2020 2020 2020 2073 6f75 7263 653d           source=
-000084e0: 736f 7572 6365 2c0a 2020 2020 2020 2020  source,.        
-000084f0: 2320 2020 2020 2020 2020 6e6f 7465 3d6e  #         note=n
-00008500: 6f74 652c 0a20 2020 2020 2020 2023 2020  ote,.        #  
-00008510: 2020 2029 0a20 2020 2020 2020 2023 2073     ).        # s
-00008520: 656c 662e 7570 6461 7465 5f66 6965 6c64  elf.update_field
-00008530: 286b 6579 3d6b 6579 2c20 7661 6c75 653d  (key=key, value=
-00008540: 7661 6c2c 2073 6f75 7263 653d 736f 7572  val, source=sour
-00008550: 6365 2c20 6e6f 7465 3d6e 6f74 6529 0a0a  ce, note=note)..
-00008560: 2020 2020 4063 6c61 7373 6d65 7468 6f64      @classmethod
-00008570: 0a20 2020 2064 6566 2067 6574 5f72 6563  .    def get_rec
-00008580: 6f72 645f 6368 616e 6765 5f73 636f 7265  ord_change_score
-00008590: 2863 6c73 2c20 2a2c 2072 6563 6f72 645f  (cls, *, record_
-000085a0: 613a 2052 6563 6f72 642c 2072 6563 6f72  a: Record, recor
-000085b0: 645f 623a 2052 6563 6f72 6429 202d 3e20  d_b: Record) -> 
-000085c0: 666c 6f61 743a 0a20 2020 2020 2020 2022  float:.        "
-000085d0: 2222 4465 7465 726d 696e 6520 686f 7720  ""Determine how 
-000085e0: 6d75 6368 2072 6563 6f72 6473 2063 6861  much records cha
-000085f0: 6e67 6564 0a0a 2020 2020 2020 2020 5468  nged..        Th
-00008600: 6973 206d 6574 686f 6420 6973 206c 6573  is method is les
-00008610: 7320 7365 6e73 6974 6976 6520 7468 616e  s sensitive than
-00008620: 2067 6574 5f72 6563 6f72 645f 7369 6d69   get_record_simi
-00008630: 6c61 7269 7479 2c20 6573 7065 6369 616c  larity, especial
-00008640: 6c79 2077 6865 6e0a 2020 2020 2020 2020  ly when.        
-00008650: 6669 656c 6473 2061 7265 206d 6973 7369  fields are missi
-00008660: 6e67 2e20 466f 7220 6578 616d 706c 652c  ng. For example,
-00008670: 2069 6620 7468 6520 6a6f 7572 6e61 6c20   if the journal 
-00008680: 6669 656c 6420 6973 206d 6973 7369 6e67  field is missing
-00008690: 2069 6e20 626f 7468 0a20 2020 2020 2020   in both.       
-000086a0: 2072 6563 6f72 6473 2c20 6765 745f 7369   records, get_si
-000086b0: 6d69 6c61 7269 7479 2077 696c 6c20 7265  milarity will re
-000086c0: 7475 726e 2061 2076 616c 7565 203e 2031  turn a value > 1
-000086d0: 2e30 2e20 5468 6520 6765 745f 7265 636f  .0. The get_reco
-000086e0: 7264 5f63 6861 6e67 6573 0a20 2020 2020  rd_changes.     
-000086f0: 2020 2077 696c 6c20 7265 7475 726e 2030     will return 0
-00008700: 2e30 2028 6966 2061 6c6c 206f 7468 6572  .0 (if all other
-00008710: 2066 6965 6c64 7320 6172 6520 6571 7561   fields are equa
-00008720: 6c29 2e22 2222 0a0a 2020 2020 2020 2020  l)."""..        
-00008730: 2320 4174 2073 6f6d 6520 706f 696e 742c  # At some point,
-00008740: 2074 6869 7320 6d61 7920 6265 636f 6d65   this may become
-00008750: 206d 6f72 6520 7365 6e73 6974 6976 6520   more sensitive 
-00008760: 746f 206d 616a 6f72 2063 6861 6e67 6573  to major changes
-00008770: 0a20 2020 2020 2020 2073 7472 5f61 203d  .        str_a =
-00008780: 2028 0a20 2020 2020 2020 2020 2020 2066   (.            f
-00008790: 227b 7265 636f 7264 5f61 2e64 6174 612e  "{record_a.data.
-000087a0: 6765 7428 2761 7574 686f 7227 2c20 2727  get('author', ''
-000087b0: 297d 2028 7b72 6563 6f72 645f 612e 6461  )} ({record_a.da
-000087c0: 7461 2e67 6574 2827 7965 6172 272c 2027  ta.get('year', '
-000087d0: 2729 7d29 2022 0a20 2020 2020 2020 2020  ')}) ".         
-000087e0: 2020 202b 2066 227b 7265 636f 7264 5f61     + f"{record_a
-000087f0: 2e64 6174 612e 6765 7428 2774 6974 6c65  .data.get('title
-00008800: 272c 2027 2729 7d2e 2022 0a20 2020 2020  ', '')}. ".     
-00008810: 2020 2020 2020 202b 2066 227b 7265 636f         + f"{reco
-00008820: 7264 5f61 2e64 6174 612e 6765 7428 276a  rd_a.data.get('j
-00008830: 6f75 726e 616c 272c 2027 2729 7d7b 7265  ournal', '')}{re
-00008840: 636f 7264 5f61 2e64 6174 612e 6765 7428  cord_a.data.get(
-00008850: 2762 6f6f 6b74 6974 6c65 272c 2027 2729  'booktitle', '')
-00008860: 7d2c 2022 0a20 2020 2020 2020 2020 2020  }, ".           
-00008870: 202b 2066 227b 7265 636f 7264 5f61 2e64   + f"{record_a.d
-00008880: 6174 612e 6765 7428 2776 6f6c 756d 6527  ata.get('volume'
-00008890: 2c20 2727 297d 2028 7b72 6563 6f72 645f  , '')} ({record_
-000088a0: 612e 6461 7461 2e67 6574 2827 6e75 6d62  a.data.get('numb
-000088b0: 6572 272c 2027 2729 7d29 220a 2020 2020  er', '')})".    
-000088c0: 2020 2020 290a 2020 2020 2020 2020 7374      ).        st
-000088d0: 725f 6220 3d20 280a 2020 2020 2020 2020  r_b = (.        
-000088e0: 2020 2020 6622 7b72 6563 6f72 645f 622e      f"{record_b.
-000088f0: 6461 7461 2e67 6574 2827 6175 7468 6f72  data.get('author
-00008900: 272c 2027 2729 7d20 287b 7265 636f 7264  ', '')} ({record
-00008910: 5f62 2e64 6174 612e 6765 7428 2779 6561  _b.data.get('yea
-00008920: 7227 2c20 2727 297d 2920 220a 2020 2020  r', '')}) ".    
-00008930: 2020 2020 2020 2020 2b20 6622 7b72 6563          + f"{rec
-00008940: 6f72 645f 622e 6461 7461 2e67 6574 2827  ord_b.data.get('
-00008950: 7469 746c 6527 2c20 2727 297d 2e20 220a  title', '')}. ".
-00008960: 2020 2020 2020 2020 2020 2020 2b20 6622              + f"
-00008970: 7b72 6563 6f72 645f 622e 6461 7461 2e67  {record_b.data.g
-00008980: 6574 2827 6a6f 7572 6e61 6c27 2c20 2727  et('journal', ''
-00008990: 297d 7b72 6563 6f72 645f 622e 6461 7461  )}{record_b.data
-000089a0: 2e67 6574 2827 626f 6f6b 7469 746c 6527  .get('booktitle'
-000089b0: 2c20 2727 297d 2c20 220a 2020 2020 2020  , '')}, ".      
-000089c0: 2020 2020 2020 2b20 6622 7b72 6563 6f72        + f"{recor
-000089d0: 645f 622e 6461 7461 2e67 6574 2827 766f  d_b.data.get('vo
-000089e0: 6c75 6d65 272c 2027 2729 7d20 287b 7265  lume', '')} ({re
-000089f0: 636f 7264 5f62 2e64 6174 612e 6765 7428  cord_b.data.get(
-00008a00: 276e 756d 6265 7227 2c20 2727 297d 2922  'number', '')})"
-00008a10: 0a20 2020 2020 2020 2029 0a20 2020 2020  .        ).     
-00008a20: 2020 2072 6574 7572 6e20 3120 2d20 6675     return 1 - fu
-00008a30: 7a7a 2e72 6174 696f 2873 7472 5f61 2e6c  zz.ratio(str_a.l
-00008a40: 6f77 6572 2829 2c20 7374 725f 622e 6c6f  ower(), str_b.lo
-00008a50: 7765 7228 2929 202f 2031 3030 0a0a 2020  wer()) / 100..  
-00008a60: 2020 4063 6c61 7373 6d65 7468 6f64 0a20    @classmethod. 
-00008a70: 2020 2064 6566 2067 6574 5f72 6563 6f72     def get_recor
-00008a80: 645f 7369 6d69 6c61 7269 7479 2863 6c73  d_similarity(cls
-00008a90: 2c20 2a2c 2072 6563 6f72 645f 613a 2052  , *, record_a: R
-00008aa0: 6563 6f72 642c 2072 6563 6f72 645f 623a  ecord, record_b:
-00008ab0: 2052 6563 6f72 6429 202d 3e20 666c 6f61   Record) -> floa
-00008ac0: 743a 0a20 2020 2020 2020 2022 2222 4465  t:.        """De
-00008ad0: 7465 726d 696e 6520 7468 6520 7369 6d69  termine the simi
-00008ae0: 6c61 7269 7479 2062 6574 7765 656e 2074  larity between t
-00008af0: 776f 2072 6563 6f72 6473 2028 7468 6569  wo records (thei
-00008b00: 7220 6d61 7374 6572 6461 7461 2922 2222  r masterdata)"""
-00008b10: 0a20 2020 2020 2020 2072 6563 6f72 645f  .        record_
-00008b20: 615f 6469 6374 203d 2072 6563 6f72 645f  a_dict = record_
-00008b30: 612e 636f 7079 2829 2e67 6574 5f64 6174  a.copy().get_dat
-00008b40: 6128 290a 2020 2020 2020 2020 7265 636f  a().        reco
-00008b50: 7264 5f62 5f64 6963 7420 3d20 7265 636f  rd_b_dict = reco
-00008b60: 7264 5f62 2e63 6f70 7928 292e 6765 745f  rd_b.copy().get_
-00008b70: 6461 7461 2829 0a0a 2020 2020 2020 2020  data()..        
-00008b80: 6d61 6e64 6174 6f72 795f 6669 656c 6473  mandatory_fields
-00008b90: 203d 205b 0a20 2020 2020 2020 2020 2020   = [.           
-00008ba0: 2022 7469 746c 6522 2c0a 2020 2020 2020   "title",.      
-00008bb0: 2020 2020 2020 2261 7574 686f 7222 2c0a        "author",.
-00008bc0: 2020 2020 2020 2020 2020 2020 2279 6561              "yea
-00008bd0: 7222 2c0a 2020 2020 2020 2020 2020 2020  r",.            
-00008be0: 226a 6f75 726e 616c 222c 0a20 2020 2020  "journal",.     
-00008bf0: 2020 2020 2020 2022 766f 6c75 6d65 222c         "volume",
-00008c00: 0a20 2020 2020 2020 2020 2020 2022 6e75  .            "nu
-00008c10: 6d62 6572 222c 0a20 2020 2020 2020 2020  mber",.         
-00008c20: 2020 2022 7061 6765 7322 2c0a 2020 2020     "pages",.    
-00008c30: 2020 2020 2020 2020 2262 6f6f 6b74 6974          "booktit
-00008c40: 6c65 222c 0a20 2020 2020 2020 205d 0a0a  le",.        ]..
-00008c50: 2020 2020 2020 2020 666f 7220 6d61 6e64          for mand
-00008c60: 6174 6f72 795f 6669 656c 6420 696e 206d  atory_field in m
-00008c70: 616e 6461 746f 7279 5f66 6965 6c64 733a  andatory_fields:
-00008c80: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00008c90: 7265 636f 7264 5f61 5f64 6963 742e 6765  record_a_dict.ge
-00008ca0: 7428 6d61 6e64 6174 6f72 795f 6669 656c  t(mandatory_fiel
-00008cb0: 642c 2022 554e 4b4e 4f57 4e22 2920 3d3d  d, "UNKNOWN") ==
-00008cc0: 2022 554e 4b4e 4f57 4e22 3a0a 2020 2020   "UNKNOWN":.    
-00008cd0: 2020 2020 2020 2020 2020 2020 7265 636f              reco
-00008ce0: 7264 5f61 5f64 6963 745b 6d61 6e64 6174  rd_a_dict[mandat
-00008cf0: 6f72 795f 6669 656c 645d 203d 2022 220a  ory_field] = "".
-00008d00: 2020 2020 2020 2020 2020 2020 6966 2072              if r
-00008d10: 6563 6f72 645f 625f 6469 6374 2e67 6574  ecord_b_dict.get
-00008d20: 286d 616e 6461 746f 7279 5f66 6965 6c64  (mandatory_field
-00008d30: 2c20 2255 4e4b 4e4f 574e 2229 203d 3d20  , "UNKNOWN") == 
-00008d40: 2255 4e4b 4e4f 574e 223a 0a20 2020 2020  "UNKNOWN":.     
-00008d50: 2020 2020 2020 2020 2020 2072 6563 6f72             recor
-00008d60: 645f 625f 6469 6374 5b6d 616e 6461 746f  d_b_dict[mandato
-00008d70: 7279 5f66 6965 6c64 5d20 3d20 2222 0a0a  ry_field] = ""..
-00008d80: 2020 2020 2020 2020 6966 2022 636f 6e74          if "cont
-00008d90: 6169 6e65 725f 7469 746c 6522 206e 6f74  ainer_title" not
-00008da0: 2069 6e20 7265 636f 7264 5f61 5f64 6963   in record_a_dic
-00008db0: 743a 0a20 2020 2020 2020 2020 2020 2072  t:.            r
-00008dc0: 6563 6f72 645f 615f 6469 6374 5b22 636f  ecord_a_dict["co
-00008dd0: 6e74 6169 6e65 725f 7469 746c 6522 5d20  ntainer_title"] 
-00008de0: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
-00008df0: 2020 2020 7265 636f 7264 5f61 5f64 6963      record_a_dic
-00008e00: 742e 6765 7428 226a 6f75 726e 616c 222c  t.get("journal",
-00008e10: 2022 2229 0a20 2020 2020 2020 2020 2020   "").           
-00008e20: 2020 2020 202b 2072 6563 6f72 645f 615f       + record_a_
-00008e30: 6469 6374 2e67 6574 2822 626f 6f6b 7469  dict.get("bookti
-00008e40: 746c 6522 2c20 2222 290a 2020 2020 2020  tle", "").      
-00008e50: 2020 2020 2020 2020 2020 2b20 7265 636f            + reco
-00008e60: 7264 5f61 5f64 6963 742e 6765 7428 2273  rd_a_dict.get("s
-00008e70: 6572 6965 7322 2c20 2222 290a 2020 2020  eries", "").    
-00008e80: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
-00008e90: 2020 2069 6620 2263 6f6e 7461 696e 6572     if "container
-00008ea0: 5f74 6974 6c65 2220 6e6f 7420 696e 2072  _title" not in r
-00008eb0: 6563 6f72 645f 625f 6469 6374 3a0a 2020  ecord_b_dict:.  
-00008ec0: 2020 2020 2020 2020 2020 7265 636f 7264            record
-00008ed0: 5f62 5f64 6963 745b 2263 6f6e 7461 696e  _b_dict["contain
-00008ee0: 6572 5f74 6974 6c65 225d 203d 2028 0a20  er_title"] = (. 
-00008ef0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00008f00: 6563 6f72 645f 625f 6469 6374 2e67 6574  ecord_b_dict.get
-00008f10: 2822 6a6f 7572 6e61 6c22 2c20 2222 290a  ("journal", "").
-00008f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008f30: 2b20 7265 636f 7264 5f62 5f64 6963 742e  + record_b_dict.
-00008f40: 6765 7428 2262 6f6f 6b74 6974 6c65 222c  get("booktitle",
-00008f50: 2022 2229 0a20 2020 2020 2020 2020 2020   "").           
-00008f60: 2020 2020 202b 2072 6563 6f72 645f 625f       + record_b_
-00008f70: 6469 6374 2e67 6574 2822 7365 7269 6573  dict.get("series
-00008f80: 222c 2022 2229 0a20 2020 2020 2020 2020  ", "").         
-00008f90: 2020 2029 0a0a 2020 2020 2020 2020 6466     )..        df
-00008fa0: 5f61 203d 2070 642e 4461 7461 4672 616d  _a = pd.DataFram
-00008fb0: 652e 6672 6f6d 5f64 6963 7428 5b72 6563  e.from_dict([rec
-00008fc0: 6f72 645f 615f 6469 6374 5d29 2020 2320  ord_a_dict])  # 
-00008fd0: 7479 7065 3a20 6967 6e6f 7265 0a20 2020  type: ignore.   
-00008fe0: 2020 2020 2064 665f 6220 3d20 7064 2e44       df_b = pd.D
-00008ff0: 6174 6146 7261 6d65 2e66 726f 6d5f 6469  ataFrame.from_di
-00009000: 6374 285b 7265 636f 7264 5f62 5f64 6963  ct([record_b_dic
-00009010: 745d 2920 2023 2074 7970 653a 2069 676e  t])  # type: ign
-00009020: 6f72 650a 0a20 2020 2020 2020 2072 6574  ore..        ret
-00009030: 7572 6e20 5265 636f 7264 2e67 6574 5f73  urn Record.get_s
-00009040: 696d 696c 6172 6974 7928 6466 5f61 3d64  imilarity(df_a=d
-00009050: 665f 612e 696c 6f63 5b30 5d2c 2064 665f  f_a.iloc[0], df_
-00009060: 623d 6466 5f62 2e69 6c6f 635b 305d 290a  b=df_b.iloc[0]).
-00009070: 0a20 2020 2040 636c 6173 736d 6574 686f  .    @classmetho
-00009080: 640a 2020 2020 6465 6620 6765 745f 7369  d.    def get_si
-00009090: 6d69 6c61 7269 7479 2863 6c73 2c20 2a2c  milarity(cls, *,
-000090a0: 2064 665f 613a 2064 6963 742c 2064 665f   df_a: dict, df_
-000090b0: 623a 2064 6963 7429 202d 3e20 666c 6f61  b: dict) -> floa
-000090c0: 743a 0a20 2020 2020 2020 2022 2222 4465  t:.        """De
-000090d0: 7465 726d 696e 6520 7468 6520 7369 6d69  termine the simi
-000090e0: 6c61 7269 7479 2062 6574 7765 656e 2074  larity between t
-000090f0: 776f 2072 6563 6f72 6473 2222 220a 0a20  wo records""".. 
-00009100: 2020 2020 2020 2064 6574 6169 6c73 203d         details =
-00009110: 2052 6563 6f72 642e 6765 745f 7369 6d69   Record.get_simi
-00009120: 6c61 7269 7479 5f64 6574 6169 6c65 6428  larity_detailed(
-00009130: 7265 636f 7264 5f61 3d64 665f 612c 2072  record_a=df_a, r
-00009140: 6563 6f72 645f 623d 6466 5f62 290a 2020  ecord_b=df_b).  
-00009150: 2020 2020 2020 7265 7475 726e 2064 6574        return det
-00009160: 6169 6c73 5b22 7363 6f72 6522 5d0a 0a20  ails["score"].. 
-00009170: 2020 2040 636c 6173 736d 6574 686f 640a     @classmethod.
-00009180: 2020 2020 6465 6620 6765 745f 7369 6d69      def get_simi
-00009190: 6c61 7269 7479 5f64 6574 6169 6c65 6428  larity_detailed(
-000091a0: 636c 732c 202a 2c20 7265 636f 7264 5f61  cls, *, record_a
-000091b0: 3a20 6469 6374 2c20 7265 636f 7264 5f62  : dict, record_b
-000091c0: 3a20 6469 6374 2920 2d3e 2064 6963 743a  : dict) -> dict:
-000091d0: 0a20 2020 2020 2020 2022 2222 4465 7465  .        """Dete
-000091e0: 726d 696e 6520 7468 6520 6465 7461 696c  rmine the detail
-000091f0: 6564 2073 696d 696c 6172 6974 6965 7320  ed similarities 
-00009200: 6265 7477 6565 6e20 7265 636f 7264 7322  between records"
-00009210: 2222 0a20 2020 2020 2020 2074 7279 3a0a  "".        try:.
-00009220: 2020 2020 2020 2020 2020 2020 6175 7468              auth
-00009230: 6f72 5f73 696d 696c 6172 6974 7920 3d20  or_similarity = 
-00009240: 6675 7a7a 2e72 6174 696f 2872 6563 6f72  fuzz.ratio(recor
-00009250: 645f 615b 2261 7574 686f 7222 5d2c 2072  d_a["author"], r
-00009260: 6563 6f72 645f 625b 2261 7574 686f 7222  ecord_b["author"
-00009270: 5d29 202f 2031 3030 0a0a 2020 2020 2020  ]) / 100..      
-00009280: 2020 2020 2020 7469 746c 655f 7369 6d69        title_simi
-00009290: 6c61 7269 7479 203d 2028 0a20 2020 2020  larity = (.     
-000092a0: 2020 2020 2020 2020 2020 2066 757a 7a2e             fuzz.
-000092b0: 7261 7469 6f28 0a20 2020 2020 2020 2020  ratio(.         
-000092c0: 2020 2020 2020 2020 2020 2072 6563 6f72             recor
-000092d0: 645f 615b 2274 6974 6c65 225d 2e6c 6f77  d_a["title"].low
-000092e0: 6572 2829 2e72 6570 6c61 6365 2822 3a22  er().replace(":"
-000092f0: 2c20 2222 292e 7265 706c 6163 6528 222d  , "").replace("-
-00009300: 222c 2022 2229 2c0a 2020 2020 2020 2020  ", ""),.        
-00009310: 2020 2020 2020 2020 2020 2020 7265 636f              reco
-00009320: 7264 5f62 5b22 7469 746c 6522 5d2e 6c6f  rd_b["title"].lo
-00009330: 7765 7228 292e 7265 706c 6163 6528 223a  wer().replace(":
-00009340: 222c 2022 2229 2e72 6570 6c61 6365 2822  ", "").replace("
-00009350: 2d22 2c20 2222 292c 0a20 2020 2020 2020  -", ""),.       
-00009360: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
-00009370: 2020 2020 2020 2020 2020 202f 2031 3030             / 100
-00009380: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
-00009390: 2020 2020 2020 2020 2020 2020 2320 7061              # pa
-000093a0: 7274 6961 6c20 7261 7469 6f20 2863 6174  rtial ratio (cat
-000093b0: 6368 696e 6720 3230 3130 2d31 3020 6f72  ching 2010-10 or
-000093c0: 2032 3030 312d 3230 3032 290a 2020 2020   2001-2002).    
-000093d0: 2020 2020 2020 2020 7965 6172 5f73 696d          year_sim
-000093e0: 696c 6172 6974 7920 3d20 280a 2020 2020  ilarity = (.    
-000093f0: 2020 2020 2020 2020 2020 2020 6675 7a7a              fuzz
-00009400: 2e72 6174 696f 2873 7472 2872 6563 6f72  .ratio(str(recor
-00009410: 645f 615b 2279 6561 7222 5d29 2c20 7374  d_a["year"]), st
-00009420: 7228 7265 636f 7264 5f62 5b22 7965 6172  r(record_b["year
-00009430: 225d 2929 202f 2031 3030 0a20 2020 2020  "])) / 100.     
-00009440: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
-00009450: 2020 2020 2020 6f75 746c 6574 5f73 696d        outlet_sim
-00009460: 696c 6172 6974 7920 3d20 302e 300a 2020  ilarity = 0.0.  
-00009470: 2020 2020 2020 2020 2020 6966 2072 6563            if rec
-00009480: 6f72 645f 625b 2263 6f6e 7461 696e 6572  ord_b["container
-00009490: 5f74 6974 6c65 225d 2061 6e64 2072 6563  _title"] and rec
-000094a0: 6f72 645f 615b 2263 6f6e 7461 696e 6572  ord_a["container
-000094b0: 5f74 6974 6c65 225d 3a0a 2020 2020 2020  _title"]:.      
-000094c0: 2020 2020 2020 2020 2020 6f75 746c 6574            outlet
-000094d0: 5f73 696d 696c 6172 6974 7920 3d20 280a  _similarity = (.
-000094e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000094f0: 2020 2020 6675 7a7a 2e72 6174 696f 2872      fuzz.ratio(r
-00009500: 6563 6f72 645f 615b 2263 6f6e 7461 696e  ecord_a["contain
-00009510: 6572 5f74 6974 6c65 225d 2c20 7265 636f  er_title"], reco
-00009520: 7264 5f62 5b22 636f 6e74 6169 6e65 725f  rd_b["container_
-00009530: 7469 746c 6522 5d29 0a20 2020 2020 2020  title"]).       
-00009540: 2020 2020 2020 2020 2020 2020 202f 2031               / 1
-00009550: 3030 0a20 2020 2020 2020 2020 2020 2020  00.             
-00009560: 2020 2029 0a0a 2020 2020 2020 2020 2020     )..          
-00009570: 2020 6966 2073 7472 2872 6563 6f72 645f    if str(record_
-00009580: 615b 226a 6f75 726e 616c 225d 2920 213d  a["journal"]) !=
-00009590: 2022 6e61 6e22 3a0a 2020 2020 2020 2020   "nan":.        
-000095a0: 2020 2020 2020 2020 2320 4e6f 7465 3a20          # Note: 
-000095b0: 666f 7220 6a6f 7572 6e61 6c73 2070 6170  for journals pap
-000095c0: 6572 732c 2077 6520 6578 7065 6374 206d  ers, we expect m
-000095d0: 6f72 6520 6465 7461 696c 730a 2020 2020  ore details.    
-000095e0: 2020 2020 2020 2020 2020 2020 766f 6c75              volu
-000095f0: 6d65 5f73 696d 696c 6172 6974 7920 3d20  me_similarity = 
-00009600: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00009610: 2020 2020 2020 3120 6966 2028 7265 636f        1 if (reco
-00009620: 7264 5f61 5b22 766f 6c75 6d65 225d 203d  rd_a["volume"] =
-00009630: 3d20 7265 636f 7264 5f62 5b22 766f 6c75  = record_b["volu
-00009640: 6d65 225d 2920 656c 7365 2030 0a20 2020  me"]) else 0.   
-00009650: 2020 2020 2020 2020 2020 2020 2029 0a0a               )..
-00009660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009670: 6e75 6d62 6572 5f73 696d 696c 6172 6974  number_similarit
-00009680: 7920 3d20 280a 2020 2020 2020 2020 2020  y = (.          
-00009690: 2020 2020 2020 2020 2020 3120 6966 2028            1 if (
-000096a0: 7265 636f 7264 5f61 5b22 6e75 6d62 6572  record_a["number
-000096b0: 225d 203d 3d20 7265 636f 7264 5f62 5b22  "] == record_b["
-000096c0: 6e75 6d62 6572 225d 2920 656c 7365 2030  number"]) else 0
-000096d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000096e0: 2029 0a0a 2020 2020 2020 2020 2020 2020   )..            
-000096f0: 2020 2020 2320 7061 6765 2073 696d 696c      # page simil
-00009700: 6172 6974 7920 6973 206e 6f74 2063 6f6e  arity is not con
-00009710: 7369 6465 7265 6420 6174 2074 6865 206d  sidered at the m
-00009720: 6f6d 656e 742e 0a20 2020 2020 2020 2020  oment..         
-00009730: 2020 2020 2020 2023 0a20 2020 2020 2020         #.       
-00009740: 2020 2020 2020 2020 2023 2073 6f6d 6574           # somet
-00009750: 696d 6573 2c20 6f6e 6c79 2074 6865 2066  imes, only the f
-00009760: 6972 7374 2070 6167 6520 6973 2070 726f  irst page is pro
-00009770: 7669 6465 642e 0a20 2020 2020 2020 2020  vided..         
-00009780: 2020 2020 2020 2023 2069 6620 7374 7228         # if str(
-00009790: 7265 636f 7264 5f61 5b22 7061 6765 7322  record_a["pages"
-000097a0: 5d29 203d 3d20 226e 616e 2220 6f72 2073  ]) == "nan" or s
-000097b0: 7472 2872 6563 6f72 645f 625b 2270 6167  tr(record_b["pag
-000097c0: 6573 225d 2920 3d3d 2022 6e61 6e22 3a0a  es"]) == "nan":.
-000097d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000097e0: 2320 2020 2020 7061 6765 735f 7369 6d69  #     pages_simi
-000097f0: 6c61 7269 7479 203d 2031 0a20 2020 2020  larity = 1.     
-00009800: 2020 2020 2020 2020 2020 2023 2065 6c73             # els
-00009810: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00009820: 2020 2023 2020 2020 2069 6620 7265 636f     #     if reco
-00009830: 7264 5f61 5b22 7061 6765 7322 5d20 3d3d  rd_a["pages"] ==
-00009840: 2072 6563 6f72 645f 625b 2270 6167 6573   record_b["pages
-00009850: 225d 3a0a 2020 2020 2020 2020 2020 2020  "]:.            
-00009860: 2020 2020 2320 2020 2020 2020 2020 7061      #         pa
-00009870: 6765 735f 7369 6d69 6c61 7269 7479 203d  ges_similarity =
-00009880: 2031 0a20 2020 2020 2020 2020 2020 2020   1.             
-00009890: 2020 2023 2020 2020 2065 6c73 653a 0a20     #     else:. 
-000098a0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-000098b0: 2020 2020 2020 2020 2069 6620 7265 636f           if reco
-000098c0: 7264 5f61 5b22 7061 6765 7322 5d2e 7370  rd_a["pages"].sp
-000098d0: 6c69 7428 222d 2229 5b30 5d20 3d3d 2072  lit("-")[0] == r
-000098e0: 6563 6f72 645f 625b 2270 6167 6573 225d  ecord_b["pages"]
-000098f0: 2e73 706c 6974 2822 2d22 295b 305d 3a0a  .split("-")[0]:.
-00009900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009910: 2320 2020 2020 2020 2020 2020 2020 7061  #             pa
-00009920: 6765 735f 7369 6d69 6c61 7269 7479 203d  ges_similarity =
-00009930: 2031 0a20 2020 2020 2020 2020 2020 2020   1.             
-00009940: 2020 2023 2020 2020 2020 2020 2065 6c73     #         els
-00009950: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00009960: 2020 2023 2020 2020 2020 2020 2020 2020     #            
-00009970: 7061 6765 735f 7369 6d69 6c61 7269 7479  pages_similarity
-00009980: 203d 2030 0a0a 2020 2020 2020 2020 2020   = 0..          
-00009990: 2020 2020 2020 2320 5075 7420 6d6f 7265        # Put more
-000099a0: 2077 6569 6768 7420 6f6e 206f 7468 6572   weight on other
-000099b0: 2066 6965 6c64 7320 6966 2074 6865 2074   fields if the t
-000099c0: 6974 6c65 2069 7320 7665 7279 2063 6f6d  itle is very com
-000099d0: 6d6f 6e0a 2020 2020 2020 2020 2020 2020  mon.            
-000099e0: 2020 2020 2320 6965 2e2c 206e 6f6e 2d64      # ie., non-d
-000099f0: 6973 7469 6e63 7469 7665 0a20 2020 2020  istinctive.     
-00009a00: 2020 2020 2020 2020 2020 2023 2054 6865             # The
-00009a10: 206c 6973 7420 6973 2062 6173 6564 206f   list is based o
-00009a20: 6e20 6120 6c61 7267 6520 6578 706f 7274  n a large export
-00009a30: 206f 6620 6469 7374 696e 6374 2070 6170   of distinct pap
-00009a40: 6572 732c 2074 6162 756c 6174 6564 0a20  ers, tabulated. 
-00009a50: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00009a60: 2061 6363 6f72 6469 6e67 2074 6f20 7469   according to ti
-00009a70: 746c 6573 2061 6e64 2073 6f72 7465 6420  tles and sorted 
-00009a80: 6279 2066 7265 7175 656e 6379 0a20 2020  by frequency.   
-00009a90: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00009aa0: 5b72 6563 6f72 645f 615b 2274 6974 6c65  [record_a["title
-00009ab0: 225d 2c20 7265 636f 7264 5f62 5b22 7469  "], record_b["ti
-00009ac0: 746c 6522 5d5d 2069 6e20 5b0a 2020 2020  tle"]] in [.    
+00004770: 6966 2072 6570 6c61 6365 5f73 6f75 7263  if replace_sourc
+00004780: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00004790: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+000047a0: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
+000047b0: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
+000047c0: 6365 225d 5b22 766f 6c75 6d65 225d 5b0a  ce"]["volume"][.
+000047d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000047e0: 2020 2020 2020 2020 2020 2020 2273 6f75              "sou
+000047f0: 7263 6522 0a20 2020 2020 2020 2020 2020  rce".           
+00004800: 2020 2020 2020 2020 2020 2020 205d 203d               ] =
+00004810: 2073 6f75 7263 650a 2020 2020 2020 2020   source.        
+00004820: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00004830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004840: 2020 7365 6c66 2e64 6174 615b 2263 6f6c    self.data["col
+00004850: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
+00004860: 726f 7665 6e61 6e63 6522 5d5b 2276 6f6c  rovenance"]["vol
+00004870: 756d 6522 5d20 3d20 7b0a 2020 2020 2020  ume"] = {.      
+00004880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004890: 2020 2273 6f75 7263 6522 3a20 736f 7572    "source": sour
+000048a0: 6365 2c0a 2020 2020 2020 2020 2020 2020  ce,.            
+000048b0: 2020 2020 2020 2020 2020 2020 226e 6f74              "not
+000048c0: 6522 3a20 226e 6f74 2d6d 6973 7369 6e67  e": "not-missing
+000048d0: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+000048e0: 2020 2020 2020 207d 0a0a 2020 2020 2020         }..      
+000048f0: 2020 2020 2020 6966 2022 6e75 6d62 6572        if "number
+00004900: 2220 6e6f 7420 696e 2073 656c 662e 6461  " not in self.da
+00004910: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
+00004920: 2020 2020 6966 2022 6e75 6d62 6572 2220      if "number" 
+00004930: 696e 2073 656c 662e 6461 7461 5b22 636f  in self.data["co
+00004940: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
+00004950: 7072 6f76 656e 616e 6365 225d 3a0a 2020  provenance"]:.  
+00004960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004970: 2020 7365 6c66 2e64 6174 615b 2263 6f6c    self.data["col
+00004980: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
+00004990: 726f 7665 6e61 6e63 6522 5d5b 226e 756d  rovenance"]["num
+000049a0: 6265 7222 5d5b 0a20 2020 2020 2020 2020  ber"][.         
+000049b0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+000049c0: 6e6f 7465 220a 2020 2020 2020 2020 2020  note".          
+000049d0: 2020 2020 2020 2020 2020 5d20 3d20 226e            ] = "n
+000049e0: 6f74 2d6d 6973 7369 6e67 220a 2020 2020  ot-missing".    
+000049f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004a00: 6966 2072 6570 6c61 6365 5f73 6f75 7263  if replace_sourc
+00004a10: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00004a20: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00004a30: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
+00004a40: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
+00004a50: 6365 225d 5b22 6e75 6d62 6572 225d 5b0a  ce"]["number"][.
+00004a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004a70: 2020 2020 2020 2020 2020 2020 2273 6f75              "sou
+00004a80: 7263 6522 0a20 2020 2020 2020 2020 2020  rce".           
+00004a90: 2020 2020 2020 2020 2020 2020 205d 203d               ] =
+00004aa0: 2073 6f75 7263 650a 2020 2020 2020 2020   source.        
+00004ab0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00004ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004ad0: 2020 7365 6c66 2e64 6174 615b 2263 6f6c    self.data["col
+00004ae0: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
+00004af0: 726f 7665 6e61 6e63 6522 5d5b 226e 756d  rovenance"]["num
+00004b00: 6265 7222 5d20 3d20 7b0a 2020 2020 2020  ber"] = {.      
+00004b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004b20: 2020 2273 6f75 7263 6522 3a20 736f 7572    "source": sour
+00004b30: 6365 2c0a 2020 2020 2020 2020 2020 2020  ce,.            
+00004b40: 2020 2020 2020 2020 2020 2020 226e 6f74              "not
+00004b50: 6522 3a20 226e 6f74 2d6d 6973 7369 6e67  e": "not-missing
+00004b60: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+00004b70: 2020 2020 2020 207d 0a0a 2020 2020 6465         }..    de
+00004b80: 6620 7365 745f 6d61 7374 6572 6461 7461  f set_masterdata
+00004b90: 5f63 6f6e 7369 7374 656e 7428 7365 6c66  _consistent(self
+00004ba0: 2920 2d3e 204e 6f6e 653a 0a20 2020 2020  ) -> None:.     
+00004bb0: 2020 2022 2222 5365 7420 7468 6520 6d61     """Set the ma
+00004bc0: 7374 6572 6461 7461 2074 6f20 636f 6e73  sterdata to cons
+00004bd0: 6973 7465 6e74 2222 220a 2020 2020 2020  istent""".      
+00004be0: 2020 6966 2022 636f 6c72 6576 5f6d 6173    if "colrev_mas
+00004bf0: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
+00004c00: 6365 2220 6e6f 7420 696e 2073 656c 662e  ce" not in self.
+00004c10: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
+00004c20: 2020 7365 6c66 2e64 6174 615b 2263 6f6c    self.data["col
+00004c30: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
+00004c40: 726f 7665 6e61 6e63 6522 5d20 3d20 7b7d  rovenance"] = {}
+00004c50: 0a20 2020 2020 2020 206d 645f 705f 6469  .        md_p_di
+00004c60: 6374 203d 2073 656c 662e 6461 7461 5b22  ct = self.data["
+00004c70: 636f 6c72 6576 5f6d 6173 7465 7264 6174  colrev_masterdat
+00004c80: 615f 7072 6f76 656e 616e 6365 225d 0a0a  a_provenance"]..
+00004c90: 2020 2020 2020 2020 666f 7220 6964 656e          for iden
+00004ca0: 7469 6679 696e 675f 6669 656c 645f 6b65  tifying_field_ke
+00004cb0: 7920 696e 2073 656c 662e 6964 656e 7469  y in self.identi
+00004cc0: 6679 696e 675f 6669 656c 645f 6b65 7973  fying_field_keys
+00004cd0: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+00004ce0: 2069 6465 6e74 6966 7969 6e67 5f66 6965   identifying_fie
+00004cf0: 6c64 5f6b 6579 2069 6e20 6d64 5f70 5f64  ld_key in md_p_d
+00004d00: 6963 743a 0a20 2020 2020 2020 2020 2020  ict:.           
+00004d10: 2020 2020 206e 6f74 6520 3d20 6d64 5f70       note = md_p
+00004d20: 5f64 6963 745b 6964 656e 7469 6679 696e  _dict[identifyin
+00004d30: 675f 6669 656c 645f 6b65 795d 5b22 6e6f  g_field_key]["no
+00004d40: 7465 225d 0a20 2020 2020 2020 2020 2020  te"].           
+00004d50: 2020 2020 2069 6620 2269 6e63 6f6e 7369       if "inconsi
+00004d60: 7374 656e 742d 7769 7468 2d65 6e74 7279  stent-with-entry
+00004d70: 7479 7065 2220 696e 206e 6f74 653a 0a20  type" in note:. 
+00004d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004d90: 2020 206d 645f 705f 6469 6374 5b69 6465     md_p_dict[ide
+00004da0: 6e74 6966 7969 6e67 5f66 6965 6c64 5f6b  ntifying_field_k
+00004db0: 6579 5d5b 226e 6f74 6522 5d20 3d20 6e6f  ey]["note"] = no
+00004dc0: 7465 2e72 6570 6c61 6365 280a 2020 2020  te.replace(.    
+00004dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004de0: 2020 2020 2269 6e63 6f6e 7369 7374 656e      "inconsisten
+00004df0: 742d 7769 7468 2d65 6e74 7279 7479 7065  t-with-entrytype
+00004e00: 222c 2022 220a 2020 2020 2020 2020 2020  ", "".          
+00004e10: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
+00004e20: 2064 6566 2072 6573 6574 5f70 6466 5f70   def reset_pdf_p
+00004e30: 726f 7665 6e61 6e63 655f 6e6f 7465 7328  rovenance_notes(
+00004e40: 7365 6c66 2920 2d3e 204e 6f6e 653a 0a20  self) -> None:. 
+00004e50: 2020 2020 2020 2022 2222 5265 7365 7420         """Reset 
+00004e60: 7468 6520 5044 4620 2866 696c 6529 2070  the PDF (file) p
+00004e70: 726f 7665 6e61 6e63 6520 6e6f 7465 7322  rovenance notes"
+00004e80: 2222 0a20 2020 2020 2020 2069 6620 2263  "".        if "c
+00004e90: 6f6c 7265 765f 6461 7461 5f70 726f 7665  olrev_data_prove
+00004ea0: 6e61 6e63 6522 206e 6f74 2069 6e20 7365  nance" not in se
+00004eb0: 6c66 2e64 6174 613a 0a20 2020 2020 2020  lf.data:.       
+00004ec0: 2020 2020 2073 656c 662e 6164 645f 6461       self.add_da
+00004ed0: 7461 5f70 726f 7665 6e61 6e63 655f 6e6f  ta_provenance_no
+00004ee0: 7465 286b 6579 3d22 6669 6c65 222c 206e  te(key="file", n
+00004ef0: 6f74 653d 2222 290a 2020 2020 2020 2020  ote="").        
+00004f00: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00004f10: 2020 6966 2022 6669 6c65 2220 696e 2073    if "file" in s
+00004f20: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
+00004f30: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
+00004f40: 225d 3a0a 2020 2020 2020 2020 2020 2020  "]:.            
+00004f50: 2020 2020 7365 6c66 2e64 6174 615b 2263      self.data["c
+00004f60: 6f6c 7265 765f 6461 7461 5f70 726f 7665  olrev_data_prove
+00004f70: 6e61 6e63 6522 5d5b 2266 696c 6522 5d5b  nance"]["file"][
+00004f80: 226e 6f74 6522 5d20 3d20 2222 0a20 2020  "note"] = "".   
+00004f90: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00004fa0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00004fb0: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
+00004fc0: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
+00004fd0: 225d 5b22 6669 6c65 225d 203d 207b 0a20  "]["file"] = {. 
+00004fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004ff0: 2020 2022 736f 7572 6365 223a 2022 4e41     "source": "NA
+00005000: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+00005010: 2020 2020 2020 2022 6e6f 7465 223a 2022         "note": "
+00005020: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+00005030: 2020 207d 0a0a 2020 2020 6465 6620 5f5f     }..    def __
+00005040: 6d65 7267 655f 6f72 6967 696e 7328 7365  merge_origins(se
+00005050: 6c66 2c20 2a2c 206d 6572 6769 6e67 5f72  lf, *, merging_r
+00005060: 6563 6f72 643a 2052 6563 6f72 6429 202d  ecord: Record) -
+00005070: 3e20 4e6f 6e65 3a0a 2020 2020 2020 2020  > None:.        
+00005080: 2222 224d 6572 6765 2074 6865 206f 7269  """Merge the ori
+00005090: 6769 6e73 2077 6974 6820 7468 6f73 6520  gins with those 
+000050a0: 6f66 2074 6865 206d 6572 6769 6e67 5f72  of the merging_r
+000050b0: 6563 6f72 6422 2222 0a0a 2020 2020 2020  ecord"""..      
+000050c0: 2020 6966 2022 636f 6c72 6576 5f6f 7269    if "colrev_ori
+000050d0: 6769 6e22 2069 6e20 6d65 7267 696e 675f  gin" in merging_
+000050e0: 7265 636f 7264 2e64 6174 613a 0a20 2020  record.data:.   
+000050f0: 2020 2020 2020 2020 206f 7269 6769 6e73           origins
+00005100: 203d 2073 656c 662e 6461 7461 5b22 636f   = self.data["co
+00005110: 6c72 6576 5f6f 7269 6769 6e22 5d20 2b20  lrev_origin"] + 
+00005120: 6d65 7267 696e 675f 7265 636f 7264 2e64  merging_record.d
+00005130: 6174 615b 2263 6f6c 7265 765f 6f72 6967  ata["colrev_orig
+00005140: 696e 225d 0a20 2020 2020 2020 2020 2020  in"].           
+00005150: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
+00005160: 6576 5f6f 7269 6769 6e22 5d20 3d20 736f  ev_origin"] = so
+00005170: 7274 6564 286c 6973 7428 7365 7428 6f72  rted(list(set(or
+00005180: 6967 696e 7329 2929 0a0a 2020 2020 6465  igins)))..    de
+00005190: 6620 5f5f 6d65 7267 655f 7374 6174 7573  f __merge_status
+000051a0: 2873 656c 662c 202a 2c20 6d65 7267 696e  (self, *, mergin
+000051b0: 675f 7265 636f 7264 3a20 5265 636f 7264  g_record: Record
+000051c0: 2920 2d3e 204e 6f6e 653a 0a20 2020 2020  ) -> None:.     
+000051d0: 2020 2022 2222 4d65 7267 6520 7468 6520     """Merge the 
+000051e0: 7374 6174 7573 2077 6974 6820 7468 6520  status with the 
+000051f0: 6d65 7267 696e 675f 7265 636f 7264 2222  merging_record""
+00005200: 220a 0a20 2020 2020 2020 2069 6620 2263  "..        if "c
+00005210: 6f6c 7265 765f 7374 6174 7573 2220 696e  olrev_status" in
+00005220: 206d 6572 6769 6e67 5f72 6563 6f72 642e   merging_record.
+00005230: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
+00005240: 2020 2320 5365 7420 626f 7468 2073 7461    # Set both sta
+00005250: 7475 7320 746f 2074 6865 206c 6174 7465  tus to the latte
+00005260: 7220 696e 2074 6865 2073 7461 7465 206d  r in the state m
+00005270: 6f64 656c 0a20 2020 2020 2020 2020 2020  odel.           
+00005280: 2069 6620 7365 6c66 2e64 6174 615b 2263   if self.data["c
+00005290: 6f6c 7265 765f 7374 6174 7573 225d 203c  olrev_status"] <
+000052a0: 206d 6572 6769 6e67 5f72 6563 6f72 642e   merging_record.
+000052b0: 6461 7461 5b22 636f 6c72 6576 5f73 7461  data["colrev_sta
+000052c0: 7475 7322 5d3a 0a20 2020 2020 2020 2020  tus"]:.         
+000052d0: 2020 2020 2020 2073 656c 662e 7365 745f         self.set_
+000052e0: 7374 6174 7573 2874 6172 6765 745f 7374  status(target_st
+000052f0: 6174 653d 6d65 7267 696e 675f 7265 636f  ate=merging_reco
+00005300: 7264 2e64 6174 615b 2263 6f6c 7265 765f  rd.data["colrev_
+00005310: 7374 6174 7573 225d 290a 2020 2020 2020  status"]).      
+00005320: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00005330: 2020 2020 2020 2020 2020 2020 6d65 7267              merg
+00005340: 696e 675f 7265 636f 7264 2e73 6574 5f73  ing_record.set_s
+00005350: 7461 7475 7328 7461 7267 6574 5f73 7461  tatus(target_sta
+00005360: 7465 3d73 656c 662e 6461 7461 5b22 636f  te=self.data["co
+00005370: 6c72 6576 5f73 7461 7475 7322 5d29 0a0a  lrev_status"])..
+00005380: 2020 2020 6465 6620 5f5f 6765 745f 6d65      def __get_me
+00005390: 7267 696e 675f 7661 6c28 7365 6c66 2c20  rging_val(self, 
+000053a0: 2a2c 206d 6572 6769 6e67 5f72 6563 6f72  *, merging_recor
+000053b0: 643a 2052 6563 6f72 642c 206b 6579 3a20  d: Record, key: 
+000053c0: 7374 7229 202d 3e20 7374 723a 0a20 2020  str) -> str:.   
+000053d0: 2020 2020 2076 616c 203d 206d 6572 6769       val = mergi
+000053e0: 6e67 5f72 6563 6f72 642e 6461 7461 2e67  ng_record.data.g
+000053f0: 6574 286b 6579 2c20 2222 290a 0a20 2020  et(key, "")..   
+00005400: 2020 2020 2069 6620 7661 6c20 3d3d 2022       if val == "
+00005410: 223a 0a20 2020 2020 2020 2020 2020 2072  ":.            r
+00005420: 6574 7572 6e20 2222 0a20 2020 2020 2020  eturn "".       
+00005430: 2069 6620 6e6f 7420 7661 6c3a 0a20 2020   if not val:.   
+00005440: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00005450: 2222 0a0a 2020 2020 2020 2020 2320 646f  ""..        # do
+00005460: 206e 6f74 206f 7665 7272 6964 6520 7072   not override pr
+00005470: 6f76 656e 616e 6365 2c20 4944 2c20 2e2e  ovenance, ID, ..
+00005480: 2e20 6669 656c 6473 0a20 2020 2020 2020  . fields.       
+00005490: 2069 6620 6b65 7920 696e 205b 0a20 2020   if key in [.   
+000054a0: 2020 2020 2020 2020 2022 4944 222c 0a20           "ID",. 
+000054b0: 2020 2020 2020 2020 2020 2022 636f 6c72             "colr
+000054c0: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
+000054d0: 6f76 656e 616e 6365 222c 0a20 2020 2020  ovenance",.     
+000054e0: 2020 2020 2020 2022 636f 6c72 6576 5f64         "colrev_d
+000054f0: 6174 615f 7072 6f76 656e 616e 6365 222c  ata_provenance",
+00005500: 0a20 2020 2020 2020 2020 2020 2022 636f  .            "co
+00005510: 6c72 6576 5f69 6422 2c0a 2020 2020 2020  lrev_id",.      
+00005520: 2020 2020 2020 2263 6f6c 7265 765f 7374        "colrev_st
+00005530: 6174 7573 222c 0a20 2020 2020 2020 2020  atus",.         
+00005540: 2020 2022 636f 6c72 6576 5f6f 7269 6769     "colrev_origi
+00005550: 6e22 2c0a 2020 2020 2020 2020 2020 2020  n",.            
+00005560: 224d 4f56 4544 5f44 5550 455f 4944 222c  "MOVED_DUPE_ID",
+00005570: 0a20 2020 2020 2020 205d 3a0a 2020 2020  .        ]:.    
+00005580: 2020 2020 2020 2020 7265 7475 726e 2022          return "
+00005590: 220a 0a20 2020 2020 2020 2072 6574 7572  "..        retur
+000055a0: 6e20 7661 6c0a 0a20 2020 2064 6566 205f  n val..    def _
+000055b0: 5f70 7265 7665 6e74 5f69 6e76 616c 6964  _prevent_invalid
+000055c0: 5f6d 6572 6765 7328 7365 6c66 2c20 2a2c  _merges(self, *,
+000055d0: 206d 6572 6769 6e67 5f72 6563 6f72 643a   merging_record:
+000055e0: 2052 6563 6f72 6429 202d 3e20 4e6f 6e65   Record) -> None
+000055f0: 3a0a 2020 2020 2020 2020 2222 2250 7265  :.        """Pre
+00005600: 7665 6e74 7320 696e 7661 6c69 6420 6d65  vents invalid me
+00005610: 7267 6573 206c 696b 6520 2e2e 2e20 7061  rges like ... pa
+00005620: 7274 2031 202f 202e 2e2e 2070 6172 7420  rt 1 / ... part 
+00005630: 3222 2222 0a0a 2020 2020 2020 2020 6c6f  2"""..        lo
+00005640: 7765 725f 7469 746c 655f 6120 3d20 7365  wer_title_a = se
+00005650: 6c66 2e64 6174 612e 6765 7428 2274 6974  lf.data.get("tit
+00005660: 6c65 222c 2022 2229 2e6c 6f77 6572 2829  le", "").lower()
+00005670: 0a20 2020 2020 2020 206c 6f77 6572 5f74  .        lower_t
+00005680: 6974 6c65 5f62 203d 206d 6572 6769 6e67  itle_b = merging
+00005690: 5f72 6563 6f72 642e 6461 7461 2e67 6574  _record.data.get
+000056a0: 2822 7469 746c 6522 2c20 2222 292e 6c6f  ("title", "").lo
+000056b0: 7765 7228 290a 0a20 2020 2020 2020 2070  wer()..        p
+000056c0: 6172 745f 6d61 7463 685f 6120 3d20 7265  art_match_a = re
+000056d0: 2e66 696e 6461 6c6c 2872 2270 6172 7420  .findall(r"part 
+000056e0: 5b41 2d5a 612d 7a30 2d39 5d2b 2422 2c20  [A-Za-z0-9]+$", 
+000056f0: 6c6f 7765 725f 7469 746c 655f 6129 0a20  lower_title_a). 
+00005700: 2020 2020 2020 2070 6172 745f 6d61 7463         part_matc
+00005710: 685f 6220 3d20 7265 2e66 696e 6461 6c6c  h_b = re.findall
+00005720: 2872 2270 6172 7420 5b41 2d5a 612d 7a30  (r"part [A-Za-z0
+00005730: 2d39 5d2b 2422 2c20 6c6f 7765 725f 7469  -9]+$", lower_ti
+00005740: 746c 655f 6229 0a0a 2020 2020 2020 2020  tle_b)..        
+00005750: 6966 2070 6172 745f 6d61 7463 685f 6120  if part_match_a 
+00005760: 213d 2070 6172 745f 6d61 7463 685f 623a  != part_match_b:
+00005770: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+00005780: 7365 2063 6f6c 7265 765f 6578 6365 7074  se colrev_except
+00005790: 696f 6e73 2e49 6e76 616c 6964 4d65 7267  ions.InvalidMerg
+000057a0: 6528 7265 636f 7264 5f61 3d73 656c 662c  e(record_a=self,
+000057b0: 2072 6563 6f72 645f 623d 6d65 7267 696e   record_b=mergin
+000057c0: 675f 7265 636f 7264 290a 0a20 2020 2020  g_record)..     
+000057d0: 2020 2074 6572 6d73 5f72 6571 7569 7265     terms_require
+000057e0: 645f 746f 5f6d 6174 6368 203d 205b 0a20  d_to_match = [. 
+000057f0: 2020 2020 2020 2020 2020 2022 6572 7261             "erra
+00005800: 7475 6d22 2c0a 2020 2020 2020 2020 2020  tum",.          
+00005810: 2020 2263 6f72 7265 6374 696f 6e22 2c0a    "correction",.
+00005820: 2020 2020 2020 2020 2020 2020 2263 6f72              "cor
+00005830: 7269 6765 6e64 756d 222c 0a20 2020 2020  rigendum",.     
+00005840: 2020 2020 2020 2022 636f 6d6d 656e 7422         "comment"
+00005850: 2c0a 2020 2020 2020 2020 2020 2020 2263  ,.            "c
+00005860: 6f6d 6d65 6e74 6172 7922 2c0a 2020 2020  ommentary",.    
+00005870: 2020 2020 2020 2020 2272 6573 706f 6e73          "respons
+00005880: 6522 2c0a 2020 2020 2020 2020 5d0a 2020  e",.        ].  
+00005890: 2020 2020 2020 7465 726d 735f 696e 5f61        terms_in_a
+000058a0: 203d 205b 7420 666f 7220 7420 696e 2074   = [t for t in t
+000058b0: 6572 6d73 5f72 6571 7569 7265 645f 746f  erms_required_to
+000058c0: 5f6d 6174 6368 2069 6620 7420 696e 206c  _match if t in l
+000058d0: 6f77 6572 5f74 6974 6c65 5f61 5d0a 2020  ower_title_a].  
+000058e0: 2020 2020 2020 7465 726d 735f 696e 5f62        terms_in_b
+000058f0: 203d 205b 7420 666f 7220 7420 696e 2074   = [t for t in t
+00005900: 6572 6d73 5f72 6571 7569 7265 645f 746f  erms_required_to
+00005910: 5f6d 6174 6368 2069 6620 7420 696e 206c  _match if t in l
+00005920: 6f77 6572 5f74 6974 6c65 5f62 5d0a 0a20  ower_title_b].. 
+00005930: 2020 2020 2020 2069 6620 7465 726d 735f         if terms_
+00005940: 696e 5f61 2021 3d20 7465 726d 735f 696e  in_a != terms_in
+00005950: 5f62 3a0a 2020 2020 2020 2020 2020 2020  _b:.            
+00005960: 7261 6973 6520 636f 6c72 6576 5f65 7863  raise colrev_exc
+00005970: 6570 7469 6f6e 732e 496e 7661 6c69 644d  eptions.InvalidM
+00005980: 6572 6765 2872 6563 6f72 645f 613d 7365  erge(record_a=se
+00005990: 6c66 2c20 7265 636f 7264 5f62 3d6d 6572  lf, record_b=mer
+000059a0: 6769 6e67 5f72 6563 6f72 6429 0a0a 2020  ging_record)..  
+000059b0: 2020 6465 6620 6d65 7267 6528 0a20 2020    def merge(.   
+000059c0: 2020 2020 2073 656c 662c 0a20 2020 2020       self,.     
+000059d0: 2020 202a 2c0a 2020 2020 2020 2020 6d65     *,.        me
+000059e0: 7267 696e 675f 7265 636f 7264 3a20 5265  rging_record: Re
+000059f0: 636f 7264 2c0a 2020 2020 2020 2020 6465  cord,.        de
+00005a00: 6661 756c 745f 736f 7572 6365 3a20 7374  fault_source: st
+00005a10: 722c 0a20 2020 2020 2020 2070 7265 6665  r,.        prefe
+00005a20: 7272 6564 5f6d 6173 7465 7264 6174 615f  rred_masterdata_
+00005a30: 736f 7572 6365 5f70 7265 6669 7865 733a  source_prefixes:
+00005a40: 204f 7074 696f 6e61 6c5b 6c69 7374 5d20   Optional[list] 
+00005a50: 3d20 4e6f 6e65 2c0a 2020 2020 2920 2d3e  = None,.    ) ->
+00005a60: 204e 6f6e 653a 0a20 2020 2020 2020 2022   None:.        "
+00005a70: 2222 4765 6e65 7261 6c2d 7075 7270 6f73  ""General-purpos
+00005a80: 6520 7265 636f 7264 206d 6572 6769 6e67  e record merging
+00005a90: 0a20 2020 2020 2020 2066 6f72 2070 7265  .        for pre
+00005aa0: 7061 7261 7469 6f6e 2c20 6375 7261 7465  paration, curate
+00005ab0: 642f 6e6f 6e2d 6375 7261 7465 6420 7265  d/non-curated re
+00005ac0: 636f 7264 7320 616e 6420 7265 636f 7264  cords and record
+00005ad0: 7320 7769 7468 206f 7269 6769 6e73 0a0a  s with origins..
+00005ae0: 0a20 2020 2020 2020 2041 7070 6c79 2068  .        Apply h
+00005af0: 6575 7269 7374 6963 7320 746f 2063 7265  euristics to cre
+00005b00: 6174 6520 6120 6675 7369 6f6e 206f 6620  ate a fusion of 
+00005b10: 7468 6520 6265 7374 2066 6965 6c64 7320  the best fields 
+00005b20: 6261 7365 6420 6f6e 0a20 2020 2020 2020  based on.       
+00005b30: 2071 7561 6c69 7479 2068 6575 7269 7374   quality heurist
+00005b40: 6963 7322 2222 0a0a 2020 2020 2020 2020  ics"""..        
+00005b50: 2320 7079 6c69 6e74 3a20 6469 7361 626c  # pylint: disabl
+00005b60: 653d 746f 6f2d 6d61 6e79 2d62 7261 6e63  e=too-many-branc
+00005b70: 6865 730a 0a20 2020 2020 2020 206d 6572  hes..        mer
+00005b80: 6769 6e67 5f72 6563 6f72 645f 7072 6566  ging_record_pref
+00005b90: 6572 7265 6420 3d20 4661 6c73 650a 2020  erred = False.  
+00005ba0: 2020 2020 2020 6966 2070 7265 6665 7272        if preferr
+00005bb0: 6564 5f6d 6173 7465 7264 6174 615f 736f  ed_masterdata_so
+00005bc0: 7572 6365 5f70 7265 6669 7865 733a 0a20  urce_prefixes:. 
+00005bd0: 2020 2020 2020 2020 2020 2069 6620 616e             if an
+00005be0: 7928 0a20 2020 2020 2020 2020 2020 2020  y(.             
+00005bf0: 2020 2061 6e79 2870 7320 696e 206f 7269     any(ps in ori
+00005c00: 6769 6e20 666f 7220 7073 2069 6e20 7072  gin for ps in pr
+00005c10: 6566 6572 7265 645f 6d61 7374 6572 6461  eferred_masterda
+00005c20: 7461 5f73 6f75 7263 655f 7072 6566 6978  ta_source_prefix
+00005c30: 6573 290a 2020 2020 2020 2020 2020 2020  es).            
+00005c40: 2020 2020 666f 7220 6f72 6967 696e 2069      for origin i
+00005c50: 6e20 6d65 7267 696e 675f 7265 636f 7264  n merging_record
+00005c60: 2e64 6174 615b 2263 6f6c 7265 765f 6f72  .data["colrev_or
+00005c70: 6967 696e 225d 0a20 2020 2020 2020 2020  igin"].         
+00005c80: 2020 2029 3a0a 2020 2020 2020 2020 2020     ):.          
+00005c90: 2020 2020 2020 6d65 7267 696e 675f 7265        merging_re
+00005ca0: 636f 7264 5f70 7265 6665 7272 6564 203d  cord_preferred =
+00005cb0: 2054 7275 650a 0a20 2020 2020 2020 2073   True..        s
+00005cc0: 656c 662e 5f5f 7072 6576 656e 745f 696e  elf.__prevent_in
+00005cd0: 7661 6c69 645f 6d65 7267 6573 286d 6572  valid_merges(mer
+00005ce0: 6769 6e67 5f72 6563 6f72 643d 6d65 7267  ging_record=merg
+00005cf0: 696e 675f 7265 636f 7264 290a 2020 2020  ing_record).    
+00005d00: 2020 2020 7365 6c66 2e5f 5f6d 6572 6765      self.__merge
+00005d10: 5f6f 7269 6769 6e73 286d 6572 6769 6e67  _origins(merging
+00005d20: 5f72 6563 6f72 643d 6d65 7267 696e 675f  _record=merging_
+00005d30: 7265 636f 7264 290a 2020 2020 2020 2020  record).        
+00005d40: 7365 6c66 2e5f 5f6d 6572 6765 5f73 7461  self.__merge_sta
+00005d50: 7475 7328 6d65 7267 696e 675f 7265 636f  tus(merging_reco
+00005d60: 7264 3d6d 6572 6769 6e67 5f72 6563 6f72  rd=merging_recor
+00005d70: 6429 0a0a 2020 2020 2020 2020 6966 206e  d)..        if n
+00005d80: 6f74 2073 656c 662e 6d61 7374 6572 6461  ot self.masterda
+00005d90: 7461 5f69 735f 6375 7261 7465 6428 2920  ta_is_curated() 
+00005da0: 616e 6420 6d65 7267 696e 675f 7265 636f  and merging_reco
+00005db0: 7264 2e6d 6173 7465 7264 6174 615f 6973  rd.masterdata_is
+00005dc0: 5f63 7572 6174 6564 2829 3a0a 2020 2020  _curated():.    
+00005dd0: 2020 2020 2020 2020 7365 6c66 2e64 6174          self.dat
+00005de0: 615b 2263 6f6c 7265 765f 6d61 7374 6572  a["colrev_master
+00005df0: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
+00005e00: 5d20 3d20 6d65 7267 696e 675f 7265 636f  ] = merging_reco
+00005e10: 7264 2e64 6174 615b 0a20 2020 2020 2020  rd.data[.       
+00005e20: 2020 2020 2020 2020 2022 636f 6c72 6576           "colrev
+00005e30: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
+00005e40: 656e 616e 6365 220a 2020 2020 2020 2020  enance".        
+00005e50: 2020 2020 5d0a 2020 2020 2020 2020 2020      ].          
+00005e60: 2020 2320 4e6f 7465 203a 2072 656d 6f76    # Note : remov
+00005e70: 6520 616c 6c20 6d61 7374 6572 6461 7461  e all masterdata
+00005e80: 2066 6965 6c64 730a 2020 2020 2020 2020   fields.        
+00005e90: 2020 2020 2320 6265 6361 7573 6520 7468      # because th
+00005ea0: 6520 6375 7261 7465 6420 7265 636f 7264  e curated record
+00005eb0: 206d 6179 2068 6176 6520 6665 7765 7220   may have fewer 
+00005ec0: 6d61 7374 6572 6461 7461 2066 6965 6c64  masterdata field
+00005ed0: 730a 2020 2020 2020 2020 2020 2020 2320  s.            # 
+00005ee0: 616e 6420 7765 2069 7465 7261 7465 206f  and we iterate o
+00005ef0: 7665 7220 7468 6520 6375 7261 7465 6420  ver the curated 
+00005f00: 7265 636f 7264 2028 6d65 7267 696e 675f  record (merging_
+00005f10: 7265 636f 7264 2920 696e 2074 6865 206e  record) in the n
+00005f20: 6578 7420 7374 6570 0a20 2020 2020 2020  ext step.       
+00005f30: 2020 2020 2066 6f72 206b 2069 6e20 6c69       for k in li
+00005f40: 7374 2873 656c 662e 6461 7461 2e6b 6579  st(self.data.key
+00005f50: 7328 2929 3a0a 2020 2020 2020 2020 2020  s()):.          
+00005f60: 2020 2020 2020 6966 206b 2069 6e20 5265        if k in Re
+00005f70: 636f 7264 2e69 6465 6e74 6966 7969 6e67  cord.identifying
+00005f80: 5f66 6965 6c64 5f6b 6579 7320 616e 6420  _field_keys and 
+00005f90: 6b20 213d 2022 7061 6765 7322 3a0a 2020  k != "pages":.  
+00005fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005fb0: 2020 6465 6c20 7365 6c66 2e64 6174 615b    del self.data[
+00005fc0: 6b5d 0a0a 2020 2020 2020 2020 666f 7220  k]..        for 
+00005fd0: 6b65 7920 696e 206c 6973 7428 6d65 7267  key in list(merg
+00005fe0: 696e 675f 7265 636f 7264 2e64 6174 612e  ing_record.data.
+00005ff0: 6b65 7973 2829 293a 0a20 2020 2020 2020  keys()):.       
+00006000: 2020 2020 2076 616c 203d 2073 656c 662e       val = self.
+00006010: 5f5f 6765 745f 6d65 7267 696e 675f 7661  __get_merging_va
+00006020: 6c28 6d65 7267 696e 675f 7265 636f 7264  l(merging_record
+00006030: 3d6d 6572 6769 6e67 5f72 6563 6f72 642c  =merging_record,
+00006040: 206b 6579 3d6b 6579 290a 2020 2020 2020   key=key).      
+00006050: 2020 2020 2020 6966 2076 616c 203d 3d20        if val == 
+00006060: 2222 3a0a 2020 2020 2020 2020 2020 2020  "":.            
+00006070: 2020 2020 636f 6e74 696e 7565 0a0a 2020      continue..  
+00006080: 2020 2020 2020 2020 2020 6669 656c 645f            field_
+00006090: 7072 6f76 656e 616e 6365 203d 206d 6572  provenance = mer
+000060a0: 6769 6e67 5f72 6563 6f72 642e 6765 745f  ging_record.get_
+000060b0: 6669 656c 645f 7072 6f76 656e 616e 6365  field_provenance
+000060c0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+000060d0: 2020 6b65 793d 6b65 792c 2064 6566 6175    key=key, defau
+000060e0: 6c74 5f73 6f75 7263 653d 6465 6661 756c  lt_source=defaul
+000060f0: 745f 736f 7572 6365 0a20 2020 2020 2020  t_source.       
+00006100: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
+00006110: 2020 2073 6f75 7263 6520 3d20 6669 656c     source = fiel
+00006120: 645f 7072 6f76 656e 616e 6365 5b22 736f  d_provenance["so
+00006130: 7572 6365 225d 0a20 2020 2020 2020 2020  urce"].         
+00006140: 2020 206e 6f74 6520 3d20 6669 656c 645f     note = field_
+00006150: 7072 6f76 656e 616e 6365 5b22 6e6f 7465  provenance["note
+00006160: 225d 0a0a 2020 2020 2020 2020 2020 2020  "]..            
+00006170: 2320 416c 7761 7973 2075 7064 6174 6520  # Always update 
+00006180: 6672 6f6d 2063 7572 6174 6564 206d 6572  from curated mer
+00006190: 6769 6e67 5f72 6563 6f72 6473 0a20 2020  ging_records.   
+000061a0: 2020 2020 2020 2020 2069 6620 6d65 7267           if merg
+000061b0: 696e 675f 7265 636f 7264 2e6d 6173 7465  ing_record.maste
+000061c0: 7264 6174 615f 6973 5f63 7572 6174 6564  rdata_is_curated
+000061d0: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
+000061e0: 2020 2020 7365 6c66 2e64 6174 615b 6b65      self.data[ke
+000061f0: 795d 203d 206d 6572 6769 6e67 5f72 6563  y] = merging_rec
+00006200: 6f72 642e 6461 7461 5b6b 6579 5d0a 2020  ord.data[key].  
+00006210: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00006220: 206b 6579 206e 6f74 2069 6e20 5265 636f   key not in Reco
+00006230: 7264 2e69 6465 6e74 6966 7969 6e67 5f66  rd.identifying_f
+00006240: 6965 6c64 5f6b 6579 7320 2b20 5b22 454e  ield_keys + ["EN
+00006250: 5452 5954 5950 4522 5d3a 0a20 2020 2020  TRYTYPE"]:.     
+00006260: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00006270: 656c 662e 6164 645f 6461 7461 5f70 726f  elf.add_data_pro
+00006280: 7665 6e61 6e63 6528 6b65 793d 6b65 792c  venance(key=key,
+00006290: 2073 6f75 7263 653d 736f 7572 6365 2c20   source=source, 
+000062a0: 6e6f 7465 3d6e 6f74 6529 0a0a 2020 2020  note=note)..    
+000062b0: 2020 2020 2020 2020 2320 446f 206e 6f74          # Do not
+000062c0: 2063 6861 6e67 6520 6966 204d 4552 4749   change if MERGI
+000062d0: 4e47 5f52 4543 4f52 4420 6973 206e 6f74  NG_RECORD is not
+000062e0: 2063 7572 6174 6564 0a20 2020 2020 2020   curated.       
+000062f0: 2020 2020 2065 6c69 6620 280a 2020 2020       elif (.    
+00006300: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00006310: 2e6d 6173 7465 7264 6174 615f 6973 5f63  .masterdata_is_c
+00006320: 7572 6174 6564 2829 0a20 2020 2020 2020  urated().       
+00006330: 2020 2020 2020 2020 2061 6e64 206e 6f74           and not
+00006340: 206d 6572 6769 6e67 5f72 6563 6f72 642e   merging_record.
+00006350: 6d61 7374 6572 6461 7461 5f69 735f 6375  masterdata_is_cu
+00006360: 7261 7465 6428 290a 2020 2020 2020 2020  rated().        
+00006370: 2020 2020 293a 0a20 2020 2020 2020 2020      ):.         
+00006380: 2020 2020 2020 2063 6f6e 7469 6e75 650a         continue.
+00006390: 0a20 2020 2020 2020 2020 2020 2023 2050  .            # P
+000063a0: 6172 7420 313a 2069 6465 6e74 6966 7969  art 1: identifyi
+000063b0: 6e67 2066 6965 6c64 730a 2020 2020 2020  ng fields.      
+000063c0: 2020 2020 2020 6966 206b 6579 2069 6e20        if key in 
+000063d0: 5265 636f 7264 2e69 6465 6e74 6966 7969  Record.identifyi
+000063e0: 6e67 5f66 6965 6c64 5f6b 6579 733a 0a20  ng_field_keys:. 
+000063f0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00006400: 6620 7072 6566 6572 7265 645f 6d61 7374  f preferred_mast
+00006410: 6572 6461 7461 5f73 6f75 7263 655f 7072  erdata_source_pr
+00006420: 6566 6978 6573 3a0a 2020 2020 2020 2020  efixes:.        
+00006430: 2020 2020 2020 2020 2020 2020 6966 206d              if m
+00006440: 6572 6769 6e67 5f72 6563 6f72 645f 7072  erging_record_pr
+00006450: 6566 6572 7265 643a 0a20 2020 2020 2020  eferred:.       
+00006460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006470: 2073 656c 662e 7570 6461 7465 5f66 6965   self.update_fie
+00006480: 6c64 280a 2020 2020 2020 2020 2020 2020  ld(.            
+00006490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000064a0: 6b65 793d 6b65 792c 2076 616c 7565 3d73  key=key, value=s
+000064b0: 7472 2876 616c 292c 2073 6f75 7263 653d  tr(val), source=
+000064c0: 736f 7572 6365 2c20 6170 7065 6e64 5f65  source, append_e
+000064d0: 6469 743d 4661 6c73 650a 2020 2020 2020  dit=False.      
+000064e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000064f0: 2020 290a 0a20 2020 2020 2020 2020 2020    )..           
+00006500: 2020 2020 2023 2046 7573 6520 6265 7374       # Fuse best
+00006510: 2066 6965 6c64 7320 6966 206e 6f6e 6520   fields if none 
+00006520: 6973 2063 7572 6174 6564 0a20 2020 2020  is curated.     
+00006530: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00006540: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006550: 2020 2020 2073 656c 662e 5f5f 6675 7365       self.__fuse
+00006560: 5f62 6573 745f 6669 656c 6428 0a20 2020  _best_field(.   
+00006570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006580: 2020 2020 206d 6572 6769 6e67 5f72 6563       merging_rec
+00006590: 6f72 643d 6d65 7267 696e 675f 7265 636f  ord=merging_reco
+000065a0: 7264 2c0a 2020 2020 2020 2020 2020 2020  rd,.            
+000065b0: 2020 2020 2020 2020 2020 2020 6b65 793d              key=
+000065c0: 6b65 792c 0a20 2020 2020 2020 2020 2020  key,.           
+000065d0: 2020 2020 2020 2020 2020 2020 2076 616c               val
+000065e0: 3d73 7472 2876 616c 292c 0a20 2020 2020  =str(val),.     
+000065f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006600: 2020 2073 6f75 7263 653d 736f 7572 6365     source=source
+00006610: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00006620: 2020 2020 2020 2020 2020 6e6f 7465 3d6e            note=n
+00006630: 6f74 652c 0a20 2020 2020 2020 2020 2020  ote,.           
+00006640: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
+00006650: 2020 2020 2020 2020 2320 5061 7274 2032          # Part 2
+00006660: 3a20 6f74 6865 7220 6669 656c 6473 0a20  : other fields. 
+00006670: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00006680: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006690: 2023 206b 6565 7020 6578 6973 7469 6e67   # keep existing
+000066a0: 2076 616c 7565 7320 7065 7220 6465 6661   values per defa
+000066b0: 756c 740a 2020 2020 2020 2020 2020 2020  ult.            
+000066c0: 2020 2020 6966 206b 6579 2069 6e20 7365      if key in se
+000066d0: 6c66 2e64 6174 613a 0a20 2020 2020 2020  lf.data:.       
+000066e0: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
+000066f0: 7469 6e75 650a 2020 2020 2020 2020 2020  tinue.          
+00006700: 2020 2020 2020 7365 6c66 2e75 7064 6174        self.updat
+00006710: 655f 6669 656c 6428 0a20 2020 2020 2020  e_field(.       
+00006720: 2020 2020 2020 2020 2020 2020 206b 6579               key
+00006730: 3d6b 6579 2c0a 2020 2020 2020 2020 2020  =key,.          
+00006740: 2020 2020 2020 2020 2020 7661 6c75 653d            value=
+00006750: 7374 7228 7661 6c29 2c0a 2020 2020 2020  str(val),.      
+00006760: 2020 2020 2020 2020 2020 2020 2020 736f                so
+00006770: 7572 6365 3d73 6f75 7263 652c 0a20 2020  urce=source,.   
+00006780: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006790: 206e 6f74 653d 6e6f 7465 2c0a 2020 2020   note=note,.    
+000067a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000067b0: 6b65 6570 5f73 6f75 7263 655f 6966 5f65  keep_source_if_e
+000067c0: 7175 616c 3d54 7275 652c 0a20 2020 2020  qual=True,.     
+000067d0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+000067e0: 7070 656e 645f 6564 6974 3d46 616c 7365  ppend_edit=False
+000067f0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00006800: 2020 290a 0a20 2020 2040 636c 6173 736d    )..    @classm
+00006810: 6574 686f 640a 2020 2020 6465 6620 5f5f  ethod.    def __
+00006820: 7365 6c65 6374 5f62 6573 745f 6175 7468  select_best_auth
+00006830: 6f72 280a 2020 2020 2020 2020 636c 732c  or(.        cls,
+00006840: 202a 2c20 7265 636f 7264 3a20 5265 636f   *, record: Reco
+00006850: 7264 2c20 6d65 7267 696e 675f 7265 636f  rd, merging_reco
+00006860: 7264 3a20 5265 636f 7264 2c20 7072 6566  rd: Record, pref
+00006870: 6572 7265 645f 736f 7572 6365 733a 206c  erred_sources: l
+00006880: 6973 740a 2020 2020 2920 2d3e 2073 7472  ist.    ) -> str
+00006890: 3a0a 2020 2020 2020 2020 2320 7079 6c69  :.        # pyli
+000068a0: 6e74 3a20 6469 7361 626c 653d 746f 6f2d  nt: disable=too-
+000068b0: 6d61 6e79 2d72 6574 7572 6e2d 7374 6174  many-return-stat
+000068c0: 656d 656e 7473 0a20 2020 2020 2020 2069  ements.        i
+000068d0: 6620 2263 6f6c 7265 765f 6d61 7374 6572  f "colrev_master
+000068e0: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
+000068f0: 206e 6f74 2069 6e20 7265 636f 7264 2e64   not in record.d
+00006900: 6174 613a 0a20 2020 2020 2020 2020 2020  ata:.           
+00006910: 2072 6563 6f72 642e 6461 7461 5b22 636f   record.data["co
+00006920: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
+00006930: 7072 6f76 656e 616e 6365 225d 203d 207b  provenance"] = {
+00006940: 7d0a 2020 2020 2020 2020 7265 636f 7264  }.        record
+00006950: 5f61 5f70 726f 7620 3d20 7265 636f 7264  _a_prov = record
+00006960: 2e64 6174 615b 2263 6f6c 7265 765f 6d61  .data["colrev_ma
+00006970: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
+00006980: 6e63 6522 5d0a 0a20 2020 2020 2020 2069  nce"]..        i
+00006990: 6620 2263 6f6c 7265 765f 6d61 7374 6572  f "colrev_master
+000069a0: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
+000069b0: 206e 6f74 2069 6e20 6d65 7267 696e 675f   not in merging_
+000069c0: 7265 636f 7264 2e64 6174 613a 0a20 2020  record.data:.   
+000069d0: 2020 2020 2020 2020 206d 6572 6769 6e67           merging
+000069e0: 5f72 6563 6f72 642e 6461 7461 5b22 636f  _record.data["co
+000069f0: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
+00006a00: 7072 6f76 656e 616e 6365 225d 203d 207b  provenance"] = {
+00006a10: 7d0a 2020 2020 2020 2020 6d65 7267 696e  }.        mergin
+00006a20: 675f 7265 636f 7264 5f61 5f70 726f 7620  g_record_a_prov 
+00006a30: 3d20 6d65 7267 696e 675f 7265 636f 7264  = merging_record
+00006a40: 2e64 6174 615b 2263 6f6c 7265 765f 6d61  .data["colrev_ma
+00006a50: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
+00006a60: 6e63 6522 5d0a 0a20 2020 2020 2020 2069  nce"]..        i
+00006a70: 6620 2261 7574 686f 7222 2069 6e20 7265  f "author" in re
+00006a80: 636f 7264 5f61 5f70 726f 7620 616e 6420  cord_a_prov and 
+00006a90: 2261 7574 686f 7222 206e 6f74 2069 6e20  "author" not in 
+00006aa0: 6d65 7267 696e 675f 7265 636f 7264 5f61  merging_record_a
+00006ab0: 5f70 726f 763a 0a20 2020 2020 2020 2020  _prov:.         
+00006ac0: 2020 2023 2050 7265 6665 7220 6e6f 6e2d     # Prefer non-
+00006ad0: 6465 6665 6374 2076 6572 7369 6f6e 0a20  defect version. 
+00006ae0: 2020 2020 2020 2020 2020 2069 6620 2271             if "q
+00006af0: 7561 6c69 7479 5f64 6566 6563 7422 2069  uality_defect" i
+00006b00: 6e20 7265 636f 7264 5f61 5f70 726f 765b  n record_a_prov[
+00006b10: 2261 7574 686f 7222 5d2e 6765 7428 226e  "author"].get("n
+00006b20: 6f74 6522 2c20 2222 293a 0a20 2020 2020  ote", ""):.     
+00006b30: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00006b40: 6e20 6d65 7267 696e 675f 7265 636f 7264  n merging_record
+00006b50: 2e64 6174 615b 2261 7574 686f 7222 5d0a  .data["author"].
+00006b60: 2020 2020 2020 2020 2020 2020 2320 5072              # Pr
+00006b70: 6566 6572 2063 6f6d 706c 6574 6520 7665  efer complete ve
+00006b80: 7273 696f 6e0a 2020 2020 2020 2020 2020  rsion.          
+00006b90: 2020 6966 2022 696e 636f 6d70 6c65 7465    if "incomplete
+00006ba0: 2220 696e 2072 6563 6f72 645f 615f 7072  " in record_a_pr
+00006bb0: 6f76 5b22 6175 7468 6f72 225d 2e67 6574  ov["author"].get
+00006bc0: 2822 6e6f 7465 222c 2022 2229 3a0a 2020  ("note", ""):.  
+00006bd0: 2020 2020 2020 2020 2020 2020 2020 7265                re
+00006be0: 7475 726e 206d 6572 6769 6e67 5f72 6563  turn merging_rec
+00006bf0: 6f72 642e 6461 7461 5b22 6175 7468 6f72  ord.data["author
+00006c00: 225d 0a20 2020 2020 2020 2065 6c69 6620  "].        elif 
+00006c10: 2261 7574 686f 7222 2069 6e20 7265 636f  "author" in reco
+00006c20: 7264 5f61 5f70 726f 7620 616e 6420 2261  rd_a_prov and "a
+00006c30: 7574 686f 7222 2069 6e20 6d65 7267 696e  uthor" in mergin
+00006c40: 675f 7265 636f 7264 5f61 5f70 726f 763a  g_record_a_prov:
+00006c50: 0a20 2020 2020 2020 2020 2020 2023 2050  .            # P
+00006c60: 7265 6665 7220 6e6f 6e2d 6465 6665 6374  refer non-defect
+00006c70: 2076 6572 7369 6f6e 0a20 2020 2020 2020   version.       
+00006c80: 2020 2020 2069 6620 2271 7561 6c69 7479       if "quality
+00006c90: 5f64 6566 6563 7422 2069 6e20 7265 636f  _defect" in reco
+00006ca0: 7264 5f61 5f70 726f 765b 2261 7574 686f  rd_a_prov["autho
+00006cb0: 7222 5d2e 6765 7428 0a20 2020 2020 2020  r"].get(.       
+00006cc0: 2020 2020 2020 2020 2022 6e6f 7465 222c           "note",
+00006cd0: 2022 220a 2020 2020 2020 2020 2020 2020   "".            
+00006ce0: 2920 616e 6420 2271 7561 6c69 7479 5f64  ) and "quality_d
+00006cf0: 6566 6563 7422 206e 6f74 2069 6e20 6d65  efect" not in me
+00006d00: 7267 696e 675f 7265 636f 7264 5f61 5f70  rging_record_a_p
+00006d10: 726f 765b 2261 7574 686f 7222 5d2e 6765  rov["author"].ge
+00006d20: 7428 0a20 2020 2020 2020 2020 2020 2020  t(.             
+00006d30: 2020 2022 6e6f 7465 222c 2022 220a 2020     "note", "".  
+00006d40: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
+00006d50: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00006d60: 7572 6e20 6d65 7267 696e 675f 7265 636f  urn merging_reco
+00006d70: 7264 2e64 6174 615b 2261 7574 686f 7222  rd.data["author"
+00006d80: 5d0a 0a20 2020 2020 2020 2020 2020 2023  ]..            #
+00006d90: 2050 7265 6665 7220 636f 6d70 6c65 7465   Prefer complete
+00006da0: 2076 6572 7369 6f6e 0a20 2020 2020 2020   version.       
+00006db0: 2020 2020 2069 6620 2269 6e63 6f6d 706c       if "incompl
+00006dc0: 6574 6522 2069 6e20 7265 636f 7264 5f61  ete" in record_a
+00006dd0: 5f70 726f 765b 2261 7574 686f 7222 5d2e  _prov["author"].
+00006de0: 6765 7428 0a20 2020 2020 2020 2020 2020  get(.           
+00006df0: 2020 2020 2022 6e6f 7465 222c 2022 220a       "note", "".
+00006e00: 2020 2020 2020 2020 2020 2020 2920 616e              ) an
+00006e10: 6420 2269 6e63 6f6d 706c 6574 6522 206e  d "incomplete" n
+00006e20: 6f74 2069 6e20 6d65 7267 696e 675f 7265  ot in merging_re
+00006e30: 636f 7264 5f61 5f70 726f 765b 2261 7574  cord_a_prov["aut
+00006e40: 686f 7222 5d2e 6765 7428 226e 6f74 6522  hor"].get("note"
+00006e50: 2c20 2222 293a 0a20 2020 2020 2020 2020  , ""):.         
+00006e60: 2020 2020 2020 2072 6574 7572 6e20 6d65         return me
+00006e70: 7267 696e 675f 7265 636f 7264 2e64 6174  rging_record.dat
+00006e80: 615b 2261 7574 686f 7222 5d0a 0a20 2020  a["author"]..   
+00006e90: 2020 2020 2069 6620 6c65 6e28 7265 636f       if len(reco
+00006ea0: 7264 2e64 6174 615b 2261 7574 686f 7222  rd.data["author"
+00006eb0: 5d29 203e 2030 2061 6e64 206c 656e 286d  ]) > 0 and len(m
+00006ec0: 6572 6769 6e67 5f72 6563 6f72 642e 6461  erging_record.da
+00006ed0: 7461 5b22 6175 7468 6f72 225d 2920 3e20  ta["author"]) > 
+00006ee0: 303a 0a20 2020 2020 2020 2020 2020 2064  0:.            d
+00006ef0: 6566 6175 6c74 5f6d 6f73 746c 795f 7570  efault_mostly_up
+00006f00: 7065 7220 3d20 280a 2020 2020 2020 2020  per = (.        
+00006f10: 2020 2020 2020 2020 636f 6c72 6576 2e65          colrev.e
+00006f20: 6e76 2e75 7469 6c73 2e70 6572 6365 6e74  nv.utils.percent
+00006f30: 5f75 7070 6572 5f63 6861 7273 2872 6563  _upper_chars(rec
+00006f40: 6f72 642e 6461 7461 5b22 6175 7468 6f72  ord.data["author
+00006f50: 225d 2920 3e20 302e 380a 2020 2020 2020  "]) > 0.8.      
+00006f60: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00006f70: 2020 2020 6361 6e64 6964 6174 655f 6d6f      candidate_mo
+00006f80: 7374 6c79 5f75 7070 6572 203d 2028 0a20  stly_upper = (. 
+00006f90: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+00006fa0: 6f6c 7265 762e 656e 762e 7574 696c 732e  olrev.env.utils.
+00006fb0: 7065 7263 656e 745f 7570 7065 725f 6368  percent_upper_ch
+00006fc0: 6172 7328 6d65 7267 696e 675f 7265 636f  ars(merging_reco
+00006fd0: 7264 2e64 6174 615b 2261 7574 686f 7222  rd.data["author"
+00006fe0: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
+00006ff0: 2020 203e 2030 2e38 0a20 2020 2020 2020     > 0.8.       
+00007000: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
+00007010: 2020 2020 2320 5072 6566 6572 2074 6974      # Prefer tit
+00007020: 6c65 2063 6173 6520 286e 6f74 2061 6c6c  le case (not all
+00007030: 2d63 6170 7329 0a20 2020 2020 2020 2020  -caps).         
+00007040: 2020 2069 6620 6465 6661 756c 745f 6d6f     if default_mo
+00007050: 7374 6c79 5f75 7070 6572 2061 6e64 206e  stly_upper and n
+00007060: 6f74 2063 616e 6469 6461 7465 5f6d 6f73  ot candidate_mos
+00007070: 746c 795f 7570 7065 723a 0a20 2020 2020  tly_upper:.     
+00007080: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00007090: 6e20 6d65 7267 696e 675f 7265 636f 7264  n merging_record
+000070a0: 2e64 6174 615b 2261 7574 686f 7222 5d0a  .data["author"].
+000070b0: 0a20 2020 2020 2020 2023 2050 7265 6665  .        # Prefe
+000070c0: 7220 736f 7572 6365 730a 2020 2020 2020  r sources.      
+000070d0: 2020 6966 2022 6175 7468 6f72 2220 696e    if "author" in
+000070e0: 206d 6572 6769 6e67 5f72 6563 6f72 645f   merging_record_
+000070f0: 615f 7072 6f76 3a0a 2020 2020 2020 2020  a_prov:.        
+00007100: 2020 2020 6966 2061 6e79 280a 2020 2020      if any(.    
+00007110: 2020 2020 2020 2020 2020 2020 7820 696e              x in
+00007120: 206d 6572 6769 6e67 5f72 6563 6f72 645f   merging_record_
+00007130: 615f 7072 6f76 5b22 6175 7468 6f72 225d  a_prov["author"]
+00007140: 5b22 736f 7572 6365 225d 0a20 2020 2020  ["source"].     
+00007150: 2020 2020 2020 2020 2020 2066 6f72 2078             for x
+00007160: 2069 6e20 7072 6566 6572 7265 645f 736f   in preferred_so
+00007170: 7572 6365 730a 2020 2020 2020 2020 2020  urces.          
+00007180: 2020 293a 0a20 2020 2020 2020 2020 2020    ):.           
+00007190: 2020 2020 2072 6574 7572 6e20 6d65 7267       return merg
+000071a0: 696e 675f 7265 636f 7264 2e64 6174 615b  ing_record.data[
+000071b0: 2261 7574 686f 7222 5d0a 2020 2020 2020  "author"].      
+000071c0: 2020 7265 7475 726e 2072 6563 6f72 642e    return record.
+000071d0: 6461 7461 5b22 6175 7468 6f72 225d 0a0a  data["author"]..
+000071e0: 2020 2020 4063 6c61 7373 6d65 7468 6f64      @classmethod
+000071f0: 0a20 2020 2064 6566 205f 5f73 656c 6563  .    def __selec
+00007200: 745f 6265 7374 5f70 6167 6573 280a 2020  t_best_pages(.  
+00007210: 2020 2020 2020 636c 732c 0a20 2020 2020        cls,.     
+00007220: 2020 202a 2c0a 2020 2020 2020 2020 7265     *,.        re
+00007230: 636f 7264 3a20 5265 636f 7264 2c0a 2020  cord: Record,.  
+00007240: 2020 2020 2020 6d65 7267 696e 675f 7265        merging_re
+00007250: 636f 7264 3a20 5265 636f 7264 2c0a 2020  cord: Record,.  
+00007260: 2020 2020 2020 7072 6566 6572 7265 645f        preferred_
+00007270: 736f 7572 6365 733a 206c 6973 742c 2020  sources: list,  
+00007280: 2320 7079 6c69 6e74 3a20 6469 7361 626c  # pylint: disabl
+00007290: 653d 756e 7573 6564 2d61 7267 756d 656e  e=unused-argumen
+000072a0: 740a 2020 2020 2920 2d3e 2073 7472 3a0a  t.    ) -> str:.
+000072b0: 2020 2020 2020 2020 6265 7374 5f70 6167          best_pag
+000072c0: 6573 203d 2072 6563 6f72 642e 6461 7461  es = record.data
+000072d0: 5b22 7061 6765 7322 5d0a 2020 2020 2020  ["pages"].      
+000072e0: 2020 6966 2022 2d2d 2220 696e 206d 6572    if "--" in mer
+000072f0: 6769 6e67 5f72 6563 6f72 642e 6461 7461  ging_record.data
+00007300: 5b22 7061 6765 7322 5d20 616e 6420 222d  ["pages"] and "-
+00007310: 2d22 206e 6f74 2069 6e20 7265 636f 7264  -" not in record
+00007320: 2e64 6174 615b 2270 6167 6573 225d 3a0a  .data["pages"]:.
+00007330: 2020 2020 2020 2020 2020 2020 6265 7374              best
+00007340: 5f70 6167 6573 203d 206d 6572 6769 6e67  _pages = merging
+00007350: 5f72 6563 6f72 642e 6461 7461 5b22 7061  _record.data["pa
+00007360: 6765 7322 5d0a 2020 2020 2020 2020 7265  ges"].        re
+00007370: 7475 726e 2062 6573 745f 7061 6765 730a  turn best_pages.
+00007380: 0a20 2020 2040 636c 6173 736d 6574 686f  .    @classmetho
+00007390: 640a 2020 2020 6465 6620 5f5f 7365 6c65  d.    def __sele
+000073a0: 6374 5f62 6573 745f 7469 746c 6528 0a20  ct_best_title(. 
+000073b0: 2020 2020 2020 2063 6c73 2c0a 2020 2020         cls,.    
+000073c0: 2020 2020 2a2c 0a20 2020 2020 2020 2072      *,.        r
+000073d0: 6563 6f72 643a 2052 6563 6f72 642c 0a20  ecord: Record,. 
+000073e0: 2020 2020 2020 206d 6572 6769 6e67 5f72         merging_r
+000073f0: 6563 6f72 643a 2052 6563 6f72 642c 0a20  ecord: Record,. 
+00007400: 2020 2020 2020 2070 7265 6665 7272 6564         preferred
+00007410: 5f73 6f75 7263 6573 3a20 6c69 7374 2c20  _sources: list, 
+00007420: 2023 2070 796c 696e 743a 2064 6973 6162   # pylint: disab
+00007430: 6c65 3d75 6e75 7365 642d 6172 6775 6d65  le=unused-argume
+00007440: 6e74 0a20 2020 2029 202d 3e20 7374 723a  nt.    ) -> str:
+00007450: 0a20 2020 2020 2020 2064 6566 6175 6c74  .        default
+00007460: 203d 2072 6563 6f72 642e 6461 7461 5b22   = record.data["
+00007470: 7469 746c 6522 5d0a 2020 2020 2020 2020  title"].        
+00007480: 6361 6e64 6964 6174 6520 3d20 6d65 7267  candidate = merg
+00007490: 696e 675f 7265 636f 7264 2e64 6174 615b  ing_record.data[
+000074a0: 2274 6974 6c65 225d 0a20 2020 2020 2020  "title"].       
+000074b0: 2062 6573 745f 7469 746c 6520 3d20 7265   best_title = re
+000074c0: 636f 7264 2e64 6174 615b 2274 6974 6c65  cord.data["title
+000074d0: 225d 0a0a 2020 2020 2020 2020 2320 4e6f  "]..        # No
+000074e0: 7465 203a 2061 766f 6964 2073 7769 7463  te : avoid switc
+000074f0: 6869 6e67 2074 6974 6c65 730a 2020 2020  hing titles.    
+00007500: 2020 2020 6966 2064 6566 6175 6c74 2e72      if default.r
+00007510: 6570 6c61 6365 2822 202d 2022 2c20 223a  eplace(" - ", ":
+00007520: 2022 2920 3d3d 2063 616e 6469 6461 7465   ") == candidate
+00007530: 2e72 6570 6c61 6365 2822 202d 2022 2c20  .replace(" - ", 
+00007540: 223a 2022 293a 0a20 2020 2020 2020 2020  ": "):.         
+00007550: 2020 2072 6574 7572 6e20 6465 6661 756c     return defaul
+00007560: 740a 0a20 2020 2020 2020 2064 6566 6175  t..        defau
+00007570: 6c74 5f75 7070 6572 203d 2063 6f6c 7265  lt_upper = colre
+00007580: 762e 656e 762e 7574 696c 732e 7065 7263  v.env.utils.perc
+00007590: 656e 745f 7570 7065 725f 6368 6172 7328  ent_upper_chars(
+000075a0: 6465 6661 756c 7429 0a20 2020 2020 2020  default).       
+000075b0: 2063 616e 6469 6461 7465 5f75 7070 6572   candidate_upper
+000075c0: 203d 2063 6f6c 7265 762e 656e 762e 7574   = colrev.env.ut
+000075d0: 696c 732e 7065 7263 656e 745f 7570 7065  ils.percent_uppe
+000075e0: 725f 6368 6172 7328 6361 6e64 6964 6174  r_chars(candidat
+000075f0: 6529 0a0a 2020 2020 2020 2020 6966 2063  e)..        if c
+00007600: 616e 6469 6461 7465 5b2d 315d 206e 6f74  andidate[-1] not
+00007610: 2069 6e20 5b22 2a22 2c20 2231 222c 2022   in ["*", "1", "
+00007620: 3222 5d3a 0a20 2020 2020 2020 2020 2020  2"]:.           
+00007630: 2023 2052 656c 6174 6976 656c 7920 7369   # Relatively si
+00007640: 6d70 6c65 2072 756c 652e 2e2e 0a20 2020  mple rule....   
+00007650: 2020 2020 2020 2020 2023 2063 6174 6368           # catch
+00007660: 6573 2063 6173 6573 2077 6865 6e20 6465  es cases when de
+00007670: 6661 756c 7420 6973 2061 6c6c 2075 7070  fault is all upp
+00007680: 6572 206f 7220 7469 746c 6520 6361 7365  er or title case
+00007690: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+000076a0: 6465 6661 756c 745f 7570 7065 7220 3e20  default_upper > 
+000076b0: 6361 6e64 6964 6174 655f 7570 7065 723a  candidate_upper:
+000076c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000076d0: 2062 6573 745f 7469 746c 6520 3d20 6361   best_title = ca
+000076e0: 6e64 6964 6174 650a 2020 2020 2020 2020  ndidate.        
+000076f0: 7265 7475 726e 2062 6573 745f 7469 746c  return best_titl
+00007700: 650a 0a20 2020 2040 636c 6173 736d 6574  e..    @classmet
+00007710: 686f 640a 2020 2020 6465 6620 5f5f 7365  hod.    def __se
+00007720: 6c65 6374 5f62 6573 745f 6a6f 7572 6e61  lect_best_journa
+00007730: 6c28 0a20 2020 2020 2020 2063 6c73 2c0a  l(.        cls,.
+00007740: 2020 2020 2020 2020 2a2c 0a20 2020 2020          *,.     
+00007750: 2020 2072 6563 6f72 643a 2052 6563 6f72     record: Recor
+00007760: 642c 0a20 2020 2020 2020 206d 6572 6769  d,.        mergi
+00007770: 6e67 5f72 6563 6f72 643a 2052 6563 6f72  ng_record: Recor
+00007780: 642c 0a20 2020 2020 2020 2070 7265 6665  d,.        prefe
+00007790: 7272 6564 5f73 6f75 7263 6573 3a20 6c69  rred_sources: li
+000077a0: 7374 2c20 2023 2070 796c 696e 743a 2064  st,  # pylint: d
+000077b0: 6973 6162 6c65 3d75 6e75 7365 642d 6172  isable=unused-ar
+000077c0: 6775 6d65 6e74 0a20 2020 2029 202d 3e20  gument.    ) -> 
+000077d0: 7374 723a 0a20 2020 2020 2020 2072 6574  str:.        ret
+000077e0: 7572 6e20 636c 732e 5f5f 7365 6c65 6374  urn cls.__select
+000077f0: 5f62 6573 745f 636f 6e74 6169 6e65 725f  _best_container_
+00007800: 7469 746c 6528 0a20 2020 2020 2020 2020  title(.         
+00007810: 2020 2064 6566 6175 6c74 3d72 6563 6f72     default=recor
+00007820: 642e 6461 7461 5b22 6a6f 7572 6e61 6c22  d.data["journal"
+00007830: 5d2c 2063 616e 6469 6461 7465 3d6d 6572  ], candidate=mer
+00007840: 6769 6e67 5f72 6563 6f72 642e 6461 7461  ging_record.data
+00007850: 5b22 6a6f 7572 6e61 6c22 5d0a 2020 2020  ["journal"].    
+00007860: 2020 2020 290a 0a20 2020 2040 636c 6173      )..    @clas
+00007870: 736d 6574 686f 640a 2020 2020 6465 6620  smethod.    def 
+00007880: 5f5f 7365 6c65 6374 5f62 6573 745f 626f  __select_best_bo
+00007890: 6f6b 7469 746c 6528 0a20 2020 2020 2020  oktitle(.       
+000078a0: 2063 6c73 2c0a 2020 2020 2020 2020 2a2c   cls,.        *,
+000078b0: 0a20 2020 2020 2020 2072 6563 6f72 643a  .        record:
+000078c0: 2052 6563 6f72 642c 0a20 2020 2020 2020   Record,.       
+000078d0: 206d 6572 6769 6e67 5f72 6563 6f72 643a   merging_record:
+000078e0: 2052 6563 6f72 642c 0a20 2020 2020 2020   Record,.       
+000078f0: 2070 7265 6665 7272 6564 5f73 6f75 7263   preferred_sourc
+00007900: 6573 3a20 6c69 7374 2c20 2023 2070 796c  es: list,  # pyl
+00007910: 696e 743a 2064 6973 6162 6c65 3d75 6e75  int: disable=unu
+00007920: 7365 642d 6172 6775 6d65 6e74 0a20 2020  sed-argument.   
+00007930: 2029 202d 3e20 7374 723a 0a20 2020 2020   ) -> str:.     
+00007940: 2020 2072 6574 7572 6e20 636c 732e 5f5f     return cls.__
+00007950: 7365 6c65 6374 5f62 6573 745f 636f 6e74  select_best_cont
+00007960: 6169 6e65 725f 7469 746c 6528 0a20 2020  ainer_title(.   
+00007970: 2020 2020 2020 2020 2064 6566 6175 6c74           default
+00007980: 3d72 6563 6f72 642e 6461 7461 5b22 626f  =record.data["bo
+00007990: 6f6b 7469 746c 6522 5d2c 2063 616e 6469  oktitle"], candi
+000079a0: 6461 7465 3d6d 6572 6769 6e67 5f72 6563  date=merging_rec
+000079b0: 6f72 642e 6461 7461 5b22 626f 6f6b 7469  ord.data["bookti
+000079c0: 746c 6522 5d0a 2020 2020 2020 2020 290a  tle"].        ).
+000079d0: 0a20 2020 2040 636c 6173 736d 6574 686f  .    @classmetho
+000079e0: 640a 2020 2020 6465 6620 5f5f 7365 6c65  d.    def __sele
+000079f0: 6374 5f62 6573 745f 636f 6e74 6169 6e65  ct_best_containe
+00007a00: 725f 7469 746c 6528 636c 732c 202a 2c20  r_title(cls, *, 
+00007a10: 6465 6661 756c 743a 2073 7472 2c20 6361  default: str, ca
+00007a20: 6e64 6964 6174 653a 2073 7472 2920 2d3e  ndidate: str) ->
+00007a30: 2073 7472 3a0a 2020 2020 2020 2020 6265   str:.        be
+00007a40: 7374 5f6a 6f75 726e 616c 203d 2064 6566  st_journal = def
+00007a50: 6175 6c74 0a0a 2020 2020 2020 2020 6465  ault..        de
+00007a60: 6661 756c 745f 7570 7065 7220 3d20 636f  fault_upper = co
+00007a70: 6c72 6576 2e65 6e76 2e75 7469 6c73 2e70  lrev.env.utils.p
+00007a80: 6572 6365 6e74 5f75 7070 6572 5f63 6861  ercent_upper_cha
+00007a90: 7273 2864 6566 6175 6c74 290a 2020 2020  rs(default).    
+00007aa0: 2020 2020 6361 6e64 6964 6174 655f 7570      candidate_up
+00007ab0: 7065 7220 3d20 636f 6c72 6576 2e65 6e76  per = colrev.env
+00007ac0: 2e75 7469 6c73 2e70 6572 6365 6e74 5f75  .utils.percent_u
+00007ad0: 7070 6572 5f63 6861 7273 2863 616e 6469  pper_chars(candi
+00007ae0: 6461 7465 290a 0a20 2020 2020 2020 2023  date)..        #
+00007af0: 2053 696d 706c 6520 6865 7572 6973 7469   Simple heuristi
+00007b00: 6320 746f 2061 766f 6964 2061 6262 7265  c to avoid abbre
+00007b10: 7669 6174 696f 6e73 0a20 2020 2020 2020  viations.       
+00007b20: 2069 6620 222e 2220 696e 2064 6566 6175   if "." in defau
+00007b30: 6c74 2061 6e64 2022 2e22 206e 6f74 2069  lt and "." not i
+00007b40: 6e20 6361 6e64 6964 6174 653a 0a20 2020  n candidate:.   
+00007b50: 2020 2020 2020 2020 2062 6573 745f 6a6f           best_jo
+00007b60: 7572 6e61 6c20 3d20 6361 6e64 6964 6174  urnal = candidat
+00007b70: 650a 2020 2020 2020 2020 2320 5265 6c61  e.        # Rela
+00007b80: 7469 7665 6c79 2073 696d 706c 6520 7275  tively simple ru
+00007b90: 6c65 2e2e 2e0a 2020 2020 2020 2020 2320  le....        # 
+00007ba0: 6361 7463 6865 7320 6361 7365 7320 7768  catches cases wh
+00007bb0: 656e 2064 6566 6175 6c74 2069 7320 616c  en default is al
+00007bc0: 6c20 7570 7065 7220 6f72 2074 6974 6c65  l upper or title
+00007bd0: 2063 6173 650a 2020 2020 2020 2020 6966   case.        if
+00007be0: 2064 6566 6175 6c74 5f75 7070 6572 203e   default_upper >
+00007bf0: 2063 616e 6469 6461 7465 5f75 7070 6572   candidate_upper
+00007c00: 3a0a 2020 2020 2020 2020 2020 2020 6265  :.            be
+00007c10: 7374 5f6a 6f75 726e 616c 203d 2063 616e  st_journal = can
+00007c20: 6469 6461 7465 0a20 2020 2020 2020 2072  didate.        r
+00007c30: 6574 7572 6e20 6265 7374 5f6a 6f75 726e  eturn best_journ
+00007c40: 616c 0a0a 2020 2020 6465 6620 5f5f 6675  al..    def __fu
+00007c50: 7365 5f62 6573 745f 6669 656c 6428 0a20  se_best_field(. 
+00007c60: 2020 2020 2020 2073 656c 662c 0a20 2020         self,.   
+00007c70: 2020 2020 202a 2c0a 2020 2020 2020 2020       *,.        
+00007c80: 6d65 7267 696e 675f 7265 636f 7264 3a20  merging_record: 
+00007c90: 5265 636f 7264 2c0a 2020 2020 2020 2020  Record,.        
+00007ca0: 6b65 793a 2073 7472 2c0a 2020 2020 2020  key: str,.      
+00007cb0: 2020 7661 6c3a 2073 7472 2c0a 2020 2020    val: str,.    
+00007cc0: 2020 2020 736f 7572 6365 3a20 7374 722c      source: str,
+00007cd0: 0a20 2020 2020 2020 206e 6f74 653a 2073  .        note: s
+00007ce0: 7472 2c20 2023 2070 796c 696e 743a 2064  tr,  # pylint: d
+00007cf0: 6973 6162 6c65 3d75 6e75 7365 642d 6172  isable=unused-ar
+00007d00: 6775 6d65 6e74 0a20 2020 2029 202d 3e20  gument.    ) -> 
+00007d10: 4e6f 6e65 3a0a 2020 2020 2020 2020 2320  None:.        # 
+00007d20: 4e6f 7465 203a 2074 6865 2061 7373 756d  Note : the assum
+00007d30: 7074 696f 6e20 6973 2074 6861 7420 7765  ption is that we
+00007d40: 206e 6565 6420 6d61 7374 6572 6461 7461   need masterdata
+00007d50: 5f70 726f 7665 6e61 6e63 6520 6e6f 7465  _provenance note
+00007d60: 730a 2020 2020 2020 2020 2320 6f6e 6c79  s.        # only
+00007d70: 2066 6f72 2061 7574 686f 7273 0a0a 2020   for authors..  
+00007d80: 2020 2020 2020 6375 7374 6f6d 5f66 6965        custom_fie
+00007d90: 6c64 5f73 656c 6563 746f 7273 203d 207b  ld_selectors = {
+00007da0: 0a20 2020 2020 2020 2020 2020 2022 6175  .            "au
+00007db0: 7468 6f72 223a 2073 656c 662e 5f5f 7365  thor": self.__se
+00007dc0: 6c65 6374 5f62 6573 745f 6175 7468 6f72  lect_best_author
+00007dd0: 2c0a 2020 2020 2020 2020 2020 2020 2270  ,.            "p
+00007de0: 6167 6573 223a 2073 656c 662e 5f5f 7365  ages": self.__se
+00007df0: 6c65 6374 5f62 6573 745f 7061 6765 732c  lect_best_pages,
+00007e00: 0a20 2020 2020 2020 2020 2020 2022 7469  .            "ti
+00007e10: 746c 6522 3a20 7365 6c66 2e5f 5f73 656c  tle": self.__sel
+00007e20: 6563 745f 6265 7374 5f74 6974 6c65 2c0a  ect_best_title,.
+00007e30: 2020 2020 2020 2020 2020 2020 226a 6f75              "jou
+00007e40: 726e 616c 223a 2073 656c 662e 5f5f 7365  rnal": self.__se
+00007e50: 6c65 6374 5f62 6573 745f 6a6f 7572 6e61  lect_best_journa
+00007e60: 6c2c 0a20 2020 2020 2020 2020 2020 2022  l,.            "
+00007e70: 626f 6f6b 7469 746c 6522 3a20 7365 6c66  booktitle": self
+00007e80: 2e5f 5f73 656c 6563 745f 6265 7374 5f62  .__select_best_b
+00007e90: 6f6f 6b74 6974 6c65 2c0a 2020 2020 2020  ooktitle,.      
+00007ea0: 2020 7d0a 0a20 2020 2020 2020 2069 6620    }..        if 
+00007eb0: 6b65 7920 696e 2063 7573 746f 6d5f 6669  key in custom_fi
+00007ec0: 656c 645f 7365 6c65 6374 6f72 733a 0a20  eld_selectors:. 
+00007ed0: 2020 2020 2020 2020 2020 2069 6620 6b65             if ke
+00007ee0: 7920 696e 2073 656c 662e 6461 7461 3a0a  y in self.data:.
+00007ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007f00: 6265 7374 5f76 616c 7565 203d 2063 7573  best_value = cus
+00007f10: 746f 6d5f 6669 656c 645f 7365 6c65 6374  tom_field_select
+00007f20: 6f72 735b 6b65 795d 280a 2020 2020 2020  ors[key](.      
+00007f30: 2020 2020 2020 2020 2020 2020 2020 7265                re
+00007f40: 636f 7264 3d73 656c 662c 0a20 2020 2020  cord=self,.     
+00007f50: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+00007f60: 6572 6769 6e67 5f72 6563 6f72 643d 6d65  erging_record=me
+00007f70: 7267 696e 675f 7265 636f 7264 2c0a 2020  rging_record,.  
+00007f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007f90: 2020 7072 6566 6572 7265 645f 736f 7572    preferred_sour
+00007fa0: 6365 733d 7365 6c66 2e70 7265 6665 7272  ces=self.preferr
+00007fb0: 6564 5f73 6f75 7263 6573 2c0a 2020 2020  ed_sources,.    
+00007fc0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+00007fd0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00007fe0: 2073 656c 662e 6461 7461 5b6b 6579 5d20   self.data[key] 
+00007ff0: 213d 2062 6573 745f 7661 6c75 653a 0a20  != best_value:. 
+00008000: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008010: 2020 2073 656c 662e 7570 6461 7465 5f66     self.update_f
+00008020: 6965 6c64 280a 2020 2020 2020 2020 2020  ield(.          
+00008030: 2020 2020 2020 2020 2020 2020 2020 6b65                ke
+00008040: 793d 6b65 792c 2076 616c 7565 3d62 6573  y=key, value=bes
+00008050: 745f 7661 6c75 652c 2073 6f75 7263 653d  t_value, source=
+00008060: 736f 7572 6365 2c20 6170 7065 6e64 5f65  source, append_e
+00008070: 6469 743d 4661 6c73 650a 2020 2020 2020  dit=False.      
+00008080: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+00008090: 2020 2020 2020 2020 2020 2020 656c 7365              else
+000080a0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000080b0: 2020 7365 6c66 2e75 7064 6174 655f 6669    self.update_fi
+000080c0: 656c 6428 6b65 793d 6b65 792c 2076 616c  eld(key=key, val
+000080d0: 7565 3d76 616c 2c20 736f 7572 6365 3d73  ue=val, source=s
+000080e0: 6f75 7263 652c 2061 7070 656e 645f 6564  ource, append_ed
+000080f0: 6974 3d46 616c 7365 290a 0a20 2020 2020  it=False)..     
+00008100: 2020 2065 6c69 6620 6b65 7920 3d3d 2022     elif key == "
+00008110: 6669 6c65 223a 0a20 2020 2020 2020 2020  file":.         
+00008120: 2020 2069 6620 6b65 7920 696e 2073 656c     if key in sel
+00008130: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
+00008140: 2020 2020 2020 2020 7365 6c66 2e64 6174          self.dat
+00008150: 615b 6b65 795d 203d 2073 656c 662e 6461  a[key] = self.da
+00008160: 7461 5b6b 6579 5d20 2b20 223b 2220 2b20  ta[key] + ";" + 
+00008170: 6d65 7267 696e 675f 7265 636f 7264 2e64  merging_record.d
+00008180: 6174 612e 6765 7428 6b65 792c 2022 2229  ata.get(key, "")
+00008190: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
+000081a0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+000081b0: 2020 2073 656c 662e 6461 7461 5b6b 6579     self.data[key
+000081c0: 5d20 3d20 6d65 7267 696e 675f 7265 636f  ] = merging_reco
+000081d0: 7264 2e64 6174 615b 6b65 795d 0a20 2020  rd.data[key].   
+000081e0: 2020 2020 2065 6c69 6620 6b65 7920 696e       elif key in
+000081f0: 205b 2275 726c 222c 2022 6c69 6e6b 225d   ["url", "link"]
+00008200: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+00008210: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
+00008220: 2020 206b 6579 2069 6e20 7365 6c66 2e64     key in self.d
+00008230: 6174 610a 2020 2020 2020 2020 2020 2020  ata.            
+00008240: 2020 2020 616e 6420 7365 6c66 2e64 6174      and self.dat
+00008250: 615b 6b65 795d 2e72 7374 7269 7028 222f  a[key].rstrip("/
+00008260: 2229 2021 3d20 6d65 7267 696e 675f 7265  ") != merging_re
+00008270: 636f 7264 2e64 6174 615b 6b65 795d 2e72  cord.data[key].r
+00008280: 7374 7269 7028 222f 2229 0a20 2020 2020  strip("/").     
+00008290: 2020 2020 2020 2020 2020 2061 6e64 2022             and "
+000082a0: 6874 7470 7322 206e 6f74 2069 6e20 7365  https" not in se
+000082b0: 6c66 2e64 6174 615b 6b65 795d 0a20 2020  lf.data[key].   
+000082c0: 2020 2020 2020 2020 2029 3a0a 2020 2020           ):.    
+000082d0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000082e0: 2e75 7064 6174 655f 6669 656c 6428 6b65  .update_field(ke
+000082f0: 793d 6b65 792c 2076 616c 7565 3d76 616c  y=key, value=val
+00008300: 2c20 736f 7572 6365 3d73 6f75 7263 652c  , source=source,
+00008310: 2061 7070 656e 645f 6564 6974 3d46 616c   append_edit=Fal
+00008320: 7365 290a 0a20 2020 2020 2020 2065 6c69  se)..        eli
+00008330: 6620 2255 4e4b 4e4f 574e 2220 3d3d 2073  f "UNKNOWN" == s
+00008340: 656c 662e 6461 7461 2e67 6574 280a 2020  elf.data.get(.  
+00008350: 2020 2020 2020 2020 2020 6b65 792c 2022            key, "
+00008360: 220a 2020 2020 2020 2020 2920 616e 6420  ".        ) and 
+00008370: 2255 4e4b 4e4f 574e 2220 213d 206d 6572  "UNKNOWN" != mer
+00008380: 6769 6e67 5f72 6563 6f72 642e 6461 7461  ging_record.data
+00008390: 2e67 6574 286b 6579 2c20 2222 293a 0a20  .get(key, ""):. 
+000083a0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+000083b0: 6461 7461 5b6b 6579 5d20 3d20 6d65 7267  data[key] = merg
+000083c0: 696e 675f 7265 636f 7264 2e64 6174 615b  ing_record.data[
+000083d0: 6b65 795d 0a20 2020 2020 2020 2020 2020  key].           
+000083e0: 2069 6620 6b65 7920 696e 2073 656c 662e   if key in self.
+000083f0: 6964 656e 7469 6679 696e 675f 6669 656c  identifying_fiel
+00008400: 645f 6b65 7973 3a0a 2020 2020 2020 2020  d_keys:.        
+00008410: 2020 2020 2020 2020 7365 6c66 2e61 6464          self.add
+00008420: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
+00008430: 656e 616e 6365 286b 6579 3d6b 6579 2c20  enance(key=key, 
+00008440: 736f 7572 6365 3d73 6f75 7263 6529 0a20  source=source). 
+00008450: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00008460: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008470: 2073 656c 662e 6164 645f 6461 7461 5f70   self.add_data_p
+00008480: 726f 7665 6e61 6e63 6528 6b65 793d 6b65  rovenance(key=ke
+00008490: 792c 2073 6f75 7263 653d 736f 7572 6365  y, source=source
+000084a0: 290a 0a20 2020 2020 2020 2023 2065 6c69  )..        # eli
+000084b0: 6620 6d65 7267 696e 675f 7265 636f 7264  f merging_record
+000084c0: 2e64 6174 612e 6765 7428 6b65 792c 2022  .data.get(key, "
+000084d0: 554e 4b4e 4f57 4e22 2920 3d3d 2022 554e  UNKNOWN") == "UN
+000084e0: 4b4e 4f57 4e22 3a0a 2020 2020 2020 2020  KNOWN":.        
+000084f0: 2320 2020 2020 7061 7373 0a20 2020 2020  #     pass.     
+00008500: 2020 2023 204e 6f74 6520 3a20 7468 6520     # Note : the 
+00008510: 666f 6c6c 6f77 696e 6720 6973 2064 6561  following is dea
+00008520: 6374 6976 6174 6564 2074 6f20 6176 6f69  ctivated to avoi
+00008530: 6420 6672 6571 7565 6e74 2063 6861 6e67  d frequent chang
+00008540: 6573 2069 6e20 6d65 7267 6564 2072 6563  es in merged rec
+00008550: 6f72 6473 0a20 2020 2020 2020 2023 2065  ords.        # e
+00008560: 6c73 653a 0a20 2020 2020 2020 2023 2020  lse:.        #  
+00008570: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
+00008580: 2320 2020 2020 2020 2020 6966 206b 6579  #         if key
+00008590: 2069 6e20 7365 6c66 2e69 6465 6e74 6966   in self.identif
+000085a0: 7969 6e67 5f66 6965 6c64 5f6b 6579 733a  ying_field_keys:
+000085b0: 0a20 2020 2020 2020 2023 2020 2020 2020  .        #      
+000085c0: 2020 2020 2020 2073 6f75 7263 6520 3d20         source = 
+000085d0: 6d65 7267 696e 675f 7265 636f 7264 2e64  merging_record.d
+000085e0: 6174 615b 2263 6f6c 7265 765f 6d61 7374  ata["colrev_mast
+000085f0: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
+00008600: 6522 5d5b 6b65 795d 5b0a 2020 2020 2020  e"][key][.      
+00008610: 2020 2320 2020 2020 2020 2020 2020 2020    #             
+00008620: 2020 2020 2273 6f75 7263 6522 0a20 2020      "source".   
+00008630: 2020 2020 2023 2020 2020 2020 2020 2020       #          
+00008640: 2020 205d 0a20 2020 2020 2020 2023 2020     ].        #  
+00008650: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00008660: 2020 2020 2023 2020 2020 2020 2020 2020       #          
+00008670: 2020 2073 6f75 7263 6520 3d20 6d65 7267     source = merg
+00008680: 696e 675f 7265 636f 7264 2e64 6174 615b  ing_record.data[
+00008690: 2263 6f6c 7265 765f 6461 7461 5f70 726f  "colrev_data_pro
+000086a0: 7665 6e61 6e63 6522 5d5b 6b65 795d 5b0a  venance"][key][.
+000086b0: 2020 2020 2020 2020 2320 2020 2020 2020          #       
+000086c0: 2020 2020 2020 2020 2020 2273 6f75 7263            "sourc
+000086d0: 6522 0a20 2020 2020 2020 2023 2020 2020  e".        #    
+000086e0: 2020 2020 2020 2020 205d 0a20 2020 2020           ].     
+000086f0: 2020 2023 2020 2020 2065 7863 6570 7420     #     except 
+00008700: 4b65 7945 7272 6f72 3a0a 2020 2020 2020  KeyError:.      
+00008710: 2020 2320 2020 2020 2020 2020 7061 7373    #         pass
+00008720: 0a20 2020 2020 2020 2023 2069 6620 7661  .        # if va
+00008730: 6c20 213d 2073 7472 286d 6572 6769 6e67  l != str(merging
+00008740: 5f72 6563 6f72 642e 6461 7461 5b6b 6579  _record.data[key
+00008750: 5d29 3a0a 2020 2020 2020 2020 2320 2020  ]):.        #   
+00008760: 2020 7365 6c66 2e75 7064 6174 655f 6669    self.update_fi
+00008770: 656c 6428 0a20 2020 2020 2020 2023 2020  eld(.        #  
+00008780: 2020 2020 2020 206b 6579 3d6b 6579 2c0a         key=key,.
+00008790: 2020 2020 2020 2020 2320 2020 2020 2020          #       
+000087a0: 2020 7661 6c75 653d 7374 7228 6d65 7267    value=str(merg
+000087b0: 696e 675f 7265 636f 7264 2e64 6174 615b  ing_record.data[
+000087c0: 6b65 795d 292c 0a20 2020 2020 2020 2023  key]),.        #
+000087d0: 2020 2020 2020 2020 2073 6f75 7263 653d           source=
+000087e0: 736f 7572 6365 2c0a 2020 2020 2020 2020  source,.        
+000087f0: 2320 2020 2020 2020 2020 6e6f 7465 3d6e  #         note=n
+00008800: 6f74 652c 0a20 2020 2020 2020 2023 2020  ote,.        #  
+00008810: 2020 2029 0a20 2020 2020 2020 2023 2073     ).        # s
+00008820: 656c 662e 7570 6461 7465 5f66 6965 6c64  elf.update_field
+00008830: 286b 6579 3d6b 6579 2c20 7661 6c75 653d  (key=key, value=
+00008840: 7661 6c2c 2073 6f75 7263 653d 736f 7572  val, source=sour
+00008850: 6365 2c20 6e6f 7465 3d6e 6f74 6529 0a0a  ce, note=note)..
+00008860: 2020 2020 4063 6c61 7373 6d65 7468 6f64      @classmethod
+00008870: 0a20 2020 2064 6566 2067 6574 5f72 6563  .    def get_rec
+00008880: 6f72 645f 6368 616e 6765 5f73 636f 7265  ord_change_score
+00008890: 2863 6c73 2c20 2a2c 2072 6563 6f72 645f  (cls, *, record_
+000088a0: 613a 2052 6563 6f72 642c 2072 6563 6f72  a: Record, recor
+000088b0: 645f 623a 2052 6563 6f72 6429 202d 3e20  d_b: Record) -> 
+000088c0: 666c 6f61 743a 0a20 2020 2020 2020 2022  float:.        "
+000088d0: 2222 4465 7465 726d 696e 6520 686f 7720  ""Determine how 
+000088e0: 6d75 6368 2072 6563 6f72 6473 2063 6861  much records cha
+000088f0: 6e67 6564 0a0a 2020 2020 2020 2020 5468  nged..        Th
+00008900: 6973 206d 6574 686f 6420 6973 206c 6573  is method is les
+00008910: 7320 7365 6e73 6974 6976 6520 7468 616e  s sensitive than
+00008920: 2067 6574 5f72 6563 6f72 645f 7369 6d69   get_record_simi
+00008930: 6c61 7269 7479 2c20 6573 7065 6369 616c  larity, especial
+00008940: 6c79 2077 6865 6e0a 2020 2020 2020 2020  ly when.        
+00008950: 6669 656c 6473 2061 7265 206d 6973 7369  fields are missi
+00008960: 6e67 2e20 466f 7220 6578 616d 706c 652c  ng. For example,
+00008970: 2069 6620 7468 6520 6a6f 7572 6e61 6c20   if the journal 
+00008980: 6669 656c 6420 6973 206d 6973 7369 6e67  field is missing
+00008990: 2069 6e20 626f 7468 0a20 2020 2020 2020   in both.       
+000089a0: 2072 6563 6f72 6473 2c20 6765 745f 7369   records, get_si
+000089b0: 6d69 6c61 7269 7479 2077 696c 6c20 7265  milarity will re
+000089c0: 7475 726e 2061 2076 616c 7565 203e 2031  turn a value > 1
+000089d0: 2e30 2e20 5468 6520 6765 745f 7265 636f  .0. The get_reco
+000089e0: 7264 5f63 6861 6e67 6573 0a20 2020 2020  rd_changes.     
+000089f0: 2020 2077 696c 6c20 7265 7475 726e 2030     will return 0
+00008a00: 2e30 2028 6966 2061 6c6c 206f 7468 6572  .0 (if all other
+00008a10: 2066 6965 6c64 7320 6172 6520 6571 7561   fields are equa
+00008a20: 6c29 2e22 2222 0a0a 2020 2020 2020 2020  l)."""..        
+00008a30: 2320 4174 2073 6f6d 6520 706f 696e 742c  # At some point,
+00008a40: 2074 6869 7320 6d61 7920 6265 636f 6d65   this may become
+00008a50: 206d 6f72 6520 7365 6e73 6974 6976 6520   more sensitive 
+00008a60: 746f 206d 616a 6f72 2063 6861 6e67 6573  to major changes
+00008a70: 0a20 2020 2020 2020 2073 7472 5f61 203d  .        str_a =
+00008a80: 2028 0a20 2020 2020 2020 2020 2020 2066   (.            f
+00008a90: 227b 7265 636f 7264 5f61 2e64 6174 612e  "{record_a.data.
+00008aa0: 6765 7428 2761 7574 686f 7227 2c20 2727  get('author', ''
+00008ab0: 297d 2028 7b72 6563 6f72 645f 612e 6461  )} ({record_a.da
+00008ac0: 7461 2e67 6574 2827 7965 6172 272c 2027  ta.get('year', '
+00008ad0: 2729 7d29 2022 0a20 2020 2020 2020 2020  ')}) ".         
+00008ae0: 2020 202b 2066 227b 7265 636f 7264 5f61     + f"{record_a
+00008af0: 2e64 6174 612e 6765 7428 2774 6974 6c65  .data.get('title
+00008b00: 272c 2027 2729 7d2e 2022 0a20 2020 2020  ', '')}. ".     
+00008b10: 2020 2020 2020 202b 2066 227b 7265 636f         + f"{reco
+00008b20: 7264 5f61 2e64 6174 612e 6765 7428 276a  rd_a.data.get('j
+00008b30: 6f75 726e 616c 272c 2027 2729 7d7b 7265  ournal', '')}{re
+00008b40: 636f 7264 5f61 2e64 6174 612e 6765 7428  cord_a.data.get(
+00008b50: 2762 6f6f 6b74 6974 6c65 272c 2027 2729  'booktitle', '')
+00008b60: 7d2c 2022 0a20 2020 2020 2020 2020 2020  }, ".           
+00008b70: 202b 2066 227b 7265 636f 7264 5f61 2e64   + f"{record_a.d
+00008b80: 6174 612e 6765 7428 2776 6f6c 756d 6527  ata.get('volume'
+00008b90: 2c20 2727 297d 2028 7b72 6563 6f72 645f  , '')} ({record_
+00008ba0: 612e 6461 7461 2e67 6574 2827 6e75 6d62  a.data.get('numb
+00008bb0: 6572 272c 2027 2729 7d29 220a 2020 2020  er', '')})".    
+00008bc0: 2020 2020 290a 2020 2020 2020 2020 7374      ).        st
+00008bd0: 725f 6220 3d20 280a 2020 2020 2020 2020  r_b = (.        
+00008be0: 2020 2020 6622 7b72 6563 6f72 645f 622e      f"{record_b.
+00008bf0: 6461 7461 2e67 6574 2827 6175 7468 6f72  data.get('author
+00008c00: 272c 2027 2729 7d20 287b 7265 636f 7264  ', '')} ({record
+00008c10: 5f62 2e64 6174 612e 6765 7428 2779 6561  _b.data.get('yea
+00008c20: 7227 2c20 2727 297d 2920 220a 2020 2020  r', '')}) ".    
+00008c30: 2020 2020 2020 2020 2b20 6622 7b72 6563          + f"{rec
+00008c40: 6f72 645f 622e 6461 7461 2e67 6574 2827  ord_b.data.get('
+00008c50: 7469 746c 6527 2c20 2727 297d 2e20 220a  title', '')}. ".
+00008c60: 2020 2020 2020 2020 2020 2020 2b20 6622              + f"
+00008c70: 7b72 6563 6f72 645f 622e 6461 7461 2e67  {record_b.data.g
+00008c80: 6574 2827 6a6f 7572 6e61 6c27 2c20 2727  et('journal', ''
+00008c90: 297d 7b72 6563 6f72 645f 622e 6461 7461  )}{record_b.data
+00008ca0: 2e67 6574 2827 626f 6f6b 7469 746c 6527  .get('booktitle'
+00008cb0: 2c20 2727 297d 2c20 220a 2020 2020 2020  , '')}, ".      
+00008cc0: 2020 2020 2020 2b20 6622 7b72 6563 6f72        + f"{recor
+00008cd0: 645f 622e 6461 7461 2e67 6574 2827 766f  d_b.data.get('vo
+00008ce0: 6c75 6d65 272c 2027 2729 7d20 287b 7265  lume', '')} ({re
+00008cf0: 636f 7264 5f62 2e64 6174 612e 6765 7428  cord_b.data.get(
+00008d00: 276e 756d 6265 7227 2c20 2727 297d 2922  'number', '')})"
+00008d10: 0a20 2020 2020 2020 2029 0a20 2020 2020  .        ).     
+00008d20: 2020 2072 6574 7572 6e20 3120 2d20 6675     return 1 - fu
+00008d30: 7a7a 2e72 6174 696f 2873 7472 5f61 2e6c  zz.ratio(str_a.l
+00008d40: 6f77 6572 2829 2c20 7374 725f 622e 6c6f  ower(), str_b.lo
+00008d50: 7765 7228 2929 202f 2031 3030 0a0a 2020  wer()) / 100..  
+00008d60: 2020 4063 6c61 7373 6d65 7468 6f64 0a20    @classmethod. 
+00008d70: 2020 2064 6566 2067 6574 5f72 6563 6f72     def get_recor
+00008d80: 645f 7369 6d69 6c61 7269 7479 2863 6c73  d_similarity(cls
+00008d90: 2c20 2a2c 2072 6563 6f72 645f 613a 2052  , *, record_a: R
+00008da0: 6563 6f72 642c 2072 6563 6f72 645f 623a  ecord, record_b:
+00008db0: 2052 6563 6f72 6429 202d 3e20 666c 6f61   Record) -> floa
+00008dc0: 743a 0a20 2020 2020 2020 2022 2222 4465  t:.        """De
+00008dd0: 7465 726d 696e 6520 7468 6520 7369 6d69  termine the simi
+00008de0: 6c61 7269 7479 2062 6574 7765 656e 2074  larity between t
+00008df0: 776f 2072 6563 6f72 6473 2028 7468 6569  wo records (thei
+00008e00: 7220 6d61 7374 6572 6461 7461 2922 2222  r masterdata)"""
+00008e10: 0a20 2020 2020 2020 2072 6563 6f72 645f  .        record_
+00008e20: 615f 6469 6374 203d 2072 6563 6f72 645f  a_dict = record_
+00008e30: 612e 636f 7079 2829 2e67 6574 5f64 6174  a.copy().get_dat
+00008e40: 6128 290a 2020 2020 2020 2020 7265 636f  a().        reco
+00008e50: 7264 5f62 5f64 6963 7420 3d20 7265 636f  rd_b_dict = reco
+00008e60: 7264 5f62 2e63 6f70 7928 292e 6765 745f  rd_b.copy().get_
+00008e70: 6461 7461 2829 0a0a 2020 2020 2020 2020  data()..        
+00008e80: 6d61 6e64 6174 6f72 795f 6669 656c 6473  mandatory_fields
+00008e90: 203d 205b 0a20 2020 2020 2020 2020 2020   = [.           
+00008ea0: 2022 7469 746c 6522 2c0a 2020 2020 2020   "title",.      
+00008eb0: 2020 2020 2020 2261 7574 686f 7222 2c0a        "author",.
+00008ec0: 2020 2020 2020 2020 2020 2020 2279 6561              "yea
+00008ed0: 7222 2c0a 2020 2020 2020 2020 2020 2020  r",.            
+00008ee0: 226a 6f75 726e 616c 222c 0a20 2020 2020  "journal",.     
+00008ef0: 2020 2020 2020 2022 766f 6c75 6d65 222c         "volume",
+00008f00: 0a20 2020 2020 2020 2020 2020 2022 6e75  .            "nu
+00008f10: 6d62 6572 222c 0a20 2020 2020 2020 2020  mber",.         
+00008f20: 2020 2022 7061 6765 7322 2c0a 2020 2020     "pages",.    
+00008f30: 2020 2020 2020 2020 2262 6f6f 6b74 6974          "booktit
+00008f40: 6c65 222c 0a20 2020 2020 2020 205d 0a0a  le",.        ]..
+00008f50: 2020 2020 2020 2020 666f 7220 6d61 6e64          for mand
+00008f60: 6174 6f72 795f 6669 656c 6420 696e 206d  atory_field in m
+00008f70: 616e 6461 746f 7279 5f66 6965 6c64 733a  andatory_fields:
+00008f80: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00008f90: 7265 636f 7264 5f61 5f64 6963 742e 6765  record_a_dict.ge
+00008fa0: 7428 6d61 6e64 6174 6f72 795f 6669 656c  t(mandatory_fiel
+00008fb0: 642c 2022 554e 4b4e 4f57 4e22 2920 3d3d  d, "UNKNOWN") ==
+00008fc0: 2022 554e 4b4e 4f57 4e22 3a0a 2020 2020   "UNKNOWN":.    
+00008fd0: 2020 2020 2020 2020 2020 2020 7265 636f              reco
+00008fe0: 7264 5f61 5f64 6963 745b 6d61 6e64 6174  rd_a_dict[mandat
+00008ff0: 6f72 795f 6669 656c 645d 203d 2022 220a  ory_field] = "".
+00009000: 2020 2020 2020 2020 2020 2020 6966 2072              if r
+00009010: 6563 6f72 645f 625f 6469 6374 2e67 6574  ecord_b_dict.get
+00009020: 286d 616e 6461 746f 7279 5f66 6965 6c64  (mandatory_field
+00009030: 2c20 2255 4e4b 4e4f 574e 2229 203d 3d20  , "UNKNOWN") == 
+00009040: 2255 4e4b 4e4f 574e 223a 0a20 2020 2020  "UNKNOWN":.     
+00009050: 2020 2020 2020 2020 2020 2072 6563 6f72             recor
+00009060: 645f 625f 6469 6374 5b6d 616e 6461 746f  d_b_dict[mandato
+00009070: 7279 5f66 6965 6c64 5d20 3d20 2222 0a0a  ry_field] = ""..
+00009080: 2020 2020 2020 2020 6966 2022 636f 6e74          if "cont
+00009090: 6169 6e65 725f 7469 746c 6522 206e 6f74  ainer_title" not
+000090a0: 2069 6e20 7265 636f 7264 5f61 5f64 6963   in record_a_dic
+000090b0: 743a 0a20 2020 2020 2020 2020 2020 2072  t:.            r
+000090c0: 6563 6f72 645f 615f 6469 6374 5b22 636f  ecord_a_dict["co
+000090d0: 6e74 6169 6e65 725f 7469 746c 6522 5d20  ntainer_title"] 
+000090e0: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
+000090f0: 2020 2020 7265 636f 7264 5f61 5f64 6963      record_a_dic
+00009100: 742e 6765 7428 226a 6f75 726e 616c 222c  t.get("journal",
+00009110: 2022 2229 0a20 2020 2020 2020 2020 2020   "").           
+00009120: 2020 2020 202b 2072 6563 6f72 645f 615f       + record_a_
+00009130: 6469 6374 2e67 6574 2822 626f 6f6b 7469  dict.get("bookti
+00009140: 746c 6522 2c20 2222 290a 2020 2020 2020  tle", "").      
+00009150: 2020 2020 2020 2020 2020 2b20 7265 636f            + reco
+00009160: 7264 5f61 5f64 6963 742e 6765 7428 2273  rd_a_dict.get("s
+00009170: 6572 6965 7322 2c20 2222 290a 2020 2020  eries", "").    
+00009180: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
+00009190: 2020 2069 6620 2263 6f6e 7461 696e 6572     if "container
+000091a0: 5f74 6974 6c65 2220 6e6f 7420 696e 2072  _title" not in r
+000091b0: 6563 6f72 645f 625f 6469 6374 3a0a 2020  ecord_b_dict:.  
+000091c0: 2020 2020 2020 2020 2020 7265 636f 7264            record
+000091d0: 5f62 5f64 6963 745b 2263 6f6e 7461 696e  _b_dict["contain
+000091e0: 6572 5f74 6974 6c65 225d 203d 2028 0a20  er_title"] = (. 
+000091f0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00009200: 6563 6f72 645f 625f 6469 6374 2e67 6574  ecord_b_dict.get
+00009210: 2822 6a6f 7572 6e61 6c22 2c20 2222 290a  ("journal", "").
+00009220: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009230: 2b20 7265 636f 7264 5f62 5f64 6963 742e  + record_b_dict.
+00009240: 6765 7428 2262 6f6f 6b74 6974 6c65 222c  get("booktitle",
+00009250: 2022 2229 0a20 2020 2020 2020 2020 2020   "").           
+00009260: 2020 2020 202b 2072 6563 6f72 645f 625f       + record_b_
+00009270: 6469 6374 2e67 6574 2822 7365 7269 6573  dict.get("series
+00009280: 222c 2022 2229 0a20 2020 2020 2020 2020  ", "").         
+00009290: 2020 2029 0a0a 2020 2020 2020 2020 6466     )..        df
+000092a0: 5f61 203d 2070 642e 4461 7461 4672 616d  _a = pd.DataFram
+000092b0: 652e 6672 6f6d 5f64 6963 7428 5b72 6563  e.from_dict([rec
+000092c0: 6f72 645f 615f 6469 6374 5d29 2020 2320  ord_a_dict])  # 
+000092d0: 7479 7065 3a20 6967 6e6f 7265 0a20 2020  type: ignore.   
+000092e0: 2020 2020 2064 665f 6220 3d20 7064 2e44       df_b = pd.D
+000092f0: 6174 6146 7261 6d65 2e66 726f 6d5f 6469  ataFrame.from_di
+00009300: 6374 285b 7265 636f 7264 5f62 5f64 6963  ct([record_b_dic
+00009310: 745d 2920 2023 2074 7970 653a 2069 676e  t])  # type: ign
+00009320: 6f72 650a 0a20 2020 2020 2020 2072 6574  ore..        ret
+00009330: 7572 6e20 5265 636f 7264 2e67 6574 5f73  urn Record.get_s
+00009340: 696d 696c 6172 6974 7928 6466 5f61 3d64  imilarity(df_a=d
+00009350: 665f 612e 696c 6f63 5b30 5d2c 2064 665f  f_a.iloc[0], df_
+00009360: 623d 6466 5f62 2e69 6c6f 635b 305d 290a  b=df_b.iloc[0]).
+00009370: 0a20 2020 2040 636c 6173 736d 6574 686f  .    @classmetho
+00009380: 640a 2020 2020 6465 6620 6765 745f 7369  d.    def get_si
+00009390: 6d69 6c61 7269 7479 2863 6c73 2c20 2a2c  milarity(cls, *,
+000093a0: 2064 665f 613a 2064 6963 742c 2064 665f   df_a: dict, df_
+000093b0: 623a 2064 6963 7429 202d 3e20 666c 6f61  b: dict) -> floa
+000093c0: 743a 0a20 2020 2020 2020 2022 2222 4465  t:.        """De
+000093d0: 7465 726d 696e 6520 7468 6520 7369 6d69  termine the simi
+000093e0: 6c61 7269 7479 2062 6574 7765 656e 2074  larity between t
+000093f0: 776f 2072 6563 6f72 6473 2222 220a 0a20  wo records""".. 
+00009400: 2020 2020 2020 2064 6574 6169 6c73 203d         details =
+00009410: 2052 6563 6f72 642e 6765 745f 7369 6d69   Record.get_simi
+00009420: 6c61 7269 7479 5f64 6574 6169 6c65 6428  larity_detailed(
+00009430: 7265 636f 7264 5f61 3d64 665f 612c 2072  record_a=df_a, r
+00009440: 6563 6f72 645f 623d 6466 5f62 290a 2020  ecord_b=df_b).  
+00009450: 2020 2020 2020 7265 7475 726e 2064 6574        return det
+00009460: 6169 6c73 5b22 7363 6f72 6522 5d0a 0a20  ails["score"].. 
+00009470: 2020 2040 636c 6173 736d 6574 686f 640a     @classmethod.
+00009480: 2020 2020 6465 6620 6765 745f 7369 6d69      def get_simi
+00009490: 6c61 7269 7479 5f64 6574 6169 6c65 6428  larity_detailed(
+000094a0: 636c 732c 202a 2c20 7265 636f 7264 5f61  cls, *, record_a
+000094b0: 3a20 6469 6374 2c20 7265 636f 7264 5f62  : dict, record_b
+000094c0: 3a20 6469 6374 2920 2d3e 2064 6963 743a  : dict) -> dict:
+000094d0: 0a20 2020 2020 2020 2022 2222 4465 7465  .        """Dete
+000094e0: 726d 696e 6520 7468 6520 6465 7461 696c  rmine the detail
+000094f0: 6564 2073 696d 696c 6172 6974 6965 7320  ed similarities 
+00009500: 6265 7477 6565 6e20 7265 636f 7264 7322  between records"
+00009510: 2222 0a20 2020 2020 2020 2074 7279 3a0a  "".        try:.
+00009520: 2020 2020 2020 2020 2020 2020 6175 7468              auth
+00009530: 6f72 5f73 696d 696c 6172 6974 7920 3d20  or_similarity = 
+00009540: 6675 7a7a 2e72 6174 696f 2872 6563 6f72  fuzz.ratio(recor
+00009550: 645f 615b 2261 7574 686f 7222 5d2c 2072  d_a["author"], r
+00009560: 6563 6f72 645f 625b 2261 7574 686f 7222  ecord_b["author"
+00009570: 5d29 202f 2031 3030 0a0a 2020 2020 2020  ]) / 100..      
+00009580: 2020 2020 2020 7469 746c 655f 7369 6d69        title_simi
+00009590: 6c61 7269 7479 203d 2028 0a20 2020 2020  larity = (.     
+000095a0: 2020 2020 2020 2020 2020 2066 757a 7a2e             fuzz.
+000095b0: 7261 7469 6f28 0a20 2020 2020 2020 2020  ratio(.         
+000095c0: 2020 2020 2020 2020 2020 2072 6563 6f72             recor
+000095d0: 645f 615b 2274 6974 6c65 225d 2e6c 6f77  d_a["title"].low
+000095e0: 6572 2829 2e72 6570 6c61 6365 2822 3a22  er().replace(":"
+000095f0: 2c20 2222 292e 7265 706c 6163 6528 222d  , "").replace("-
+00009600: 222c 2022 2229 2c0a 2020 2020 2020 2020  ", ""),.        
+00009610: 2020 2020 2020 2020 2020 2020 7265 636f              reco
+00009620: 7264 5f62 5b22 7469 746c 6522 5d2e 6c6f  rd_b["title"].lo
+00009630: 7765 7228 292e 7265 706c 6163 6528 223a  wer().replace(":
+00009640: 222c 2022 2229 2e72 6570 6c61 6365 2822  ", "").replace("
+00009650: 2d22 2c20 2222 292c 0a20 2020 2020 2020  -", ""),.       
+00009660: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00009670: 2020 2020 2020 2020 2020 202f 2031 3030             / 100
+00009680: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
+00009690: 2020 2020 2020 2020 2020 2020 2320 7061              # pa
+000096a0: 7274 6961 6c20 7261 7469 6f20 2863 6174  rtial ratio (cat
+000096b0: 6368 696e 6720 3230 3130 2d31 3020 6f72  ching 2010-10 or
+000096c0: 2032 3030 312d 3230 3032 290a 2020 2020   2001-2002).    
+000096d0: 2020 2020 2020 2020 7965 6172 5f73 696d          year_sim
+000096e0: 696c 6172 6974 7920 3d20 280a 2020 2020  ilarity = (.    
+000096f0: 2020 2020 2020 2020 2020 2020 6675 7a7a              fuzz
+00009700: 2e72 6174 696f 2873 7472 2872 6563 6f72  .ratio(str(recor
+00009710: 645f 615b 2279 6561 7222 5d29 2c20 7374  d_a["year"]), st
+00009720: 7228 7265 636f 7264 5f62 5b22 7965 6172  r(record_b["year
+00009730: 225d 2929 202f 2031 3030 0a20 2020 2020  "])) / 100.     
+00009740: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
+00009750: 2020 2020 2020 6f75 746c 6574 5f73 696d        outlet_sim
+00009760: 696c 6172 6974 7920 3d20 302e 300a 2020  ilarity = 0.0.  
+00009770: 2020 2020 2020 2020 2020 6966 2072 6563            if rec
+00009780: 6f72 645f 625b 2263 6f6e 7461 696e 6572  ord_b["container
+00009790: 5f74 6974 6c65 225d 2061 6e64 2072 6563  _title"] and rec
+000097a0: 6f72 645f 615b 2263 6f6e 7461 696e 6572  ord_a["container
+000097b0: 5f74 6974 6c65 225d 3a0a 2020 2020 2020  _title"]:.      
+000097c0: 2020 2020 2020 2020 2020 6f75 746c 6574            outlet
+000097d0: 5f73 696d 696c 6172 6974 7920 3d20 280a  _similarity = (.
+000097e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000097f0: 2020 2020 6675 7a7a 2e72 6174 696f 2872      fuzz.ratio(r
+00009800: 6563 6f72 645f 615b 2263 6f6e 7461 696e  ecord_a["contain
+00009810: 6572 5f74 6974 6c65 225d 2c20 7265 636f  er_title"], reco
+00009820: 7264 5f62 5b22 636f 6e74 6169 6e65 725f  rd_b["container_
+00009830: 7469 746c 6522 5d29 0a20 2020 2020 2020  title"]).       
+00009840: 2020 2020 2020 2020 2020 2020 202f 2031               / 1
+00009850: 3030 0a20 2020 2020 2020 2020 2020 2020  00.             
+00009860: 2020 2029 0a0a 2020 2020 2020 2020 2020     )..          
+00009870: 2020 6966 2073 7472 2872 6563 6f72 645f    if str(record_
+00009880: 615b 226a 6f75 726e 616c 225d 2920 213d  a["journal"]) !=
+00009890: 2022 6e61 6e22 3a0a 2020 2020 2020 2020   "nan":.        
+000098a0: 2020 2020 2020 2020 2320 4e6f 7465 3a20          # Note: 
+000098b0: 666f 7220 6a6f 7572 6e61 6c73 2070 6170  for journals pap
+000098c0: 6572 732c 2077 6520 6578 7065 6374 206d  ers, we expect m
+000098d0: 6f72 6520 6465 7461 696c 730a 2020 2020  ore details.    
+000098e0: 2020 2020 2020 2020 2020 2020 766f 6c75              volu
+000098f0: 6d65 5f73 696d 696c 6172 6974 7920 3d20  me_similarity = 
+00009900: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00009910: 2020 2020 2020 3120 6966 2028 7265 636f        1 if (reco
+00009920: 7264 5f61 5b22 766f 6c75 6d65 225d 203d  rd_a["volume"] =
+00009930: 3d20 7265 636f 7264 5f62 5b22 766f 6c75  = record_b["volu
+00009940: 6d65 225d 2920 656c 7365 2030 0a20 2020  me"]) else 0.   
+00009950: 2020 2020 2020 2020 2020 2020 2029 0a0a               )..
+00009960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009970: 6e75 6d62 6572 5f73 696d 696c 6172 6974  number_similarit
+00009980: 7920 3d20 280a 2020 2020 2020 2020 2020  y = (.          
+00009990: 2020 2020 2020 2020 2020 3120 6966 2028            1 if (
+000099a0: 7265 636f 7264 5f61 5b22 6e75 6d62 6572  record_a["number
+000099b0: 225d 203d 3d20 7265 636f 7264 5f62 5b22  "] == record_b["
+000099c0: 6e75 6d62 6572 225d 2920 656c 7365 2030  number"]) else 0
+000099d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000099e0: 2029 0a0a 2020 2020 2020 2020 2020 2020   )..            
+000099f0: 2020 2020 2320 7061 6765 2073 696d 696c      # page simil
+00009a00: 6172 6974 7920 6973 206e 6f74 2063 6f6e  arity is not con
+00009a10: 7369 6465 7265 6420 6174 2074 6865 206d  sidered at the m
+00009a20: 6f6d 656e 742e 0a20 2020 2020 2020 2020  oment..         
+00009a30: 2020 2020 2020 2023 0a20 2020 2020 2020         #.       
+00009a40: 2020 2020 2020 2020 2023 2073 6f6d 6574           # somet
+00009a50: 696d 6573 2c20 6f6e 6c79 2074 6865 2066  imes, only the f
+00009a60: 6972 7374 2070 6167 6520 6973 2070 726f  irst page is pro
+00009a70: 7669 6465 642e 0a20 2020 2020 2020 2020  vided..         
+00009a80: 2020 2020 2020 2023 2069 6620 7374 7228         # if str(
+00009a90: 7265 636f 7264 5f61 5b22 7061 6765 7322  record_a["pages"
+00009aa0: 5d29 203d 3d20 226e 616e 2220 6f72 2073  ]) == "nan" or s
+00009ab0: 7472 2872 6563 6f72 645f 625b 2270 6167  tr(record_b["pag
+00009ac0: 6573 225d 2920 3d3d 2022 6e61 6e22 3a0a  es"]) == "nan":.
 00009ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009ae0: 5b22 6564 6974 6f72 6961 6c22 2c20 2265  ["editorial", "e
-00009af0: 6469 746f 7269 616c 225d 2c0a 2020 2020  ditorial"],.    
-00009b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009b10: 5b22 6564 6974 6f72 6961 6c20 696e 7472  ["editorial intr
-00009b20: 6f64 7563 7469 6f6e 222c 2022 6564 6974  oduction", "edit
-00009b30: 6f72 6961 6c20 696e 7472 6f64 7563 7469  orial introducti
-00009b40: 6f6e 225d 2c0a 2020 2020 2020 2020 2020  on"],.          
-00009b50: 2020 2020 2020 2020 2020 5b22 6564 6974            ["edit
-00009b60: 6f72 6961 6c20 6e6f 7465 7322 2c20 2265  orial notes", "e
-00009b70: 6469 746f 7269 616c 206e 6f74 6573 225d  ditorial notes"]
-00009b80: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00009b90: 2020 2020 2020 5b22 6564 6974 6f72 2773        ["editor's
-00009ba0: 2063 6f6d 6d65 6e74 7322 2c20 2265 6469   comments", "edi
-00009bb0: 746f 7227 7320 636f 6d6d 656e 7473 225d  tor's comments"]
-00009bc0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00009bd0: 2020 2020 2020 5b22 626f 6f6b 2072 6576        ["book rev
-00009be0: 6965 7773 222c 2022 626f 6f6b 2072 6576  iews", "book rev
-00009bf0: 6965 7773 225d 2c0a 2020 2020 2020 2020  iews"],.        
-00009c00: 2020 2020 2020 2020 2020 2020 5b22 6564              ["ed
-00009c10: 6974 6f72 6961 6c20 6e6f 7465 222c 2022  itorial note", "
-00009c20: 6564 6974 6f72 6961 6c20 6e6f 7465 225d  editorial note"]
-00009c30: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00009c40: 2020 2020 2020 5b22 7265 7669 6577 6572        ["reviewer
-00009c50: 2061 636b 6f77 6c65 6467 6d65 6e74 222c   ackowledgment",
-00009c60: 2022 7265 7669 6577 6572 2061 636b 6f77   "reviewer ackow
-00009c70: 6c65 6467 6d65 6e74 225d 2c0a 2020 2020  ledgment"],.    
-00009c80: 2020 2020 2020 2020 2020 2020 5d3a 0a20              ]:. 
-00009c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009ca0: 2020 2077 6569 6768 7473 203d 205b 302e     weights = [0.
-00009cb0: 3137 352c 2030 2c20 302e 3137 352c 2030  175, 0, 0.175, 0
-00009cc0: 2e31 3735 2c20 302e 3237 352c 2030 2e32  .175, 0.275, 0.2
-00009cd0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-00009ce0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00009cf0: 2020 2020 2020 2020 2020 2020 7765 6967              weig
-00009d00: 6874 7320 3d20 5b30 2e32 2c20 302e 3235  hts = [0.2, 0.25
-00009d10: 2c20 302e 3133 2c20 302e 322c 2030 2e31  , 0.13, 0.2, 0.1
-00009d20: 322c 2030 2e31 5d0a 0a20 2020 2020 2020  2, 0.1]..       
-00009d30: 2020 2020 2020 2020 2073 696d 5f6e 616d           sim_nam
-00009d40: 6573 203d 205b 0a20 2020 2020 2020 2020  es = [.         
-00009d50: 2020 2020 2020 2020 2020 2022 6175 7468             "auth
-00009d60: 6f72 7322 2c0a 2020 2020 2020 2020 2020  ors",.          
-00009d70: 2020 2020 2020 2020 2020 2274 6974 6c65            "title
-00009d80: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
-00009d90: 2020 2020 2020 2022 7965 6172 222c 0a20         "year",. 
-00009da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009db0: 2020 2022 6f75 746c 6574 222c 0a20 2020     "outlet",.   
-00009dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009dd0: 2022 766f 6c75 6d65 222c 0a20 2020 2020   "volume",.     
-00009de0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
-00009df0: 6e75 6d62 6572 222c 0a20 2020 2020 2020  number",.       
-00009e00: 2020 2020 2020 2020 205d 0a20 2020 2020           ].     
-00009e10: 2020 2020 2020 2020 2020 2073 696d 696c             simil
-00009e20: 6172 6974 6965 7320 3d20 5b0a 2020 2020  arities = [.    
-00009e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009e40: 6175 7468 6f72 5f73 696d 696c 6172 6974  author_similarit
-00009e50: 792c 0a20 2020 2020 2020 2020 2020 2020  y,.             
-00009e60: 2020 2020 2020 2074 6974 6c65 5f73 696d         title_sim
-00009e70: 696c 6172 6974 792c 0a20 2020 2020 2020  ilarity,.       
-00009e80: 2020 2020 2020 2020 2020 2020 2079 6561               yea
-00009e90: 725f 7369 6d69 6c61 7269 7479 2c0a 2020  r_similarity,.  
-00009ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009eb0: 2020 6f75 746c 6574 5f73 696d 696c 6172    outlet_similar
-00009ec0: 6974 792c 0a20 2020 2020 2020 2020 2020  ity,.           
-00009ed0: 2020 2020 2020 2020 2076 6f6c 756d 655f           volume_
-00009ee0: 7369 6d69 6c61 7269 7479 2c0a 2020 2020  similarity,.    
-00009ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009f00: 6e75 6d62 6572 5f73 696d 696c 6172 6974  number_similarit
-00009f10: 792c 0a20 2020 2020 2020 2020 2020 2020  y,.             
-00009f20: 2020 205d 0a0a 2020 2020 2020 2020 2020     ]..          
-00009f30: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00009f40: 2020 2020 2020 2020 7765 6967 6874 7320          weights 
-00009f50: 3d20 5b30 2e31 352c 2030 2e37 352c 2030  = [0.15, 0.75, 0
-00009f60: 2e30 352c 2030 2e30 355d 0a20 2020 2020  .05, 0.05].     
-00009f70: 2020 2020 2020 2020 2020 2073 696d 5f6e             sim_n
-00009f80: 616d 6573 203d 205b 0a20 2020 2020 2020  ames = [.       
-00009f90: 2020 2020 2020 2020 2020 2020 2022 6175               "au
-00009fa0: 7468 6f72 222c 0a20 2020 2020 2020 2020  thor",.         
-00009fb0: 2020 2020 2020 2020 2020 2022 7469 746c             "titl
-00009fc0: 6522 2c0a 2020 2020 2020 2020 2020 2020  e",.            
-00009fd0: 2020 2020 2020 2020 2279 6561 7222 2c0a          "year",.
-00009fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009ff0: 2020 2020 226f 7574 6c65 7422 2c0a 2020      "outlet",.  
-0000a000: 2020 2020 2020 2020 2020 2020 2020 5d0a                ].
-0000a010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a020: 7369 6d69 6c61 7269 7469 6573 203d 205b  similarities = [
-0000a030: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a040: 2020 2020 2061 7574 686f 725f 7369 6d69       author_simi
-0000a050: 6c61 7269 7479 2c0a 2020 2020 2020 2020  larity,.        
-0000a060: 2020 2020 2020 2020 2020 2020 7469 746c              titl
-0000a070: 655f 7369 6d69 6c61 7269 7479 2c0a 2020  e_similarity,.  
-0000a080: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a090: 2020 7965 6172 5f73 696d 696c 6172 6974    year_similarit
-0000a0a0: 792c 0a20 2020 2020 2020 2020 2020 2020  y,.             
-0000a0b0: 2020 2020 2020 206f 7574 6c65 745f 7369         outlet_si
-0000a0c0: 6d69 6c61 7269 7479 2c0a 2020 2020 2020  milarity,.      
-0000a0d0: 2020 2020 2020 2020 2020 5d0a 0a20 2020            ]..   
-0000a0e0: 2020 2020 2020 2020 2077 6569 6768 7465           weighte
-0000a0f0: 645f 6176 6572 6167 6520 3d20 7375 6d28  d_average = sum(
-0000a100: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a110: 2073 696d 696c 6172 6974 6965 735b 675d   similarities[g]
-0000a120: 202a 2077 6569 6768 7473 5b67 5d20 666f   * weights[g] fo
-0000a130: 7220 6720 696e 2072 616e 6765 286c 656e  r g in range(len
-0000a140: 2873 696d 696c 6172 6974 6965 7329 290a  (similarities)).
-0000a150: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
-0000a160: 2020 2020 2020 2020 2020 2064 6574 6169             detai
-0000a170: 6c73 203d 2028 0a20 2020 2020 2020 2020  ls = (.         
-0000a180: 2020 2020 2020 2022 5b22 0a20 2020 2020         "[".     
-0000a190: 2020 2020 2020 2020 2020 202b 2022 2c22             + ","
-0000a1a0: 2e6a 6f69 6e28 5b73 696d 5f6e 616d 6573  .join([sim_names
-0000a1b0: 5b67 5d20 666f 7220 6720 696e 2072 616e  [g] for g in ran
-0000a1c0: 6765 286c 656e 2873 696d 696c 6172 6974  ge(len(similarit
-0000a1d0: 6965 7329 295d 290a 2020 2020 2020 2020  ies))]).        
-0000a1e0: 2020 2020 2020 2020 2b20 225d 220a 2020          + "]".  
-0000a1f0: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-0000a200: 222a 7765 6967 6874 735f 7665 636f 725e  "*weights_vecor^
-0000a210: 5420 3d20 220a 2020 2020 2020 2020 2020  T = ".          
-0000a220: 2020 2020 2020 2b20 225b 220a 2020 2020        + "[".    
-0000a230: 2020 2020 2020 2020 2020 2020 2b20 222c              + ",
-0000a240: 222e 6a6f 696e 285b 7374 7228 7369 6d69  ".join([str(simi
-0000a250: 6c61 7269 7469 6573 5b67 5d29 2066 6f72  larities[g]) for
-0000a260: 2067 2069 6e20 7261 6e67 6528 6c65 6e28   g in range(len(
-0000a270: 7369 6d69 6c61 7269 7469 6573 2929 5d29  similarities))])
-0000a280: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a290: 202b 2022 5d2a 220a 2020 2020 2020 2020   + "]*".        
-0000a2a0: 2020 2020 2020 2020 2b20 225b 220a 2020          + "[".  
-0000a2b0: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-0000a2c0: 222c 222e 6a6f 696e 285b 7374 7228 7765  ",".join([str(we
-0000a2d0: 6967 6874 735b 675d 2920 666f 7220 6720  ights[g]) for g 
-0000a2e0: 696e 2072 616e 6765 286c 656e 2873 696d  in range(len(sim
-0000a2f0: 696c 6172 6974 6965 7329 295d 290a 2020  ilarities))]).  
-0000a300: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-0000a310: 225d 5e54 220a 2020 2020 2020 2020 2020  "]^T".          
-0000a320: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-0000a330: 7369 6d69 6c61 7269 7479 5f73 636f 7265  similarity_score
-0000a340: 203d 2072 6f75 6e64 2877 6569 6768 7465   = round(weighte
-0000a350: 645f 6176 6572 6167 652c 2034 290a 2020  d_average, 4).  
-0000a360: 2020 2020 2020 6578 6365 7074 2041 7474        except Att
-0000a370: 7269 6275 7465 4572 726f 723a 0a20 2020  ributeError:.   
-0000a380: 2020 2020 2020 2020 2073 696d 696c 6172           similar
-0000a390: 6974 795f 7363 6f72 6520 3d20 300a 2020  ity_score = 0.  
-0000a3a0: 2020 2020 2020 2020 2020 6465 7461 696c            detail
-0000a3b0: 7320 3d20 2222 0a20 2020 2020 2020 2072  s = "".        r
-0000a3c0: 6574 7572 6e20 7b22 7363 6f72 6522 3a20  eturn {"score": 
-0000a3d0: 7369 6d69 6c61 7269 7479 5f73 636f 7265  similarity_score
-0000a3e0: 2c20 2264 6574 6169 6c73 223a 2064 6574  , "details": det
-0000a3f0: 6169 6c73 7d0a 0a20 2020 2064 6566 2067  ails}..    def g
-0000a400: 6574 5f66 6965 6c64 5f70 726f 7665 6e61  et_field_provena
-0000a410: 6e63 6528 0a20 2020 2020 2020 2073 656c  nce(.        sel
-0000a420: 662c 202a 2c20 6b65 793a 2073 7472 2c20  f, *, key: str, 
-0000a430: 6465 6661 756c 745f 736f 7572 6365 3a20  default_source: 
-0000a440: 7374 7220 3d20 224f 5249 4749 4e41 4c22  str = "ORIGINAL"
-0000a450: 0a20 2020 2029 202d 3e20 6469 6374 3a0a  .    ) -> dict:.
-0000a460: 2020 2020 2020 2020 2222 2247 6574 2074          """Get t
-0000a470: 6865 2070 726f 7665 6e61 6e63 6520 666f  he provenance fo
-0000a480: 7220 6120 7365 6c65 6374 6564 2066 6965  r a selected fie
-0000a490: 6c64 2028 6b65 7929 2222 220a 2020 2020  ld (key)""".    
-0000a4a0: 2020 2020 6465 6661 756c 745f 6e6f 7465      default_note
-0000a4b0: 203d 2022 220a 2020 2020 2020 2020 6e6f   = "".        no
-0000a4c0: 7465 203d 2064 6566 6175 6c74 5f6e 6f74  te = default_not
-0000a4d0: 650a 2020 2020 2020 2020 736f 7572 6365  e.        source
-0000a4e0: 203d 2064 6566 6175 6c74 5f73 6f75 7263   = default_sourc
-0000a4f0: 650a 2020 2020 2020 2020 6966 206b 6579  e.        if key
-0000a500: 2069 6e20 7365 6c66 2e69 6465 6e74 6966   in self.identif
-0000a510: 7969 6e67 5f66 6965 6c64 5f6b 6579 733a  ying_field_keys:
-0000a520: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000a530: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
-0000a540: 7461 5f70 726f 7665 6e61 6e63 6522 2069  ta_provenance" i
-0000a550: 6e20 7365 6c66 2e64 6174 613a 0a20 2020  n self.data:.   
-0000a560: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000a570: 6b65 7920 696e 2073 656c 662e 6461 7461  key in self.data
-0000a580: 2e67 6574 2822 636f 6c72 6576 5f6d 6173  .get("colrev_mas
-0000a590: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-0000a5a0: 6365 222c 207b 7d29 3a0a 2020 2020 2020  ce", {}):.      
-0000a5b0: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0000a5c0: 2022 736f 7572 6365 2220 696e 2073 656c   "source" in sel
-0000a5d0: 662e 6461 7461 5b22 636f 6c72 6576 5f6d  f.data["colrev_m
-0000a5e0: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
-0000a5f0: 616e 6365 225d 5b6b 6579 5d3a 0a20 2020  ance"][key]:.   
-0000a600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a610: 2020 2020 2073 6f75 7263 6520 3d20 7365       source = se
-0000a620: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
-0000a630: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
-0000a640: 6e61 6e63 6522 5d5b 6b65 795d 5b0a 2020  nance"][key][.  
-0000a650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a660: 2020 2020 2020 2020 2020 2273 6f75 7263            "sourc
-0000a670: 6522 0a20 2020 2020 2020 2020 2020 2020  e".             
-0000a680: 2020 2020 2020 2020 2020 205d 0a20 2020             ].   
-0000a690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a6a0: 2069 6620 226e 6f74 6522 2069 6e20 7365   if "note" in se
-0000a6b0: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
-0000a6c0: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
-0000a6d0: 6e61 6e63 6522 5d5b 6b65 795d 3a0a 2020  nance"][key]:.  
-0000a6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a6f0: 2020 2020 2020 6e6f 7465 203d 2073 656c        note = sel
-0000a700: 662e 6461 7461 5b22 636f 6c72 6576 5f6d  f.data["colrev_m
-0000a710: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
-0000a720: 616e 6365 225d 5b6b 6579 5d5b 226e 6f74  ance"][key]["not
-0000a730: 6522 5d0a 2020 2020 2020 2020 656c 7365  e"].        else
-0000a740: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-0000a750: 2022 636f 6c72 6576 5f64 6174 615f 7072   "colrev_data_pr
-0000a760: 6f76 656e 616e 6365 2220 696e 2073 656c  ovenance" in sel
-0000a770: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
-0000a780: 2020 2020 2020 2020 6966 206b 6579 2069          if key i
-0000a790: 6e20 7365 6c66 2e64 6174 615b 2263 6f6c  n self.data["col
-0000a7a0: 7265 765f 6461 7461 5f70 726f 7665 6e61  rev_data_provena
-0000a7b0: 6e63 6522 5d3a 0a20 2020 2020 2020 2020  nce"]:.         
-0000a7c0: 2020 2020 2020 2020 2020 2069 6620 2273             if "s
-0000a7d0: 6f75 7263 6522 2069 6e20 7365 6c66 2e64  ource" in self.d
-0000a7e0: 6174 615b 2263 6f6c 7265 765f 6461 7461  ata["colrev_data
-0000a7f0: 5f70 726f 7665 6e61 6e63 6522 5d5b 6b65  _provenance"][ke
-0000a800: 795d 3a0a 2020 2020 2020 2020 2020 2020  y]:.            
-0000a810: 2020 2020 2020 2020 2020 2020 736f 7572              sour
-0000a820: 6365 203d 2073 656c 662e 6461 7461 5b22  ce = self.data["
-0000a830: 636f 6c72 6576 5f64 6174 615f 7072 6f76  colrev_data_prov
-0000a840: 656e 616e 6365 225d 5b6b 6579 5d5b 2273  enance"][key]["s
-0000a850: 6f75 7263 6522 5d0a 2020 2020 2020 2020  ource"].        
-0000a860: 2020 2020 2020 2020 2020 2020 6966 2022              if "
-0000a870: 6e6f 7465 2220 696e 2073 656c 662e 6461  note" in self.da
-0000a880: 7461 5b22 636f 6c72 6576 5f64 6174 615f  ta["colrev_data_
-0000a890: 7072 6f76 656e 616e 6365 225d 5b6b 6579  provenance"][key
-0000a8a0: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
-0000a8b0: 2020 2020 2020 2020 2020 206e 6f74 6520             note 
-0000a8c0: 3d20 7365 6c66 2e64 6174 615b 2263 6f6c  = self.data["col
-0000a8d0: 7265 765f 6461 7461 5f70 726f 7665 6e61  rev_data_provena
-0000a8e0: 6e63 6522 5d5b 6b65 795d 5b22 6e6f 7465  nce"][key]["note
-0000a8f0: 225d 0a0a 2020 2020 2020 2020 7265 7475  "]..        retu
-0000a900: 726e 207b 2273 6f75 7263 6522 3a20 736f  rn {"source": so
-0000a910: 7572 6365 2c20 226e 6f74 6522 3a20 6e6f  urce, "note": no
-0000a920: 7465 7d0a 0a20 2020 2064 6566 2072 656d  te}..    def rem
-0000a930: 6f76 655f 6d61 7374 6572 6461 7461 5f70  ove_masterdata_p
-0000a940: 726f 7665 6e61 6e63 655f 6e6f 7465 2873  rovenance_note(s
-0000a950: 656c 662c 202a 2c20 6b65 793a 2073 7472  elf, *, key: str
-0000a960: 2c20 6e6f 7465 3a20 7374 7229 202d 3e20  , note: str) -> 
-0000a970: 4e6f 6e65 3a0a 2020 2020 2020 2020 2222  None:.        ""
-0000a980: 2252 656d 6f76 6520 6120 6d61 7374 6572  "Remove a master
-0000a990: 6461 7461 2070 726f 7665 6e61 6e63 6520  data provenance 
-0000a9a0: 6e6f 7465 2222 220a 2020 2020 2020 2020  note""".        
-0000a9b0: 6966 2022 636f 6c72 6576 5f6d 6173 7465  if "colrev_maste
-0000a9c0: 7264 6174 615f 7072 6f76 656e 616e 6365  rdata_provenance
-0000a9d0: 2220 6e6f 7420 696e 2073 656c 662e 6461  " not in self.da
-0000a9e0: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
-0000a9f0: 7265 7475 726e 0a20 2020 2020 2020 2069  return.        i
-0000aa00: 6620 6b65 7920 6e6f 7420 696e 2073 656c  f key not in sel
-0000aa10: 662e 6461 7461 5b22 636f 6c72 6576 5f6d  f.data["colrev_m
-0000aa20: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
-0000aa30: 616e 6365 225d 3a0a 2020 2020 2020 2020  ance"]:.        
-0000aa40: 2020 2020 7265 7475 726e 0a20 2020 2020      return.     
-0000aa50: 2020 206e 6f74 6573 203d 2073 656c 662e     notes = self.
-0000aa60: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
-0000aa70: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-0000aa80: 6365 225d 5b6b 6579 5d5b 226e 6f74 6522  ce"][key]["note"
-0000aa90: 5d2e 7370 6c69 7428 222c 2229 0a20 2020  ].split(",").   
-0000aaa0: 2020 2020 2069 6620 6e6f 7465 206e 6f74       if note not
-0000aab0: 2069 6e20 6e6f 7465 733a 0a20 2020 2020   in notes:.     
-0000aac0: 2020 2020 2020 2072 6574 7572 6e0a 2020         return.  
-0000aad0: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
-0000aae0: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
-0000aaf0: 7461 5f70 726f 7665 6e61 6e63 6522 5d5b  ta_provenance"][
-0000ab00: 6b65 795d 5b22 6e6f 7465 225d 203d 2022  key]["note"] = "
-0000ab10: 2c22 2e6a 6f69 6e28 0a20 2020 2020 2020  ,".join(.       
-0000ab20: 2020 2020 206e 2066 6f72 206e 2069 6e20       n for n in 
-0000ab30: 6e6f 7465 7320 6966 206e 2021 3d20 6e6f  notes if n != no
-0000ab40: 7465 0a20 2020 2020 2020 2029 0a0a 2020  te.        )..  
-0000ab50: 2020 6465 6620 6164 645f 6d61 7374 6572    def add_master
-0000ab60: 6461 7461 5f70 726f 7665 6e61 6e63 655f  data_provenance_
-0000ab70: 6e6f 7465 2873 656c 662c 202a 2c20 6b65  note(self, *, ke
-0000ab80: 793a 2073 7472 2c20 6e6f 7465 3a20 7374  y: str, note: st
-0000ab90: 7229 202d 3e20 4e6f 6e65 3a0a 2020 2020  r) -> None:.    
-0000aba0: 2020 2020 2222 2241 6464 2061 206d 6173      """Add a mas
-0000abb0: 7465 7264 6174 6120 7072 6f76 656e 616e  terdata provenan
-0000abc0: 6365 206e 6f74 6520 2862 6173 6564 206f  ce note (based o
-0000abd0: 6e20 6120 6b65 7929 2222 220a 2020 2020  n a key)""".    
-0000abe0: 2020 2020 6966 2022 636f 6c72 6576 5f6d      if "colrev_m
-0000abf0: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
-0000ac00: 616e 6365 2220 6e6f 7420 696e 2073 656c  ance" not in sel
-0000ac10: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
-0000ac20: 2020 2020 7365 6c66 2e64 6174 615b 2263      self.data["c
-0000ac30: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
-0000ac40: 5f70 726f 7665 6e61 6e63 6522 5d20 3d20  _provenance"] = 
-0000ac50: 7b7d 0a20 2020 2020 2020 2069 6620 6b65  {}.        if ke
-0000ac60: 7920 696e 2073 656c 662e 6461 7461 2e67  y in self.data.g
-0000ac70: 6574 2822 636f 6c72 6576 5f6d 6173 7465  et("colrev_maste
-0000ac80: 7264 6174 615f 7072 6f76 656e 616e 6365  rdata_provenance
-0000ac90: 222c 207b 7d29 3a0a 2020 2020 2020 2020  ", {}):.        
-0000aca0: 2020 2020 6966 2028 0a20 2020 2020 2020      if (.       
-0000acb0: 2020 2020 2020 2020 2022 2220 3d3d 2073           "" == s
-0000acc0: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
-0000acd0: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
-0000ace0: 656e 616e 6365 225d 5b6b 6579 5d5b 226e  enance"][key]["n
-0000acf0: 6f74 6522 5d0a 2020 2020 2020 2020 2020  ote"].          
-0000ad00: 2020 2020 2020 6f72 2022 2220 3d3d 206e        or "" == n
-0000ad10: 6f74 650a 2020 2020 2020 2020 2020 2020  ote.            
-0000ad20: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-0000ad30: 2020 2073 656c 662e 6461 7461 5b22 636f     self.data["co
-0000ad40: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
-0000ad50: 7072 6f76 656e 616e 6365 225d 5b6b 6579  provenance"][key
-0000ad60: 5d5b 226e 6f74 6522 5d20 3d20 6e6f 7465  ]["note"] = note
-0000ad70: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
-0000ad80: 6620 6e6f 7465 206e 6f74 2069 6e20 7365  f note not in se
-0000ad90: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
-0000ada0: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
-0000adb0: 6e61 6e63 6522 5d5b 6b65 795d 5b0a 2020  nance"][key][.  
-0000adc0: 2020 2020 2020 2020 2020 2020 2020 226e                "n
-0000add0: 6f74 6522 0a20 2020 2020 2020 2020 2020  ote".           
-0000ade0: 205d 2e73 706c 6974 2822 2c22 293a 0a20   ].split(","):. 
-0000adf0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0000ae00: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
-0000ae10: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
-0000ae20: 656e 616e 6365 225d 5b6b 6579 5d5b 226e  enance"][key]["n
-0000ae30: 6f74 6522 5d20 2b3d 2066 222c 7b6e 6f74  ote"] += f",{not
-0000ae40: 657d 220a 2020 2020 2020 2020 656c 7365  e}".        else
-0000ae50: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
-0000ae60: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
-0000ae70: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
-0000ae80: 6e61 6e63 6522 5d5b 6b65 795d 203d 207b  nance"][key] = {
-0000ae90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000aea0: 2022 736f 7572 6365 223a 2022 4f52 4947   "source": "ORIG
-0000aeb0: 494e 414c 222c 0a20 2020 2020 2020 2020  INAL",.         
-0000aec0: 2020 2020 2020 2022 6e6f 7465 223a 206e         "note": n
-0000aed0: 6f74 652c 0a20 2020 2020 2020 2020 2020  ote,.           
-0000aee0: 207d 0a0a 2020 2020 2020 2020 6578 6973   }..        exis
-0000aef0: 7469 6e67 5f6e 6f74 6520 3d20 7365 6c66  ting_note = self
-0000af00: 2e64 6174 615b 2263 6f6c 7265 765f 6d61  .data["colrev_ma
-0000af10: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
-0000af20: 6e63 6522 5d5b 6b65 795d 5b22 6e6f 7465  nce"][key]["note
-0000af30: 225d 0a20 2020 2020 2020 2069 6620 2271  "].        if "q
-0000af40: 7561 6c69 7479 5f64 6566 6563 7422 2069  uality_defect" i
-0000af50: 6e20 6578 6973 7469 6e67 5f6e 6f74 6520  n existing_note 
-0000af60: 616e 6420 616e 7928 0a20 2020 2020 2020  and any(.       
-0000af70: 2020 2020 2078 2069 6e20 6578 6973 7469       x in existi
-0000af80: 6e67 5f6e 6f74 6520 666f 7220 7820 696e  ng_note for x in
-0000af90: 205b 226d 6973 7369 6e67 222c 2022 6469   ["missing", "di
-0000afa0: 7361 6772 6565 6d65 6e74 225d 0a20 2020  sagreement"].   
-0000afb0: 2020 2020 2029 3a0a 2020 2020 2020 2020       ):.        
-0000afc0: 2020 2020 7365 6c66 2e64 6174 615b 2263      self.data["c
-0000afd0: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
-0000afe0: 5f70 726f 7665 6e61 6e63 6522 5d5b 6b65  _provenance"][ke
-0000aff0: 795d 5b22 6e6f 7465 225d 203d 2028 0a20  y]["note"] = (. 
-0000b000: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-0000b010: 7869 7374 696e 675f 6e6f 7465 2e72 6570  xisting_note.rep
-0000b020: 6c61 6365 2822 7175 616c 6974 795f 6465  lace("quality_de
-0000b030: 6665 6374 222c 2022 2229 2e72 7374 7269  fect", "").rstri
-0000b040: 7028 222c 2229 2e6c 7374 7269 7028 222c  p(",").lstrip(",
-0000b050: 2229 0a20 2020 2020 2020 2020 2020 2029  ").            )
-0000b060: 0a0a 2020 2020 6465 6620 6164 645f 6461  ..    def add_da
-0000b070: 7461 5f70 726f 7665 6e61 6e63 655f 6e6f  ta_provenance_no
-0000b080: 7465 2873 656c 662c 202a 2c20 6b65 793a  te(self, *, key:
-0000b090: 2073 7472 2c20 6e6f 7465 3a20 7374 7229   str, note: str)
-0000b0a0: 202d 3e20 4e6f 6e65 3a0a 2020 2020 2020   -> None:.      
-0000b0b0: 2020 2222 2241 6464 2061 2064 6174 6120    """Add a data 
-0000b0c0: 7072 6f76 656e 616e 6365 206e 6f74 6520  provenance note 
-0000b0d0: 2862 6173 6564 206f 6e20 6120 6b65 7929  (based on a key)
-0000b0e0: 2222 220a 2020 2020 2020 2020 6966 2022  """.        if "
-0000b0f0: 636f 6c72 6576 5f64 6174 615f 7072 6f76  colrev_data_prov
-0000b100: 656e 616e 6365 2220 6e6f 7420 696e 2073  enance" not in s
-0000b110: 656c 662e 6461 7461 3a0a 2020 2020 2020  elf.data:.      
-0000b120: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
-0000b130: 2263 6f6c 7265 765f 6461 7461 5f70 726f  "colrev_data_pro
-0000b140: 7665 6e61 6e63 6522 5d20 3d20 7b7d 0a20  venance"] = {}. 
-0000b150: 2020 2020 2020 2069 6620 6b65 7920 696e         if key in
-0000b160: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
-0000b170: 6576 5f64 6174 615f 7072 6f76 656e 616e  ev_data_provenan
-0000b180: 6365 225d 3a0a 2020 2020 2020 2020 2020  ce"]:.          
-0000b190: 2020 6966 2073 656c 662e 6461 7461 5b22    if self.data["
-0000b1a0: 636f 6c72 6576 5f64 6174 615f 7072 6f76  colrev_data_prov
-0000b1b0: 656e 616e 6365 225d 5b6b 6579 5d5b 226e  enance"][key]["n
-0000b1c0: 6f74 6522 5d20 3d3d 2022 223a 0a20 2020  ote"] == "":.   
-0000b1d0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-0000b1e0: 662e 6461 7461 5b22 636f 6c72 6576 5f64  f.data["colrev_d
-0000b1f0: 6174 615f 7072 6f76 656e 616e 6365 225d  ata_provenance"]
-0000b200: 5b6b 6579 5d5b 226e 6f74 6522 5d20 3d20  [key]["note"] = 
-0000b210: 6e6f 7465 0a20 2020 2020 2020 2020 2020  note.           
-0000b220: 2065 6c69 6620 6e6f 7465 206e 6f74 2069   elif note not i
-0000b230: 6e20 7365 6c66 2e64 6174 615b 2263 6f6c  n self.data["col
-0000b240: 7265 765f 6461 7461 5f70 726f 7665 6e61  rev_data_provena
-0000b250: 6e63 6522 5d5b 6b65 795d 5b22 6e6f 7465  nce"][key]["note
-0000b260: 225d 2e73 706c 6974 280a 2020 2020 2020  "].split(.      
-0000b270: 2020 2020 2020 2020 2020 222c 220a 2020            ",".  
-0000b280: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
-0000b290: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-0000b2a0: 662e 6461 7461 5b22 636f 6c72 6576 5f64  f.data["colrev_d
-0000b2b0: 6174 615f 7072 6f76 656e 616e 6365 225d  ata_provenance"]
-0000b2c0: 5b6b 6579 5d5b 226e 6f74 6522 5d20 2b3d  [key]["note"] +=
-0000b2d0: 2066 222c 7b6e 6f74 657d 220a 2020 2020   f",{note}".    
-0000b2e0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0000b2f0: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
-0000b300: 2263 6f6c 7265 765f 6461 7461 5f70 726f  "colrev_data_pro
-0000b310: 7665 6e61 6e63 6522 5d5b 6b65 795d 203d  venance"][key] =
-0000b320: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-0000b330: 2020 2022 736f 7572 6365 223a 2022 4f52     "source": "OR
-0000b340: 4947 494e 414c 222c 0a20 2020 2020 2020  IGINAL",.       
-0000b350: 2020 2020 2020 2020 2022 6e6f 7465 223a           "note":
-0000b360: 206e 6f74 652c 0a20 2020 2020 2020 2020   note,.         
-0000b370: 2020 207d 0a0a 2020 2020 6465 6620 6164     }..    def ad
-0000b380: 645f 6d61 7374 6572 6461 7461 5f70 726f  d_masterdata_pro
-0000b390: 7665 6e61 6e63 6528 0a20 2020 2020 2020  venance(.       
-0000b3a0: 2073 656c 662c 202a 2c20 6b65 793a 2073   self, *, key: s
-0000b3b0: 7472 2c20 736f 7572 6365 3a20 7374 722c  tr, source: str,
-0000b3c0: 206e 6f74 653a 2073 7472 203d 2022 220a   note: str = "".
-0000b3d0: 2020 2020 2920 2d3e 204e 6f6e 653a 0a20      ) -> None:. 
-0000b3e0: 2020 2020 2020 2022 2222 4164 6420 6120         """Add a 
-0000b3f0: 6d61 7374 6572 6461 7461 2070 726f 7665  masterdata prove
-0000b400: 6e61 6e63 652c 2069 6e63 6c75 6469 6e67  nance, including
-0000b410: 2073 6f75 7263 6520 616e 6420 6e6f 7465   source and note
-0000b420: 2028 6261 7365 6420 6f6e 2061 206b 6579   (based on a key
-0000b430: 2922 2222 0a20 2020 2020 2020 2069 6620  )""".        if 
-0000b440: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
-0000b450: 7461 5f70 726f 7665 6e61 6e63 6522 206e  ta_provenance" n
-0000b460: 6f74 2069 6e20 7365 6c66 2e64 6174 613a  ot in self.data:
-0000b470: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-0000b480: 662e 6461 7461 5b22 636f 6c72 6576 5f6d  f.data["colrev_m
-0000b490: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
-0000b4a0: 616e 6365 225d 203d 207b 7d0a 2020 2020  ance"] = {}.    
-0000b4b0: 2020 2020 6d64 5f70 5f64 6963 7420 3d20      md_p_dict = 
-0000b4c0: 7365 6c66 2e64 6174 615b 2263 6f6c 7265  self.data["colre
-0000b4d0: 765f 6d61 7374 6572 6461 7461 5f70 726f  v_masterdata_pro
-0000b4e0: 7665 6e61 6e63 6522 5d0a 0a20 2020 2020  venance"]..     
-0000b4f0: 2020 2069 6620 6b65 7920 696e 206d 645f     if key in md_
-0000b500: 705f 6469 6374 3a0a 2020 2020 2020 2020  p_dict:.        
-0000b510: 2020 2020 6966 206d 645f 705f 6469 6374      if md_p_dict
-0000b520: 5b6b 6579 5d5b 226e 6f74 6522 5d20 3d3d  [key]["note"] ==
-0000b530: 2022 2220 6f72 2022 2220 3d3d 206e 6f74   "" or "" == not
-0000b540: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0000b550: 2020 206d 645f 705f 6469 6374 5b6b 6579     md_p_dict[key
-0000b560: 5d5b 226e 6f74 6522 5d20 3d20 6e6f 7465  ]["note"] = note
-0000b570: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
-0000b580: 6620 226d 6973 7369 6e67 2220 3d3d 206e  f "missing" == n
-0000b590: 6f74 6520 616e 6420 226e 6f74 2d6d 6973  ote and "not-mis
-0000b5a0: 7369 6e67 2220 696e 206d 645f 705f 6469  sing" in md_p_di
-0000b5b0: 6374 5b6b 6579 5d5b 226e 6f74 6522 5d2e  ct[key]["note"].
-0000b5c0: 7370 6c69 7428 0a20 2020 2020 2020 2020  split(.         
-0000b5d0: 2020 2020 2020 2022 2c22 0a20 2020 2020         ",".     
-0000b5e0: 2020 2020 2020 2029 3a0a 2020 2020 2020         ):.      
-0000b5f0: 2020 2020 2020 2020 2020 6d64 5f70 5f64            md_p_d
-0000b600: 6963 745b 6b65 795d 5b22 6e6f 7465 225d  ict[key]["note"]
-0000b610: 203d 2022 6d69 7373 696e 6722 0a20 2020   = "missing".   
-0000b620: 2020 2020 2020 2020 2065 6c69 6620 6e6f           elif no
-0000b630: 7465 206e 6f74 2069 6e20 6d64 5f70 5f64  te not in md_p_d
-0000b640: 6963 745b 6b65 795d 5b22 6e6f 7465 225d  ict[key]["note"]
-0000b650: 2e73 706c 6974 2822 2c22 293a 0a20 2020  .split(","):.   
-0000b660: 2020 2020 2020 2020 2020 2020 206d 645f               md_
-0000b670: 705f 6469 6374 5b6b 6579 5d5b 226e 6f74  p_dict[key]["not
-0000b680: 6522 5d20 2b3d 2066 222c 7b6e 6f74 657d  e"] += f",{note}
-0000b690: 220a 2020 2020 2020 2020 2020 2020 6d64  ".            md
-0000b6a0: 5f70 5f64 6963 745b 6b65 795d 5b22 736f  _p_dict[key]["so
-0000b6b0: 7572 6365 225d 203d 2073 6f75 7263 650a  urce"] = source.
-0000b6c0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0000b6d0: 2020 2020 2020 2020 2020 6d64 5f70 5f64            md_p_d
-0000b6e0: 6963 745b 6b65 795d 203d 207b 2273 6f75  ict[key] = {"sou
-0000b6f0: 7263 6522 3a20 736f 7572 6365 2c20 226e  rce": source, "n
-0000b700: 6f74 6522 3a20 6622 7b6e 6f74 657d 227d  ote": f"{note}"}
-0000b710: 0a0a 2020 2020 6465 6620 6164 645f 7072  ..    def add_pr
-0000b720: 6f76 656e 616e 6365 5f61 6c6c 2873 656c  ovenance_all(sel
-0000b730: 662c 202a 2c20 736f 7572 6365 3a20 7374  f, *, source: st
-0000b740: 7229 202d 3e20 4e6f 6e65 3a0a 2020 2020  r) -> None:.    
-0000b750: 2020 2020 2222 2241 6464 2061 2064 6174      """Add a dat
-0000b760: 6120 7072 6f76 656e 616e 6365 2028 736f  a provenance (so
-0000b770: 7572 6365 2920 746f 2061 6c6c 2066 6965  urce) to all fie
-0000b780: 6c64 7322 2222 0a20 2020 2020 2020 2069  lds""".        i
-0000b790: 6620 2263 6f6c 7265 765f 6d61 7374 6572  f "colrev_master
-0000b7a0: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
-0000b7b0: 206e 6f74 2069 6e20 7365 6c66 2e64 6174   not in self.dat
-0000b7c0: 613a 0a20 2020 2020 2020 2020 2020 2073  a:.            s
-0000b7d0: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
-0000b7e0: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
-0000b7f0: 656e 616e 6365 225d 203d 207b 7d0a 2020  enance"] = {}.  
-0000b800: 2020 2020 2020 6966 2022 636f 6c72 6576        if "colrev
-0000b810: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
-0000b820: 2220 6e6f 7420 696e 2073 656c 662e 6461  " not in self.da
-0000b830: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
-0000b840: 7365 6c66 2e64 6174 615b 2263 6f6c 7265  self.data["colre
-0000b850: 765f 6461 7461 5f70 726f 7665 6e61 6e63  v_data_provenanc
-0000b860: 6522 5d20 3d20 7b7d 0a0a 2020 2020 2020  e"] = {}..      
-0000b870: 2020 6d64 5f70 5f64 6963 7420 3d20 7365    md_p_dict = se
-0000b880: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
-0000b890: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
-0000b8a0: 6e61 6e63 6522 5d0a 2020 2020 2020 2020  nance"].        
-0000b8b0: 645f 705f 6469 6374 203d 2073 656c 662e  d_p_dict = self.
-0000b8c0: 6461 7461 5b22 636f 6c72 6576 5f64 6174  data["colrev_dat
-0000b8d0: 615f 7072 6f76 656e 616e 6365 225d 0a20  a_provenance"]. 
-0000b8e0: 2020 2020 2020 2066 6f72 206b 6579 2069         for key i
-0000b8f0: 6e20 7365 6c66 2e64 6174 612e 6b65 7973  n self.data.keys
-0000b900: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
-0000b910: 6966 206b 6579 2069 6e20 5b0a 2020 2020  if key in [.    
-0000b920: 2020 2020 2020 2020 2020 2020 2245 4e54              "ENT
-0000b930: 5259 5459 5045 222c 0a20 2020 2020 2020  RYTYPE",.       
-0000b940: 2020 2020 2020 2020 2022 636f 6c72 6576           "colrev
-0000b950: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
-0000b960: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
-0000b970: 2020 2022 636f 6c72 6576 5f6d 6173 7465     "colrev_maste
-0000b980: 7264 6174 615f 7072 6f76 656e 616e 6365  rdata_provenance
-0000b990: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
-0000b9a0: 2020 2022 636f 6c72 6576 5f73 7461 7475     "colrev_statu
-0000b9b0: 7322 2c0a 2020 2020 2020 2020 2020 2020  s",.            
-0000b9c0: 2020 2020 2263 6f6c 7265 765f 6964 222c      "colrev_id",
-0000b9d0: 0a20 2020 2020 2020 2020 2020 205d 3a0a  .            ]:.
-0000b9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b9f0: 636f 6e74 696e 7565 0a20 2020 2020 2020  continue.       
-0000ba00: 2020 2020 2069 6620 280a 2020 2020 2020       if (.      
-0000ba10: 2020 2020 2020 2020 2020 6b65 7920 696e            key in
-0000ba20: 2073 656c 662e 6964 656e 7469 6679 696e   self.identifyin
-0000ba30: 675f 6669 656c 645f 6b65 7973 0a20 2020  g_field_keys.   
-0000ba40: 2020 2020 2020 2020 2020 2020 2061 6e64               and
-0000ba50: 2022 4355 5241 5445 4422 206e 6f74 2069   "CURATED" not i
-0000ba60: 6e20 7365 6c66 2e64 6174 615b 2263 6f6c  n self.data["col
-0000ba70: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
-0000ba80: 726f 7665 6e61 6e63 6522 5d0a 2020 2020  rovenance"].    
-0000ba90: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
-0000baa0: 2020 2020 2020 2020 2020 206d 645f 705f             md_p_
-0000bab0: 6469 6374 5b6b 6579 5d20 3d20 7b22 736f  dict[key] = {"so
-0000bac0: 7572 6365 223a 2073 6f75 7263 652c 2022  urce": source, "
-0000bad0: 6e6f 7465 223a 2022 227d 0a20 2020 2020  note": ""}.     
-0000bae0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0000baf0: 2020 2020 2020 2020 2020 2020 2064 5f70               d_p
-0000bb00: 5f64 6963 745b 6b65 795d 203d 207b 2273  _dict[key] = {"s
-0000bb10: 6f75 7263 6522 3a20 736f 7572 6365 2c20  ource": source, 
-0000bb20: 226e 6f74 6522 3a20 2222 7d0a 0a20 2020  "note": ""}..   
-0000bb30: 2064 6566 2061 6464 5f64 6174 615f 7072   def add_data_pr
-0000bb40: 6f76 656e 616e 6365 2873 656c 662c 202a  ovenance(self, *
-0000bb50: 2c20 6b65 793a 2073 7472 2c20 736f 7572  , key: str, sour
-0000bb60: 6365 3a20 7374 722c 206e 6f74 653a 2073  ce: str, note: s
-0000bb70: 7472 203d 2022 2229 202d 3e20 4e6f 6e65  tr = "") -> None
-0000bb80: 3a0a 2020 2020 2020 2020 2222 2241 6464  :.        """Add
-0000bb90: 2061 2064 6174 6120 7072 6f76 656e 616e   a data provenan
-0000bba0: 6365 2c20 696e 636c 7564 696e 6720 736f  ce, including so
-0000bbb0: 7572 6365 2061 6e64 206e 6f74 6520 2862  urce and note (b
-0000bbc0: 6173 6564 206f 6e20 6120 6b65 7929 2222  ased on a key)""
-0000bbd0: 220a 2020 2020 2020 2020 6966 2022 636f  ".        if "co
-0000bbe0: 6c72 6576 5f64 6174 615f 7072 6f76 656e  lrev_data_proven
-0000bbf0: 616e 6365 2220 6e6f 7420 696e 2073 656c  ance" not in sel
-0000bc00: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
-0000bc10: 2020 2020 7365 6c66 2e64 6174 615b 2263      self.data["c
-0000bc20: 6f6c 7265 765f 6461 7461 5f70 726f 7665  olrev_data_prove
-0000bc30: 6e61 6e63 6522 5d20 3d20 7b7d 0a20 2020  nance"] = {}.   
-0000bc40: 2020 2020 206d 645f 705f 6469 6374 203d       md_p_dict =
-0000bc50: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
-0000bc60: 6576 5f64 6174 615f 7072 6f76 656e 616e  ev_data_provenan
-0000bc70: 6365 225d 0a20 2020 2020 2020 2069 6620  ce"].        if 
-0000bc80: 6b65 7920 696e 206d 645f 705f 6469 6374  key in md_p_dict
-0000bc90: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-0000bca0: 206e 6f74 6520 213d 2022 223a 0a20 2020   note != "":.   
-0000bcb0: 2020 2020 2020 2020 2020 2020 206d 645f               md_
-0000bcc0: 705f 6469 6374 5b6b 6579 5d5b 226e 6f74  p_dict[key]["not
-0000bcd0: 6522 5d20 2b3d 2066 222c 7b6e 6f74 657d  e"] += f",{note}
-0000bce0: 220a 2020 2020 2020 2020 2020 2020 656c  ".            el
-0000bcf0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000bd00: 2020 2020 6d64 5f70 5f64 6963 745b 6b65      md_p_dict[ke
-0000bd10: 795d 5b22 6e6f 7465 225d 203d 2022 220a  y]["note"] = "".
-0000bd20: 2020 2020 2020 2020 2020 2020 6d64 5f70              md_p
-0000bd30: 5f64 6963 745b 6b65 795d 5b22 736f 7572  _dict[key]["sour
-0000bd40: 6365 225d 203d 2073 6f75 7263 650a 2020  ce"] = source.  
-0000bd50: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0000bd60: 2020 2020 2020 2020 6d64 5f70 5f64 6963          md_p_dic
-0000bd70: 745b 6b65 795d 203d 207b 2273 6f75 7263  t[key] = {"sourc
-0000bd80: 6522 3a20 736f 7572 6365 2c20 226e 6f74  e": source, "not
-0000bd90: 6522 3a20 6622 7b6e 6f74 657d 227d 0a0a  e": f"{note}"}..
-0000bda0: 2020 2020 6465 6620 636f 6d70 6c65 7465      def complete
-0000bdb0: 5f70 726f 7665 6e61 6e63 6528 7365 6c66  _provenance(self
-0000bdc0: 2c20 2a2c 2073 6f75 7263 655f 696e 666f  , *, source_info
-0000bdd0: 3a20 7374 7229 202d 3e20 626f 6f6c 3a0a  : str) -> bool:.
-0000bde0: 2020 2020 2020 2020 2222 2243 6f6d 706c          """Compl
-0000bdf0: 6574 6520 7072 6f76 656e 616e 6365 2069  ete provenance i
-0000be00: 6e66 6f72 6d61 7469 6f6e 2066 6f72 2069  nformation for i
-0000be10: 6e64 6578 696e 6722 2222 0a0a 2020 2020  ndexing"""..    
-0000be20: 2020 2020 666f 7220 6b65 7920 696e 206c      for key in l
-0000be30: 6973 7428 7365 6c66 2e64 6174 612e 6b65  ist(self.data.ke
-0000be40: 7973 2829 293a 0a20 2020 2020 2020 2020  ys()):.         
-0000be50: 2020 2069 6620 280a 2020 2020 2020 2020     if (.        
-0000be60: 2020 2020 2020 2020 6b65 790a 2020 2020          key.    
-0000be70: 2020 2020 2020 2020 2020 2020 696e 205b              in [
-0000be80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000be90: 2020 2020 2022 636f 6c72 6576 5f69 6422       "colrev_id"
-0000bea0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000beb0: 2020 2020 2020 2245 4e54 5259 5459 5045        "ENTRYTYPE
-0000bec0: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
-0000bed0: 2020 2020 2020 2022 4944 222c 0a20 2020         "ID",.   
-0000bee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bef0: 2022 6d65 7461 6461 7461 5f73 6f75 7263   "metadata_sourc
-0000bf00: 655f 7265 706f 7369 746f 7279 5f70 6174  e_repository_pat
-0000bf10: 6873 222c 0a20 2020 2020 2020 2020 2020  hs",.           
-0000bf20: 2020 2020 2020 2020 2022 6c6f 6361 6c5f           "local_
-0000bf30: 6375 7261 7465 645f 6d65 7461 6461 7461  curated_metadata
-0000bf40: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
-0000bf50: 2020 205d 0a20 2020 2020 2020 2020 2020     ].           
-0000bf60: 2020 2020 202b 2073 656c 662e 7072 6f76       + self.prov
-0000bf70: 656e 616e 6365 5f6b 6579 730a 2020 2020  enance_keys.    
-0000bf80: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
-0000bf90: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
-0000bfa0: 6e75 650a 0a20 2020 2020 2020 2020 2020  nue..           
-0000bfb0: 2069 6620 6b65 7920 696e 2073 656c 662e   if key in self.
-0000bfc0: 6964 656e 7469 6679 696e 675f 6669 656c  identifying_fiel
-0000bfd0: 645f 6b65 7973 3a0a 2020 2020 2020 2020  d_keys:.        
-0000bfe0: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
-0000bff0: 656c 662e 6d61 7374 6572 6461 7461 5f69  elf.masterdata_i
-0000c000: 735f 6375 7261 7465 6428 293a 0a20 2020  s_curated():.   
-0000c010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c020: 2073 656c 662e 6164 645f 6d61 7374 6572   self.add_master
-0000c030: 6461 7461 5f70 726f 7665 6e61 6e63 6528  data_provenance(
-0000c040: 6b65 793d 6b65 792c 2073 6f75 7263 653d  key=key, source=
-0000c050: 736f 7572 6365 5f69 6e66 6f2c 206e 6f74  source_info, not
-0000c060: 653d 2222 290a 2020 2020 2020 2020 2020  e="").          
-0000c070: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0000c080: 2020 2020 2020 2020 7365 6c66 2e61 6464          self.add
-0000c090: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
-0000c0a0: 286b 6579 3d6b 6579 2c20 736f 7572 6365  (key=key, source
-0000c0b0: 3d73 6f75 7263 655f 696e 666f 2c20 6e6f  =source_info, no
-0000c0c0: 7465 3d22 2229 0a0a 2020 2020 2020 2020  te="")..        
-0000c0d0: 7265 7475 726e 2054 7275 650a 0a20 2020  return True..   
-0000c0e0: 2064 6566 2068 6173 5f71 7561 6c69 7479   def has_quality
-0000c0f0: 5f64 6566 6563 7473 2873 656c 6629 202d  _defects(self) -
-0000c100: 3e20 626f 6f6c 3a0a 2020 2020 2020 2020  > bool:.        
-0000c110: 2222 2243 6865 636b 2077 6865 7468 6572  """Check whether
-0000c120: 2061 2072 6563 6f72 6420 6861 7320 7175   a record has qu
-0000c130: 616c 6974 7920 6465 6665 6374 7322 2222  ality defects"""
-0000c140: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-0000c150: 616e 7928 0a20 2020 2020 2020 2020 2020  any(.           
-0000c160: 2078 5b22 6e6f 7465 225d 2021 3d20 2222   x["note"] != ""
-0000c170: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-0000c180: 2078 2069 6e20 7365 6c66 2e64 6174 612e   x in self.data.
-0000c190: 6765 7428 2263 6f6c 7265 765f 6d61 7374  get("colrev_mast
-0000c1a0: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
-0000c1b0: 6522 2c20 7b7d 292e 7661 6c75 6573 2829  e", {}).values()
-0000c1c0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000c1d0: 6e6f 7420 616e 7928 7920 3d3d 2078 5b22  not any(y == x["
-0000c1e0: 6e6f 7465 225d 2066 6f72 2079 2069 6e20  note"] for y in 
-0000c1f0: 5b22 6e6f 742d 6d69 7373 696e 6722 5d29  ["not-missing"])
-0000c200: 0a20 2020 2020 2020 2029 0a0a 2020 2020  .        )..    
-0000c210: 6465 6620 6765 745f 636f 6e74 6169 6e65  def get_containe
-0000c220: 725f 7469 746c 6528 7365 6c66 2920 2d3e  r_title(self) ->
-0000c230: 2073 7472 3a0a 2020 2020 2020 2020 2222   str:.        ""
-0000c240: 2247 6574 2074 6865 2072 6563 6f72 6427  "Get the record'
-0000c250: 7320 636f 6e74 6169 6e65 7220 7469 746c  s container titl
-0000c260: 6520 286a 6f75 726e 616c 206e 616d 652c  e (journal name,
-0000c270: 2062 6f6f 6b74 6974 6c65 2c20 6574 632e   booktitle, etc.
-0000c280: 2922 2222 0a20 2020 2020 2020 2063 6f6e  )""".        con
-0000c290: 7461 696e 6572 5f74 6974 6c65 203d 2022  tainer_title = "
-0000c2a0: 4e41 220a 2020 2020 2020 2020 6966 2022  NA".        if "
-0000c2b0: 454e 5452 5954 5950 4522 206e 6f74 2069  ENTRYTYPE" not i
-0000c2c0: 6e20 7365 6c66 2e64 6174 613a 0a20 2020  n self.data:.   
-0000c2d0: 2020 2020 2020 2020 2063 6f6e 7461 696e           contain
-0000c2e0: 6572 5f74 6974 6c65 203d 2073 656c 662e  er_title = self.
-0000c2f0: 6461 7461 2e67 6574 2822 6a6f 7572 6e61  data.get("journa
-0000c300: 6c22 2c20 7365 6c66 2e64 6174 612e 6765  l", self.data.ge
-0000c310: 7428 2262 6f6f 6b74 6974 6c65 222c 2022  t("booktitle", "
-0000c320: 4e41 2229 290a 2020 2020 2020 2020 656c  NA")).        el
-0000c330: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000c340: 6966 2073 656c 662e 6461 7461 5b22 454e  if self.data["EN
-0000c350: 5452 5954 5950 4522 5d20 3d3d 2022 6172  TRYTYPE"] == "ar
-0000c360: 7469 636c 6522 3a0a 2020 2020 2020 2020  ticle":.        
-0000c370: 2020 2020 2020 2020 636f 6e74 6169 6e65          containe
-0000c380: 725f 7469 746c 6520 3d20 7365 6c66 2e64  r_title = self.d
-0000c390: 6174 612e 6765 7428 226a 6f75 726e 616c  ata.get("journal
-0000c3a0: 222c 2022 4e41 2229 0a20 2020 2020 2020  ", "NA").       
-0000c3b0: 2020 2020 2069 6620 7365 6c66 2e64 6174       if self.dat
-0000c3c0: 615b 2245 4e54 5259 5459 5045 225d 203d  a["ENTRYTYPE"] =
-0000c3d0: 3d20 2269 6e70 726f 6365 6564 696e 6773  = "inproceedings
-0000c3e0: 223a 0a20 2020 2020 2020 2020 2020 2020  ":.             
-0000c3f0: 2020 2063 6f6e 7461 696e 6572 5f74 6974     container_tit
-0000c400: 6c65 203d 2073 656c 662e 6461 7461 2e67  le = self.data.g
-0000c410: 6574 2822 626f 6f6b 7469 746c 6522 2c20  et("booktitle", 
-0000c420: 224e 4122 290a 2020 2020 2020 2020 2020  "NA").          
-0000c430: 2020 6966 2073 656c 662e 6461 7461 5b22    if self.data["
-0000c440: 454e 5452 5954 5950 4522 5d20 3d3d 2022  ENTRYTYPE"] == "
-0000c450: 626f 6f6b 223a 0a20 2020 2020 2020 2020  book":.         
-0000c460: 2020 2020 2020 2063 6f6e 7461 696e 6572         container
-0000c470: 5f74 6974 6c65 203d 2073 656c 662e 6461  _title = self.da
-0000c480: 7461 2e67 6574 2822 7469 746c 6522 2c20  ta.get("title", 
-0000c490: 224e 4122 290a 2020 2020 2020 2020 2020  "NA").          
-0000c4a0: 2020 6966 2073 656c 662e 6461 7461 5b22    if self.data["
-0000c4b0: 454e 5452 5954 5950 4522 5d20 3d3d 2022  ENTRYTYPE"] == "
-0000c4c0: 696e 626f 6f6b 223a 0a20 2020 2020 2020  inbook":.       
-0000c4d0: 2020 2020 2020 2020 2063 6f6e 7461 696e           contain
-0000c4e0: 6572 5f74 6974 6c65 203d 2073 656c 662e  er_title = self.
-0000c4f0: 6461 7461 2e67 6574 2822 626f 6f6b 7469  data.get("bookti
-0000c500: 746c 6522 2c20 224e 4122 290a 2020 2020  tle", "NA").    
-0000c510: 2020 2020 7265 7475 726e 2063 6f6e 7461      return conta
-0000c520: 696e 6572 5f74 6974 6c65 0a0a 2020 2020  iner_title..    
-0000c530: 6465 6620 6372 6561 7465 5f63 6f6c 7265  def create_colre
-0000c540: 765f 6964 280a 2020 2020 2020 2020 7365  v_id(.        se
-0000c550: 6c66 2c0a 2020 2020 2020 2020 2a2c 0a20  lf,.        *,. 
-0000c560: 2020 2020 2020 2061 7373 756d 655f 636f         assume_co
-0000c570: 6d70 6c65 7465 3a20 626f 6f6c 203d 2046  mplete: bool = F
-0000c580: 616c 7365 2c0a 2020 2020 2920 2d3e 2073  alse,.    ) -> s
-0000c590: 7472 3a0a 2020 2020 2020 2020 2222 2252  tr:.        """R
-0000c5a0: 6574 7572 6e73 2074 6865 2063 6f6c 7265  eturns the colre
-0000c5b0: 765f 6964 206f 6620 7468 6520 5265 636f  v_id of the Reco
-0000c5c0: 7264 2e22 2222 0a0a 2020 2020 2020 2020  rd."""..        
-0000c5d0: 7265 7475 726e 2063 6f6c 7265 762e 716d  return colrev.qm
-0000c5e0: 2e63 6f6c 7265 765f 6964 2e63 7265 6174  .colrev_id.creat
-0000c5f0: 655f 636f 6c72 6576 5f69 6428 0a20 2020  e_colrev_id(.   
-0000c600: 2020 2020 2020 2020 2072 6563 6f72 643d           record=
-0000c610: 7365 6c66 2c0a 2020 2020 2020 2020 2020  self,.          
-0000c620: 2020 6173 7375 6d65 5f63 6f6d 706c 6574    assume_complet
-0000c630: 653d 6173 7375 6d65 5f63 6f6d 706c 6574  e=assume_complet
-0000c640: 652c 0a20 2020 2020 2020 2029 0a0a 2020  e,.        )..  
-0000c650: 2020 6465 6620 7072 6573 6372 6565 6e5f    def prescreen_
-0000c660: 6578 636c 7564 6528 7365 6c66 2c20 2a2c  exclude(self, *,
-0000c670: 2072 6561 736f 6e3a 2073 7472 2c20 7072   reason: str, pr
-0000c680: 696e 745f 7761 726e 696e 673a 2062 6f6f  int_warning: boo
-0000c690: 6c20 3d20 4661 6c73 6529 202d 3e20 4e6f  l = False) -> No
-0000c6a0: 6e65 3a0a 2020 2020 2020 2020 2222 2250  ne:.        """P
-0000c6b0: 7265 7363 7265 656e 2d65 7863 6c75 6465  rescreen-exclude
-0000c6c0: 2061 2072 6563 6f72 6422 2222 0a20 2020   a record""".   
-0000c6d0: 2020 2020 2023 2057 6172 6e20 7768 656e       # Warn when
-0000c6e0: 2073 6574 7469 6e67 2072 6576 5f73 796e   setting rev_syn
-0000c6f0: 7468 6573 697a 6564 2f72 6576 5f69 6e63  thesized/rev_inc
-0000c700: 6c75 6465 6420 746f 2070 7265 7363 7265  luded to prescre
-0000c710: 656e 5f65 7863 6c75 6465 640a 2020 2020  en_excluded.    
-0000c720: 2020 2020 2320 4573 7065 6369 616c 6c79      # Especially
-0000c730: 2069 6e20 6361 7365 7320 696e 2077 6869   in cases in whi
-0000c740: 6368 2074 6865 2070 7265 7363 7265 656e  ch the prescreen
-0000c750: 2d65 7863 6c75 7369 6f6e 2064 6563 6973  -exclusion decis
-0000c760: 696f 6e0a 2020 2020 2020 2020 2320 6973  ion.        # is
-0000c770: 2072 6576 6973 6564 2028 652e 672e 2c20   revised (e.g., 
-0000c780: 6265 6361 7573 6520 6120 7061 7065 7220  because a paper 
-0000c790: 7761 7320 7265 7472 6163 7465 6429 0a20  was retracted). 
-0000c7a0: 2020 2020 2020 2023 2049 6e20 7468 6573         # In thes
-0000c7b0: 6520 6361 7365 732c 2074 6865 2070 6170  e cases, the pap
-0000c7c0: 6572 206d 6179 2061 6c72 6561 6479 2062  er may already b
-0000c7d0: 6520 696e 2074 6865 2064 6174 6120 6578  e in the data ex
-0000c7e0: 7472 6163 7469 6f6e 2f73 796e 7468 6573  traction/synthes
-0000c7f0: 6973 0a20 2020 2020 2020 2069 6620 7365  is.        if se
-0000c800: 6c66 2e64 6174 612e 6765 7428 2263 6f6c  lf.data.get("col
-0000c810: 7265 765f 7374 6174 7573 222c 2022 4e41  rev_status", "NA
-0000c820: 2229 2069 6e20 5b0a 2020 2020 2020 2020  ") in [.        
-0000c830: 2020 2020 5265 636f 7264 5374 6174 652e      RecordState.
-0000c840: 7265 765f 7379 6e74 6865 7369 7a65 642c  rev_synthesized,
-0000c850: 0a20 2020 2020 2020 2020 2020 2052 6563  .            Rec
-0000c860: 6f72 6453 7461 7465 2e72 6576 5f69 6e63  ordState.rev_inc
-0000c870: 6c75 6465 642c 0a20 2020 2020 2020 205d  luded,.        ]
-0000c880: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
-0000c890: 696e 7428 0a20 2020 2020 2020 2020 2020  int(.           
-0000c8a0: 2020 2020 2066 225c 6e7b 636f 6c6f 7273       f"\n{colors
-0000c8b0: 2e52 4544 7d57 6172 6e69 6e67 3a20 7365  .RED}Warning: se
-0000c8c0: 7474 696e 6720 7061 7065 7220 746f 2070  tting paper to p
-0000c8d0: 7265 7363 7265 656e 5f65 7863 6c75 6465  rescreen_exclude
-0000c8e0: 642e 2050 6c65 6173 6520 6368 6563 6b20  d. Please check 
-0000c8f0: 616e 6420 220a 2020 2020 2020 2020 2020  and ".          
-0000c900: 2020 2020 2020 6622 7265 6d6f 7665 2066        f"remove f
-0000c910: 726f 6d20 7379 6e74 6865 7369 733a 207b  rom synthesis: {
-0000c920: 7365 6c66 2e64 6174 615b 2749 4427 5d7d  self.data['ID']}
-0000c930: 7b63 6f6c 6f72 732e 454e 447d 5c6e 220a  {colors.END}\n".
-0000c940: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
-0000c950: 2020 2020 2020 2073 656c 662e 7365 745f         self.set_
-0000c960: 7374 6174 7573 2874 6172 6765 745f 7374  status(target_st
-0000c970: 6174 653d 5265 636f 7264 5374 6174 652e  ate=RecordState.
-0000c980: 7265 765f 7072 6573 6372 6565 6e5f 6578  rev_prescreen_ex
-0000c990: 636c 7564 6564 290a 0a20 2020 2020 2020  cluded)..       
-0000c9a0: 2069 6620 280a 2020 2020 2020 2020 2020   if (.          
-0000c9b0: 2020 2272 6574 7261 6374 6564 2220 6e6f    "retracted" no
-0000c9c0: 7420 696e 2073 656c 662e 6461 7461 2e67  t in self.data.g
-0000c9d0: 6574 2822 7072 6573 6372 6565 6e5f 6578  et("prescreen_ex
-0000c9e0: 636c 7573 696f 6e22 2c20 2222 290a 2020  clusion", "").  
-0000c9f0: 2020 2020 2020 2020 2020 616e 6420 2272            and "r
-0000ca00: 6574 7261 6374 6564 2220 3d3d 2072 6561  etracted" == rea
-0000ca10: 736f 6e0a 2020 2020 2020 2020 2020 2020  son.            
-0000ca20: 616e 6420 7072 696e 745f 7761 726e 696e  and print_warnin
-0000ca30: 670a 2020 2020 2020 2020 293a 0a20 2020  g.        ):.   
-0000ca40: 2020 2020 2020 2020 2070 7269 6e74 280a           print(.
-0000ca50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ca60: 6622 5c6e 7b63 6f6c 6f72 732e 5245 447d  f"\n{colors.RED}
-0000ca70: 5061 7065 7220 7265 7472 6163 7465 6420  Paper retracted 
-0000ca80: 616e 6420 7072 6573 6372 6565 6e20 220a  and prescreen ".
-0000ca90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000caa0: 6622 6578 636c 7564 6564 3a20 7b73 656c  f"excluded: {sel
-0000cab0: 662e 6461 7461 5b27 4944 275d 7d7b 636f  f.data['ID']}{co
-0000cac0: 6c6f 7273 2e45 4e44 7d5c 6e22 0a20 2020  lors.END}\n".   
-0000cad0: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
-0000cae0: 2020 2020 7365 6c66 2e64 6174 615b 2270      self.data["p
-0000caf0: 7265 7363 7265 656e 5f65 7863 6c75 7369  rescreen_exclusi
-0000cb00: 6f6e 225d 203d 2072 6561 736f 6e0a 0a20  on"] = reason.. 
-0000cb10: 2020 2020 2020 2023 204e 6f74 653a 2077         # Note: w
-0000cb20: 6865 6e20 7265 636f 7264 7320 6172 6520  hen records are 
-0000cb30: 7072 6573 6372 6565 6e2d 6578 636c 7564  prescreen-exclud
-0000cb40: 6564 2064 7572 696e 6720 7072 6570 3a0a  ed during prep:.
-0000cb50: 2020 2020 2020 2020 746f 5f64 726f 7020          to_drop 
-0000cb60: 3d20 5b5d 0a20 2020 2020 2020 2066 6f72  = [].        for
-0000cb70: 206b 6579 2c20 7661 6c75 6520 696e 2073   key, value in s
-0000cb80: 656c 662e 6461 7461 2e69 7465 6d73 2829  elf.data.items()
-0000cb90: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-0000cba0: 2076 616c 7565 203d 3d20 2255 4e4b 4e4f   value == "UNKNO
-0000cbb0: 574e 223a 0a20 2020 2020 2020 2020 2020  WN":.           
-0000cbc0: 2020 2020 2074 6f5f 6472 6f70 2e61 7070       to_drop.app
-0000cbd0: 656e 6428 6b65 7929 0a20 2020 2020 2020  end(key).       
-0000cbe0: 2066 6f72 206b 6579 2069 6e20 746f 5f64   for key in to_d
-0000cbf0: 726f 703a 0a20 2020 2020 2020 2020 2020  rop:.           
-0000cc00: 2073 656c 662e 7265 6d6f 7665 5f66 6965   self.remove_fie
-0000cc10: 6c64 286b 6579 3d6b 6579 290a 0a20 2020  ld(key=key)..   
-0000cc20: 2064 6566 2065 7874 7261 6374 5f74 6578   def extract_tex
-0000cc30: 745f 6279 5f70 6167 6528 0a20 2020 2020  t_by_page(.     
-0000cc40: 2020 2073 656c 662c 202a 2c20 7061 6765     self, *, page
-0000cc50: 733a 204f 7074 696f 6e61 6c5b 6c69 7374  s: Optional[list
-0000cc60: 5d20 3d20 4e6f 6e65 2c20 7072 6f6a 6563  ] = None, projec
-0000cc70: 745f 7061 7468 3a20 5061 7468 0a20 2020  t_path: Path.   
-0000cc80: 2029 202d 3e20 7374 723a 0a20 2020 2020   ) -> str:.     
-0000cc90: 2020 2022 2222 4578 7472 6163 7420 7468     """Extract th
-0000cca0: 6520 7465 7874 2066 726f 6d20 7468 6520  e text from the 
-0000ccb0: 5044 4620 666f 7220 6120 6769 7665 6e20  PDF for a given 
-0000ccc0: 6e75 6d62 6572 206f 6620 7061 6765 7322  number of pages"
-0000ccd0: 2222 0a20 2020 2020 2020 2074 6578 745f  "".        text_
-0000cce0: 6c69 7374 3a20 6c69 7374 203d 205b 5d0a  list: list = [].
-0000ccf0: 2020 2020 2020 2020 7064 665f 7061 7468          pdf_path
-0000cd00: 203d 2070 726f 6a65 6374 5f70 6174 6820   = project_path 
-0000cd10: 2f20 5061 7468 2873 656c 662e 6461 7461  / Path(self.data
-0000cd20: 5b22 6669 6c65 225d 290a 0a20 2020 2020  ["file"])..     
-0000cd30: 2020 2023 2068 7474 7073 3a2f 2f73 7461     # https://sta
-0000cd40: 636b 6f76 6572 666c 6f77 2e63 6f6d 2f71  ckoverflow.com/q
-0000cd50: 7565 7374 696f 6e73 2f34 3934 3537 3434  uestions/4945744
-0000cd60: 332f 7079 7468 6f6e 2d70 6466 6d69 6e65  3/python-pdfmine
-0000cd70: 722d 636f 6e76 6572 7473 2d70 6466 2d66  r-converts-pdf-f
-0000cd80: 696c 652d 696e 746f 2d6f 6e65 2d63 6875  ile-into-one-chu
-0000cd90: 6e6b 2d6f 662d 7374 7269 6e67 2d77 6974  nk-of-string-wit
-0000cda0: 682d 6e6f 2d73 7061 6365 732d 6265 7477  h-no-spaces-betw
-0000cdb0: 6565 0a20 2020 2020 2020 206c 6170 6172  ee.        lapar
-0000cdc0: 616d 7320 3d20 7064 666d 696e 6572 2e6c  ams = pdfminer.l
-0000cdd0: 6179 6f75 742e 4c41 5061 7261 6d73 2829  ayout.LAParams()
-0000cde0: 0a20 2020 2020 2020 2073 6574 6174 7472  .        setattr
-0000cdf0: 286c 6170 6172 616d 732c 2022 616c 6c5f  (laparams, "all_
-0000ce00: 7465 7874 7322 2c20 5472 7565 290a 0a20  texts", True).. 
-0000ce10: 2020 2020 2020 2077 6974 6820 6f70 656e         with open
-0000ce20: 2870 6466 5f70 6174 682c 2022 7262 2229  (pdf_path, "rb")
-0000ce30: 2061 7320 7064 665f 6669 6c65 3a0a 2020   as pdf_file:.  
-0000ce40: 2020 2020 2020 2020 2020 7472 793a 0a20            try:. 
-0000ce50: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-0000ce60: 6f72 2070 6167 6520 696e 2050 4446 5061  or page in PDFPa
-0000ce70: 6765 2e67 6574 5f70 6167 6573 280a 2020  ge.get_pages(.  
-0000ce80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ce90: 2020 7064 665f 6669 6c65 2c0a 2020 2020    pdf_file,.    
-0000cea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ceb0: 7061 6765 6e6f 733d 7061 6765 732c 2020  pagenos=pages,  
-0000cec0: 2320 6e6f 7465 3a20 6d61 7962 6520 736b  # note: maybe sk
-0000ced0: 6970 2070 6f74 656e 7469 616c 2063 6f76  ip potential cov
-0000cee0: 6572 2070 6167 6573 3f0a 2020 2020 2020  er pages?.      
-0000cef0: 2020 2020 2020 2020 2020 2020 2020 6361                ca
-0000cf00: 6368 696e 673d 5472 7565 2c0a 2020 2020  ching=True,.    
-0000cf10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cf20: 6368 6563 6b5f 6578 7472 6163 7461 626c  check_extractabl
-0000cf30: 653d 5472 7565 2c0a 2020 2020 2020 2020  e=True,.        
-0000cf40: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
-0000cf50: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-0000cf60: 6573 6f75 7263 655f 6d61 6e61 6765 7220  esource_manager 
-0000cf70: 3d20 5044 4652 6573 6f75 7263 654d 616e  = PDFResourceMan
-0000cf80: 6167 6572 2829 0a20 2020 2020 2020 2020  ager().         
-0000cf90: 2020 2020 2020 2020 2020 2066 616b 655f             fake_
-0000cfa0: 6669 6c65 5f68 616e 646c 6520 3d20 696f  file_handle = io
-0000cfb0: 2e53 7472 696e 6749 4f28 290a 2020 2020  .StringIO().    
-0000cfc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cfd0: 636f 6e76 6572 7465 7220 3d20 5465 7874  converter = Text
-0000cfe0: 436f 6e76 6572 7465 7228 0a20 2020 2020  Converter(.     
-0000cff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d000: 2020 2072 6573 6f75 7263 655f 6d61 6e61     resource_mana
-0000d010: 6765 722c 2066 616b 655f 6669 6c65 5f68  ger, fake_file_h
-0000d020: 616e 646c 652c 206c 6170 6172 616d 733d  andle, laparams=
-0000d030: 6c61 7061 7261 6d73 0a20 2020 2020 2020  laparams.       
-0000d040: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
-0000d050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d060: 2020 2070 6167 655f 696e 7465 7270 7265     page_interpre
-0000d070: 7465 7220 3d20 5044 4650 6167 6549 6e74  ter = PDFPageInt
-0000d080: 6572 7072 6574 6572 2872 6573 6f75 7263  erpreter(resourc
-0000d090: 655f 6d61 6e61 6765 722c 2063 6f6e 7665  e_manager, conve
-0000d0a0: 7274 6572 290a 2020 2020 2020 2020 2020  rter).          
-0000d0b0: 2020 2020 2020 2020 2020 7061 6765 5f69            page_i
-0000d0c0: 6e74 6572 7072 6574 6572 2e70 726f 6365  nterpreter.proce
-0000d0d0: 7373 5f70 6167 6528 7061 6765 290a 0a20  ss_page(page).. 
-0000d0e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d0f0: 2020 2074 6578 7420 3d20 6661 6b65 5f66     text = fake_f
-0000d100: 696c 655f 6861 6e64 6c65 2e67 6574 7661  ile_handle.getva
-0000d110: 6c75 6528 290a 2020 2020 2020 2020 2020  lue().          
-0000d120: 2020 2020 2020 2020 2020 7465 7874 5f6c            text_l
-0000d130: 6973 7420 2b3d 2074 6578 740a 0a20 2020  ist += text..   
-0000d140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d150: 2023 2063 6c6f 7365 206f 7065 6e20 6861   # close open ha
-0000d160: 6e64 6c65 730a 2020 2020 2020 2020 2020  ndles.          
-0000d170: 2020 2020 2020 2020 2020 636f 6e76 6572            conver
-0000d180: 7465 722e 636c 6f73 6528 290a 2020 2020  ter.close().    
-0000d190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d1a0: 6661 6b65 5f66 696c 655f 6861 6e64 6c65  fake_file_handle
-0000d1b0: 2e63 6c6f 7365 2829 0a20 2020 2020 2020  .close().       
-0000d1c0: 2020 2020 2065 7863 6570 7420 2854 7970       except (Typ
-0000d1d0: 6545 7272 6f72 2c20 4b65 7945 7272 6f72  eError, KeyError
-0000d1e0: 293a 2020 2320 7072 6167 6d61 3a20 6e6f  ):  # pragma: no
-0000d1f0: 2063 6f76 6572 0a20 2020 2020 2020 2020   cover.         
-0000d200: 2020 2020 2020 2070 6173 730a 2020 2020         pass.    
-0000d210: 2020 2020 7265 7475 726e 2022 222e 6a6f      return "".jo
-0000d220: 696e 2874 6578 745f 6c69 7374 290a 0a20  in(text_list).. 
-0000d230: 2020 2064 6566 2073 6574 5f70 6167 6573     def set_pages
-0000d240: 5f69 6e5f 7064 6628 7365 6c66 2c20 2a2c  _in_pdf(self, *,
-0000d250: 2070 726f 6a65 6374 5f70 6174 683a 2050   project_path: P
-0000d260: 6174 6829 202d 3e20 4e6f 6e65 3a0a 2020  ath) -> None:.  
-0000d270: 2020 2020 2020 2222 2253 6574 2074 6865        """Set the
-0000d280: 2070 6167 6573 5f69 6e5f 6669 6c65 2066   pages_in_file f
-0000d290: 6965 6c64 2062 6173 6564 206f 6e20 7468  ield based on th
-0000d2a0: 6520 5044 4622 2222 0a20 2020 2020 2020  e PDF""".       
-0000d2b0: 2070 6466 5f70 6174 6820 3d20 7072 6f6a   pdf_path = proj
-0000d2c0: 6563 745f 7061 7468 202f 2050 6174 6828  ect_path / Path(
-0000d2d0: 7365 6c66 2e64 6174 615b 2266 696c 6522  self.data["file"
-0000d2e0: 5d29 0a20 2020 2020 2020 2077 6974 6820  ]).        with 
-0000d2f0: 6f70 656e 2870 6466 5f70 6174 682c 2022  open(pdf_path, "
-0000d300: 7262 2229 2061 7320 6669 6c65 3a0a 2020  rb") as file:.  
-0000d310: 2020 2020 2020 2020 2020 7061 7273 6572            parser
-0000d320: 203d 2050 4446 5061 7273 6572 2866 696c   = PDFParser(fil
-0000d330: 6529 0a20 2020 2020 2020 2020 2020 2064  e).            d
-0000d340: 6f63 756d 656e 7420 3d20 5044 4644 6f63  ocument = PDFDoc
-0000d350: 756d 656e 7428 7061 7273 6572 290a 2020  ument(parser).  
-0000d360: 2020 2020 2020 2020 2020 7061 6765 735f            pages_
-0000d370: 696e 5f66 696c 6520 3d20 7265 736f 6c76  in_file = resolv
-0000d380: 6531 2864 6f63 756d 656e 742e 6361 7461  e1(document.cata
-0000d390: 6c6f 675b 2250 6167 6573 225d 295b 2243  log["Pages"])["C
-0000d3a0: 6f75 6e74 225d 0a20 2020 2020 2020 2073  ount"].        s
-0000d3b0: 656c 662e 6461 7461 5b22 7061 6765 735f  elf.data["pages_
-0000d3c0: 696e 5f66 696c 6522 5d20 3d20 7061 6765  in_file"] = page
-0000d3d0: 735f 696e 5f66 696c 650a 0a20 2020 2064  s_in_file..    d
-0000d3e0: 6566 2073 6574 5f74 6578 745f 6672 6f6d  ef set_text_from
-0000d3f0: 5f70 6466 2873 656c 662c 202a 2c20 7072  _pdf(self, *, pr
-0000d400: 6f6a 6563 745f 7061 7468 3a20 5061 7468  oject_path: Path
-0000d410: 2920 2d3e 204e 6f6e 653a 0a20 2020 2020  ) -> None:.     
-0000d420: 2020 2022 2222 5365 7420 7468 6520 7465     """Set the te
-0000d430: 7874 5f66 726f 6d5f 7064 6620 6669 656c  xt_from_pdf fiel
-0000d440: 6420 6261 7365 6420 6f6e 2074 6865 2050  d based on the P
-0000d450: 4446 2222 220a 2020 2020 2020 2020 7365  DF""".        se
-0000d460: 6c66 2e64 6174 615b 2274 6578 745f 6672  lf.data["text_fr
-0000d470: 6f6d 5f70 6466 225d 203d 2022 220a 2020  om_pdf"] = "".  
-0000d480: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
-0000d490: 2020 2020 2020 2073 656c 662e 7365 745f         self.set_
-0000d4a0: 7061 6765 735f 696e 5f70 6466 2870 726f  pages_in_pdf(pro
-0000d4b0: 6a65 6374 5f70 6174 683d 7072 6f6a 6563  ject_path=projec
-0000d4c0: 745f 7061 7468 290a 2020 2020 2020 2020  t_path).        
-0000d4d0: 2020 2020 7465 7874 203d 2073 656c 662e      text = self.
-0000d4e0: 6578 7472 6163 745f 7465 7874 5f62 795f  extract_text_by_
-0000d4f0: 7061 6765 2870 6167 6573 3d5b 302c 2031  page(pages=[0, 1
-0000d500: 2c20 325d 2c20 7072 6f6a 6563 745f 7061  , 2], project_pa
-0000d510: 7468 3d70 726f 6a65 6374 5f70 6174 6829  th=project_path)
-0000d520: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-0000d530: 662e 6461 7461 5b22 7465 7874 5f66 726f  f.data["text_fro
-0000d540: 6d5f 7064 6622 5d20 3d20 7465 7874 2e72  m_pdf"] = text.r
-0000d550: 6570 6c61 6365 2822 5c6e 222c 2022 2022  eplace("\n", " "
-0000d560: 292e 7265 706c 6163 6528 225c 7830 6322  ).replace("\x0c"
-0000d570: 2c20 2222 290a 0a20 2020 2020 2020 2065  , "")..        e
-0000d580: 7863 6570 7420 5044 4653 796e 7461 7845  xcept PDFSyntaxE
-0000d590: 7272 6f72 3a20 2023 2070 7261 676d 613a  rror:  # pragma:
-0000d5a0: 206e 6f20 636f 7665 720a 2020 2020 2020   no cover.      
-0000d5b0: 2020 2020 2020 7365 6c66 2e61 6464 5f64        self.add_d
-0000d5c0: 6174 615f 7072 6f76 656e 616e 6365 5f6e  ata_provenance_n
-0000d5d0: 6f74 6528 6b65 793d 2266 696c 6522 2c20  ote(key="file", 
-0000d5e0: 6e6f 7465 3d22 7064 665f 7265 6164 6572  note="pdf_reader
-0000d5f0: 5f65 7272 6f72 2229 0a20 2020 2020 2020  _error").       
-0000d600: 2020 2020 2073 656c 662e 6461 7461 2e75       self.data.u
-0000d610: 7064 6174 6528 636f 6c72 6576 5f73 7461  pdate(colrev_sta
-0000d620: 7475 733d 5265 636f 7264 5374 6174 652e  tus=RecordState.
-0000d630: 7064 665f 6e65 6564 735f 6d61 6e75 616c  pdf_needs_manual
-0000d640: 5f70 7265 7061 7261 7469 6f6e 290a 2020  _preparation).  
-0000d650: 2020 2020 2020 6578 6365 7074 2050 4446        except PDF
-0000d660: 5465 7874 4578 7472 6163 7469 6f6e 4e6f  TextExtractionNo
-0000d670: 7441 6c6c 6f77 6564 3a20 2023 2070 7261  tAllowed:  # pra
-0000d680: 676d 613a 206e 6f20 636f 7665 720a 2020  gma: no cover.  
-0000d690: 2020 2020 2020 2020 2020 7365 6c66 2e61            self.a
-0000d6a0: 6464 5f64 6174 615f 7072 6f76 656e 616e  dd_data_provenan
-0000d6b0: 6365 5f6e 6f74 6528 6b65 793d 2266 696c  ce_note(key="fil
-0000d6c0: 6522 2c20 6e6f 7465 3d22 7064 665f 7072  e", note="pdf_pr
-0000d6d0: 6f74 6563 7465 6422 290a 2020 2020 2020  otected").      
-0000d6e0: 2020 2020 2020 7365 6c66 2e64 6174 612e        self.data.
-0000d6f0: 7570 6461 7465 2863 6f6c 7265 765f 7374  update(colrev_st
-0000d700: 6174 7573 3d52 6563 6f72 6453 7461 7465  atus=RecordState
-0000d710: 2e70 6466 5f6e 6565 6473 5f6d 616e 7561  .pdf_needs_manua
-0000d720: 6c5f 7072 6570 6172 6174 696f 6e29 0a0a  l_preparation)..
-0000d730: 2020 2020 6465 6620 6578 7472 6163 745f      def extract_
-0000d740: 7061 6765 7328 0a20 2020 2020 2020 2073  pages(.        s
-0000d750: 656c 662c 202a 2c20 7061 6765 733a 206c  elf, *, pages: l
-0000d760: 6973 742c 2070 726f 6a65 6374 5f70 6174  ist, project_pat
-0000d770: 683a 2050 6174 682c 2073 6176 655f 746f  h: Path, save_to
-0000d780: 5f70 6174 683a 204f 7074 696f 6e61 6c5b  _path: Optional[
-0000d790: 5061 7468 5d20 3d20 4e6f 6e65 0a20 2020  Path] = None.   
-0000d7a0: 2029 202d 3e20 4e6f 6e65 3a20 2023 2070   ) -> None:  # p
-0000d7b0: 7261 676d 613a 206e 6f20 636f 7665 720a  ragma: no cover.
-0000d7c0: 2020 2020 2020 2020 2222 2245 7874 7261          """Extra
-0000d7d0: 6374 2070 6167 6573 2066 726f 6d20 7468  ct pages from th
-0000d7e0: 6520 5044 4620 2873 6176 6569 6e67 2074  e PDF (saveing t
-0000d7f0: 6865 6d20 746f 2074 6865 2073 6176 655f  hem to the save_
-0000d800: 746f 5f70 6174 6829 2222 220a 2020 2020  to_path)""".    
-0000d810: 2020 2020 7064 665f 7061 7468 203d 2070      pdf_path = p
-0000d820: 726f 6a65 6374 5f70 6174 6820 2f20 5061  roject_path / Pa
-0000d830: 7468 2873 656c 662e 6461 7461 5b22 6669  th(self.data["fi
-0000d840: 6c65 225d 290a 2020 2020 2020 2020 7064  le"]).        pd
-0000d850: 665f 7265 6164 6572 203d 2050 6466 4669  f_reader = PdfFi
-0000d860: 6c65 5265 6164 6572 2873 7472 2870 6466  leReader(str(pdf
-0000d870: 5f70 6174 6829 2c20 7374 7269 6374 3d46  _path), strict=F
-0000d880: 616c 7365 290a 2020 2020 2020 2020 7772  alse).        wr
-0000d890: 6974 6572 203d 2050 6466 4669 6c65 5772  iter = PdfFileWr
-0000d8a0: 6974 6572 2829 0a20 2020 2020 2020 2066  iter().        f
-0000d8b0: 6f72 2069 2069 6e20 7261 6e67 6528 302c  or i in range(0,
-0000d8c0: 206c 656e 2870 6466 5f72 6561 6465 722e   len(pdf_reader.
-0000d8d0: 7061 6765 7329 293a 0a20 2020 2020 2020  pages)):.       
-0000d8e0: 2020 2020 2069 6620 6920 696e 2070 6167       if i in pag
-0000d8f0: 6573 3a0a 2020 2020 2020 2020 2020 2020  es:.            
-0000d900: 2020 2020 636f 6e74 696e 7565 0a20 2020      continue.   
-0000d910: 2020 2020 2020 2020 2077 7269 7465 722e           writer.
-0000d920: 6164 6450 6167 6528 7064 665f 7265 6164  addPage(pdf_read
-0000d930: 6572 2e67 6574 5061 6765 2869 2929 0a20  er.getPage(i)). 
-0000d940: 2020 2020 2020 2077 6974 6820 6f70 656e         with open
-0000d950: 2870 6466 5f70 6174 682c 2022 7762 2229  (pdf_path, "wb")
-0000d960: 2061 7320 6f75 7466 696c 653a 0a20 2020   as outfile:.   
-0000d970: 2020 2020 2020 2020 2077 7269 7465 722e           writer.
-0000d980: 7772 6974 6528 6f75 7466 696c 6529 0a0a  write(outfile)..
-0000d990: 2020 2020 2020 2020 6966 2073 6176 655f          if save_
-0000d9a0: 746f 5f70 6174 683a 0a20 2020 2020 2020  to_path:.       
-0000d9b0: 2020 2020 2077 7269 7465 725f 6370 203d       writer_cp =
-0000d9c0: 2050 6466 4669 6c65 5772 6974 6572 2829   PdfFileWriter()
-0000d9d0: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-0000d9e0: 2070 6167 6520 696e 2070 6167 6573 3a0a   page in pages:.
-0000d9f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000da00: 7772 6974 6572 5f63 702e 6164 6450 6167  writer_cp.addPag
-0000da10: 6528 7064 665f 7265 6164 6572 2e67 6574  e(pdf_reader.get
-0000da20: 5061 6765 2870 6167 6529 290a 2020 2020  Page(page)).    
-0000da30: 2020 2020 2020 2020 6669 6c65 7061 7468          filepath
-0000da40: 203d 2050 6174 6828 7064 665f 7061 7468   = Path(pdf_path
-0000da50: 290a 2020 2020 2020 2020 2020 2020 7769  ).            wi
-0000da60: 7468 206f 7065 6e28 7361 7665 5f74 6f5f  th open(save_to_
-0000da70: 7061 7468 202f 2066 696c 6570 6174 682e  path / filepath.
-0000da80: 6e61 6d65 2c20 2277 6222 2920 6173 206f  name, "wb") as o
-0000da90: 7574 6669 6c65 3a0a 2020 2020 2020 2020  utfile:.        
-0000daa0: 2020 2020 2020 2020 7772 6974 6572 5f63          writer_c
-0000dab0: 702e 7772 6974 6528 6f75 7466 696c 6529  p.write(outfile)
-0000dac0: 0a0a 2020 2020 4063 6c61 7373 6d65 7468  ..    @classmeth
-0000dad0: 6f64 0a20 2020 2064 6566 2067 6574 5f63  od.    def get_c
-0000dae0: 6f6c 7265 765f 7064 665f 6964 280a 2020  olrev_pdf_id(.  
-0000daf0: 2020 2020 2020 636c 732c 0a20 2020 2020        cls,.     
-0000db00: 2020 202a 2c0a 2020 2020 2020 2020 7064     *,.        pd
-0000db10: 665f 7061 7468 3a20 5061 7468 2c0a 2020  f_path: Path,.  
-0000db20: 2020 2920 2d3e 2073 7472 3a20 2023 2070    ) -> str:  # p
-0000db30: 7261 676d 613a 206e 6f20 636f 7665 720a  ragma: no cover.
-0000db40: 2020 2020 2020 2020 2222 2247 656e 6572          """Gener
-0000db50: 6174 6520 7468 6520 636f 6c72 6576 5f70  ate the colrev_p
-0000db60: 6466 5f69 6422 2222 0a0a 2020 2020 2020  df_id"""..      
-0000db70: 2020 7265 7475 726e 2063 6f6c 7265 762e    return colrev.
-0000db80: 716d 2e63 6f6c 7265 765f 7064 665f 6964  qm.colrev_pdf_id
-0000db90: 2e63 7265 6174 655f 636f 6c72 6576 5f70  .create_colrev_p
-0000dba0: 6466 5f69 6428 7064 665f 7061 7468 3d70  df_id(pdf_path=p
-0000dbb0: 6466 5f70 6174 6829 0a0a 2020 2020 6465  df_path)..    de
-0000dbc0: 6620 6765 745f 746f 635f 6b65 7928 7365  f get_toc_key(se
-0000dbd0: 6c66 2920 2d3e 2073 7472 3a0a 2020 2020  lf) -> str:.    
-0000dbe0: 2020 2020 2222 2247 6574 2074 6865 2072      """Get the r
-0000dbf0: 6563 6f72 6427 7320 746f 632d 6b65 7922  ecord's toc-key"
-0000dc00: 2222 0a0a 2020 2020 2020 2020 7472 793a  ""..        try:
-0000dc10: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0000dc20: 7365 6c66 2e64 6174 615b 2245 4e54 5259  self.data["ENTRY
-0000dc30: 5459 5045 225d 203d 3d20 2261 7274 6963  TYPE"] == "artic
-0000dc40: 6c65 223a 0a20 2020 2020 2020 2020 2020  le":.           
-0000dc50: 2020 2020 2074 6f63 5f6b 6579 203d 2028       toc_key = (
-0000dc60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000dc70: 2020 2020 2073 656c 662e 6461 7461 5b22       self.data["
-0000dc80: 6a6f 7572 6e61 6c22 5d0a 2020 2020 2020  journal"].      
-0000dc90: 2020 2020 2020 2020 2020 2020 2020 2e72                .r
-0000dca0: 6570 6c61 6365 2822 2022 2c20 222d 2229  eplace(" ", "-")
-0000dcb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000dcc0: 2020 2020 202e 7265 706c 6163 6528 225c       .replace("\
-0000dcd0: 5c22 2c20 2222 290a 2020 2020 2020 2020  \", "").        
-0000dce0: 2020 2020 2020 2020 2020 2020 2e72 6570              .rep
-0000dcf0: 6c61 6365 2822 2622 2c20 2261 6e64 2229  lace("&", "and")
-0000dd00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000dd10: 2020 2020 202e 6c6f 7765 7228 290a 2020       .lower().  
-0000dd20: 2020 2020 2020 2020 2020 2020 2020 290a                ).
-0000dd30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dd40: 746f 635f 6b65 7920 2b3d 2028 0a20 2020  toc_key += (.   
-0000dd50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dd60: 2066 227c 7b73 656c 662e 6461 7461 5b27   f"|{self.data['
-0000dd70: 766f 6c75 6d65 275d 7d22 0a20 2020 2020  volume']}".     
-0000dd80: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000dd90: 6620 2822 554e 4b4e 4f57 4e22 2021 3d20  f ("UNKNOWN" != 
-0000dda0: 7365 6c66 2e64 6174 612e 6765 7428 2276  self.data.get("v
-0000ddb0: 6f6c 756d 6522 2c20 2255 4e4b 4e4f 574e  olume", "UNKNOWN
-0000ddc0: 2229 290a 2020 2020 2020 2020 2020 2020  ")).            
-0000ddd0: 2020 2020 2020 2020 656c 7365 2022 7c2d          else "|-
-0000dde0: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
-0000ddf0: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-0000de00: 2020 2020 746f 635f 6b65 7920 2b3d 2028      toc_key += (
-0000de10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000de20: 2020 2020 2066 227c 7b73 656c 662e 6461       f"|{self.da
-0000de30: 7461 5b27 6e75 6d62 6572 275d 7d22 0a20  ta['number']}". 
-0000de40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000de50: 2020 2069 6620 2822 554e 4b4e 4f57 4e22     if ("UNKNOWN"
-0000de60: 2021 3d20 7365 6c66 2e64 6174 612e 6765   != self.data.ge
-0000de70: 7428 226e 756d 6265 7222 2c20 2255 4e4b  t("number", "UNK
-0000de80: 4e4f 574e 2229 290a 2020 2020 2020 2020  NOWN")).        
-0000de90: 2020 2020 2020 2020 2020 2020 656c 7365              else
-0000dea0: 2022 7c2d 220a 2020 2020 2020 2020 2020   "|-".          
-0000deb0: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
-0000dec0: 2020 2020 2065 6c69 6620 7365 6c66 2e64       elif self.d
-0000ded0: 6174 615b 2245 4e54 5259 5459 5045 225d  ata["ENTRYTYPE"]
-0000dee0: 203d 3d20 2269 6e70 726f 6365 6564 696e   == "inproceedin
-0000def0: 6773 223a 0a20 2020 2020 2020 2020 2020  gs":.           
-0000df00: 2020 2020 2074 6f63 5f6b 6579 203d 2028       toc_key = (
-0000df10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000df20: 2020 2020 2073 656c 662e 6461 7461 5b22       self.data["
-0000df30: 626f 6f6b 7469 746c 6522 5d0a 2020 2020  booktitle"].    
-0000df40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000df50: 2e72 6570 6c61 6365 2822 2022 2c20 222d  .replace(" ", "-
-0000df60: 2229 0a20 2020 2020 2020 2020 2020 2020  ").             
-0000df70: 2020 2020 2020 202e 7265 706c 6163 6528         .replace(
-0000df80: 225c 5c22 2c20 2222 290a 2020 2020 2020  "\\", "").      
+00009ae0: 2320 2020 2020 7061 6765 735f 7369 6d69  #     pages_simi
+00009af0: 6c61 7269 7479 203d 2031 0a20 2020 2020  larity = 1.     
+00009b00: 2020 2020 2020 2020 2020 2023 2065 6c73             # els
+00009b10: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00009b20: 2020 2023 2020 2020 2069 6620 7265 636f     #     if reco
+00009b30: 7264 5f61 5b22 7061 6765 7322 5d20 3d3d  rd_a["pages"] ==
+00009b40: 2072 6563 6f72 645f 625b 2270 6167 6573   record_b["pages
+00009b50: 225d 3a0a 2020 2020 2020 2020 2020 2020  "]:.            
+00009b60: 2020 2020 2320 2020 2020 2020 2020 7061      #         pa
+00009b70: 6765 735f 7369 6d69 6c61 7269 7479 203d  ges_similarity =
+00009b80: 2031 0a20 2020 2020 2020 2020 2020 2020   1.             
+00009b90: 2020 2023 2020 2020 2065 6c73 653a 0a20     #     else:. 
+00009ba0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+00009bb0: 2020 2020 2020 2020 2069 6620 7265 636f           if reco
+00009bc0: 7264 5f61 5b22 7061 6765 7322 5d2e 7370  rd_a["pages"].sp
+00009bd0: 6c69 7428 222d 2229 5b30 5d20 3d3d 2072  lit("-")[0] == r
+00009be0: 6563 6f72 645f 625b 2270 6167 6573 225d  ecord_b["pages"]
+00009bf0: 2e73 706c 6974 2822 2d22 295b 305d 3a0a  .split("-")[0]:.
+00009c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009c10: 2320 2020 2020 2020 2020 2020 2020 7061  #             pa
+00009c20: 6765 735f 7369 6d69 6c61 7269 7479 203d  ges_similarity =
+00009c30: 2031 0a20 2020 2020 2020 2020 2020 2020   1.             
+00009c40: 2020 2023 2020 2020 2020 2020 2065 6c73     #         els
+00009c50: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00009c60: 2020 2023 2020 2020 2020 2020 2020 2020     #            
+00009c70: 7061 6765 735f 7369 6d69 6c61 7269 7479  pages_similarity
+00009c80: 203d 2030 0a0a 2020 2020 2020 2020 2020   = 0..          
+00009c90: 2020 2020 2020 2320 5075 7420 6d6f 7265        # Put more
+00009ca0: 2077 6569 6768 7420 6f6e 206f 7468 6572   weight on other
+00009cb0: 2066 6965 6c64 7320 6966 2074 6865 2074   fields if the t
+00009cc0: 6974 6c65 2069 7320 7665 7279 2063 6f6d  itle is very com
+00009cd0: 6d6f 6e0a 2020 2020 2020 2020 2020 2020  mon.            
+00009ce0: 2020 2020 2320 6965 2e2c 206e 6f6e 2d64      # ie., non-d
+00009cf0: 6973 7469 6e63 7469 7665 0a20 2020 2020  istinctive.     
+00009d00: 2020 2020 2020 2020 2020 2023 2054 6865             # The
+00009d10: 206c 6973 7420 6973 2062 6173 6564 206f   list is based o
+00009d20: 6e20 6120 6c61 7267 6520 6578 706f 7274  n a large export
+00009d30: 206f 6620 6469 7374 696e 6374 2070 6170   of distinct pap
+00009d40: 6572 732c 2074 6162 756c 6174 6564 0a20  ers, tabulated. 
+00009d50: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+00009d60: 2061 6363 6f72 6469 6e67 2074 6f20 7469   according to ti
+00009d70: 746c 6573 2061 6e64 2073 6f72 7465 6420  tles and sorted 
+00009d80: 6279 2066 7265 7175 656e 6379 0a20 2020  by frequency.   
+00009d90: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00009da0: 5b72 6563 6f72 645f 615b 2274 6974 6c65  [record_a["title
+00009db0: 225d 2c20 7265 636f 7264 5f62 5b22 7469  "], record_b["ti
+00009dc0: 746c 6522 5d5d 2069 6e20 5b0a 2020 2020  tle"]] in [.    
+00009dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009de0: 5b22 6564 6974 6f72 6961 6c22 2c20 2265  ["editorial", "e
+00009df0: 6469 746f 7269 616c 225d 2c0a 2020 2020  ditorial"],.    
+00009e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009e10: 5b22 6564 6974 6f72 6961 6c20 696e 7472  ["editorial intr
+00009e20: 6f64 7563 7469 6f6e 222c 2022 6564 6974  oduction", "edit
+00009e30: 6f72 6961 6c20 696e 7472 6f64 7563 7469  orial introducti
+00009e40: 6f6e 225d 2c0a 2020 2020 2020 2020 2020  on"],.          
+00009e50: 2020 2020 2020 2020 2020 5b22 6564 6974            ["edit
+00009e60: 6f72 6961 6c20 6e6f 7465 7322 2c20 2265  orial notes", "e
+00009e70: 6469 746f 7269 616c 206e 6f74 6573 225d  ditorial notes"]
+00009e80: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00009e90: 2020 2020 2020 5b22 6564 6974 6f72 2773        ["editor's
+00009ea0: 2063 6f6d 6d65 6e74 7322 2c20 2265 6469   comments", "edi
+00009eb0: 746f 7227 7320 636f 6d6d 656e 7473 225d  tor's comments"]
+00009ec0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00009ed0: 2020 2020 2020 5b22 626f 6f6b 2072 6576        ["book rev
+00009ee0: 6965 7773 222c 2022 626f 6f6b 2072 6576  iews", "book rev
+00009ef0: 6965 7773 225d 2c0a 2020 2020 2020 2020  iews"],.        
+00009f00: 2020 2020 2020 2020 2020 2020 5b22 6564              ["ed
+00009f10: 6974 6f72 6961 6c20 6e6f 7465 222c 2022  itorial note", "
+00009f20: 6564 6974 6f72 6961 6c20 6e6f 7465 225d  editorial note"]
+00009f30: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00009f40: 2020 2020 2020 5b22 7265 7669 6577 6572        ["reviewer
+00009f50: 2061 636b 6f77 6c65 6467 6d65 6e74 222c   ackowledgment",
+00009f60: 2022 7265 7669 6577 6572 2061 636b 6f77   "reviewer ackow
+00009f70: 6c65 6467 6d65 6e74 225d 2c0a 2020 2020  ledgment"],.    
+00009f80: 2020 2020 2020 2020 2020 2020 5d3a 0a20              ]:. 
+00009f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009fa0: 2020 2077 6569 6768 7473 203d 205b 302e     weights = [0.
+00009fb0: 3137 352c 2030 2c20 302e 3137 352c 2030  175, 0, 0.175, 0
+00009fc0: 2e31 3735 2c20 302e 3237 352c 2030 2e32  .175, 0.275, 0.2
+00009fd0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+00009fe0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00009ff0: 2020 2020 2020 2020 2020 2020 7765 6967              weig
+0000a000: 6874 7320 3d20 5b30 2e32 2c20 302e 3235  hts = [0.2, 0.25
+0000a010: 2c20 302e 3133 2c20 302e 322c 2030 2e31  , 0.13, 0.2, 0.1
+0000a020: 322c 2030 2e31 5d0a 0a20 2020 2020 2020  2, 0.1]..       
+0000a030: 2020 2020 2020 2020 2073 696d 5f6e 616d           sim_nam
+0000a040: 6573 203d 205b 0a20 2020 2020 2020 2020  es = [.         
+0000a050: 2020 2020 2020 2020 2020 2022 6175 7468             "auth
+0000a060: 6f72 7322 2c0a 2020 2020 2020 2020 2020  ors",.          
+0000a070: 2020 2020 2020 2020 2020 2274 6974 6c65            "title
+0000a080: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+0000a090: 2020 2020 2020 2022 7965 6172 222c 0a20         "year",. 
+0000a0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a0b0: 2020 2022 6f75 746c 6574 222c 0a20 2020     "outlet",.   
+0000a0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a0d0: 2022 766f 6c75 6d65 222c 0a20 2020 2020   "volume",.     
+0000a0e0: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+0000a0f0: 6e75 6d62 6572 222c 0a20 2020 2020 2020  number",.       
+0000a100: 2020 2020 2020 2020 205d 0a20 2020 2020           ].     
+0000a110: 2020 2020 2020 2020 2020 2073 696d 696c             simil
+0000a120: 6172 6974 6965 7320 3d20 5b0a 2020 2020  arities = [.    
+0000a130: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a140: 6175 7468 6f72 5f73 696d 696c 6172 6974  author_similarit
+0000a150: 792c 0a20 2020 2020 2020 2020 2020 2020  y,.             
+0000a160: 2020 2020 2020 2074 6974 6c65 5f73 696d         title_sim
+0000a170: 696c 6172 6974 792c 0a20 2020 2020 2020  ilarity,.       
+0000a180: 2020 2020 2020 2020 2020 2020 2079 6561               yea
+0000a190: 725f 7369 6d69 6c61 7269 7479 2c0a 2020  r_similarity,.  
+0000a1a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a1b0: 2020 6f75 746c 6574 5f73 696d 696c 6172    outlet_similar
+0000a1c0: 6974 792c 0a20 2020 2020 2020 2020 2020  ity,.           
+0000a1d0: 2020 2020 2020 2020 2076 6f6c 756d 655f           volume_
+0000a1e0: 7369 6d69 6c61 7269 7479 2c0a 2020 2020  similarity,.    
+0000a1f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a200: 6e75 6d62 6572 5f73 696d 696c 6172 6974  number_similarit
+0000a210: 792c 0a20 2020 2020 2020 2020 2020 2020  y,.             
+0000a220: 2020 205d 0a0a 2020 2020 2020 2020 2020     ]..          
+0000a230: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000a240: 2020 2020 2020 2020 7765 6967 6874 7320          weights 
+0000a250: 3d20 5b30 2e31 352c 2030 2e37 352c 2030  = [0.15, 0.75, 0
+0000a260: 2e30 352c 2030 2e30 355d 0a20 2020 2020  .05, 0.05].     
+0000a270: 2020 2020 2020 2020 2020 2073 696d 5f6e             sim_n
+0000a280: 616d 6573 203d 205b 0a20 2020 2020 2020  ames = [.       
+0000a290: 2020 2020 2020 2020 2020 2020 2022 6175               "au
+0000a2a0: 7468 6f72 222c 0a20 2020 2020 2020 2020  thor",.         
+0000a2b0: 2020 2020 2020 2020 2020 2022 7469 746c             "titl
+0000a2c0: 6522 2c0a 2020 2020 2020 2020 2020 2020  e",.            
+0000a2d0: 2020 2020 2020 2020 2279 6561 7222 2c0a          "year",.
+0000a2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a2f0: 2020 2020 226f 7574 6c65 7422 2c0a 2020      "outlet",.  
+0000a300: 2020 2020 2020 2020 2020 2020 2020 5d0a                ].
+0000a310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a320: 7369 6d69 6c61 7269 7469 6573 203d 205b  similarities = [
+0000a330: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a340: 2020 2020 2061 7574 686f 725f 7369 6d69       author_simi
+0000a350: 6c61 7269 7479 2c0a 2020 2020 2020 2020  larity,.        
+0000a360: 2020 2020 2020 2020 2020 2020 7469 746c              titl
+0000a370: 655f 7369 6d69 6c61 7269 7479 2c0a 2020  e_similarity,.  
+0000a380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a390: 2020 7965 6172 5f73 696d 696c 6172 6974    year_similarit
+0000a3a0: 792c 0a20 2020 2020 2020 2020 2020 2020  y,.             
+0000a3b0: 2020 2020 2020 206f 7574 6c65 745f 7369         outlet_si
+0000a3c0: 6d69 6c61 7269 7479 2c0a 2020 2020 2020  milarity,.      
+0000a3d0: 2020 2020 2020 2020 2020 5d0a 0a20 2020            ]..   
+0000a3e0: 2020 2020 2020 2020 2077 6569 6768 7465           weighte
+0000a3f0: 645f 6176 6572 6167 6520 3d20 7375 6d28  d_average = sum(
+0000a400: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a410: 2073 696d 696c 6172 6974 6965 735b 675d   similarities[g]
+0000a420: 202a 2077 6569 6768 7473 5b67 5d20 666f   * weights[g] fo
+0000a430: 7220 6720 696e 2072 616e 6765 286c 656e  r g in range(len
+0000a440: 2873 696d 696c 6172 6974 6965 7329 290a  (similarities)).
+0000a450: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
+0000a460: 2020 2020 2020 2020 2020 2064 6574 6169             detai
+0000a470: 6c73 203d 2028 0a20 2020 2020 2020 2020  ls = (.         
+0000a480: 2020 2020 2020 2022 5b22 0a20 2020 2020         "[".     
+0000a490: 2020 2020 2020 2020 2020 202b 2022 2c22             + ","
+0000a4a0: 2e6a 6f69 6e28 5b73 696d 5f6e 616d 6573  .join([sim_names
+0000a4b0: 5b67 5d20 666f 7220 6720 696e 2072 616e  [g] for g in ran
+0000a4c0: 6765 286c 656e 2873 696d 696c 6172 6974  ge(len(similarit
+0000a4d0: 6965 7329 295d 290a 2020 2020 2020 2020  ies))]).        
+0000a4e0: 2020 2020 2020 2020 2b20 225d 220a 2020          + "]".  
+0000a4f0: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
+0000a500: 222a 7765 6967 6874 735f 7665 636f 725e  "*weights_vecor^
+0000a510: 5420 3d20 220a 2020 2020 2020 2020 2020  T = ".          
+0000a520: 2020 2020 2020 2b20 225b 220a 2020 2020        + "[".    
+0000a530: 2020 2020 2020 2020 2020 2020 2b20 222c              + ",
+0000a540: 222e 6a6f 696e 285b 7374 7228 7369 6d69  ".join([str(simi
+0000a550: 6c61 7269 7469 6573 5b67 5d29 2066 6f72  larities[g]) for
+0000a560: 2067 2069 6e20 7261 6e67 6528 6c65 6e28   g in range(len(
+0000a570: 7369 6d69 6c61 7269 7469 6573 2929 5d29  similarities))])
+0000a580: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a590: 202b 2022 5d2a 220a 2020 2020 2020 2020   + "]*".        
+0000a5a0: 2020 2020 2020 2020 2b20 225b 220a 2020          + "[".  
+0000a5b0: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
+0000a5c0: 222c 222e 6a6f 696e 285b 7374 7228 7765  ",".join([str(we
+0000a5d0: 6967 6874 735b 675d 2920 666f 7220 6720  ights[g]) for g 
+0000a5e0: 696e 2072 616e 6765 286c 656e 2873 696d  in range(len(sim
+0000a5f0: 696c 6172 6974 6965 7329 295d 290a 2020  ilarities))]).  
+0000a600: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
+0000a610: 225d 5e54 220a 2020 2020 2020 2020 2020  "]^T".          
+0000a620: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+0000a630: 7369 6d69 6c61 7269 7479 5f73 636f 7265  similarity_score
+0000a640: 203d 2072 6f75 6e64 2877 6569 6768 7465   = round(weighte
+0000a650: 645f 6176 6572 6167 652c 2034 290a 2020  d_average, 4).  
+0000a660: 2020 2020 2020 6578 6365 7074 2041 7474        except Att
+0000a670: 7269 6275 7465 4572 726f 723a 0a20 2020  ributeError:.   
+0000a680: 2020 2020 2020 2020 2073 696d 696c 6172           similar
+0000a690: 6974 795f 7363 6f72 6520 3d20 300a 2020  ity_score = 0.  
+0000a6a0: 2020 2020 2020 2020 2020 6465 7461 696c            detail
+0000a6b0: 7320 3d20 2222 0a20 2020 2020 2020 2072  s = "".        r
+0000a6c0: 6574 7572 6e20 7b22 7363 6f72 6522 3a20  eturn {"score": 
+0000a6d0: 7369 6d69 6c61 7269 7479 5f73 636f 7265  similarity_score
+0000a6e0: 2c20 2264 6574 6169 6c73 223a 2064 6574  , "details": det
+0000a6f0: 6169 6c73 7d0a 0a20 2020 2064 6566 2067  ails}..    def g
+0000a700: 6574 5f66 6965 6c64 5f70 726f 7665 6e61  et_field_provena
+0000a710: 6e63 6528 0a20 2020 2020 2020 2073 656c  nce(.        sel
+0000a720: 662c 202a 2c20 6b65 793a 2073 7472 2c20  f, *, key: str, 
+0000a730: 6465 6661 756c 745f 736f 7572 6365 3a20  default_source: 
+0000a740: 7374 7220 3d20 224f 5249 4749 4e41 4c22  str = "ORIGINAL"
+0000a750: 0a20 2020 2029 202d 3e20 6469 6374 3a0a  .    ) -> dict:.
+0000a760: 2020 2020 2020 2020 2222 2247 6574 2074          """Get t
+0000a770: 6865 2070 726f 7665 6e61 6e63 6520 666f  he provenance fo
+0000a780: 7220 6120 7365 6c65 6374 6564 2066 6965  r a selected fie
+0000a790: 6c64 2028 6b65 7929 2222 220a 2020 2020  ld (key)""".    
+0000a7a0: 2020 2020 6465 6661 756c 745f 6e6f 7465      default_note
+0000a7b0: 203d 2022 220a 2020 2020 2020 2020 6e6f   = "".        no
+0000a7c0: 7465 203d 2064 6566 6175 6c74 5f6e 6f74  te = default_not
+0000a7d0: 650a 2020 2020 2020 2020 736f 7572 6365  e.        source
+0000a7e0: 203d 2064 6566 6175 6c74 5f73 6f75 7263   = default_sourc
+0000a7f0: 650a 2020 2020 2020 2020 6966 206b 6579  e.        if key
+0000a800: 2069 6e20 7365 6c66 2e69 6465 6e74 6966   in self.identif
+0000a810: 7969 6e67 5f66 6965 6c64 5f6b 6579 733a  ying_field_keys:
+0000a820: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000a830: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
+0000a840: 7461 5f70 726f 7665 6e61 6e63 6522 2069  ta_provenance" i
+0000a850: 6e20 7365 6c66 2e64 6174 613a 0a20 2020  n self.data:.   
+0000a860: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000a870: 6b65 7920 696e 2073 656c 662e 6461 7461  key in self.data
+0000a880: 2e67 6574 2822 636f 6c72 6576 5f6d 6173  .get("colrev_mas
+0000a890: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
+0000a8a0: 6365 222c 207b 7d29 3a0a 2020 2020 2020  ce", {}):.      
+0000a8b0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0000a8c0: 2022 736f 7572 6365 2220 696e 2073 656c   "source" in sel
+0000a8d0: 662e 6461 7461 5b22 636f 6c72 6576 5f6d  f.data["colrev_m
+0000a8e0: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
+0000a8f0: 616e 6365 225d 5b6b 6579 5d3a 0a20 2020  ance"][key]:.   
+0000a900: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a910: 2020 2020 2073 6f75 7263 6520 3d20 7365       source = se
+0000a920: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
+0000a930: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
+0000a940: 6e61 6e63 6522 5d5b 6b65 795d 5b0a 2020  nance"][key][.  
+0000a950: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a960: 2020 2020 2020 2020 2020 2273 6f75 7263            "sourc
+0000a970: 6522 0a20 2020 2020 2020 2020 2020 2020  e".             
+0000a980: 2020 2020 2020 2020 2020 205d 0a20 2020             ].   
+0000a990: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a9a0: 2069 6620 226e 6f74 6522 2069 6e20 7365   if "note" in se
+0000a9b0: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
+0000a9c0: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
+0000a9d0: 6e61 6e63 6522 5d5b 6b65 795d 3a0a 2020  nance"][key]:.  
+0000a9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a9f0: 2020 2020 2020 6e6f 7465 203d 2073 656c        note = sel
+0000aa00: 662e 6461 7461 5b22 636f 6c72 6576 5f6d  f.data["colrev_m
+0000aa10: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
+0000aa20: 616e 6365 225d 5b6b 6579 5d5b 226e 6f74  ance"][key]["not
+0000aa30: 6522 5d0a 2020 2020 2020 2020 656c 7365  e"].        else
+0000aa40: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+0000aa50: 2022 636f 6c72 6576 5f64 6174 615f 7072   "colrev_data_pr
+0000aa60: 6f76 656e 616e 6365 2220 696e 2073 656c  ovenance" in sel
+0000aa70: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
+0000aa80: 2020 2020 2020 2020 6966 206b 6579 2069          if key i
+0000aa90: 6e20 7365 6c66 2e64 6174 615b 2263 6f6c  n self.data["col
+0000aaa0: 7265 765f 6461 7461 5f70 726f 7665 6e61  rev_data_provena
+0000aab0: 6e63 6522 5d3a 0a20 2020 2020 2020 2020  nce"]:.         
+0000aac0: 2020 2020 2020 2020 2020 2069 6620 2273             if "s
+0000aad0: 6f75 7263 6522 2069 6e20 7365 6c66 2e64  ource" in self.d
+0000aae0: 6174 615b 2263 6f6c 7265 765f 6461 7461  ata["colrev_data
+0000aaf0: 5f70 726f 7665 6e61 6e63 6522 5d5b 6b65  _provenance"][ke
+0000ab00: 795d 3a0a 2020 2020 2020 2020 2020 2020  y]:.            
+0000ab10: 2020 2020 2020 2020 2020 2020 736f 7572              sour
+0000ab20: 6365 203d 2073 656c 662e 6461 7461 5b22  ce = self.data["
+0000ab30: 636f 6c72 6576 5f64 6174 615f 7072 6f76  colrev_data_prov
+0000ab40: 656e 616e 6365 225d 5b6b 6579 5d5b 2273  enance"][key]["s
+0000ab50: 6f75 7263 6522 5d0a 2020 2020 2020 2020  ource"].        
+0000ab60: 2020 2020 2020 2020 2020 2020 6966 2022              if "
+0000ab70: 6e6f 7465 2220 696e 2073 656c 662e 6461  note" in self.da
+0000ab80: 7461 5b22 636f 6c72 6576 5f64 6174 615f  ta["colrev_data_
+0000ab90: 7072 6f76 656e 616e 6365 225d 5b6b 6579  provenance"][key
+0000aba0: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
+0000abb0: 2020 2020 2020 2020 2020 206e 6f74 6520             note 
+0000abc0: 3d20 7365 6c66 2e64 6174 615b 2263 6f6c  = self.data["col
+0000abd0: 7265 765f 6461 7461 5f70 726f 7665 6e61  rev_data_provena
+0000abe0: 6e63 6522 5d5b 6b65 795d 5b22 6e6f 7465  nce"][key]["note
+0000abf0: 225d 0a0a 2020 2020 2020 2020 7265 7475  "]..        retu
+0000ac00: 726e 207b 2273 6f75 7263 6522 3a20 736f  rn {"source": so
+0000ac10: 7572 6365 2c20 226e 6f74 6522 3a20 6e6f  urce, "note": no
+0000ac20: 7465 7d0a 0a20 2020 2064 6566 2072 656d  te}..    def rem
+0000ac30: 6f76 655f 6d61 7374 6572 6461 7461 5f70  ove_masterdata_p
+0000ac40: 726f 7665 6e61 6e63 655f 6e6f 7465 2873  rovenance_note(s
+0000ac50: 656c 662c 202a 2c20 6b65 793a 2073 7472  elf, *, key: str
+0000ac60: 2c20 6e6f 7465 3a20 7374 7229 202d 3e20  , note: str) -> 
+0000ac70: 4e6f 6e65 3a0a 2020 2020 2020 2020 2222  None:.        ""
+0000ac80: 2252 656d 6f76 6520 6120 6d61 7374 6572  "Remove a master
+0000ac90: 6461 7461 2070 726f 7665 6e61 6e63 6520  data provenance 
+0000aca0: 6e6f 7465 2222 220a 2020 2020 2020 2020  note""".        
+0000acb0: 6966 2022 636f 6c72 6576 5f6d 6173 7465  if "colrev_maste
+0000acc0: 7264 6174 615f 7072 6f76 656e 616e 6365  rdata_provenance
+0000acd0: 2220 6e6f 7420 696e 2073 656c 662e 6461  " not in self.da
+0000ace0: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
+0000acf0: 7265 7475 726e 0a20 2020 2020 2020 2069  return.        i
+0000ad00: 6620 6b65 7920 6e6f 7420 696e 2073 656c  f key not in sel
+0000ad10: 662e 6461 7461 5b22 636f 6c72 6576 5f6d  f.data["colrev_m
+0000ad20: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
+0000ad30: 616e 6365 225d 3a0a 2020 2020 2020 2020  ance"]:.        
+0000ad40: 2020 2020 7265 7475 726e 0a20 2020 2020      return.     
+0000ad50: 2020 206e 6f74 6573 203d 2073 656c 662e     notes = self.
+0000ad60: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
+0000ad70: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
+0000ad80: 6365 225d 5b6b 6579 5d5b 226e 6f74 6522  ce"][key]["note"
+0000ad90: 5d2e 7370 6c69 7428 222c 2229 0a20 2020  ].split(",").   
+0000ada0: 2020 2020 2069 6620 6e6f 7465 206e 6f74       if note not
+0000adb0: 2069 6e20 6e6f 7465 733a 0a20 2020 2020   in notes:.     
+0000adc0: 2020 2020 2020 2072 6574 7572 6e0a 2020         return.  
+0000add0: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
+0000ade0: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
+0000adf0: 7461 5f70 726f 7665 6e61 6e63 6522 5d5b  ta_provenance"][
+0000ae00: 6b65 795d 5b22 6e6f 7465 225d 203d 2022  key]["note"] = "
+0000ae10: 2c22 2e6a 6f69 6e28 0a20 2020 2020 2020  ,".join(.       
+0000ae20: 2020 2020 206e 2066 6f72 206e 2069 6e20       n for n in 
+0000ae30: 6e6f 7465 7320 6966 206e 2021 3d20 6e6f  notes if n != no
+0000ae40: 7465 0a20 2020 2020 2020 2029 0a0a 2020  te.        )..  
+0000ae50: 2020 6465 6620 6164 645f 6d61 7374 6572    def add_master
+0000ae60: 6461 7461 5f70 726f 7665 6e61 6e63 655f  data_provenance_
+0000ae70: 6e6f 7465 2873 656c 662c 202a 2c20 6b65  note(self, *, ke
+0000ae80: 793a 2073 7472 2c20 6e6f 7465 3a20 7374  y: str, note: st
+0000ae90: 7229 202d 3e20 4e6f 6e65 3a0a 2020 2020  r) -> None:.    
+0000aea0: 2020 2020 2222 2241 6464 2061 206d 6173      """Add a mas
+0000aeb0: 7465 7264 6174 6120 7072 6f76 656e 616e  terdata provenan
+0000aec0: 6365 206e 6f74 6520 2862 6173 6564 206f  ce note (based o
+0000aed0: 6e20 6120 6b65 7929 2222 220a 2020 2020  n a key)""".    
+0000aee0: 2020 2020 6966 2022 636f 6c72 6576 5f6d      if "colrev_m
+0000aef0: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
+0000af00: 616e 6365 2220 6e6f 7420 696e 2073 656c  ance" not in sel
+0000af10: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
+0000af20: 2020 2020 7365 6c66 2e64 6174 615b 2263      self.data["c
+0000af30: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
+0000af40: 5f70 726f 7665 6e61 6e63 6522 5d20 3d20  _provenance"] = 
+0000af50: 7b7d 0a20 2020 2020 2020 2069 6620 6b65  {}.        if ke
+0000af60: 7920 696e 2073 656c 662e 6461 7461 2e67  y in self.data.g
+0000af70: 6574 2822 636f 6c72 6576 5f6d 6173 7465  et("colrev_maste
+0000af80: 7264 6174 615f 7072 6f76 656e 616e 6365  rdata_provenance
+0000af90: 222c 207b 7d29 3a0a 2020 2020 2020 2020  ", {}):.        
+0000afa0: 2020 2020 6966 2028 0a20 2020 2020 2020      if (.       
+0000afb0: 2020 2020 2020 2020 2022 2220 3d3d 2073           "" == s
+0000afc0: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
+0000afd0: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
+0000afe0: 656e 616e 6365 225d 5b6b 6579 5d5b 226e  enance"][key]["n
+0000aff0: 6f74 6522 5d0a 2020 2020 2020 2020 2020  ote"].          
+0000b000: 2020 2020 2020 6f72 2022 2220 3d3d 206e        or "" == n
+0000b010: 6f74 650a 2020 2020 2020 2020 2020 2020  ote.            
+0000b020: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000b030: 2020 2073 656c 662e 6461 7461 5b22 636f     self.data["co
+0000b040: 6c72 6576 5f6d 6173 7465 7264 6174 615f  lrev_masterdata_
+0000b050: 7072 6f76 656e 616e 6365 225d 5b6b 6579  provenance"][key
+0000b060: 5d5b 226e 6f74 6522 5d20 3d20 6e6f 7465  ]["note"] = note
+0000b070: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
+0000b080: 6620 6e6f 7465 206e 6f74 2069 6e20 7365  f note not in se
+0000b090: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
+0000b0a0: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
+0000b0b0: 6e61 6e63 6522 5d5b 6b65 795d 5b0a 2020  nance"][key][.  
+0000b0c0: 2020 2020 2020 2020 2020 2020 2020 226e                "n
+0000b0d0: 6f74 6522 0a20 2020 2020 2020 2020 2020  ote".           
+0000b0e0: 205d 2e73 706c 6974 2822 2c22 293a 0a20   ].split(","):. 
+0000b0f0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000b100: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
+0000b110: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
+0000b120: 656e 616e 6365 225d 5b6b 6579 5d5b 226e  enance"][key]["n
+0000b130: 6f74 6522 5d20 2b3d 2066 222c 7b6e 6f74  ote"] += f",{not
+0000b140: 657d 220a 2020 2020 2020 2020 656c 7365  e}".        else
+0000b150: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+0000b160: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
+0000b170: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
+0000b180: 6e61 6e63 6522 5d5b 6b65 795d 203d 207b  nance"][key] = {
+0000b190: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b1a0: 2022 736f 7572 6365 223a 2022 4f52 4947   "source": "ORIG
+0000b1b0: 494e 414c 222c 0a20 2020 2020 2020 2020  INAL",.         
+0000b1c0: 2020 2020 2020 2022 6e6f 7465 223a 206e         "note": n
+0000b1d0: 6f74 652c 0a20 2020 2020 2020 2020 2020  ote,.           
+0000b1e0: 207d 0a0a 2020 2020 2020 2020 6578 6973   }..        exis
+0000b1f0: 7469 6e67 5f6e 6f74 6520 3d20 7365 6c66  ting_note = self
+0000b200: 2e64 6174 615b 2263 6f6c 7265 765f 6d61  .data["colrev_ma
+0000b210: 7374 6572 6461 7461 5f70 726f 7665 6e61  sterdata_provena
+0000b220: 6e63 6522 5d5b 6b65 795d 5b22 6e6f 7465  nce"][key]["note
+0000b230: 225d 0a20 2020 2020 2020 2069 6620 2271  "].        if "q
+0000b240: 7561 6c69 7479 5f64 6566 6563 7422 2069  uality_defect" i
+0000b250: 6e20 6578 6973 7469 6e67 5f6e 6f74 6520  n existing_note 
+0000b260: 616e 6420 616e 7928 0a20 2020 2020 2020  and any(.       
+0000b270: 2020 2020 2078 2069 6e20 6578 6973 7469       x in existi
+0000b280: 6e67 5f6e 6f74 6520 666f 7220 7820 696e  ng_note for x in
+0000b290: 205b 226d 6973 7369 6e67 222c 2022 6469   ["missing", "di
+0000b2a0: 7361 6772 6565 6d65 6e74 225d 0a20 2020  sagreement"].   
+0000b2b0: 2020 2020 2029 3a0a 2020 2020 2020 2020       ):.        
+0000b2c0: 2020 2020 7365 6c66 2e64 6174 615b 2263      self.data["c
+0000b2d0: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
+0000b2e0: 5f70 726f 7665 6e61 6e63 6522 5d5b 6b65  _provenance"][ke
+0000b2f0: 795d 5b22 6e6f 7465 225d 203d 2028 0a20  y]["note"] = (. 
+0000b300: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000b310: 7869 7374 696e 675f 6e6f 7465 2e72 6570  xisting_note.rep
+0000b320: 6c61 6365 2822 7175 616c 6974 795f 6465  lace("quality_de
+0000b330: 6665 6374 222c 2022 2229 2e72 7374 7269  fect", "").rstri
+0000b340: 7028 222c 2229 2e6c 7374 7269 7028 222c  p(",").lstrip(",
+0000b350: 2229 0a20 2020 2020 2020 2020 2020 2029  ").            )
+0000b360: 0a0a 2020 2020 6465 6620 6164 645f 6461  ..    def add_da
+0000b370: 7461 5f70 726f 7665 6e61 6e63 655f 6e6f  ta_provenance_no
+0000b380: 7465 2873 656c 662c 202a 2c20 6b65 793a  te(self, *, key:
+0000b390: 2073 7472 2c20 6e6f 7465 3a20 7374 7229   str, note: str)
+0000b3a0: 202d 3e20 4e6f 6e65 3a0a 2020 2020 2020   -> None:.      
+0000b3b0: 2020 2222 2241 6464 2061 2064 6174 6120    """Add a data 
+0000b3c0: 7072 6f76 656e 616e 6365 206e 6f74 6520  provenance note 
+0000b3d0: 2862 6173 6564 206f 6e20 6120 6b65 7929  (based on a key)
+0000b3e0: 2222 220a 2020 2020 2020 2020 6966 2022  """.        if "
+0000b3f0: 636f 6c72 6576 5f64 6174 615f 7072 6f76  colrev_data_prov
+0000b400: 656e 616e 6365 2220 6e6f 7420 696e 2073  enance" not in s
+0000b410: 656c 662e 6461 7461 3a0a 2020 2020 2020  elf.data:.      
+0000b420: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
+0000b430: 2263 6f6c 7265 765f 6461 7461 5f70 726f  "colrev_data_pro
+0000b440: 7665 6e61 6e63 6522 5d20 3d20 7b7d 0a20  venance"] = {}. 
+0000b450: 2020 2020 2020 2069 6620 6b65 7920 696e         if key in
+0000b460: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
+0000b470: 6576 5f64 6174 615f 7072 6f76 656e 616e  ev_data_provenan
+0000b480: 6365 225d 3a0a 2020 2020 2020 2020 2020  ce"]:.          
+0000b490: 2020 6966 2073 656c 662e 6461 7461 5b22    if self.data["
+0000b4a0: 636f 6c72 6576 5f64 6174 615f 7072 6f76  colrev_data_prov
+0000b4b0: 656e 616e 6365 225d 5b6b 6579 5d5b 226e  enance"][key]["n
+0000b4c0: 6f74 6522 5d20 3d3d 2022 223a 0a20 2020  ote"] == "":.   
+0000b4d0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000b4e0: 662e 6461 7461 5b22 636f 6c72 6576 5f64  f.data["colrev_d
+0000b4f0: 6174 615f 7072 6f76 656e 616e 6365 225d  ata_provenance"]
+0000b500: 5b6b 6579 5d5b 226e 6f74 6522 5d20 3d20  [key]["note"] = 
+0000b510: 6e6f 7465 0a20 2020 2020 2020 2020 2020  note.           
+0000b520: 2065 6c69 6620 6e6f 7465 206e 6f74 2069   elif note not i
+0000b530: 6e20 7365 6c66 2e64 6174 615b 2263 6f6c  n self.data["col
+0000b540: 7265 765f 6461 7461 5f70 726f 7665 6e61  rev_data_provena
+0000b550: 6e63 6522 5d5b 6b65 795d 5b22 6e6f 7465  nce"][key]["note
+0000b560: 225d 2e73 706c 6974 280a 2020 2020 2020  "].split(.      
+0000b570: 2020 2020 2020 2020 2020 222c 220a 2020            ",".  
+0000b580: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
+0000b590: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000b5a0: 662e 6461 7461 5b22 636f 6c72 6576 5f64  f.data["colrev_d
+0000b5b0: 6174 615f 7072 6f76 656e 616e 6365 225d  ata_provenance"]
+0000b5c0: 5b6b 6579 5d5b 226e 6f74 6522 5d20 2b3d  [key]["note"] +=
+0000b5d0: 2066 222c 7b6e 6f74 657d 220a 2020 2020   f",{note}".    
+0000b5e0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000b5f0: 2020 2020 2020 7365 6c66 2e64 6174 615b        self.data[
+0000b600: 2263 6f6c 7265 765f 6461 7461 5f70 726f  "colrev_data_pro
+0000b610: 7665 6e61 6e63 6522 5d5b 6b65 795d 203d  venance"][key] =
+0000b620: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+0000b630: 2020 2022 736f 7572 6365 223a 2022 4f52     "source": "OR
+0000b640: 4947 494e 414c 222c 0a20 2020 2020 2020  IGINAL",.       
+0000b650: 2020 2020 2020 2020 2022 6e6f 7465 223a           "note":
+0000b660: 206e 6f74 652c 0a20 2020 2020 2020 2020   note,.         
+0000b670: 2020 207d 0a0a 2020 2020 6465 6620 6164     }..    def ad
+0000b680: 645f 6d61 7374 6572 6461 7461 5f70 726f  d_masterdata_pro
+0000b690: 7665 6e61 6e63 6528 0a20 2020 2020 2020  venance(.       
+0000b6a0: 2073 656c 662c 202a 2c20 6b65 793a 2073   self, *, key: s
+0000b6b0: 7472 2c20 736f 7572 6365 3a20 7374 722c  tr, source: str,
+0000b6c0: 206e 6f74 653a 2073 7472 203d 2022 220a   note: str = "".
+0000b6d0: 2020 2020 2920 2d3e 204e 6f6e 653a 0a20      ) -> None:. 
+0000b6e0: 2020 2020 2020 2022 2222 4164 6420 6120         """Add a 
+0000b6f0: 6d61 7374 6572 6461 7461 2070 726f 7665  masterdata prove
+0000b700: 6e61 6e63 652c 2069 6e63 6c75 6469 6e67  nance, including
+0000b710: 2073 6f75 7263 6520 616e 6420 6e6f 7465   source and note
+0000b720: 2028 6261 7365 6420 6f6e 2061 206b 6579   (based on a key
+0000b730: 2922 2222 0a20 2020 2020 2020 2069 6620  )""".        if 
+0000b740: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
+0000b750: 7461 5f70 726f 7665 6e61 6e63 6522 206e  ta_provenance" n
+0000b760: 6f74 2069 6e20 7365 6c66 2e64 6174 613a  ot in self.data:
+0000b770: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+0000b780: 662e 6461 7461 5b22 636f 6c72 6576 5f6d  f.data["colrev_m
+0000b790: 6173 7465 7264 6174 615f 7072 6f76 656e  asterdata_proven
+0000b7a0: 616e 6365 225d 203d 207b 7d0a 2020 2020  ance"] = {}.    
+0000b7b0: 2020 2020 6d64 5f70 5f64 6963 7420 3d20      md_p_dict = 
+0000b7c0: 7365 6c66 2e64 6174 615b 2263 6f6c 7265  self.data["colre
+0000b7d0: 765f 6d61 7374 6572 6461 7461 5f70 726f  v_masterdata_pro
+0000b7e0: 7665 6e61 6e63 6522 5d0a 0a20 2020 2020  venance"]..     
+0000b7f0: 2020 2069 6620 6b65 7920 696e 206d 645f     if key in md_
+0000b800: 705f 6469 6374 3a0a 2020 2020 2020 2020  p_dict:.        
+0000b810: 2020 2020 6966 206d 645f 705f 6469 6374      if md_p_dict
+0000b820: 5b6b 6579 5d5b 226e 6f74 6522 5d20 3d3d  [key]["note"] ==
+0000b830: 2022 2220 6f72 2022 2220 3d3d 206e 6f74   "" or "" == not
+0000b840: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000b850: 2020 206d 645f 705f 6469 6374 5b6b 6579     md_p_dict[key
+0000b860: 5d5b 226e 6f74 6522 5d20 3d20 6e6f 7465  ]["note"] = note
+0000b870: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
+0000b880: 6620 226d 6973 7369 6e67 2220 3d3d 206e  f "missing" == n
+0000b890: 6f74 6520 616e 6420 226e 6f74 2d6d 6973  ote and "not-mis
+0000b8a0: 7369 6e67 2220 696e 206d 645f 705f 6469  sing" in md_p_di
+0000b8b0: 6374 5b6b 6579 5d5b 226e 6f74 6522 5d2e  ct[key]["note"].
+0000b8c0: 7370 6c69 7428 0a20 2020 2020 2020 2020  split(.         
+0000b8d0: 2020 2020 2020 2022 2c22 0a20 2020 2020         ",".     
+0000b8e0: 2020 2020 2020 2029 3a0a 2020 2020 2020         ):.      
+0000b8f0: 2020 2020 2020 2020 2020 6d64 5f70 5f64            md_p_d
+0000b900: 6963 745b 6b65 795d 5b22 6e6f 7465 225d  ict[key]["note"]
+0000b910: 203d 2022 6d69 7373 696e 6722 0a20 2020   = "missing".   
+0000b920: 2020 2020 2020 2020 2065 6c69 6620 6e6f           elif no
+0000b930: 7465 206e 6f74 2069 6e20 6d64 5f70 5f64  te not in md_p_d
+0000b940: 6963 745b 6b65 795d 5b22 6e6f 7465 225d  ict[key]["note"]
+0000b950: 2e73 706c 6974 2822 2c22 293a 0a20 2020  .split(","):.   
+0000b960: 2020 2020 2020 2020 2020 2020 206d 645f               md_
+0000b970: 705f 6469 6374 5b6b 6579 5d5b 226e 6f74  p_dict[key]["not
+0000b980: 6522 5d20 2b3d 2066 222c 7b6e 6f74 657d  e"] += f",{note}
+0000b990: 220a 2020 2020 2020 2020 2020 2020 6d64  ".            md
+0000b9a0: 5f70 5f64 6963 745b 6b65 795d 5b22 736f  _p_dict[key]["so
+0000b9b0: 7572 6365 225d 203d 2073 6f75 7263 650a  urce"] = source.
+0000b9c0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0000b9d0: 2020 2020 2020 2020 2020 6d64 5f70 5f64            md_p_d
+0000b9e0: 6963 745b 6b65 795d 203d 207b 2273 6f75  ict[key] = {"sou
+0000b9f0: 7263 6522 3a20 736f 7572 6365 2c20 226e  rce": source, "n
+0000ba00: 6f74 6522 3a20 6622 7b6e 6f74 657d 227d  ote": f"{note}"}
+0000ba10: 0a0a 2020 2020 6465 6620 6164 645f 7072  ..    def add_pr
+0000ba20: 6f76 656e 616e 6365 5f61 6c6c 2873 656c  ovenance_all(sel
+0000ba30: 662c 202a 2c20 736f 7572 6365 3a20 7374  f, *, source: st
+0000ba40: 7229 202d 3e20 4e6f 6e65 3a0a 2020 2020  r) -> None:.    
+0000ba50: 2020 2020 2222 2241 6464 2061 2064 6174      """Add a dat
+0000ba60: 6120 7072 6f76 656e 616e 6365 2028 736f  a provenance (so
+0000ba70: 7572 6365 2920 746f 2061 6c6c 2066 6965  urce) to all fie
+0000ba80: 6c64 7322 2222 0a20 2020 2020 2020 2069  lds""".        i
+0000ba90: 6620 2263 6f6c 7265 765f 6d61 7374 6572  f "colrev_master
+0000baa0: 6461 7461 5f70 726f 7665 6e61 6e63 6522  data_provenance"
+0000bab0: 206e 6f74 2069 6e20 7365 6c66 2e64 6174   not in self.dat
+0000bac0: 613a 0a20 2020 2020 2020 2020 2020 2073  a:.            s
+0000bad0: 656c 662e 6461 7461 5b22 636f 6c72 6576  elf.data["colrev
+0000bae0: 5f6d 6173 7465 7264 6174 615f 7072 6f76  _masterdata_prov
+0000baf0: 656e 616e 6365 225d 203d 207b 7d0a 2020  enance"] = {}.  
+0000bb00: 2020 2020 2020 6966 2022 636f 6c72 6576        if "colrev
+0000bb10: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
+0000bb20: 2220 6e6f 7420 696e 2073 656c 662e 6461  " not in self.da
+0000bb30: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
+0000bb40: 7365 6c66 2e64 6174 615b 2263 6f6c 7265  self.data["colre
+0000bb50: 765f 6461 7461 5f70 726f 7665 6e61 6e63  v_data_provenanc
+0000bb60: 6522 5d20 3d20 7b7d 0a0a 2020 2020 2020  e"] = {}..      
+0000bb70: 2020 6d64 5f70 5f64 6963 7420 3d20 7365    md_p_dict = se
+0000bb80: 6c66 2e64 6174 615b 2263 6f6c 7265 765f  lf.data["colrev_
+0000bb90: 6d61 7374 6572 6461 7461 5f70 726f 7665  masterdata_prove
+0000bba0: 6e61 6e63 6522 5d0a 2020 2020 2020 2020  nance"].        
+0000bbb0: 645f 705f 6469 6374 203d 2073 656c 662e  d_p_dict = self.
+0000bbc0: 6461 7461 5b22 636f 6c72 6576 5f64 6174  data["colrev_dat
+0000bbd0: 615f 7072 6f76 656e 616e 6365 225d 0a20  a_provenance"]. 
+0000bbe0: 2020 2020 2020 2066 6f72 206b 6579 2069         for key i
+0000bbf0: 6e20 7365 6c66 2e64 6174 612e 6b65 7973  n self.data.keys
+0000bc00: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
+0000bc10: 6966 206b 6579 2069 6e20 5b0a 2020 2020  if key in [.    
+0000bc20: 2020 2020 2020 2020 2020 2020 2245 4e54              "ENT
+0000bc30: 5259 5459 5045 222c 0a20 2020 2020 2020  RYTYPE",.       
+0000bc40: 2020 2020 2020 2020 2022 636f 6c72 6576           "colrev
+0000bc50: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
+0000bc60: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+0000bc70: 2020 2022 636f 6c72 6576 5f6d 6173 7465     "colrev_maste
+0000bc80: 7264 6174 615f 7072 6f76 656e 616e 6365  rdata_provenance
+0000bc90: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+0000bca0: 2020 2022 636f 6c72 6576 5f73 7461 7475     "colrev_statu
+0000bcb0: 7322 2c0a 2020 2020 2020 2020 2020 2020  s",.            
+0000bcc0: 2020 2020 2263 6f6c 7265 765f 6964 222c      "colrev_id",
+0000bcd0: 0a20 2020 2020 2020 2020 2020 205d 3a0a  .            ]:.
+0000bce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bcf0: 636f 6e74 696e 7565 0a20 2020 2020 2020  continue.       
+0000bd00: 2020 2020 2069 6620 280a 2020 2020 2020       if (.      
+0000bd10: 2020 2020 2020 2020 2020 6b65 7920 696e            key in
+0000bd20: 2073 656c 662e 6964 656e 7469 6679 696e   self.identifyin
+0000bd30: 675f 6669 656c 645f 6b65 7973 0a20 2020  g_field_keys.   
+0000bd40: 2020 2020 2020 2020 2020 2020 2061 6e64               and
+0000bd50: 2022 4355 5241 5445 4422 206e 6f74 2069   "CURATED" not i
+0000bd60: 6e20 7365 6c66 2e64 6174 615b 2263 6f6c  n self.data["col
+0000bd70: 7265 765f 6d61 7374 6572 6461 7461 5f70  rev_masterdata_p
+0000bd80: 726f 7665 6e61 6e63 6522 5d0a 2020 2020  rovenance"].    
+0000bd90: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
+0000bda0: 2020 2020 2020 2020 2020 206d 645f 705f             md_p_
+0000bdb0: 6469 6374 5b6b 6579 5d20 3d20 7b22 736f  dict[key] = {"so
+0000bdc0: 7572 6365 223a 2073 6f75 7263 652c 2022  urce": source, "
+0000bdd0: 6e6f 7465 223a 2022 227d 0a20 2020 2020  note": ""}.     
+0000bde0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+0000bdf0: 2020 2020 2020 2020 2020 2020 2064 5f70               d_p
+0000be00: 5f64 6963 745b 6b65 795d 203d 207b 2273  _dict[key] = {"s
+0000be10: 6f75 7263 6522 3a20 736f 7572 6365 2c20  ource": source, 
+0000be20: 226e 6f74 6522 3a20 2222 7d0a 0a20 2020  "note": ""}..   
+0000be30: 2064 6566 2061 6464 5f64 6174 615f 7072   def add_data_pr
+0000be40: 6f76 656e 616e 6365 2873 656c 662c 202a  ovenance(self, *
+0000be50: 2c20 6b65 793a 2073 7472 2c20 736f 7572  , key: str, sour
+0000be60: 6365 3a20 7374 722c 206e 6f74 653a 2073  ce: str, note: s
+0000be70: 7472 203d 2022 2229 202d 3e20 4e6f 6e65  tr = "") -> None
+0000be80: 3a0a 2020 2020 2020 2020 2222 2241 6464  :.        """Add
+0000be90: 2061 2064 6174 6120 7072 6f76 656e 616e   a data provenan
+0000bea0: 6365 2c20 696e 636c 7564 696e 6720 736f  ce, including so
+0000beb0: 7572 6365 2061 6e64 206e 6f74 6520 2862  urce and note (b
+0000bec0: 6173 6564 206f 6e20 6120 6b65 7929 2222  ased on a key)""
+0000bed0: 220a 2020 2020 2020 2020 6966 2022 636f  ".        if "co
+0000bee0: 6c72 6576 5f64 6174 615f 7072 6f76 656e  lrev_data_proven
+0000bef0: 616e 6365 2220 6e6f 7420 696e 2073 656c  ance" not in sel
+0000bf00: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
+0000bf10: 2020 2020 7365 6c66 2e64 6174 615b 2263      self.data["c
+0000bf20: 6f6c 7265 765f 6461 7461 5f70 726f 7665  olrev_data_prove
+0000bf30: 6e61 6e63 6522 5d20 3d20 7b7d 0a20 2020  nance"] = {}.   
+0000bf40: 2020 2020 206d 645f 705f 6469 6374 203d       md_p_dict =
+0000bf50: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
+0000bf60: 6576 5f64 6174 615f 7072 6f76 656e 616e  ev_data_provenan
+0000bf70: 6365 225d 0a20 2020 2020 2020 2069 6620  ce"].        if 
+0000bf80: 6b65 7920 696e 206d 645f 705f 6469 6374  key in md_p_dict
+0000bf90: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+0000bfa0: 206e 6f74 6520 213d 2022 223a 0a20 2020   note != "":.   
+0000bfb0: 2020 2020 2020 2020 2020 2020 206d 645f               md_
+0000bfc0: 705f 6469 6374 5b6b 6579 5d5b 226e 6f74  p_dict[key]["not
+0000bfd0: 6522 5d20 2b3d 2066 222c 7b6e 6f74 657d  e"] += f",{note}
+0000bfe0: 220a 2020 2020 2020 2020 2020 2020 656c  ".            el
+0000bff0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000c000: 2020 2020 6d64 5f70 5f64 6963 745b 6b65      md_p_dict[ke
+0000c010: 795d 5b22 6e6f 7465 225d 203d 2022 220a  y]["note"] = "".
+0000c020: 2020 2020 2020 2020 2020 2020 6d64 5f70              md_p
+0000c030: 5f64 6963 745b 6b65 795d 5b22 736f 7572  _dict[key]["sour
+0000c040: 6365 225d 203d 2073 6f75 7263 650a 2020  ce"] = source.  
+0000c050: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000c060: 2020 2020 2020 2020 6d64 5f70 5f64 6963          md_p_dic
+0000c070: 745b 6b65 795d 203d 207b 2273 6f75 7263  t[key] = {"sourc
+0000c080: 6522 3a20 736f 7572 6365 2c20 226e 6f74  e": source, "not
+0000c090: 6522 3a20 6622 7b6e 6f74 657d 227d 0a0a  e": f"{note}"}..
+0000c0a0: 2020 2020 6465 6620 636f 6d70 6c65 7465      def complete
+0000c0b0: 5f70 726f 7665 6e61 6e63 6528 7365 6c66  _provenance(self
+0000c0c0: 2c20 2a2c 2073 6f75 7263 655f 696e 666f  , *, source_info
+0000c0d0: 3a20 7374 7229 202d 3e20 626f 6f6c 3a0a  : str) -> bool:.
+0000c0e0: 2020 2020 2020 2020 2222 2243 6f6d 706c          """Compl
+0000c0f0: 6574 6520 7072 6f76 656e 616e 6365 2069  ete provenance i
+0000c100: 6e66 6f72 6d61 7469 6f6e 2066 6f72 2069  nformation for i
+0000c110: 6e64 6578 696e 6722 2222 0a0a 2020 2020  ndexing"""..    
+0000c120: 2020 2020 666f 7220 6b65 7920 696e 206c      for key in l
+0000c130: 6973 7428 7365 6c66 2e64 6174 612e 6b65  ist(self.data.ke
+0000c140: 7973 2829 293a 0a20 2020 2020 2020 2020  ys()):.         
+0000c150: 2020 2069 6620 280a 2020 2020 2020 2020     if (.        
+0000c160: 2020 2020 2020 2020 6b65 790a 2020 2020          key.    
+0000c170: 2020 2020 2020 2020 2020 2020 696e 205b              in [
+0000c180: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c190: 2020 2020 2022 636f 6c72 6576 5f69 6422       "colrev_id"
+0000c1a0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000c1b0: 2020 2020 2020 2245 4e54 5259 5459 5045        "ENTRYTYPE
+0000c1c0: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+0000c1d0: 2020 2020 2020 2022 4944 222c 0a20 2020         "ID",.   
+0000c1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c1f0: 2022 6d65 7461 6461 7461 5f73 6f75 7263   "metadata_sourc
+0000c200: 655f 7265 706f 7369 746f 7279 5f70 6174  e_repository_pat
+0000c210: 6873 222c 0a20 2020 2020 2020 2020 2020  hs",.           
+0000c220: 2020 2020 2020 2020 2022 6c6f 6361 6c5f           "local_
+0000c230: 6375 7261 7465 645f 6d65 7461 6461 7461  curated_metadata
+0000c240: 222c 0a20 2020 2020 2020 2020 2020 2020  ",.             
+0000c250: 2020 205d 0a20 2020 2020 2020 2020 2020     ].           
+0000c260: 2020 2020 202b 2073 656c 662e 7072 6f76       + self.prov
+0000c270: 656e 616e 6365 5f6b 6579 730a 2020 2020  enance_keys.    
+0000c280: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
+0000c290: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
+0000c2a0: 6e75 650a 0a20 2020 2020 2020 2020 2020  nue..           
+0000c2b0: 2069 6620 6b65 7920 696e 2073 656c 662e   if key in self.
+0000c2c0: 6964 656e 7469 6679 696e 675f 6669 656c  identifying_fiel
+0000c2d0: 645f 6b65 7973 3a0a 2020 2020 2020 2020  d_keys:.        
+0000c2e0: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
+0000c2f0: 656c 662e 6d61 7374 6572 6461 7461 5f69  elf.masterdata_i
+0000c300: 735f 6375 7261 7465 6428 293a 0a20 2020  s_curated():.   
+0000c310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c320: 2073 656c 662e 6164 645f 6d61 7374 6572   self.add_master
+0000c330: 6461 7461 5f70 726f 7665 6e61 6e63 6528  data_provenance(
+0000c340: 6b65 793d 6b65 792c 2073 6f75 7263 653d  key=key, source=
+0000c350: 736f 7572 6365 5f69 6e66 6f2c 206e 6f74  source_info, not
+0000c360: 653d 2222 290a 2020 2020 2020 2020 2020  e="").          
+0000c370: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000c380: 2020 2020 2020 2020 7365 6c66 2e61 6464          self.add
+0000c390: 5f64 6174 615f 7072 6f76 656e 616e 6365  _data_provenance
+0000c3a0: 286b 6579 3d6b 6579 2c20 736f 7572 6365  (key=key, source
+0000c3b0: 3d73 6f75 7263 655f 696e 666f 2c20 6e6f  =source_info, no
+0000c3c0: 7465 3d22 2229 0a0a 2020 2020 2020 2020  te="")..        
+0000c3d0: 7265 7475 726e 2054 7275 650a 0a20 2020  return True..   
+0000c3e0: 2064 6566 2068 6173 5f71 7561 6c69 7479   def has_quality
+0000c3f0: 5f64 6566 6563 7473 2873 656c 6629 202d  _defects(self) -
+0000c400: 3e20 626f 6f6c 3a0a 2020 2020 2020 2020  > bool:.        
+0000c410: 2222 2243 6865 636b 2077 6865 7468 6572  """Check whether
+0000c420: 2061 2072 6563 6f72 6420 6861 7320 7175   a record has qu
+0000c430: 616c 6974 7920 6465 6665 6374 7322 2222  ality defects"""
+0000c440: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+0000c450: 616e 7928 0a20 2020 2020 2020 2020 2020  any(.           
+0000c460: 2078 5b22 6e6f 7465 225d 2021 3d20 2222   x["note"] != ""
+0000c470: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
+0000c480: 2078 2069 6e20 7365 6c66 2e64 6174 612e   x in self.data.
+0000c490: 6765 7428 2263 6f6c 7265 765f 6d61 7374  get("colrev_mast
+0000c4a0: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
+0000c4b0: 6522 2c20 7b7d 292e 7661 6c75 6573 2829  e", {}).values()
+0000c4c0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000c4d0: 6e6f 7420 616e 7928 7920 3d3d 2078 5b22  not any(y == x["
+0000c4e0: 6e6f 7465 225d 2066 6f72 2079 2069 6e20  note"] for y in 
+0000c4f0: 5b22 6e6f 742d 6d69 7373 696e 6722 5d29  ["not-missing"])
+0000c500: 0a20 2020 2020 2020 2029 0a0a 2020 2020  .        )..    
+0000c510: 6465 6620 6765 745f 636f 6e74 6169 6e65  def get_containe
+0000c520: 725f 7469 746c 6528 7365 6c66 2920 2d3e  r_title(self) ->
+0000c530: 2073 7472 3a0a 2020 2020 2020 2020 2222   str:.        ""
+0000c540: 2247 6574 2074 6865 2072 6563 6f72 6427  "Get the record'
+0000c550: 7320 636f 6e74 6169 6e65 7220 7469 746c  s container titl
+0000c560: 6520 286a 6f75 726e 616c 206e 616d 652c  e (journal name,
+0000c570: 2062 6f6f 6b74 6974 6c65 2c20 6574 632e   booktitle, etc.
+0000c580: 2922 2222 0a20 2020 2020 2020 2063 6f6e  )""".        con
+0000c590: 7461 696e 6572 5f74 6974 6c65 203d 2022  tainer_title = "
+0000c5a0: 4e41 220a 2020 2020 2020 2020 6966 2022  NA".        if "
+0000c5b0: 454e 5452 5954 5950 4522 206e 6f74 2069  ENTRYTYPE" not i
+0000c5c0: 6e20 7365 6c66 2e64 6174 613a 0a20 2020  n self.data:.   
+0000c5d0: 2020 2020 2020 2020 2063 6f6e 7461 696e           contain
+0000c5e0: 6572 5f74 6974 6c65 203d 2073 656c 662e  er_title = self.
+0000c5f0: 6461 7461 2e67 6574 2822 6a6f 7572 6e61  data.get("journa
+0000c600: 6c22 2c20 7365 6c66 2e64 6174 612e 6765  l", self.data.ge
+0000c610: 7428 2262 6f6f 6b74 6974 6c65 222c 2022  t("booktitle", "
+0000c620: 4e41 2229 290a 2020 2020 2020 2020 656c  NA")).        el
+0000c630: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000c640: 6966 2073 656c 662e 6461 7461 5b22 454e  if self.data["EN
+0000c650: 5452 5954 5950 4522 5d20 3d3d 2022 6172  TRYTYPE"] == "ar
+0000c660: 7469 636c 6522 3a0a 2020 2020 2020 2020  ticle":.        
+0000c670: 2020 2020 2020 2020 636f 6e74 6169 6e65          containe
+0000c680: 725f 7469 746c 6520 3d20 7365 6c66 2e64  r_title = self.d
+0000c690: 6174 612e 6765 7428 226a 6f75 726e 616c  ata.get("journal
+0000c6a0: 222c 2022 4e41 2229 0a20 2020 2020 2020  ", "NA").       
+0000c6b0: 2020 2020 2069 6620 7365 6c66 2e64 6174       if self.dat
+0000c6c0: 615b 2245 4e54 5259 5459 5045 225d 203d  a["ENTRYTYPE"] =
+0000c6d0: 3d20 2269 6e70 726f 6365 6564 696e 6773  = "inproceedings
+0000c6e0: 223a 0a20 2020 2020 2020 2020 2020 2020  ":.             
+0000c6f0: 2020 2063 6f6e 7461 696e 6572 5f74 6974     container_tit
+0000c700: 6c65 203d 2073 656c 662e 6461 7461 2e67  le = self.data.g
+0000c710: 6574 2822 626f 6f6b 7469 746c 6522 2c20  et("booktitle", 
+0000c720: 224e 4122 290a 2020 2020 2020 2020 2020  "NA").          
+0000c730: 2020 6966 2073 656c 662e 6461 7461 5b22    if self.data["
+0000c740: 454e 5452 5954 5950 4522 5d20 3d3d 2022  ENTRYTYPE"] == "
+0000c750: 626f 6f6b 223a 0a20 2020 2020 2020 2020  book":.         
+0000c760: 2020 2020 2020 2063 6f6e 7461 696e 6572         container
+0000c770: 5f74 6974 6c65 203d 2073 656c 662e 6461  _title = self.da
+0000c780: 7461 2e67 6574 2822 7469 746c 6522 2c20  ta.get("title", 
+0000c790: 224e 4122 290a 2020 2020 2020 2020 2020  "NA").          
+0000c7a0: 2020 6966 2073 656c 662e 6461 7461 5b22    if self.data["
+0000c7b0: 454e 5452 5954 5950 4522 5d20 3d3d 2022  ENTRYTYPE"] == "
+0000c7c0: 696e 626f 6f6b 223a 0a20 2020 2020 2020  inbook":.       
+0000c7d0: 2020 2020 2020 2020 2063 6f6e 7461 696e           contain
+0000c7e0: 6572 5f74 6974 6c65 203d 2073 656c 662e  er_title = self.
+0000c7f0: 6461 7461 2e67 6574 2822 626f 6f6b 7469  data.get("bookti
+0000c800: 746c 6522 2c20 224e 4122 290a 2020 2020  tle", "NA").    
+0000c810: 2020 2020 7265 7475 726e 2063 6f6e 7461      return conta
+0000c820: 696e 6572 5f74 6974 6c65 0a0a 2020 2020  iner_title..    
+0000c830: 6465 6620 6372 6561 7465 5f63 6f6c 7265  def create_colre
+0000c840: 765f 6964 280a 2020 2020 2020 2020 7365  v_id(.        se
+0000c850: 6c66 2c0a 2020 2020 2020 2020 2a2c 0a20  lf,.        *,. 
+0000c860: 2020 2020 2020 2061 7373 756d 655f 636f         assume_co
+0000c870: 6d70 6c65 7465 3a20 626f 6f6c 203d 2046  mplete: bool = F
+0000c880: 616c 7365 2c0a 2020 2020 2920 2d3e 2073  alse,.    ) -> s
+0000c890: 7472 3a0a 2020 2020 2020 2020 2222 2252  tr:.        """R
+0000c8a0: 6574 7572 6e73 2074 6865 2063 6f6c 7265  eturns the colre
+0000c8b0: 765f 6964 206f 6620 7468 6520 5265 636f  v_id of the Reco
+0000c8c0: 7264 2e22 2222 0a0a 2020 2020 2020 2020  rd."""..        
+0000c8d0: 7265 7475 726e 2063 6f6c 7265 762e 716d  return colrev.qm
+0000c8e0: 2e63 6f6c 7265 765f 6964 2e63 7265 6174  .colrev_id.creat
+0000c8f0: 655f 636f 6c72 6576 5f69 6428 0a20 2020  e_colrev_id(.   
+0000c900: 2020 2020 2020 2020 2072 6563 6f72 643d           record=
+0000c910: 7365 6c66 2c0a 2020 2020 2020 2020 2020  self,.          
+0000c920: 2020 6173 7375 6d65 5f63 6f6d 706c 6574    assume_complet
+0000c930: 653d 6173 7375 6d65 5f63 6f6d 706c 6574  e=assume_complet
+0000c940: 652c 0a20 2020 2020 2020 2029 0a0a 2020  e,.        )..  
+0000c950: 2020 6465 6620 7072 6573 6372 6565 6e5f    def prescreen_
+0000c960: 6578 636c 7564 6528 7365 6c66 2c20 2a2c  exclude(self, *,
+0000c970: 2072 6561 736f 6e3a 2073 7472 2c20 7072   reason: str, pr
+0000c980: 696e 745f 7761 726e 696e 673a 2062 6f6f  int_warning: boo
+0000c990: 6c20 3d20 4661 6c73 6529 202d 3e20 4e6f  l = False) -> No
+0000c9a0: 6e65 3a0a 2020 2020 2020 2020 2222 2250  ne:.        """P
+0000c9b0: 7265 7363 7265 656e 2d65 7863 6c75 6465  rescreen-exclude
+0000c9c0: 2061 2072 6563 6f72 6422 2222 0a20 2020   a record""".   
+0000c9d0: 2020 2020 2023 2057 6172 6e20 7768 656e       # Warn when
+0000c9e0: 2073 6574 7469 6e67 2072 6576 5f73 796e   setting rev_syn
+0000c9f0: 7468 6573 697a 6564 2f72 6576 5f69 6e63  thesized/rev_inc
+0000ca00: 6c75 6465 6420 746f 2070 7265 7363 7265  luded to prescre
+0000ca10: 656e 5f65 7863 6c75 6465 640a 2020 2020  en_excluded.    
+0000ca20: 2020 2020 2320 4573 7065 6369 616c 6c79      # Especially
+0000ca30: 2069 6e20 6361 7365 7320 696e 2077 6869   in cases in whi
+0000ca40: 6368 2074 6865 2070 7265 7363 7265 656e  ch the prescreen
+0000ca50: 2d65 7863 6c75 7369 6f6e 2064 6563 6973  -exclusion decis
+0000ca60: 696f 6e0a 2020 2020 2020 2020 2320 6973  ion.        # is
+0000ca70: 2072 6576 6973 6564 2028 652e 672e 2c20   revised (e.g., 
+0000ca80: 6265 6361 7573 6520 6120 7061 7065 7220  because a paper 
+0000ca90: 7761 7320 7265 7472 6163 7465 6429 0a20  was retracted). 
+0000caa0: 2020 2020 2020 2023 2049 6e20 7468 6573         # In thes
+0000cab0: 6520 6361 7365 732c 2074 6865 2070 6170  e cases, the pap
+0000cac0: 6572 206d 6179 2061 6c72 6561 6479 2062  er may already b
+0000cad0: 6520 696e 2074 6865 2064 6174 6120 6578  e in the data ex
+0000cae0: 7472 6163 7469 6f6e 2f73 796e 7468 6573  traction/synthes
+0000caf0: 6973 0a20 2020 2020 2020 2069 6620 7365  is.        if se
+0000cb00: 6c66 2e64 6174 612e 6765 7428 2263 6f6c  lf.data.get("col
+0000cb10: 7265 765f 7374 6174 7573 222c 2022 4e41  rev_status", "NA
+0000cb20: 2229 2069 6e20 5b0a 2020 2020 2020 2020  ") in [.        
+0000cb30: 2020 2020 5265 636f 7264 5374 6174 652e      RecordState.
+0000cb40: 7265 765f 7379 6e74 6865 7369 7a65 642c  rev_synthesized,
+0000cb50: 0a20 2020 2020 2020 2020 2020 2052 6563  .            Rec
+0000cb60: 6f72 6453 7461 7465 2e72 6576 5f69 6e63  ordState.rev_inc
+0000cb70: 6c75 6465 642c 0a20 2020 2020 2020 205d  luded,.        ]
+0000cb80: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
+0000cb90: 696e 7428 0a20 2020 2020 2020 2020 2020  int(.           
+0000cba0: 2020 2020 2066 225c 6e7b 636f 6c6f 7273       f"\n{colors
+0000cbb0: 2e52 4544 7d57 6172 6e69 6e67 3a20 7365  .RED}Warning: se
+0000cbc0: 7474 696e 6720 7061 7065 7220 746f 2070  tting paper to p
+0000cbd0: 7265 7363 7265 656e 5f65 7863 6c75 6465  rescreen_exclude
+0000cbe0: 642e 2050 6c65 6173 6520 6368 6563 6b20  d. Please check 
+0000cbf0: 616e 6420 220a 2020 2020 2020 2020 2020  and ".          
+0000cc00: 2020 2020 2020 6622 7265 6d6f 7665 2066        f"remove f
+0000cc10: 726f 6d20 7379 6e74 6865 7369 733a 207b  rom synthesis: {
+0000cc20: 7365 6c66 2e64 6174 615b 2749 4427 5d7d  self.data['ID']}
+0000cc30: 7b63 6f6c 6f72 732e 454e 447d 5c6e 220a  {colors.END}\n".
+0000cc40: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
+0000cc50: 2020 2020 2020 2073 656c 662e 7365 745f         self.set_
+0000cc60: 7374 6174 7573 2874 6172 6765 745f 7374  status(target_st
+0000cc70: 6174 653d 5265 636f 7264 5374 6174 652e  ate=RecordState.
+0000cc80: 7265 765f 7072 6573 6372 6565 6e5f 6578  rev_prescreen_ex
+0000cc90: 636c 7564 6564 290a 0a20 2020 2020 2020  cluded)..       
+0000cca0: 2069 6620 280a 2020 2020 2020 2020 2020   if (.          
+0000ccb0: 2020 2272 6574 7261 6374 6564 2220 6e6f    "retracted" no
+0000ccc0: 7420 696e 2073 656c 662e 6461 7461 2e67  t in self.data.g
+0000ccd0: 6574 2822 7072 6573 6372 6565 6e5f 6578  et("prescreen_ex
+0000cce0: 636c 7573 696f 6e22 2c20 2222 290a 2020  clusion", "").  
+0000ccf0: 2020 2020 2020 2020 2020 616e 6420 2272            and "r
+0000cd00: 6574 7261 6374 6564 2220 3d3d 2072 6561  etracted" == rea
+0000cd10: 736f 6e0a 2020 2020 2020 2020 2020 2020  son.            
+0000cd20: 616e 6420 7072 696e 745f 7761 726e 696e  and print_warnin
+0000cd30: 670a 2020 2020 2020 2020 293a 0a20 2020  g.        ):.   
+0000cd40: 2020 2020 2020 2020 2070 7269 6e74 280a           print(.
+0000cd50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cd60: 6622 5c6e 7b63 6f6c 6f72 732e 5245 447d  f"\n{colors.RED}
+0000cd70: 5061 7065 7220 7265 7472 6163 7465 6420  Paper retracted 
+0000cd80: 616e 6420 7072 6573 6372 6565 6e20 220a  and prescreen ".
+0000cd90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cda0: 6622 6578 636c 7564 6564 3a20 7b73 656c  f"excluded: {sel
+0000cdb0: 662e 6461 7461 5b27 4944 275d 7d7b 636f  f.data['ID']}{co
+0000cdc0: 6c6f 7273 2e45 4e44 7d5c 6e22 0a20 2020  lors.END}\n".   
+0000cdd0: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
+0000cde0: 2020 2020 7365 6c66 2e64 6174 615b 2270      self.data["p
+0000cdf0: 7265 7363 7265 656e 5f65 7863 6c75 7369  rescreen_exclusi
+0000ce00: 6f6e 225d 203d 2072 6561 736f 6e0a 0a20  on"] = reason.. 
+0000ce10: 2020 2020 2020 2023 204e 6f74 653a 2077         # Note: w
+0000ce20: 6865 6e20 7265 636f 7264 7320 6172 6520  hen records are 
+0000ce30: 7072 6573 6372 6565 6e2d 6578 636c 7564  prescreen-exclud
+0000ce40: 6564 2064 7572 696e 6720 7072 6570 3a0a  ed during prep:.
+0000ce50: 2020 2020 2020 2020 746f 5f64 726f 7020          to_drop 
+0000ce60: 3d20 5b5d 0a20 2020 2020 2020 2066 6f72  = [].        for
+0000ce70: 206b 6579 2c20 7661 6c75 6520 696e 2073   key, value in s
+0000ce80: 656c 662e 6461 7461 2e69 7465 6d73 2829  elf.data.items()
+0000ce90: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+0000cea0: 2076 616c 7565 203d 3d20 2255 4e4b 4e4f   value == "UNKNO
+0000ceb0: 574e 223a 0a20 2020 2020 2020 2020 2020  WN":.           
+0000cec0: 2020 2020 2074 6f5f 6472 6f70 2e61 7070       to_drop.app
+0000ced0: 656e 6428 6b65 7929 0a20 2020 2020 2020  end(key).       
+0000cee0: 2066 6f72 206b 6579 2069 6e20 746f 5f64   for key in to_d
+0000cef0: 726f 703a 0a20 2020 2020 2020 2020 2020  rop:.           
+0000cf00: 2073 656c 662e 7265 6d6f 7665 5f66 6965   self.remove_fie
+0000cf10: 6c64 286b 6579 3d6b 6579 290a 0a20 2020  ld(key=key)..   
+0000cf20: 2064 6566 2065 7874 7261 6374 5f74 6578   def extract_tex
+0000cf30: 745f 6279 5f70 6167 6528 0a20 2020 2020  t_by_page(.     
+0000cf40: 2020 2073 656c 662c 202a 2c20 7061 6765     self, *, page
+0000cf50: 733a 204f 7074 696f 6e61 6c5b 6c69 7374  s: Optional[list
+0000cf60: 5d20 3d20 4e6f 6e65 2c20 7072 6f6a 6563  ] = None, projec
+0000cf70: 745f 7061 7468 3a20 5061 7468 0a20 2020  t_path: Path.   
+0000cf80: 2029 202d 3e20 7374 723a 0a20 2020 2020   ) -> str:.     
+0000cf90: 2020 2022 2222 4578 7472 6163 7420 7468     """Extract th
+0000cfa0: 6520 7465 7874 2066 726f 6d20 7468 6520  e text from the 
+0000cfb0: 5044 4620 666f 7220 6120 6769 7665 6e20  PDF for a given 
+0000cfc0: 6e75 6d62 6572 206f 6620 7061 6765 7322  number of pages"
+0000cfd0: 2222 0a20 2020 2020 2020 2074 6578 745f  "".        text_
+0000cfe0: 6c69 7374 3a20 6c69 7374 203d 205b 5d0a  list: list = [].
+0000cff0: 2020 2020 2020 2020 7064 665f 7061 7468          pdf_path
+0000d000: 203d 2070 726f 6a65 6374 5f70 6174 6820   = project_path 
+0000d010: 2f20 5061 7468 2873 656c 662e 6461 7461  / Path(self.data
+0000d020: 5b22 6669 6c65 225d 290a 0a20 2020 2020  ["file"])..     
+0000d030: 2020 2023 2068 7474 7073 3a2f 2f73 7461     # https://sta
+0000d040: 636b 6f76 6572 666c 6f77 2e63 6f6d 2f71  ckoverflow.com/q
+0000d050: 7565 7374 696f 6e73 2f34 3934 3537 3434  uestions/4945744
+0000d060: 332f 7079 7468 6f6e 2d70 6466 6d69 6e65  3/python-pdfmine
+0000d070: 722d 636f 6e76 6572 7473 2d70 6466 2d66  r-converts-pdf-f
+0000d080: 696c 652d 696e 746f 2d6f 6e65 2d63 6875  ile-into-one-chu
+0000d090: 6e6b 2d6f 662d 7374 7269 6e67 2d77 6974  nk-of-string-wit
+0000d0a0: 682d 6e6f 2d73 7061 6365 732d 6265 7477  h-no-spaces-betw
+0000d0b0: 6565 0a20 2020 2020 2020 206c 6170 6172  ee.        lapar
+0000d0c0: 616d 7320 3d20 7064 666d 696e 6572 2e6c  ams = pdfminer.l
+0000d0d0: 6179 6f75 742e 4c41 5061 7261 6d73 2829  ayout.LAParams()
+0000d0e0: 0a20 2020 2020 2020 2073 6574 6174 7472  .        setattr
+0000d0f0: 286c 6170 6172 616d 732c 2022 616c 6c5f  (laparams, "all_
+0000d100: 7465 7874 7322 2c20 5472 7565 290a 0a20  texts", True).. 
+0000d110: 2020 2020 2020 2077 6974 6820 6f70 656e         with open
+0000d120: 2870 6466 5f70 6174 682c 2022 7262 2229  (pdf_path, "rb")
+0000d130: 2061 7320 7064 665f 6669 6c65 3a0a 2020   as pdf_file:.  
+0000d140: 2020 2020 2020 2020 2020 7472 793a 0a20            try:. 
+0000d150: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+0000d160: 6f72 2070 6167 6520 696e 2050 4446 5061  or page in PDFPa
+0000d170: 6765 2e67 6574 5f70 6167 6573 280a 2020  ge.get_pages(.  
+0000d180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d190: 2020 7064 665f 6669 6c65 2c0a 2020 2020    pdf_file,.    
+0000d1a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d1b0: 7061 6765 6e6f 733d 7061 6765 732c 2020  pagenos=pages,  
+0000d1c0: 2320 6e6f 7465 3a20 6d61 7962 6520 736b  # note: maybe sk
+0000d1d0: 6970 2070 6f74 656e 7469 616c 2063 6f76  ip potential cov
+0000d1e0: 6572 2070 6167 6573 3f0a 2020 2020 2020  er pages?.      
+0000d1f0: 2020 2020 2020 2020 2020 2020 2020 6361                ca
+0000d200: 6368 696e 673d 5472 7565 2c0a 2020 2020  ching=True,.    
+0000d210: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d220: 6368 6563 6b5f 6578 7472 6163 7461 626c  check_extractabl
+0000d230: 653d 5472 7565 2c0a 2020 2020 2020 2020  e=True,.        
+0000d240: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
+0000d250: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0000d260: 6573 6f75 7263 655f 6d61 6e61 6765 7220  esource_manager 
+0000d270: 3d20 5044 4652 6573 6f75 7263 654d 616e  = PDFResourceMan
+0000d280: 6167 6572 2829 0a20 2020 2020 2020 2020  ager().         
+0000d290: 2020 2020 2020 2020 2020 2066 616b 655f             fake_
+0000d2a0: 6669 6c65 5f68 616e 646c 6520 3d20 696f  file_handle = io
+0000d2b0: 2e53 7472 696e 6749 4f28 290a 2020 2020  .StringIO().    
+0000d2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d2d0: 636f 6e76 6572 7465 7220 3d20 5465 7874  converter = Text
+0000d2e0: 436f 6e76 6572 7465 7228 0a20 2020 2020  Converter(.     
+0000d2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d300: 2020 2072 6573 6f75 7263 655f 6d61 6e61     resource_mana
+0000d310: 6765 722c 2066 616b 655f 6669 6c65 5f68  ger, fake_file_h
+0000d320: 616e 646c 652c 206c 6170 6172 616d 733d  andle, laparams=
+0000d330: 6c61 7061 7261 6d73 0a20 2020 2020 2020  laparams.       
+0000d340: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+0000d350: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d360: 2020 2070 6167 655f 696e 7465 7270 7265     page_interpre
+0000d370: 7465 7220 3d20 5044 4650 6167 6549 6e74  ter = PDFPageInt
+0000d380: 6572 7072 6574 6572 2872 6573 6f75 7263  erpreter(resourc
+0000d390: 655f 6d61 6e61 6765 722c 2063 6f6e 7665  e_manager, conve
+0000d3a0: 7274 6572 290a 2020 2020 2020 2020 2020  rter).          
+0000d3b0: 2020 2020 2020 2020 2020 7061 6765 5f69            page_i
+0000d3c0: 6e74 6572 7072 6574 6572 2e70 726f 6365  nterpreter.proce
+0000d3d0: 7373 5f70 6167 6528 7061 6765 290a 0a20  ss_page(page).. 
+0000d3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d3f0: 2020 2074 6578 7420 3d20 6661 6b65 5f66     text = fake_f
+0000d400: 696c 655f 6861 6e64 6c65 2e67 6574 7661  ile_handle.getva
+0000d410: 6c75 6528 290a 2020 2020 2020 2020 2020  lue().          
+0000d420: 2020 2020 2020 2020 2020 7465 7874 5f6c            text_l
+0000d430: 6973 7420 2b3d 2074 6578 740a 0a20 2020  ist += text..   
+0000d440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d450: 2023 2063 6c6f 7365 206f 7065 6e20 6861   # close open ha
+0000d460: 6e64 6c65 730a 2020 2020 2020 2020 2020  ndles.          
+0000d470: 2020 2020 2020 2020 2020 636f 6e76 6572            conver
+0000d480: 7465 722e 636c 6f73 6528 290a 2020 2020  ter.close().    
+0000d490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d4a0: 6661 6b65 5f66 696c 655f 6861 6e64 6c65  fake_file_handle
+0000d4b0: 2e63 6c6f 7365 2829 0a20 2020 2020 2020  .close().       
+0000d4c0: 2020 2020 2065 7863 6570 7420 2854 7970       except (Typ
+0000d4d0: 6545 7272 6f72 2c20 4b65 7945 7272 6f72  eError, KeyError
+0000d4e0: 293a 2020 2320 7072 6167 6d61 3a20 6e6f  ):  # pragma: no
+0000d4f0: 2063 6f76 6572 0a20 2020 2020 2020 2020   cover.         
+0000d500: 2020 2020 2020 2070 6173 730a 2020 2020         pass.    
+0000d510: 2020 2020 7265 7475 726e 2022 222e 6a6f      return "".jo
+0000d520: 696e 2874 6578 745f 6c69 7374 290a 0a20  in(text_list).. 
+0000d530: 2020 2064 6566 2073 6574 5f70 6167 6573     def set_pages
+0000d540: 5f69 6e5f 7064 6628 7365 6c66 2c20 2a2c  _in_pdf(self, *,
+0000d550: 2070 726f 6a65 6374 5f70 6174 683a 2050   project_path: P
+0000d560: 6174 6829 202d 3e20 4e6f 6e65 3a0a 2020  ath) -> None:.  
+0000d570: 2020 2020 2020 2222 2253 6574 2074 6865        """Set the
+0000d580: 2070 6167 6573 5f69 6e5f 6669 6c65 2066   pages_in_file f
+0000d590: 6965 6c64 2062 6173 6564 206f 6e20 7468  ield based on th
+0000d5a0: 6520 5044 4622 2222 0a20 2020 2020 2020  e PDF""".       
+0000d5b0: 2070 6466 5f70 6174 6820 3d20 7072 6f6a   pdf_path = proj
+0000d5c0: 6563 745f 7061 7468 202f 2050 6174 6828  ect_path / Path(
+0000d5d0: 7365 6c66 2e64 6174 615b 2266 696c 6522  self.data["file"
+0000d5e0: 5d29 0a20 2020 2020 2020 2077 6974 6820  ]).        with 
+0000d5f0: 6f70 656e 2870 6466 5f70 6174 682c 2022  open(pdf_path, "
+0000d600: 7262 2229 2061 7320 6669 6c65 3a0a 2020  rb") as file:.  
+0000d610: 2020 2020 2020 2020 2020 7061 7273 6572            parser
+0000d620: 203d 2050 4446 5061 7273 6572 2866 696c   = PDFParser(fil
+0000d630: 6529 0a20 2020 2020 2020 2020 2020 2064  e).            d
+0000d640: 6f63 756d 656e 7420 3d20 5044 4644 6f63  ocument = PDFDoc
+0000d650: 756d 656e 7428 7061 7273 6572 290a 2020  ument(parser).  
+0000d660: 2020 2020 2020 2020 2020 7061 6765 735f            pages_
+0000d670: 696e 5f66 696c 6520 3d20 7265 736f 6c76  in_file = resolv
+0000d680: 6531 2864 6f63 756d 656e 742e 6361 7461  e1(document.cata
+0000d690: 6c6f 675b 2250 6167 6573 225d 295b 2243  log["Pages"])["C
+0000d6a0: 6f75 6e74 225d 0a20 2020 2020 2020 2073  ount"].        s
+0000d6b0: 656c 662e 6461 7461 5b22 7061 6765 735f  elf.data["pages_
+0000d6c0: 696e 5f66 696c 6522 5d20 3d20 7061 6765  in_file"] = page
+0000d6d0: 735f 696e 5f66 696c 650a 0a20 2020 2064  s_in_file..    d
+0000d6e0: 6566 2073 6574 5f74 6578 745f 6672 6f6d  ef set_text_from
+0000d6f0: 5f70 6466 2873 656c 662c 202a 2c20 7072  _pdf(self, *, pr
+0000d700: 6f6a 6563 745f 7061 7468 3a20 5061 7468  oject_path: Path
+0000d710: 2920 2d3e 204e 6f6e 653a 0a20 2020 2020  ) -> None:.     
+0000d720: 2020 2022 2222 5365 7420 7468 6520 7465     """Set the te
+0000d730: 7874 5f66 726f 6d5f 7064 6620 6669 656c  xt_from_pdf fiel
+0000d740: 6420 6261 7365 6420 6f6e 2074 6865 2050  d based on the P
+0000d750: 4446 2222 220a 2020 2020 2020 2020 7365  DF""".        se
+0000d760: 6c66 2e64 6174 615b 2274 6578 745f 6672  lf.data["text_fr
+0000d770: 6f6d 5f70 6466 225d 203d 2022 220a 2020  om_pdf"] = "".  
+0000d780: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
+0000d790: 2020 2020 2020 2073 656c 662e 7365 745f         self.set_
+0000d7a0: 7061 6765 735f 696e 5f70 6466 2870 726f  pages_in_pdf(pro
+0000d7b0: 6a65 6374 5f70 6174 683d 7072 6f6a 6563  ject_path=projec
+0000d7c0: 745f 7061 7468 290a 2020 2020 2020 2020  t_path).        
+0000d7d0: 2020 2020 7465 7874 203d 2073 656c 662e      text = self.
+0000d7e0: 6578 7472 6163 745f 7465 7874 5f62 795f  extract_text_by_
+0000d7f0: 7061 6765 2870 6167 6573 3d5b 302c 2031  page(pages=[0, 1
+0000d800: 2c20 325d 2c20 7072 6f6a 6563 745f 7061  , 2], project_pa
+0000d810: 7468 3d70 726f 6a65 6374 5f70 6174 6829  th=project_path)
+0000d820: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+0000d830: 662e 6461 7461 5b22 7465 7874 5f66 726f  f.data["text_fro
+0000d840: 6d5f 7064 6622 5d20 3d20 7465 7874 2e72  m_pdf"] = text.r
+0000d850: 6570 6c61 6365 2822 5c6e 222c 2022 2022  eplace("\n", " "
+0000d860: 292e 7265 706c 6163 6528 225c 7830 6322  ).replace("\x0c"
+0000d870: 2c20 2222 290a 0a20 2020 2020 2020 2065  , "")..        e
+0000d880: 7863 6570 7420 5044 4653 796e 7461 7845  xcept PDFSyntaxE
+0000d890: 7272 6f72 3a20 2023 2070 7261 676d 613a  rror:  # pragma:
+0000d8a0: 206e 6f20 636f 7665 720a 2020 2020 2020   no cover.      
+0000d8b0: 2020 2020 2020 7365 6c66 2e61 6464 5f64        self.add_d
+0000d8c0: 6174 615f 7072 6f76 656e 616e 6365 5f6e  ata_provenance_n
+0000d8d0: 6f74 6528 6b65 793d 2266 696c 6522 2c20  ote(key="file", 
+0000d8e0: 6e6f 7465 3d22 7064 665f 7265 6164 6572  note="pdf_reader
+0000d8f0: 5f65 7272 6f72 2229 0a20 2020 2020 2020  _error").       
+0000d900: 2020 2020 2073 656c 662e 6461 7461 2e75       self.data.u
+0000d910: 7064 6174 6528 636f 6c72 6576 5f73 7461  pdate(colrev_sta
+0000d920: 7475 733d 5265 636f 7264 5374 6174 652e  tus=RecordState.
+0000d930: 7064 665f 6e65 6564 735f 6d61 6e75 616c  pdf_needs_manual
+0000d940: 5f70 7265 7061 7261 7469 6f6e 290a 2020  _preparation).  
+0000d950: 2020 2020 2020 6578 6365 7074 2050 4446        except PDF
+0000d960: 5465 7874 4578 7472 6163 7469 6f6e 4e6f  TextExtractionNo
+0000d970: 7441 6c6c 6f77 6564 3a20 2023 2070 7261  tAllowed:  # pra
+0000d980: 676d 613a 206e 6f20 636f 7665 720a 2020  gma: no cover.  
+0000d990: 2020 2020 2020 2020 2020 7365 6c66 2e61            self.a
+0000d9a0: 6464 5f64 6174 615f 7072 6f76 656e 616e  dd_data_provenan
+0000d9b0: 6365 5f6e 6f74 6528 6b65 793d 2266 696c  ce_note(key="fil
+0000d9c0: 6522 2c20 6e6f 7465 3d22 7064 665f 7072  e", note="pdf_pr
+0000d9d0: 6f74 6563 7465 6422 290a 2020 2020 2020  otected").      
+0000d9e0: 2020 2020 2020 7365 6c66 2e64 6174 612e        self.data.
+0000d9f0: 7570 6461 7465 2863 6f6c 7265 765f 7374  update(colrev_st
+0000da00: 6174 7573 3d52 6563 6f72 6453 7461 7465  atus=RecordState
+0000da10: 2e70 6466 5f6e 6565 6473 5f6d 616e 7561  .pdf_needs_manua
+0000da20: 6c5f 7072 6570 6172 6174 696f 6e29 0a0a  l_preparation)..
+0000da30: 2020 2020 6465 6620 6578 7472 6163 745f      def extract_
+0000da40: 7061 6765 7328 0a20 2020 2020 2020 2073  pages(.        s
+0000da50: 656c 662c 202a 2c20 7061 6765 733a 206c  elf, *, pages: l
+0000da60: 6973 742c 2070 726f 6a65 6374 5f70 6174  ist, project_pat
+0000da70: 683a 2050 6174 682c 2073 6176 655f 746f  h: Path, save_to
+0000da80: 5f70 6174 683a 204f 7074 696f 6e61 6c5b  _path: Optional[
+0000da90: 5061 7468 5d20 3d20 4e6f 6e65 0a20 2020  Path] = None.   
+0000daa0: 2029 202d 3e20 4e6f 6e65 3a20 2023 2070   ) -> None:  # p
+0000dab0: 7261 676d 613a 206e 6f20 636f 7665 720a  ragma: no cover.
+0000dac0: 2020 2020 2020 2020 2222 2245 7874 7261          """Extra
+0000dad0: 6374 2070 6167 6573 2066 726f 6d20 7468  ct pages from th
+0000dae0: 6520 5044 4620 2873 6176 6569 6e67 2074  e PDF (saveing t
+0000daf0: 6865 6d20 746f 2074 6865 2073 6176 655f  hem to the save_
+0000db00: 746f 5f70 6174 6829 2222 220a 2020 2020  to_path)""".    
+0000db10: 2020 2020 7064 665f 7061 7468 203d 2070      pdf_path = p
+0000db20: 726f 6a65 6374 5f70 6174 6820 2f20 5061  roject_path / Pa
+0000db30: 7468 2873 656c 662e 6461 7461 5b22 6669  th(self.data["fi
+0000db40: 6c65 225d 290a 2020 2020 2020 2020 7064  le"]).        pd
+0000db50: 665f 7265 6164 6572 203d 2050 6466 4669  f_reader = PdfFi
+0000db60: 6c65 5265 6164 6572 2873 7472 2870 6466  leReader(str(pdf
+0000db70: 5f70 6174 6829 2c20 7374 7269 6374 3d46  _path), strict=F
+0000db80: 616c 7365 290a 2020 2020 2020 2020 7772  alse).        wr
+0000db90: 6974 6572 203d 2050 6466 4669 6c65 5772  iter = PdfFileWr
+0000dba0: 6974 6572 2829 0a20 2020 2020 2020 2066  iter().        f
+0000dbb0: 6f72 2069 2069 6e20 7261 6e67 6528 302c  or i in range(0,
+0000dbc0: 206c 656e 2870 6466 5f72 6561 6465 722e   len(pdf_reader.
+0000dbd0: 7061 6765 7329 293a 0a20 2020 2020 2020  pages)):.       
+0000dbe0: 2020 2020 2069 6620 6920 696e 2070 6167       if i in pag
+0000dbf0: 6573 3a0a 2020 2020 2020 2020 2020 2020  es:.            
+0000dc00: 2020 2020 636f 6e74 696e 7565 0a20 2020      continue.   
+0000dc10: 2020 2020 2020 2020 2077 7269 7465 722e           writer.
+0000dc20: 6164 6450 6167 6528 7064 665f 7265 6164  addPage(pdf_read
+0000dc30: 6572 2e67 6574 5061 6765 2869 2929 0a20  er.getPage(i)). 
+0000dc40: 2020 2020 2020 2077 6974 6820 6f70 656e         with open
+0000dc50: 2870 6466 5f70 6174 682c 2022 7762 2229  (pdf_path, "wb")
+0000dc60: 2061 7320 6f75 7466 696c 653a 0a20 2020   as outfile:.   
+0000dc70: 2020 2020 2020 2020 2077 7269 7465 722e           writer.
+0000dc80: 7772 6974 6528 6f75 7466 696c 6529 0a0a  write(outfile)..
+0000dc90: 2020 2020 2020 2020 6966 2073 6176 655f          if save_
+0000dca0: 746f 5f70 6174 683a 0a20 2020 2020 2020  to_path:.       
+0000dcb0: 2020 2020 2077 7269 7465 725f 6370 203d       writer_cp =
+0000dcc0: 2050 6466 4669 6c65 5772 6974 6572 2829   PdfFileWriter()
+0000dcd0: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
+0000dce0: 2070 6167 6520 696e 2070 6167 6573 3a0a   page in pages:.
+0000dcf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd00: 7772 6974 6572 5f63 702e 6164 6450 6167  writer_cp.addPag
+0000dd10: 6528 7064 665f 7265 6164 6572 2e67 6574  e(pdf_reader.get
+0000dd20: 5061 6765 2870 6167 6529 290a 2020 2020  Page(page)).    
+0000dd30: 2020 2020 2020 2020 6669 6c65 7061 7468          filepath
+0000dd40: 203d 2050 6174 6828 7064 665f 7061 7468   = Path(pdf_path
+0000dd50: 290a 2020 2020 2020 2020 2020 2020 7769  ).            wi
+0000dd60: 7468 206f 7065 6e28 7361 7665 5f74 6f5f  th open(save_to_
+0000dd70: 7061 7468 202f 2066 696c 6570 6174 682e  path / filepath.
+0000dd80: 6e61 6d65 2c20 2277 6222 2920 6173 206f  name, "wb") as o
+0000dd90: 7574 6669 6c65 3a0a 2020 2020 2020 2020  utfile:.        
+0000dda0: 2020 2020 2020 2020 7772 6974 6572 5f63          writer_c
+0000ddb0: 702e 7772 6974 6528 6f75 7466 696c 6529  p.write(outfile)
+0000ddc0: 0a0a 2020 2020 4063 6c61 7373 6d65 7468  ..    @classmeth
+0000ddd0: 6f64 0a20 2020 2064 6566 2067 6574 5f63  od.    def get_c
+0000dde0: 6f6c 7265 765f 7064 665f 6964 280a 2020  olrev_pdf_id(.  
+0000ddf0: 2020 2020 2020 636c 732c 0a20 2020 2020        cls,.     
+0000de00: 2020 202a 2c0a 2020 2020 2020 2020 7064     *,.        pd
+0000de10: 665f 7061 7468 3a20 5061 7468 2c0a 2020  f_path: Path,.  
+0000de20: 2020 2920 2d3e 2073 7472 3a20 2023 2070    ) -> str:  # p
+0000de30: 7261 676d 613a 206e 6f20 636f 7665 720a  ragma: no cover.
+0000de40: 2020 2020 2020 2020 2222 2247 656e 6572          """Gener
+0000de50: 6174 6520 7468 6520 636f 6c72 6576 5f70  ate the colrev_p
+0000de60: 6466 5f69 6422 2222 0a0a 2020 2020 2020  df_id"""..      
+0000de70: 2020 7265 7475 726e 2063 6f6c 7265 762e    return colrev.
+0000de80: 716d 2e63 6f6c 7265 765f 7064 665f 6964  qm.colrev_pdf_id
+0000de90: 2e63 7265 6174 655f 636f 6c72 6576 5f70  .create_colrev_p
+0000dea0: 6466 5f69 6428 7064 665f 7061 7468 3d70  df_id(pdf_path=p
+0000deb0: 6466 5f70 6174 6829 0a0a 2020 2020 6465  df_path)..    de
+0000dec0: 6620 6765 745f 746f 635f 6b65 7928 7365  f get_toc_key(se
+0000ded0: 6c66 2920 2d3e 2073 7472 3a0a 2020 2020  lf) -> str:.    
+0000dee0: 2020 2020 2222 2247 6574 2074 6865 2072      """Get the r
+0000def0: 6563 6f72 6427 7320 746f 632d 6b65 7922  ecord's toc-key"
+0000df00: 2222 0a0a 2020 2020 2020 2020 7472 793a  ""..        try:
+0000df10: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000df20: 7365 6c66 2e64 6174 615b 2245 4e54 5259  self.data["ENTRY
+0000df30: 5459 5045 225d 203d 3d20 2261 7274 6963  TYPE"] == "artic
+0000df40: 6c65 223a 0a20 2020 2020 2020 2020 2020  le":.           
+0000df50: 2020 2020 2074 6f63 5f6b 6579 203d 2028       toc_key = (
+0000df60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000df70: 2020 2020 2073 656c 662e 6461 7461 5b22       self.data["
+0000df80: 6a6f 7572 6e61 6c22 5d0a 2020 2020 2020  journal"].      
 0000df90: 2020 2020 2020 2020 2020 2020 2020 2e72                .r
-0000dfa0: 6570 6c61 6365 2822 2622 2c20 2261 6e64  eplace("&", "and
-0000dfb0: 2229 0a20 2020 2020 2020 2020 2020 2020  ").             
-0000dfc0: 2020 2020 2020 202e 6c6f 7765 7228 290a         .lower().
-0000dfd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dfe0: 2020 2020 2b20 6622 7c7b 7365 6c66 2e64      + f"|{self.d
-0000dff0: 6174 612e 6765 7428 2779 6561 7227 2c20  ata.get('year', 
-0000e000: 2727 297d 220a 2020 2020 2020 2020 2020  '')}".          
-0000e010: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-0000e020: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0000e030: 2020 2020 2020 2020 2020 6d73 6720 3d20            msg = 
-0000e040: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000e050: 2020 2020 2020 6622 454e 5452 5954 5950        f"ENTRYTYP
-0000e060: 4520 7b73 656c 662e 6461 7461 5b27 454e  E {self.data['EN
-0000e070: 5452 5954 5950 4527 5d7d 2022 0a20 2020  TRYTYPE']} ".   
-0000e080: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e090: 202b 2066 2228 7b73 656c 662e 6461 7461   + f"({self.data
-0000e0a0: 5b27 4944 275d 7d29 206e 6f74 2074 6f63  ['ID']}) not toc
-0000e0b0: 2d69 6465 6e74 6966 6961 626c 6522 0a20  -identifiable". 
-0000e0c0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-0000e0d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e0e0: 2072 6169 7365 2063 6f6c 7265 765f 6578   raise colrev_ex
-0000e0f0: 6365 7074 696f 6e73 2e4e 6f74 544f 4349  ceptions.NotTOCI
-0000e100: 6465 6e74 6966 6961 626c 6545 7863 6570  dentifiableExcep
-0000e110: 7469 6f6e 286d 7367 290a 2020 2020 2020  tion(msg).      
-0000e120: 2020 6578 6365 7074 204b 6579 4572 726f    except KeyErro
-0000e130: 7220 6173 2065 7863 3a0a 2020 2020 2020  r as exc:.      
-0000e140: 2020 2020 2020 7261 6973 6520 636f 6c72        raise colr
-0000e150: 6576 5f65 7863 6570 7469 6f6e 732e 4e6f  ev_exceptions.No
-0000e160: 7454 4f43 4964 656e 7469 6669 6162 6c65  tTOCIdentifiable
-0000e170: 4578 6365 7074 696f 6e28 0a20 2020 2020  Exception(.     
-0000e180: 2020 2020 2020 2020 2020 2066 226d 6973             f"mis
-0000e190: 7369 6e67 206b 6579 207b 6578 637d 220a  sing key {exc}".
-0000e1a0: 2020 2020 2020 2020 2020 2020 2920 6672              ) fr
-0000e1b0: 6f6d 2065 7863 0a0a 2020 2020 2020 2020  om exc..        
-0000e1c0: 7265 7475 726e 2074 6f63 5f6b 6579 0a0a  return toc_key..
-0000e1d0: 2020 2020 6465 6620 7072 696e 745f 6369      def print_ci
-0000e1e0: 7461 7469 6f6e 5f66 6f72 6d61 7428 7365  tation_format(se
-0000e1f0: 6c66 2920 2d3e 204e 6f6e 653a 0a20 2020  lf) -> None:.   
-0000e200: 2020 2020 2022 2222 5072 696e 7420 7468       """Print th
-0000e210: 6520 7265 636f 7264 2061 7320 6120 6369  e record as a ci
-0000e220: 7461 7469 6f6e 2222 220a 2020 2020 2020  tation""".      
-0000e230: 2020 666f 726d 6174 7465 645f 7265 6620    formatted_ref 
-0000e240: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
-0000e250: 6622 7b73 656c 662e 6461 7461 2e67 6574  f"{self.data.get
-0000e260: 2827 6175 7468 6f72 272c 2027 2729 7d20  ('author', '')} 
-0000e270: 287b 7365 6c66 2e64 6174 612e 6765 7428  ({self.data.get(
-0000e280: 2779 6561 7227 2c20 2727 297d 2920 220a  'year', '')}) ".
-0000e290: 2020 2020 2020 2020 2020 2020 2b20 6622              + f"
-0000e2a0: 7b73 656c 662e 6461 7461 2e67 6574 2827  {self.data.get('
-0000e2b0: 7469 746c 6527 2c20 2727 297d 2e20 220a  title', '')}. ".
-0000e2c0: 2020 2020 2020 2020 2020 2020 2b20 6622              + f"
-0000e2d0: 7b73 656c 662e 6461 7461 2e67 6574 2827  {self.data.get('
-0000e2e0: 6a6f 7572 6e61 6c27 2c20 2727 297d 7b73  journal', '')}{s
-0000e2f0: 656c 662e 6461 7461 2e67 6574 2827 626f  elf.data.get('bo
-0000e300: 6f6b 7469 746c 6527 2c20 2727 297d 2c20  oktitle', '')}, 
-0000e310: 220a 2020 2020 2020 2020 2020 2020 2b20  ".            + 
-0000e320: 6622 7b73 656c 662e 6461 7461 2e67 6574  f"{self.data.get
-0000e330: 2827 766f 6c75 6d65 272c 2027 2729 7d20  ('volume', '')} 
-0000e340: 287b 7365 6c66 2e64 6174 612e 6765 7428  ({self.data.get(
-0000e350: 276e 756d 6265 7227 2c20 2727 297d 2922  'number', '')})"
-0000e360: 0a20 2020 2020 2020 2029 0a20 2020 2020  .        ).     
-0000e370: 2020 2070 7269 6e74 2866 6f72 6d61 7474     print(formatt
-0000e380: 6564 5f72 6566 290a 0a20 2020 2064 6566  ed_ref)..    def
-0000e390: 2067 6574 5f74 6569 5f66 696c 656e 616d   get_tei_filenam
-0000e3a0: 6528 7365 6c66 2920 2d3e 2050 6174 683a  e(self) -> Path:
-0000e3b0: 0a20 2020 2020 2020 2022 2222 4765 7420  .        """Get 
-0000e3c0: 7468 6520 5445 4920 6669 6c65 6e61 6d65  the TEI filename
-0000e3d0: 2061 7373 6f63 6961 7465 6420 7769 7468   associated with
-0000e3e0: 2074 6865 2066 696c 6520 2850 4446 2922   the file (PDF)"
-0000e3f0: 2222 0a20 2020 2020 2020 2074 6569 5f66  "".        tei_f
-0000e400: 696c 656e 616d 6520 3d20 5061 7468 2866  ilename = Path(f
-0000e410: 272e 7465 692f 7b73 656c 662e 6461 7461  '.tei/{self.data
-0000e420: 5b22 4944 225d 7d2e 7465 692e 786d 6c27  ["ID"]}.tei.xml'
-0000e430: 290a 2020 2020 2020 2020 6966 2022 6669  ).        if "fi
-0000e440: 6c65 2220 696e 2073 656c 662e 6461 7461  le" in self.data
-0000e450: 3a0a 2020 2020 2020 2020 2020 2020 7465  :.            te
-0000e460: 695f 6669 6c65 6e61 6d65 203d 2050 6174  i_filename = Pat
-0000e470: 6828 0a20 2020 2020 2020 2020 2020 2020  h(.             
-0000e480: 2020 2073 656c 662e 6461 7461 5b22 6669     self.data["fi
-0000e490: 6c65 225d 2e72 6570 6c61 6365 2822 7064  le"].replace("pd
-0000e4a0: 6673 2f22 2c20 222e 7465 692f 2229 0a20  fs/", ".tei/"). 
-0000e4b0: 2020 2020 2020 2020 2020 2029 2e77 6974             ).wit
-0000e4c0: 685f 7375 6666 6978 2822 2e74 6569 2e78  h_suffix(".tei.x
-0000e4d0: 6d6c 2229 0a20 2020 2020 2020 2072 6574  ml").        ret
-0000e4e0: 7572 6e20 7465 695f 6669 6c65 6e61 6d65  urn tei_filename
-0000e4f0: 0a0a 2020 2020 4063 6c61 7373 6d65 7468  ..    @classmeth
-0000e500: 6f64 0a20 2020 2064 6566 2070 7269 6e74  od.    def print
-0000e510: 5f64 6966 665f 7061 6972 2863 6c73 2c20  _diff_pair(cls, 
-0000e520: 2a2c 2072 6563 6f72 645f 7061 6972 3a20  *, record_pair: 
-0000e530: 6c69 7374 2c20 6b65 7973 3a20 6c69 7374  list, keys: list
-0000e540: 2920 2d3e 204e 6f6e 653a 0a20 2020 2020  ) -> None:.     
-0000e550: 2020 2022 2222 5072 696e 7420 7468 6520     """Print the 
-0000e560: 6469 6666 2062 6574 7765 656e 2074 776f  diff between two
-0000e570: 2072 6563 6f72 6473 2222 220a 0a20 2020   records"""..   
-0000e580: 2020 2020 2064 6566 2070 7269 6e74 5f64       def print_d
-0000e590: 6966 6628 6368 616e 6765 3a20 7475 706c  iff(change: tupl
-0000e5a0: 6529 202d 3e20 7374 723a 0a20 2020 2020  e) -> str:.     
-0000e5b0: 2020 2020 2020 2064 6966 6620 3d20 6469         diff = di
-0000e5c0: 6666 6c69 622e 4469 6666 6572 2829 0a20  fflib.Differ(). 
-0000e5d0: 2020 2020 2020 2020 2020 206c 6574 7465             lette
-0000e5e0: 7273 203d 206c 6973 7428 6469 6666 2e63  rs = list(diff.c
-0000e5f0: 6f6d 7061 7265 2863 6861 6e67 655b 315d  ompare(change[1]
-0000e600: 2c20 6368 616e 6765 5b30 5d29 290a 2020  , change[0])).  
-0000e610: 2020 2020 2020 2020 2020 666f 7220 692c            for i,
-0000e620: 206c 6574 7465 7220 696e 2065 6e75 6d65   letter in enume
-0000e630: 7261 7465 286c 6574 7465 7273 293a 0a20  rate(letters):. 
-0000e640: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000e650: 6620 6c65 7474 6572 2e73 7461 7274 7377  f letter.startsw
-0000e660: 6974 6828 2220 2022 293a 0a20 2020 2020  ith("  "):.     
-0000e670: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-0000e680: 6574 7465 7273 5b69 5d20 3d20 6c65 7474  etters[i] = lett
-0000e690: 6572 735b 695d 5b2d 315d 0a20 2020 2020  ers[i][-1].     
-0000e6a0: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
-0000e6b0: 6c65 7474 6572 2e73 7461 7274 7377 6974  letter.startswit
-0000e6c0: 6828 222b 2022 293a 0a20 2020 2020 2020  h("+ "):.       
-0000e6d0: 2020 2020 2020 2020 2020 2020 206c 6574               let
-0000e6e0: 7465 7273 5b69 5d20 3d20 6622 7b63 6f6c  ters[i] = f"{col
-0000e6f0: 6f72 732e 5245 447d 2220 2b20 6c65 7474  ors.RED}" + lett
-0000e700: 6572 735b 695d 5b2d 315d 202b 2066 227b  ers[i][-1] + f"{
-0000e710: 636f 6c6f 7273 2e45 4e44 7d22 0a20 2020  colors.END}".   
-0000e720: 2020 2020 2020 2020 2020 2020 2065 6c69               eli
-0000e730: 6620 6c65 7474 6572 2e73 7461 7274 7377  f letter.startsw
-0000e740: 6974 6828 222d 2022 293a 0a20 2020 2020  ith("- "):.     
-0000e750: 2020 2020 2020 2020 2020 2020 2020 206c                 l
-0000e760: 6574 7465 7273 5b69 5d20 3d20 6622 7b63  etters[i] = f"{c
-0000e770: 6f6c 6f72 732e 4752 4545 4e7d 2220 2b20  olors.GREEN}" + 
-0000e780: 6c65 7474 6572 735b 695d 5b2d 315d 202b  letters[i][-1] +
-0000e790: 2066 227b 636f 6c6f 7273 2e45 4e44 7d22   f"{colors.END}"
-0000e7a0: 0a20 2020 2020 2020 2020 2020 2072 6573  .            res
-0000e7b0: 203d 2022 222e 6a6f 696e 286c 6574 7465   = "".join(lette
-0000e7c0: 7273 292e 7265 706c 6163 6528 225c 6e22  rs).replace("\n"
-0000e7d0: 2c20 2220 2229 0a20 2020 2020 2020 2020  , " ").         
-0000e7e0: 2020 2072 6574 7572 6e20 7265 730a 0a20     return res.. 
-0000e7f0: 2020 2020 2020 2066 6f72 206b 6579 2069         for key i
-0000e800: 6e20 6b65 7973 3a0a 2020 2020 2020 2020  n keys:.        
-0000e810: 2020 2020 7072 6576 5f76 616c 203d 2022      prev_val = "
-0000e820: 5f46 4952 5354 5f56 414c 220a 2020 2020  _FIRST_VAL".    
-0000e830: 2020 2020 2020 2020 666f 7220 7265 6320          for rec 
-0000e840: 696e 2072 6563 6f72 645f 7061 6972 3a0a  in record_pair:.
-0000e850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e860: 6966 2070 7265 765f 7661 6c20 3d3d 2072  if prev_val == r
-0000e870: 6563 2e67 6574 286b 6579 2c20 2222 2920  ec.get(key, "") 
-0000e880: 6f72 2070 7265 765f 7661 6c20 3d3d 2022  or prev_val == "
-0000e890: 5f46 4952 5354 5f56 414c 223a 0a20 2020  _FIRST_VAL":.   
-0000e8a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e8b0: 206c 696e 6520 3d20 6622 7b72 6563 2e67   line = f"{rec.g
-0000e8c0: 6574 286b 6579 2c20 2727 297d 220a 2020  et(key, '')}".  
-0000e8d0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-0000e8e0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000e8f0: 2020 2020 2020 2020 7369 6d69 6c61 7269          similari
-0000e900: 7479 203d 2030 2e30 0a20 2020 2020 2020  ty = 0.0.       
-0000e910: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000e920: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000e930: 2020 2020 2020 2020 2020 7072 6576 5f76            prev_v
-0000e940: 616c 2069 7320 6e6f 7420 4e6f 6e65 0a20  al is not None. 
-0000e950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e960: 2020 2020 2020 2061 6e64 2072 6563 2e67         and rec.g
-0000e970: 6574 286b 6579 2c20 2222 2920 213d 2022  et(key, "") != "
-0000e980: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
-0000e990: 2020 2020 2020 2020 2020 616e 6420 7072            and pr
-0000e9a0: 6576 5f76 616c 2021 3d20 2222 0a20 2020  ev_val != "".   
-0000e9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e9c0: 2020 2020 2061 6e64 2072 6563 5b6b 6579       and rec[key
-0000e9d0: 5d20 6973 206e 6f74 204e 6f6e 650a 2020  ] is not None.  
-0000e9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e9f0: 2020 293a 0a20 2020 2020 2020 2020 2020    ):.           
-0000ea00: 2020 2020 2020 2020 2020 2020 2073 696d               sim
-0000ea10: 696c 6172 6974 7920 3d20 6675 7a7a 2e70  ilarity = fuzz.p
-0000ea20: 6172 7469 616c 5f72 6174 696f 2870 7265  artial_ratio(pre
-0000ea30: 765f 7661 6c2c 2072 6563 5b6b 6579 5d29  v_val, rec[key])
-0000ea40: 202f 2031 3030 0a20 2020 2020 2020 2020   / 100.         
-0000ea50: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000ea60: 204e 6f74 6520 3a20 7468 6520 6675 7a7a   Note : the fuzz
-0000ea70: 2e70 6172 7469 616c 5f72 6174 696f 2077  .partial_ratio w
-0000ea80: 6f72 6b73 2062 6574 7465 7220 666f 7220  orks better for 
-0000ea90: 7061 7274 6961 6c20 7375 6273 7472 696e  partial substrin
-0000eaa0: 6773 0a20 2020 2020 2020 2020 2020 2020  gs.             
-0000eab0: 2020 2020 2020 2020 2020 2023 2066 726f             # fro
-0000eac0: 6d20 6469 6666 6c69 6220 696d 706f 7274  m difflib import
-0000ead0: 2053 6571 7565 6e63 654d 6174 6368 6572   SequenceMatcher
-0000eae0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000eaf0: 2020 2020 2020 2020 2023 2073 696d 696c           # simil
-0000eb00: 6172 6974 7920 3d20 5365 7175 656e 6365  arity = Sequence
-0000eb10: 4d61 7463 6865 7228 4e6f 6e65 2c20 7072  Matcher(None, pr
-0000eb20: 6576 5f76 616c 2c20 7265 635b 6b65 795d  ev_val, rec[key]
-0000eb30: 292e 7261 7469 6f28 290a 2020 2020 2020  ).ratio().      
-0000eb40: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0000eb50: 2073 696d 696c 6172 6974 7920 3c20 302e   similarity < 0.
-0000eb60: 3520 6f72 206b 6579 2069 6e20 5b0a 2020  5 or key in [.  
-0000eb70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eb80: 2020 2020 2020 2276 6f6c 756d 6522 2c0a        "volume",.
-0000eb90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eba0: 2020 2020 2020 2020 226e 756d 6265 7222          "number"
-0000ebb0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000ebc0: 2020 2020 2020 2020 2020 2279 6561 7222            "year"
-0000ebd0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000ebe0: 2020 2020 2020 5d3a 0a20 2020 2020 2020        ]:.       
-0000ebf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ec00: 206c 696e 6520 3d20 6622 7b63 6f6c 6f72   line = f"{color
-0000ec10: 732e 5245 447d 7b72 6563 2e67 6574 286b  s.RED}{rec.get(k
-0000ec20: 6579 2c20 2727 297d 7b63 6f6c 6f72 732e  ey, '')}{colors.
-0000ec30: 454e 447d 220a 2020 2020 2020 2020 2020  END}".          
-0000ec40: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+0000dfa0: 6570 6c61 6365 2822 2022 2c20 222d 2229  eplace(" ", "-")
+0000dfb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000dfc0: 2020 2020 202e 7265 706c 6163 6528 225c       .replace("\
+0000dfd0: 5c22 2c20 2222 290a 2020 2020 2020 2020  \", "").        
+0000dfe0: 2020 2020 2020 2020 2020 2020 2e72 6570              .rep
+0000dff0: 6c61 6365 2822 2622 2c20 2261 6e64 2229  lace("&", "and")
+0000e000: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e010: 2020 2020 202e 6c6f 7765 7228 290a 2020       .lower().  
+0000e020: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0000e030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e040: 746f 635f 6b65 7920 2b3d 2028 0a20 2020  toc_key += (.   
+0000e050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e060: 2066 227c 7b73 656c 662e 6461 7461 5b27   f"|{self.data['
+0000e070: 766f 6c75 6d65 275d 7d22 0a20 2020 2020  volume']}".     
+0000e080: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000e090: 6620 2822 554e 4b4e 4f57 4e22 2021 3d20  f ("UNKNOWN" != 
+0000e0a0: 7365 6c66 2e64 6174 612e 6765 7428 2276  self.data.get("v
+0000e0b0: 6f6c 756d 6522 2c20 2255 4e4b 4e4f 574e  olume", "UNKNOWN
+0000e0c0: 2229 290a 2020 2020 2020 2020 2020 2020  ")).            
+0000e0d0: 2020 2020 2020 2020 656c 7365 2022 7c2d          else "|-
+0000e0e0: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+0000e0f0: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+0000e100: 2020 2020 746f 635f 6b65 7920 2b3d 2028      toc_key += (
+0000e110: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e120: 2020 2020 2066 227c 7b73 656c 662e 6461       f"|{self.da
+0000e130: 7461 5b27 6e75 6d62 6572 275d 7d22 0a20  ta['number']}". 
+0000e140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e150: 2020 2069 6620 2822 554e 4b4e 4f57 4e22     if ("UNKNOWN"
+0000e160: 2021 3d20 7365 6c66 2e64 6174 612e 6765   != self.data.ge
+0000e170: 7428 226e 756d 6265 7222 2c20 2255 4e4b  t("number", "UNK
+0000e180: 4e4f 574e 2229 290a 2020 2020 2020 2020  NOWN")).        
+0000e190: 2020 2020 2020 2020 2020 2020 656c 7365              else
+0000e1a0: 2022 7c2d 220a 2020 2020 2020 2020 2020   "|-".          
+0000e1b0: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
+0000e1c0: 2020 2020 2065 6c69 6620 7365 6c66 2e64       elif self.d
+0000e1d0: 6174 615b 2245 4e54 5259 5459 5045 225d  ata["ENTRYTYPE"]
+0000e1e0: 203d 3d20 2269 6e70 726f 6365 6564 696e   == "inproceedin
+0000e1f0: 6773 223a 0a20 2020 2020 2020 2020 2020  gs":.           
+0000e200: 2020 2020 2074 6f63 5f6b 6579 203d 2028       toc_key = (
+0000e210: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e220: 2020 2020 2073 656c 662e 6461 7461 5b22       self.data["
+0000e230: 626f 6f6b 7469 746c 6522 5d0a 2020 2020  booktitle"].    
+0000e240: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e250: 2e72 6570 6c61 6365 2822 2022 2c20 222d  .replace(" ", "-
+0000e260: 2229 0a20 2020 2020 2020 2020 2020 2020  ").             
+0000e270: 2020 2020 2020 202e 7265 706c 6163 6528         .replace(
+0000e280: 225c 5c22 2c20 2222 290a 2020 2020 2020  "\\", "").      
+0000e290: 2020 2020 2020 2020 2020 2020 2020 2e72                .r
+0000e2a0: 6570 6c61 6365 2822 2622 2c20 2261 6e64  eplace("&", "and
+0000e2b0: 2229 0a20 2020 2020 2020 2020 2020 2020  ").             
+0000e2c0: 2020 2020 2020 202e 6c6f 7765 7228 290a         .lower().
+0000e2d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e2e0: 2020 2020 2b20 6622 7c7b 7365 6c66 2e64      + f"|{self.d
+0000e2f0: 6174 612e 6765 7428 2779 6561 7227 2c20  ata.get('year', 
+0000e300: 2727 297d 220a 2020 2020 2020 2020 2020  '')}".          
+0000e310: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+0000e320: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000e330: 2020 2020 2020 2020 2020 6d73 6720 3d20            msg = 
+0000e340: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000e350: 2020 2020 2020 6622 454e 5452 5954 5950        f"ENTRYTYP
+0000e360: 4520 7b73 656c 662e 6461 7461 5b27 454e  E {self.data['EN
+0000e370: 5452 5954 5950 4527 5d7d 2022 0a20 2020  TRYTYPE']} ".   
+0000e380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e390: 202b 2066 2228 7b73 656c 662e 6461 7461   + f"({self.data
+0000e3a0: 5b27 4944 275d 7d29 206e 6f74 2074 6f63  ['ID']}) not toc
+0000e3b0: 2d69 6465 6e74 6966 6961 626c 6522 0a20  -identifiable". 
+0000e3c0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+0000e3d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e3e0: 2072 6169 7365 2063 6f6c 7265 765f 6578   raise colrev_ex
+0000e3f0: 6365 7074 696f 6e73 2e4e 6f74 544f 4349  ceptions.NotTOCI
+0000e400: 6465 6e74 6966 6961 626c 6545 7863 6570  dentifiableExcep
+0000e410: 7469 6f6e 286d 7367 290a 2020 2020 2020  tion(msg).      
+0000e420: 2020 6578 6365 7074 204b 6579 4572 726f    except KeyErro
+0000e430: 7220 6173 2065 7863 3a0a 2020 2020 2020  r as exc:.      
+0000e440: 2020 2020 2020 7261 6973 6520 636f 6c72        raise colr
+0000e450: 6576 5f65 7863 6570 7469 6f6e 732e 4e6f  ev_exceptions.No
+0000e460: 7454 4f43 4964 656e 7469 6669 6162 6c65  tTOCIdentifiable
+0000e470: 4578 6365 7074 696f 6e28 0a20 2020 2020  Exception(.     
+0000e480: 2020 2020 2020 2020 2020 2066 226d 6973             f"mis
+0000e490: 7369 6e67 206b 6579 207b 6578 637d 220a  sing key {exc}".
+0000e4a0: 2020 2020 2020 2020 2020 2020 2920 6672              ) fr
+0000e4b0: 6f6d 2065 7863 0a0a 2020 2020 2020 2020  om exc..        
+0000e4c0: 7265 7475 726e 2074 6f63 5f6b 6579 0a0a  return toc_key..
+0000e4d0: 2020 2020 6465 6620 7072 696e 745f 6369      def print_ci
+0000e4e0: 7461 7469 6f6e 5f66 6f72 6d61 7428 7365  tation_format(se
+0000e4f0: 6c66 2920 2d3e 204e 6f6e 653a 0a20 2020  lf) -> None:.   
+0000e500: 2020 2020 2022 2222 5072 696e 7420 7468       """Print th
+0000e510: 6520 7265 636f 7264 2061 7320 6120 6369  e record as a ci
+0000e520: 7461 7469 6f6e 2222 220a 2020 2020 2020  tation""".      
+0000e530: 2020 666f 726d 6174 7465 645f 7265 6620    formatted_ref 
+0000e540: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
+0000e550: 6622 7b73 656c 662e 6461 7461 2e67 6574  f"{self.data.get
+0000e560: 2827 6175 7468 6f72 272c 2027 2729 7d20  ('author', '')} 
+0000e570: 287b 7365 6c66 2e64 6174 612e 6765 7428  ({self.data.get(
+0000e580: 2779 6561 7227 2c20 2727 297d 2920 220a  'year', '')}) ".
+0000e590: 2020 2020 2020 2020 2020 2020 2b20 6622              + f"
+0000e5a0: 7b73 656c 662e 6461 7461 2e67 6574 2827  {self.data.get('
+0000e5b0: 7469 746c 6527 2c20 2727 297d 2e20 220a  title', '')}. ".
+0000e5c0: 2020 2020 2020 2020 2020 2020 2b20 6622              + f"
+0000e5d0: 7b73 656c 662e 6461 7461 2e67 6574 2827  {self.data.get('
+0000e5e0: 6a6f 7572 6e61 6c27 2c20 2727 297d 7b73  journal', '')}{s
+0000e5f0: 656c 662e 6461 7461 2e67 6574 2827 626f  elf.data.get('bo
+0000e600: 6f6b 7469 746c 6527 2c20 2727 297d 2c20  oktitle', '')}, 
+0000e610: 220a 2020 2020 2020 2020 2020 2020 2b20  ".            + 
+0000e620: 6622 7b73 656c 662e 6461 7461 2e67 6574  f"{self.data.get
+0000e630: 2827 766f 6c75 6d65 272c 2027 2729 7d20  ('volume', '')} 
+0000e640: 287b 7365 6c66 2e64 6174 612e 6765 7428  ({self.data.get(
+0000e650: 276e 756d 6265 7227 2c20 2727 297d 2922  'number', '')})"
+0000e660: 0a20 2020 2020 2020 2029 0a20 2020 2020  .        ).     
+0000e670: 2020 2070 7269 6e74 2866 6f72 6d61 7474     print(formatt
+0000e680: 6564 5f72 6566 290a 0a20 2020 2064 6566  ed_ref)..    def
+0000e690: 2067 6574 5f74 6569 5f66 696c 656e 616d   get_tei_filenam
+0000e6a0: 6528 7365 6c66 2920 2d3e 2050 6174 683a  e(self) -> Path:
+0000e6b0: 0a20 2020 2020 2020 2022 2222 4765 7420  .        """Get 
+0000e6c0: 7468 6520 5445 4920 6669 6c65 6e61 6d65  the TEI filename
+0000e6d0: 2061 7373 6f63 6961 7465 6420 7769 7468   associated with
+0000e6e0: 2074 6865 2066 696c 6520 2850 4446 2922   the file (PDF)"
+0000e6f0: 2222 0a20 2020 2020 2020 2074 6569 5f66  "".        tei_f
+0000e700: 696c 656e 616d 6520 3d20 5061 7468 2866  ilename = Path(f
+0000e710: 272e 7465 692f 7b73 656c 662e 6461 7461  '.tei/{self.data
+0000e720: 5b22 4944 225d 7d2e 7465 692e 786d 6c27  ["ID"]}.tei.xml'
+0000e730: 290a 2020 2020 2020 2020 6966 2022 6669  ).        if "fi
+0000e740: 6c65 2220 696e 2073 656c 662e 6461 7461  le" in self.data
+0000e750: 3a0a 2020 2020 2020 2020 2020 2020 7465  :.            te
+0000e760: 695f 6669 6c65 6e61 6d65 203d 2050 6174  i_filename = Pat
+0000e770: 6828 0a20 2020 2020 2020 2020 2020 2020  h(.             
+0000e780: 2020 2073 656c 662e 6461 7461 5b22 6669     self.data["fi
+0000e790: 6c65 225d 2e72 6570 6c61 6365 2822 7064  le"].replace("pd
+0000e7a0: 6673 2f22 2c20 222e 7465 692f 2229 0a20  fs/", ".tei/"). 
+0000e7b0: 2020 2020 2020 2020 2020 2029 2e77 6974             ).wit
+0000e7c0: 685f 7375 6666 6978 2822 2e74 6569 2e78  h_suffix(".tei.x
+0000e7d0: 6d6c 2229 0a20 2020 2020 2020 2072 6574  ml").        ret
+0000e7e0: 7572 6e20 7465 695f 6669 6c65 6e61 6d65  urn tei_filename
+0000e7f0: 0a0a 2020 2020 4063 6c61 7373 6d65 7468  ..    @classmeth
+0000e800: 6f64 0a20 2020 2064 6566 2070 7269 6e74  od.    def print
+0000e810: 5f64 6966 665f 7061 6972 2863 6c73 2c20  _diff_pair(cls, 
+0000e820: 2a2c 2072 6563 6f72 645f 7061 6972 3a20  *, record_pair: 
+0000e830: 6c69 7374 2c20 6b65 7973 3a20 6c69 7374  list, keys: list
+0000e840: 2920 2d3e 204e 6f6e 653a 0a20 2020 2020  ) -> None:.     
+0000e850: 2020 2022 2222 5072 696e 7420 7468 6520     """Print the 
+0000e860: 6469 6666 2062 6574 7765 656e 2074 776f  diff between two
+0000e870: 2072 6563 6f72 6473 2222 220a 0a20 2020   records"""..   
+0000e880: 2020 2020 2064 6566 2070 7269 6e74 5f64       def print_d
+0000e890: 6966 6628 6368 616e 6765 3a20 7475 706c  iff(change: tupl
+0000e8a0: 6529 202d 3e20 7374 723a 0a20 2020 2020  e) -> str:.     
+0000e8b0: 2020 2020 2020 2064 6966 6620 3d20 6469         diff = di
+0000e8c0: 6666 6c69 622e 4469 6666 6572 2829 0a20  fflib.Differ(). 
+0000e8d0: 2020 2020 2020 2020 2020 206c 6574 7465             lette
+0000e8e0: 7273 203d 206c 6973 7428 6469 6666 2e63  rs = list(diff.c
+0000e8f0: 6f6d 7061 7265 2863 6861 6e67 655b 315d  ompare(change[1]
+0000e900: 2c20 6368 616e 6765 5b30 5d29 290a 2020  , change[0])).  
+0000e910: 2020 2020 2020 2020 2020 666f 7220 692c            for i,
+0000e920: 206c 6574 7465 7220 696e 2065 6e75 6d65   letter in enume
+0000e930: 7261 7465 286c 6574 7465 7273 293a 0a20  rate(letters):. 
+0000e940: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000e950: 6620 6c65 7474 6572 2e73 7461 7274 7377  f letter.startsw
+0000e960: 6974 6828 2220 2022 293a 0a20 2020 2020  ith("  "):.     
+0000e970: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+0000e980: 6574 7465 7273 5b69 5d20 3d20 6c65 7474  etters[i] = lett
+0000e990: 6572 735b 695d 5b2d 315d 0a20 2020 2020  ers[i][-1].     
+0000e9a0: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
+0000e9b0: 6c65 7474 6572 2e73 7461 7274 7377 6974  letter.startswit
+0000e9c0: 6828 222b 2022 293a 0a20 2020 2020 2020  h("+ "):.       
+0000e9d0: 2020 2020 2020 2020 2020 2020 206c 6574               let
+0000e9e0: 7465 7273 5b69 5d20 3d20 6622 7b63 6f6c  ters[i] = f"{col
+0000e9f0: 6f72 732e 5245 447d 2220 2b20 6c65 7474  ors.RED}" + lett
+0000ea00: 6572 735b 695d 5b2d 315d 202b 2066 227b  ers[i][-1] + f"{
+0000ea10: 636f 6c6f 7273 2e45 4e44 7d22 0a20 2020  colors.END}".   
+0000ea20: 2020 2020 2020 2020 2020 2020 2065 6c69               eli
+0000ea30: 6620 6c65 7474 6572 2e73 7461 7274 7377  f letter.startsw
+0000ea40: 6974 6828 222d 2022 293a 0a20 2020 2020  ith("- "):.     
+0000ea50: 2020 2020 2020 2020 2020 2020 2020 206c                 l
+0000ea60: 6574 7465 7273 5b69 5d20 3d20 6622 7b63  etters[i] = f"{c
+0000ea70: 6f6c 6f72 732e 4752 4545 4e7d 2220 2b20  olors.GREEN}" + 
+0000ea80: 6c65 7474 6572 735b 695d 5b2d 315d 202b  letters[i][-1] +
+0000ea90: 2066 227b 636f 6c6f 7273 2e45 4e44 7d22   f"{colors.END}"
+0000eaa0: 0a20 2020 2020 2020 2020 2020 2072 6573  .            res
+0000eab0: 203d 2022 222e 6a6f 696e 286c 6574 7465   = "".join(lette
+0000eac0: 7273 292e 7265 706c 6163 6528 225c 6e22  rs).replace("\n"
+0000ead0: 2c20 2220 2229 0a20 2020 2020 2020 2020  , " ").         
+0000eae0: 2020 2072 6574 7572 6e20 7265 730a 0a20     return res.. 
+0000eaf0: 2020 2020 2020 2066 6f72 206b 6579 2069         for key i
+0000eb00: 6e20 6b65 7973 3a0a 2020 2020 2020 2020  n keys:.        
+0000eb10: 2020 2020 7072 6576 5f76 616c 203d 2022      prev_val = "
+0000eb20: 5f46 4952 5354 5f56 414c 220a 2020 2020  _FIRST_VAL".    
+0000eb30: 2020 2020 2020 2020 666f 7220 7265 6320          for rec 
+0000eb40: 696e 2072 6563 6f72 645f 7061 6972 3a0a  in record_pair:.
+0000eb50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eb60: 6966 2070 7265 765f 7661 6c20 3d3d 2072  if prev_val == r
+0000eb70: 6563 2e67 6574 286b 6579 2c20 2222 2920  ec.get(key, "") 
+0000eb80: 6f72 2070 7265 765f 7661 6c20 3d3d 2022  or prev_val == "
+0000eb90: 5f46 4952 5354 5f56 414c 223a 0a20 2020  _FIRST_VAL":.   
+0000eba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ebb0: 206c 696e 6520 3d20 6622 7b72 6563 2e67   line = f"{rec.g
+0000ebc0: 6574 286b 6579 2c20 2727 297d 220a 2020  et(key, '')}".  
+0000ebd0: 2020 2020 2020 2020 2020 2020 2020 656c                el
+0000ebe0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000ebf0: 2020 2020 2020 2020 7369 6d69 6c61 7269          similari
+0000ec00: 7479 203d 2030 2e30 0a20 2020 2020 2020  ty = 0.0.       
+0000ec10: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000ec20: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000ec30: 2020 2020 2020 2020 2020 7072 6576 5f76            prev_v
+0000ec40: 616c 2069 7320 6e6f 7420 4e6f 6e65 0a20  al is not None. 
 0000ec50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ec60: 2020 2020 2020 2020 6c69 6e65 203d 2070          line = p
-0000ec70: 7269 6e74 5f64 6966 6628 2870 7265 765f  rint_diff((prev_
-0000ec80: 7661 6c2c 2072 6563 2e67 6574 286b 6579  val, rec.get(key
-0000ec90: 2c20 2222 2929 290a 2020 2020 2020 2020  , ""))).        
-0000eca0: 2020 2020 2020 2020 7072 696e 7428 6622          print(f"
-0000ecb0: 7b6b 6579 7d20 3a20 7b6c 696e 657d 2229  {key} : {line}")
-0000ecc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000ecd0: 2070 7265 765f 7661 6c20 3d20 7265 632e   prev_val = rec.
-0000ece0: 6765 7428 6b65 792c 2022 2229 0a20 2020  get(key, "").   
-0000ecf0: 2020 2020 2020 2020 2070 7269 6e74 2829           print()
-0000ed00: 0a0a 2020 2020 6465 6620 636c 6561 6e75  ..    def cleanu
-0000ed10: 705f 7064 665f 7072 6f63 6573 7369 6e67  p_pdf_processing
-0000ed20: 5f66 6965 6c64 7328 7365 6c66 2920 2d3e  _fields(self) ->
-0000ed30: 204e 6f6e 653a 0a20 2020 2020 2020 2022   None:.        "
-0000ed40: 2222 436c 6561 6e75 7020 7468 6520 5044  ""Cleanup the PD
-0000ed50: 4620 7072 6f63 6573 7369 6e67 2066 6965  F processing fie
-0000ed60: 6c73 2028 7465 7874 5f66 726f 6d5f 7064  ls (text_from_pd
-0000ed70: 662c 2070 6167 6573 5f69 6e5f 6669 6c65  f, pages_in_file
-0000ed80: 2922 2222 0a20 2020 2020 2020 2069 6620  )""".        if 
-0000ed90: 2274 6578 745f 6672 6f6d 5f70 6466 2220  "text_from_pdf" 
-0000eda0: 696e 2073 656c 662e 6461 7461 3a0a 2020  in self.data:.  
-0000edb0: 2020 2020 2020 2020 2020 6465 6c20 7365            del se
-0000edc0: 6c66 2e64 6174 615b 2274 6578 745f 6672  lf.data["text_fr
-0000edd0: 6f6d 5f70 6466 225d 0a20 2020 2020 2020  om_pdf"].       
-0000ede0: 2069 6620 2270 6167 6573 5f69 6e5f 6669   if "pages_in_fi
-0000edf0: 6c65 2220 696e 2073 656c 662e 6461 7461  le" in self.data
-0000ee00: 3a0a 2020 2020 2020 2020 2020 2020 6465  :.            de
-0000ee10: 6c20 7365 6c66 2e64 6174 615b 2270 6167  l self.data["pag
-0000ee20: 6573 5f69 6e5f 6669 6c65 225d 0a0a 2020  es_in_file"]..  
-0000ee30: 2020 6465 6620 7570 6461 7465 5f6d 6173    def update_mas
-0000ee40: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-0000ee50: 6365 280a 2020 2020 2020 2020 7365 6c66  ce(.        self
-0000ee60: 2c20 2a2c 2071 6d3a 2063 6f6c 7265 762e  , *, qm: colrev.
-0000ee70: 716d 2e71 7561 6c69 7479 5f6d 6f64 656c  qm.quality_model
-0000ee80: 2e51 7561 6c69 7479 4d6f 6465 6c2c 2073  .QualityModel, s
-0000ee90: 6574 5f70 7265 7061 7265 643a 2062 6f6f  et_prepared: boo
-0000eea0: 6c20 3d20 4661 6c73 650a 2020 2020 2920  l = False.    ) 
-0000eeb0: 2d3e 204e 6f6e 653a 0a20 2020 2020 2020  -> None:.       
-0000eec0: 2022 2222 5570 6461 7465 2074 6865 206d   """Update the m
-0000eed0: 6173 7465 7264 6174 6120 7072 6f76 656e  asterdata proven
-0000eee0: 616e 6365 2222 220a 0a20 2020 2020 2020  ance"""..       
-0000eef0: 2069 6620 2263 6f6c 7265 765f 6d61 7374   if "colrev_mast
-0000ef00: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
-0000ef10: 6522 206e 6f74 2069 6e20 7365 6c66 2e64  e" not in self.d
-0000ef20: 6174 613a 0a20 2020 2020 2020 2020 2020  ata:.           
-0000ef30: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
-0000ef40: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
-0000ef50: 6f76 656e 616e 6365 225d 203d 207b 7d0a  ovenance"] = {}.
-0000ef60: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-0000ef70: 2e6d 6173 7465 7264 6174 615f 6973 5f63  .masterdata_is_c
-0000ef80: 7572 6174 6564 2829 3a0a 2020 2020 2020  urated():.      
-0000ef90: 2020 2020 2020 7265 7475 726e 0a0a 2020        return..  
-0000efa0: 2020 2020 2020 2320 4170 706c 7920 7468        # Apply th
-0000efb0: 6520 6368 6563 6b65 7273 2028 696e 636c  e checkers (incl
-0000efc0: 7564 696e 6720 6669 656c 6420 6b65 7920  uding field key 
-0000efd0: 7265 7175 6972 656d 656e 7473 2065 7463  requirements etc
-0000efe0: 2e29 0a20 2020 2020 2020 2071 6d2e 7275  .).        qm.ru
-0000eff0: 6e28 7265 636f 7264 3d73 656c 6629 0a0a  n(record=self)..
-0000f000: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-0000f010: 6861 735f 7175 616c 6974 795f 6465 6665  has_quality_defe
-0000f020: 6374 7328 293a 0a20 2020 2020 2020 2020  cts():.         
-0000f030: 2020 2073 656c 662e 7365 745f 7374 6174     self.set_stat
-0000f040: 7573 2874 6172 6765 745f 7374 6174 653d  us(target_state=
-0000f050: 5265 636f 7264 5374 6174 652e 6d64 5f6e  RecordState.md_n
-0000f060: 6565 6473 5f6d 616e 7561 6c5f 7072 6570  eeds_manual_prep
-0000f070: 6172 6174 696f 6e29 0a20 2020 2020 2020  aration).       
-0000f080: 2065 6c69 6620 7365 745f 7072 6570 6172   elif set_prepar
-0000f090: 6564 3a0a 2020 2020 2020 2020 2020 2020  ed:.            
-0000f0a0: 7365 6c66 2e73 6574 5f73 7461 7475 7328  self.set_status(
-0000f0b0: 7461 7267 6574 5f73 7461 7465 3d52 6563  target_state=Rec
-0000f0c0: 6f72 6453 7461 7465 2e6d 645f 7072 6570  ordState.md_prep
-0000f0d0: 6172 6564 290a 0a20 2020 2064 6566 2063  ared)..    def c
-0000f0e0: 6865 636b 5f70 6f74 656e 7469 616c 5f72  heck_potential_r
-0000f0f0: 6574 7261 6374 7328 7365 6c66 2920 2d3e  etracts(self) ->
-0000f100: 2062 6f6f 6c3a 0a20 2020 2020 2020 2022   bool:.        "
-0000f110: 2222 4368 6563 6b20 666f 7220 706f 7465  ""Check for pote
-0000f120: 6e74 6961 6c20 7265 7472 6163 7473 2222  ntial retracts""
-0000f130: 220a 2020 2020 2020 2020 2320 4e6f 7465  ".        # Note
-0000f140: 203a 2077 6520 7265 7472 6965 7665 6420   : we retrieved 
-0000f150: 6d65 7461 6461 7461 2069 6e20 6765 745f  metadata in get_
-0000f160: 6d61 7374 6572 6461 7461 5f66 726f 6d5f  masterdata_from_
-0000f170: 6372 6f73 7372 6566 2829 0a20 2020 2020  crossref().     
-0000f180: 2020 2069 6620 7365 6c66 2e64 6174 612e     if self.data.
-0000f190: 6765 7428 2263 726f 7373 6d61 726b 222c  get("crossmark",
-0000f1a0: 2022 2229 203d 3d20 2254 7275 6522 3a0a   "") == "True":.
-0000f1b0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000f1c0: 2e70 7265 7363 7265 656e 5f65 7863 6c75  .prescreen_exclu
-0000f1d0: 6465 2872 6561 736f 6e3d 2272 6574 7261  de(reason="retra
-0000f1e0: 6374 6564 222c 2070 7269 6e74 5f77 6172  cted", print_war
-0000f1f0: 6e69 6e67 3d54 7275 6529 0a20 2020 2020  ning=True).     
-0000f200: 2020 2020 2020 2073 656c 662e 7265 6d6f         self.remo
-0000f210: 7665 5f66 6965 6c64 286b 6579 3d22 6372  ve_field(key="cr
-0000f220: 6f73 736d 6172 6b22 290a 2020 2020 2020  ossmark").      
-0000f230: 2020 2020 2020 7265 7475 726e 2054 7275        return Tru
-0000f240: 650a 2020 2020 2020 2020 6966 2073 656c  e.        if sel
-0000f250: 662e 6461 7461 2e67 6574 2822 7761 726e  f.data.get("warn
-0000f260: 696e 6722 2c20 2222 2920 3d3d 2022 5769  ing", "") == "Wi
-0000f270: 7468 6472 6177 6e20 2861 6363 6f72 6469  thdrawn (accordi
-0000f280: 6e67 2074 6f20 4442 4c50 2922 3a0a 2020  ng to DBLP)":.  
-0000f290: 2020 2020 2020 2020 2020 7365 6c66 2e70            self.p
-0000f2a0: 7265 7363 7265 656e 5f65 7863 6c75 6465  rescreen_exclude
-0000f2b0: 2872 6561 736f 6e3d 2272 6574 7261 6374  (reason="retract
-0000f2c0: 6564 222c 2070 7269 6e74 5f77 6172 6e69  ed", print_warni
-0000f2d0: 6e67 3d54 7275 6529 0a20 2020 2020 2020  ng=True).       
-0000f2e0: 2020 2020 2073 656c 662e 7265 6d6f 7665       self.remove
-0000f2f0: 5f66 6965 6c64 286b 6579 3d22 7761 726e  _field(key="warn
-0000f300: 696e 6722 290a 2020 2020 2020 2020 2020  ing").          
-0000f310: 2020 7265 7475 726e 2054 7275 650a 2020    return True.  
-0000f320: 2020 2020 2020 7265 7475 726e 2046 616c        return Fal
-0000f330: 7365 0a0a 2020 2020 6465 6620 7072 696e  se..    def prin
-0000f340: 745f 7072 6573 6372 6565 6e5f 7265 636f  t_prescreen_reco
-0000f350: 7264 2873 656c 6629 202d 3e20 4e6f 6e65  rd(self) -> None
-0000f360: 3a0a 2020 2020 2020 2020 2222 2250 7269  :.        """Pri
-0000f370: 6e74 2074 6865 2072 6563 6f72 6420 666f  nt the record fo
-0000f380: 7220 7072 6573 6372 6565 6e20 6f70 6572  r prescreen oper
-0000f390: 6174 696f 6e73 2222 220a 0a20 2020 2020  ations"""..     
-0000f3a0: 2020 2072 6574 5f73 7472 203d 2066 2220     ret_str = f" 
-0000f3b0: 2049 443a 207b 7365 6c66 2e64 6174 615b   ID: {self.data[
-0000f3c0: 2749 4427 5d7d 2028 7b73 656c 662e 6461  'ID']} ({self.da
-0000f3d0: 7461 5b27 454e 5452 5954 5950 4527 5d7d  ta['ENTRYTYPE']}
-0000f3e0: 2922 0a20 2020 2020 2020 2072 6574 5f73  )".        ret_s
-0000f3f0: 7472 202b 3d20 280a 2020 2020 2020 2020  tr += (.        
-0000f400: 2020 2020 6622 5c6e 2020 7b63 6f6c 6f72      f"\n  {color
-0000f410: 732e 4752 4545 4e7d 7b73 656c 662e 6461  s.GREEN}{self.da
-0000f420: 7461 2e67 6574 2827 7469 746c 6527 2c20  ta.get('title', 
-0000f430: 276e 6f20 7469 746c 6527 297d 7b63 6f6c  'no title')}{col
-0000f440: 6f72 732e 454e 447d 220a 2020 2020 2020  ors.END}".      
-0000f450: 2020 2020 2020 6622 5c6e 2020 7b73 656c        f"\n  {sel
-0000f460: 662e 6461 7461 2e67 6574 2827 6175 7468  f.data.get('auth
-0000f470: 6f72 272c 2027 6e6f 2d61 7574 686f 7227  or', 'no-author'
-0000f480: 297d 220a 2020 2020 2020 2020 290a 2020  )}".        ).  
-0000f490: 2020 2020 2020 6966 2073 656c 662e 6461        if self.da
-0000f4a0: 7461 5b22 454e 5452 5954 5950 4522 5d20  ta["ENTRYTYPE"] 
-0000f4b0: 3d3d 2022 6172 7469 636c 6522 3a0a 2020  == "article":.  
-0000f4c0: 2020 2020 2020 2020 2020 7265 745f 7374            ret_st
-0000f4d0: 7220 2b3d 2028 0a20 2020 2020 2020 2020  r += (.         
-0000f4e0: 2020 2020 2020 2066 225c 6e20 207b 7365         f"\n  {se
-0000f4f0: 6c66 2e64 6174 612e 6765 7428 276a 6f75  lf.data.get('jou
-0000f500: 726e 616c 272c 2027 6e6f 2d6a 6f75 726e  rnal', 'no-journ
-0000f510: 616c 2729 7d20 220a 2020 2020 2020 2020  al')} ".        
-0000f520: 2020 2020 2020 2020 6622 287b 7365 6c66          f"({self
-0000f530: 2e64 6174 612e 6765 7428 2779 6561 7227  .data.get('year'
-0000f540: 2c20 276e 6f2d 7965 6172 2729 7d29 2022  , 'no-year')}) "
-0000f550: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f560: 2066 227b 7365 6c66 2e64 6174 612e 6765   f"{self.data.ge
-0000f570: 7428 2776 6f6c 756d 6527 2c20 276e 6f2d  t('volume', 'no-
-0000f580: 766f 6c75 6d65 2729 7d22 0a20 2020 2020  volume')}".     
-0000f590: 2020 2020 2020 2020 2020 2066 2228 7b73             f"({s
-0000f5a0: 656c 662e 6461 7461 2e67 6574 2827 6e75  elf.data.get('nu
-0000f5b0: 6d62 6572 272c 2027 2729 7d29 220a 2020  mber', '')})".  
-0000f5c0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-0000f5d0: 2020 2020 656c 6966 2073 656c 662e 6461      elif self.da
-0000f5e0: 7461 5b22 454e 5452 5954 5950 4522 5d20  ta["ENTRYTYPE"] 
-0000f5f0: 3d3d 2022 696e 7072 6f63 6565 6469 6e67  == "inproceeding
-0000f600: 7322 3a0a 2020 2020 2020 2020 2020 2020  s":.            
-0000f610: 7265 745f 7374 7220 2b3d 2066 225c 6e20  ret_str += f"\n 
-0000f620: 207b 7365 6c66 2e64 6174 612e 6765 7428   {self.data.get(
-0000f630: 2762 6f6f 6b74 6974 6c65 272c 2027 6e6f  'booktitle', 'no
-0000f640: 2d62 6f6f 6b74 6974 6c65 2729 7d22 0a20  -booktitle')}". 
-0000f650: 2020 2020 2020 2069 6620 2261 6273 7472         if "abstr
-0000f660: 6163 7422 2069 6e20 7365 6c66 2e64 6174  act" in self.dat
-0000f670: 613a 0a20 2020 2020 2020 2020 2020 206c  a:.            l
-0000f680: 696e 6573 203d 2074 6578 7477 7261 702e  ines = textwrap.
-0000f690: 7772 6170 2873 656c 662e 6461 7461 5b22  wrap(self.data["
-0000f6a0: 6162 7374 7261 6374 225d 2c20 3130 302c  abstract"], 100,
-0000f6b0: 2062 7265 616b 5f6c 6f6e 675f 776f 7264   break_long_word
-0000f6c0: 733d 4661 6c73 6529 0a20 2020 2020 2020  s=False).       
-0000f6d0: 2020 2020 2069 6620 6c69 6e65 733a 0a20       if lines:. 
-0000f6e0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-0000f6f0: 6574 5f73 7472 202b 3d20 6622 5c6e 2020  et_str += f"\n  
-0000f700: 4162 7374 7261 6374 3a20 7b6c 696e 6573  Abstract: {lines
-0000f710: 2e70 6f70 2830 297d 5c6e 220a 2020 2020  .pop(0)}\n".    
-0000f720: 2020 2020 2020 2020 2020 2020 7265 745f              ret_
-0000f730: 7374 7220 2b3d 2022 5c6e 2020 222e 6a6f  str += "\n  ".jo
-0000f740: 696e 286c 696e 6573 2920 2b20 2222 0a0a  in(lines) + ""..
-0000f750: 2020 2020 2020 2020 6966 2022 7572 6c22          if "url"
-0000f760: 2069 6e20 7365 6c66 2e64 6174 613a 0a20   in self.data:. 
-0000f770: 2020 2020 2020 2020 2020 2072 6574 5f73             ret_s
-0000f780: 7472 202b 3d20 6622 5c6e 2020 7572 6c3a  tr += f"\n  url:
-0000f790: 207b 7365 6c66 2e64 6174 615b 2775 726c   {self.data['url
-0000f7a0: 275d 7d22 0a0a 2020 2020 2020 2020 6966  ']}"..        if
-0000f7b0: 2022 6669 6c65 2220 696e 2073 656c 662e   "file" in self.
-0000f7c0: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
-0000f7d0: 2020 7265 745f 7374 7220 2b3d 2066 225c    ret_str += f"\
-0000f7e0: 6e20 2066 696c 653a 207b 7365 6c66 2e64  n  file: {self.d
-0000f7f0: 6174 615b 2766 696c 6527 5d7d 220a 0a20  ata['file']}".. 
-0000f800: 2020 2020 2020 2070 7269 6e74 2872 6574         print(ret
-0000f810: 5f73 7472 290a 0a20 2020 2064 6566 2070  _str)..    def p
-0000f820: 7269 6e74 5f70 6466 5f70 7265 705f 6d61  rint_pdf_prep_ma
-0000f830: 6e28 7365 6c66 2920 2d3e 204e 6f6e 653a  n(self) -> None:
-0000f840: 0a20 2020 2020 2020 2022 2222 5072 696e  .        """Prin
-0000f850: 7420 7468 6520 7265 636f 7264 2066 6f72  t the record for
-0000f860: 2070 6466 2d70 7265 702d 6d61 6e20 6f70   pdf-prep-man op
-0000f870: 6572 6174 696f 6e73 2222 220a 2020 2020  erations""".    
-0000f880: 2020 2020 2320 7079 6c69 6e74 3a20 6469      # pylint: di
-0000f890: 7361 626c 653d 746f 6f2d 6d61 6e79 2d62  sable=too-many-b
-0000f8a0: 7261 6e63 6865 730a 2020 2020 2020 2020  ranches.        
-0000f8b0: 7265 745f 7374 7220 3d20 2222 0a20 2020  ret_str = "".   
-0000f8c0: 2020 2020 2069 6620 2266 696c 6522 2069       if "file" i
-0000f8d0: 6e20 7365 6c66 2e64 6174 613a 0a20 2020  n self.data:.   
-0000f8e0: 2020 2020 2020 2020 2072 6574 5f73 7472           ret_str
-0000f8f0: 202b 3d20 6622 5c6e 6669 6c65 3a20 7b63   += f"\nfile: {c
-0000f900: 6f6c 6f72 732e 4f52 414e 4745 7d7b 7365  olors.ORANGE}{se
-0000f910: 6c66 2e64 6174 615b 2766 696c 6527 5d7d  lf.data['file']}
-0000f920: 7b63 6f6c 6f72 732e 454e 447d 5c6e 5c6e  {colors.END}\n\n
-0000f930: 220a 0a20 2020 2020 2020 2070 6466 5f70  "..        pdf_p
-0000f940: 7265 705f 6e6f 7465 203d 2073 656c 662e  rep_note = self.
-0000f950: 6765 745f 6669 656c 645f 7072 6f76 656e  get_field_proven
-0000f960: 616e 6365 286b 6579 3d22 6669 6c65 2229  ance(key="file")
-0000f970: 0a0a 2020 2020 2020 2020 6966 2022 6175  ..        if "au
-0000f980: 7468 6f72 5f6e 6f74 5f69 6e5f 6669 7273  thor_not_in_firs
-0000f990: 745f 7061 6765 7322 2069 6e20 7064 665f  t_pages" in pdf_
-0000f9a0: 7072 6570 5f6e 6f74 655b 226e 6f74 6522  prep_note["note"
-0000f9b0: 5d3a 0a20 2020 2020 2020 2020 2020 2072  ]:.            r
-0000f9c0: 6574 5f73 7472 202b 3d20 280a 2020 2020  et_str += (.    
-0000f9d0: 2020 2020 2020 2020 2020 2020 6622 7b63              f"{c
-0000f9e0: 6f6c 6f72 732e 5245 447d 7b73 656c 662e  olors.RED}{self.
-0000f9f0: 6461 7461 2e67 6574 2827 6175 7468 6f72  data.get('author
-0000fa00: 272c 2027 6e6f 2d61 7574 686f 7227 297d  ', 'no-author')}
-0000fa10: 7b63 6f6c 6f72 732e 454e 447d 5c6e 220a  {colors.END}\n".
-0000fa20: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-0000fa30: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0000fa40: 2020 2020 2020 2020 7265 745f 7374 7220          ret_str 
-0000fa50: 2b3d 2028 0a20 2020 2020 2020 2020 2020  += (.           
-0000fa60: 2020 2020 2066 227b 636f 6c6f 7273 2e47       f"{colors.G
-0000fa70: 5245 454e 7d7b 7365 6c66 2e64 6174 612e  REEN}{self.data.
-0000fa80: 6765 7428 2761 7574 686f 7227 2c20 276e  get('author', 'n
-0000fa90: 6f2d 6175 7468 6f72 2729 7d7b 636f 6c6f  o-author')}{colo
-0000faa0: 7273 2e45 4e44 7d5c 6e22 0a20 2020 2020  rs.END}\n".     
-0000fab0: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
-0000fac0: 2020 6966 2022 7469 746c 655f 6e6f 745f    if "title_not_
-0000fad0: 696e 5f66 6972 7374 5f70 6167 6573 2220  in_first_pages" 
-0000fae0: 696e 2070 6466 5f70 7265 705f 6e6f 7465  in pdf_prep_note
-0000faf0: 5b22 6e6f 7465 225d 3a0a 2020 2020 2020  ["note"]:.      
-0000fb00: 2020 2020 2020 7265 745f 7374 7220 2b3d        ret_str +=
-0000fb10: 2066 227b 636f 6c6f 7273 2e52 4544 7d7b   f"{colors.RED}{
-0000fb20: 7365 6c66 2e64 6174 612e 6765 7428 2774  self.data.get('t
-0000fb30: 6974 6c65 272c 2027 6e6f 2074 6974 6c65  itle', 'no title
-0000fb40: 2729 7d7b 636f 6c6f 7273 2e45 4e44 7d5c  ')}{colors.END}\
-0000fb50: 6e22 0a20 2020 2020 2020 2065 6c73 653a  n".        else:
-0000fb60: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-0000fb70: 5f73 7472 202b 3d20 280a 2020 2020 2020  _str += (.      
-0000fb80: 2020 2020 2020 2020 2020 6622 7b63 6f6c            f"{col
-0000fb90: 6f72 732e 4752 4545 4e7d 7b73 656c 662e  ors.GREEN}{self.
-0000fba0: 6461 7461 2e67 6574 2827 7469 746c 6527  data.get('title'
-0000fbb0: 2c20 276e 6f20 7469 746c 6527 297d 7b63  , 'no title')}{c
-0000fbc0: 6f6c 6f72 732e 454e 447d 5c6e 220a 2020  olors.END}\n".  
-0000fbd0: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
-0000fbe0: 2020 2020 2069 6620 7365 6c66 2e64 6174       if self.dat
-0000fbf0: 615b 2245 4e54 5259 5459 5045 225d 203d  a["ENTRYTYPE"] =
-0000fc00: 3d20 2261 7274 6963 6c65 223a 0a20 2020  = "article":.   
-0000fc10: 2020 2020 2020 2020 2072 6574 5f73 7472           ret_str
-0000fc20: 202b 3d20 280a 2020 2020 2020 2020 2020   += (.          
-0000fc30: 2020 2020 2020 6622 7b73 656c 662e 6461        f"{self.da
-0000fc40: 7461 2e67 6574 2827 6a6f 7572 6e61 6c27  ta.get('journal'
-0000fc50: 2c20 276e 6f2d 6a6f 7572 6e61 6c27 297d  , 'no-journal')}
-0000fc60: 2022 0a20 2020 2020 2020 2020 2020 2020   ".             
-0000fc70: 2020 2066 2228 7b73 656c 662e 6461 7461     f"({self.data
-0000fc80: 2e67 6574 2827 7965 6172 272c 2027 6e6f  .get('year', 'no
-0000fc90: 2d79 6561 7227 297d 2920 220a 2020 2020  -year')}) ".    
-0000fca0: 2020 2020 2020 2020 2020 2020 6622 7b73              f"{s
-0000fcb0: 656c 662e 6461 7461 2e67 6574 2827 766f  elf.data.get('vo
-0000fcc0: 6c75 6d65 272c 2027 6e6f 2d76 6f6c 756d  lume', 'no-volum
-0000fcd0: 6527 297d 220a 2020 2020 2020 2020 2020  e')}".          
-0000fce0: 2020 2020 2020 6622 287b 7365 6c66 2e64        f"({self.d
-0000fcf0: 6174 612e 6765 7428 276e 756d 6265 7227  ata.get('number'
-0000fd00: 2c20 2727 297d 2922 0a20 2020 2020 2020  , '')})".       
-0000fd10: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-0000fd20: 2020 2069 6620 2270 6167 6573 2220 696e     if "pages" in
-0000fd30: 2073 656c 662e 6461 7461 3a0a 2020 2020   self.data:.    
-0000fd40: 2020 2020 2020 2020 2020 2020 6966 2022              if "
-0000fd50: 6e72 5f70 6167 6573 5f6e 6f74 5f6d 6174  nr_pages_not_mat
-0000fd60: 6368 696e 6722 2069 6e20 7064 665f 7072  ching" in pdf_pr
-0000fd70: 6570 5f6e 6f74 655b 226e 6f74 6522 5d3a  ep_note["note"]:
-0000fd80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000fd90: 2020 2020 2072 6574 5f73 7472 202b 3d20       ret_str += 
-0000fda0: 6622 2c20 7b63 6f6c 6f72 732e 5245 447d  f", {colors.RED}
-0000fdb0: 7070 2e7b 7365 6c66 2e64 6174 615b 2770  pp.{self.data['p
-0000fdc0: 6167 6573 275d 7d7b 636f 6c6f 7273 2e45  ages']}{colors.E
-0000fdd0: 4e44 7d5c 6e22 0a20 2020 2020 2020 2020  ND}\n".         
-0000fde0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0000fdf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fe00: 2072 6574 5f73 7472 202b 3d20 6622 2c20   ret_str += f", 
-0000fe10: 7070 2e7b 636f 6c6f 7273 2e47 5245 454e  pp.{colors.GREEN
-0000fe20: 7d7b 7365 6c66 2e64 6174 615b 2770 6167  }{self.data['pag
-0000fe30: 6573 275d 7d7b 636f 6c6f 7273 2e45 4e44  es']}{colors.END
-0000fe40: 7d5c 6e22 0a20 2020 2020 2020 2020 2020  }\n".           
-0000fe50: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0000fe60: 2020 2020 2020 2072 6574 5f73 7472 202b         ret_str +
-0000fe70: 3d20 225c 6e22 0a20 2020 2020 2020 2065  = "\n".        e
-0000fe80: 6c69 6620 7365 6c66 2e64 6174 615b 2245  lif self.data["E
-0000fe90: 4e54 5259 5459 5045 225d 203d 3d20 2269  NTRYTYPE"] == "i
-0000fea0: 6e70 726f 6365 6564 696e 6773 223a 0a20  nproceedings":. 
-0000feb0: 2020 2020 2020 2020 2020 2072 6574 5f73             ret_s
-0000fec0: 7472 202b 3d20 6622 7b73 656c 662e 6461  tr += f"{self.da
-0000fed0: 7461 2e67 6574 2827 626f 6f6b 7469 746c  ta.get('booktitl
-0000fee0: 6527 2c20 276e 6f2d 626f 6f6b 7469 746c  e', 'no-booktitl
-0000fef0: 6527 297d 5c6e 220a 2020 2020 2020 2020  e')}\n".        
-0000ff00: 6966 2022 6162 7374 7261 6374 2220 696e  if "abstract" in
-0000ff10: 2073 656c 662e 6461 7461 3a0a 2020 2020   self.data:.    
-0000ff20: 2020 2020 2020 2020 6c69 6e65 7320 3d20          lines = 
-0000ff30: 7465 7874 7772 6170 2e77 7261 7028 7365  textwrap.wrap(se
-0000ff40: 6c66 2e64 6174 615b 2261 6273 7472 6163  lf.data["abstrac
-0000ff50: 7422 5d2c 2031 3030 2c20 6272 6561 6b5f  t"], 100, break_
-0000ff60: 6c6f 6e67 5f77 6f72 6473 3d46 616c 7365  long_words=False
-0000ff70: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
-0000ff80: 745f 7374 7220 2b3d 2066 225c 6e41 6273  t_str += f"\nAbs
-0000ff90: 7472 6163 743a 207b 6c69 6e65 732e 706f  tract: {lines.po
-0000ffa0: 7028 3029 7d5c 6e22 0a20 2020 2020 2020  p(0)}\n".       
-0000ffb0: 2020 2020 2072 6574 5f73 7472 202b 3d20       ret_str += 
-0000ffc0: 225c 6e22 2e6a 6f69 6e28 6c69 6e65 7329  "\n".join(lines)
-0000ffd0: 202b 2022 5c6e 220a 0a20 2020 2020 2020   + "\n"..       
-0000ffe0: 2069 6620 2275 726c 2220 696e 2073 656c   if "url" in sel
-0000fff0: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
-00010000: 2020 2020 7265 745f 7374 7220 2b3d 2066      ret_str += f
-00010010: 225c 6e75 726c 3a20 7b73 656c 662e 6461  "\nurl: {self.da
-00010020: 7461 5b27 7572 6c27 5d7d 5c6e 220a 0a20  ta['url']}\n".. 
-00010030: 2020 2020 2020 2070 7269 6e74 2872 6574         print(ret
-00010040: 5f73 7472 290a 0a0a 636c 6173 7320 5072  _str)...class Pr
-00010050: 6570 5265 636f 7264 2852 6563 6f72 6429  epRecord(Record)
-00010060: 3a0a 2020 2020 2222 2254 6865 2050 7265  :.    """The Pre
-00010070: 7052 6563 6f72 6420 636c 6173 7320 7072  pRecord class pr
-00010080: 6f76 6964 6573 2061 2072 616e 6765 206f  ovides a range o
-00010090: 6620 636f 6e76 656e 6965 6e63 6520 6675  f convenience fu
-000100a0: 6e63 7469 6f6e 7320 666f 7220 7265 636f  nctions for reco
-000100b0: 7264 2070 7265 7061 7261 7469 6f6e 2222  rd preparation""
-000100c0: 220a 0a20 2020 2040 636c 6173 736d 6574  "..    @classmet
-000100d0: 686f 640a 2020 2020 6465 6620 666f 726d  hod.    def form
-000100e0: 6174 5f61 7574 686f 725f 6669 656c 6428  at_author_field(
-000100f0: 636c 732c 202a 2c20 696e 7075 745f 7374  cls, *, input_st
-00010100: 7269 6e67 3a20 7374 7229 202d 3e20 7374  ring: str) -> st
-00010110: 723a 0a20 2020 2020 2020 2022 2222 466f  r:.        """Fo
-00010120: 726d 6174 2074 6865 2061 7574 686f 7220  rmat the author 
-00010130: 6669 656c 6420 2872 6563 6f67 6e69 7a69  field (recognizi
-00010140: 6e67 2066 6972 7374 2f6c 6173 7420 6e61  ng first/last na
-00010150: 6d65 7320 6261 7365 6420 6f6e 2048 756d  mes based on Hum
-00010160: 616e 4e61 6d65 2070 6172 7365 7229 2222  anName parser)""
-00010170: 220a 0a20 2020 2020 2020 2064 6566 206d  "..        def m
-00010180: 6f73 746c 795f 7570 7065 725f 6361 7365  ostly_upper_case
-00010190: 2869 6e70 7574 5f73 7472 696e 673a 2073  (input_string: s
-000101a0: 7472 2920 2d3e 2062 6f6f 6c3a 0a20 2020  tr) -> bool:.   
-000101b0: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
-000101c0: 7265 2e6d 6174 6368 2872 225b 612d 7a41  re.match(r"[a-zA
-000101d0: 2d5a 5d2b 222c 2069 6e70 7574 5f73 7472  -Z]+", input_str
-000101e0: 696e 6729 3a0a 2020 2020 2020 2020 2020  ing):.          
-000101f0: 2020 2020 2020 7265 7475 726e 2046 616c        return Fal
-00010200: 7365 0a20 2020 2020 2020 2020 2020 2069  se.            i
-00010210: 6e70 7574 5f73 7472 696e 6720 3d20 696e  nput_string = in
-00010220: 7075 745f 7374 7269 6e67 2e72 6570 6c61  put_string.repla
-00010230: 6365 2822 2e22 2c20 2222 292e 7265 706c  ce(".", "").repl
-00010240: 6163 6528 222c 222c 2022 2229 0a20 2020  ace(",", "").   
-00010250: 2020 2020 2020 2020 2077 6f72 6473 203d           words =
-00010260: 2069 6e70 7574 5f73 7472 696e 672e 7370   input_string.sp
-00010270: 6c69 7428 290a 2020 2020 2020 2020 2020  lit().          
-00010280: 2020 7265 7475 726e 2073 756d 2877 6f72    return sum(wor
-00010290: 642e 6973 7570 7065 7228 2920 666f 7220  d.isupper() for 
-000102a0: 776f 7264 2069 6e20 776f 7264 7329 202f  word in words) /
-000102b0: 206c 656e 2877 6f72 6473 2920 3e20 302e   len(words) > 0.
-000102c0: 380a 0a20 2020 2020 2020 2069 6e70 7574  8..        input
-000102d0: 5f73 7472 696e 6720 3d20 696e 7075 745f  _string = input_
-000102e0: 7374 7269 6e67 2e72 6570 6c61 6365 2822  string.replace("
-000102f0: 5c6e 222c 2022 2022 290a 2020 2020 2020  \n", " ").      
-00010300: 2020 2320 4442 4c50 2061 7070 656e 6473    # DBLP appends
-00010310: 2069 6465 6e74 6966 6965 7273 2074 6f20   identifiers to 
-00010320: 6e6f 6e2d 756e 6971 7565 2061 7574 686f  non-unique autho
-00010330: 7273 0a20 2020 2020 2020 2069 6e70 7574  rs.        input
-00010340: 5f73 7472 696e 6720 3d20 7374 7228 7265  _string = str(re
-00010350: 2e73 7562 2872 225b 302d 395d 7b34 7d22  .sub(r"[0-9]{4}"
-00010360: 2c20 2222 2c20 696e 7075 745f 7374 7269  , "", input_stri
-00010370: 6e67 2929 0a0a 2020 2020 2020 2020 6966  ng))..        if
-00010380: 2022 2061 6e64 2022 2069 6e20 696e 7075   " and " in inpu
-00010390: 745f 7374 7269 6e67 3a0a 2020 2020 2020  t_string:.      
-000103a0: 2020 2020 2020 6e61 6d65 7320 3d20 696e        names = in
-000103b0: 7075 745f 7374 7269 6e67 2e73 706c 6974  put_string.split
-000103c0: 2822 2061 6e64 2022 290a 2020 2020 2020  (" and ").      
-000103d0: 2020 656c 6966 2069 6e70 7574 5f73 7472    elif input_str
-000103e0: 696e 672e 636f 756e 7428 222c 2229 203e  ing.count(",") >
-000103f0: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
-00010400: 6e61 6d65 7320 3d20 696e 7075 745f 7374  names = input_st
-00010410: 7269 6e67 2e73 706c 6974 2822 2c20 2229  ring.split(", ")
-00010420: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-00010430: 2020 2020 2020 2020 2020 206e 616d 6573             names
-00010440: 203d 205b 696e 7075 745f 7374 7269 6e67   = [input_string
-00010450: 5d0a 2020 2020 2020 2020 6175 7468 6f72  ].        author
-00010460: 5f73 7472 696e 6720 3d20 2222 0a20 2020  _string = "".   
-00010470: 2020 2020 2066 6f72 206e 616d 6520 696e       for name in
-00010480: 206e 616d 6573 3a0a 2020 2020 2020 2020   names:.        
-00010490: 2020 2020 2320 4e6f 7465 3a20 6874 7470      # Note: http
-000104a0: 733a 2f2f 6769 7468 7562 2e63 6f6d 2f64  s://github.com/d
-000104b0: 6572 656b 3733 2f70 7974 686f 6e2d 6e61  erek73/python-na
-000104c0: 6d65 7061 7273 6572 0a20 2020 2020 2020  meparser.       
-000104d0: 2020 2020 2023 2069 7320 7665 7279 2065       # is very e
-000104e0: 6666 6563 7469 7665 2028 6d61 7962 6520  ffective (maybe 
-000104f0: 6e6f 7420 7065 7266 6563 7429 0a0a 2020  not perfect)..  
-00010500: 2020 2020 2020 2020 2020 7061 7273 6564            parsed
-00010510: 5f6e 616d 6520 3d20 4875 6d61 6e4e 616d  _name = HumanNam
-00010520: 6528 6e61 6d65 290a 2020 2020 2020 2020  e(name).        
-00010530: 2020 2020 6966 206d 6f73 746c 795f 7570      if mostly_up
-00010540: 7065 725f 6361 7365 2869 6e70 7574 5f73  per_case(input_s
-00010550: 7472 696e 672e 7265 706c 6163 6528 2220  tring.replace(" 
-00010560: 616e 6420 222c 2022 2229 2e72 6570 6c61  and ", "").repla
-00010570: 6365 2822 4a72 222c 2022 2229 293a 0a20  ce("Jr", "")):. 
-00010580: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00010590: 6172 7365 645f 6e61 6d65 2e63 6170 6974  arsed_name.capit
-000105a0: 616c 697a 6528 666f 7263 653d 5472 7565  alize(force=True
-000105b0: 290a 0a20 2020 2020 2020 2020 2020 2023  )..            #
-000105c0: 2046 6978 2074 7970 6963 616c 2070 6172   Fix typical par
-000105d0: 7365 7220 6572 726f 720a 2020 2020 2020  ser error.      
-000105e0: 2020 2020 2020 6966 2070 6172 7365 645f        if parsed_
-000105f0: 6e61 6d65 2e6c 6173 7420 3d3d 2022 2220  name.last == "" 
-00010600: 616e 6420 7061 7273 6564 5f6e 616d 652e  and parsed_name.
-00010610: 7469 746c 6520 213d 2022 223a 0a20 2020  title != "":.   
-00010620: 2020 2020 2020 2020 2020 2020 2070 6172               par
-00010630: 7365 645f 6e61 6d65 2e6c 6173 7420 3d20  sed_name.last = 
-00010640: 7061 7273 6564 5f6e 616d 652e 7469 746c  parsed_name.titl
-00010650: 650a 0a20 2020 2020 2020 2020 2020 2023  e..            #
-00010660: 2070 796c 696e 743a 2064 6973 6162 6c65   pylint: disable
-00010670: 3d63 6861 696e 6564 2d63 6f6d 7061 7269  =chained-compari
-00010680: 736f 6e0a 2020 2020 2020 2020 2020 2020  son.            
-00010690: 2320 4669 783a 2077 6865 6e20 6669 7273  # Fix: when firs
-000106a0: 7420 6e61 6d65 7320 6172 6520 6162 6272  t names are abbr
-000106b0: 6576 6961 7465 642c 206e 616d 6570 6172  eviated, namepar
-000106c0: 7365 7220 6372 6561 7465 7320 6572 726f  ser creates erro
-000106d0: 7273 3a0a 2020 2020 2020 2020 2020 2020  rs:.            
-000106e0: 6966 2028 0a20 2020 2020 2020 2020 2020  if (.           
-000106f0: 2020 2020 206c 656e 2870 6172 7365 645f       len(parsed_
-00010700: 6e61 6d65 2e6c 6173 7429 203c 3d20 330a  name.last) <= 3.
-00010710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010720: 616e 6420 7061 7273 6564 5f6e 616d 652e  and parsed_name.
-00010730: 6c61 7374 2e69 7375 7070 6572 2829 0a20  last.isupper(). 
-00010740: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-00010750: 6e64 206c 656e 2870 6172 7365 645f 6e61  nd len(parsed_na
-00010760: 6d65 2e66 6972 7374 2920 3e20 330a 2020  me.first) > 3.  
-00010770: 2020 2020 2020 2020 2020 2020 2020 616e                an
-00010780: 6420 6e6f 7420 7061 7273 6564 5f6e 616d  d not parsed_nam
-00010790: 652e 6669 7273 742e 6973 7570 7065 7228  e.first.isupper(
-000107a0: 290a 2020 2020 2020 2020 2020 2020 293a  ).            ):
-000107b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000107c0: 2023 2069 6e20 7468 6573 6520 6361 7365   # in these case
-000107d0: 6573 2c20 6669 7273 7420 616e 6420 6c61  es, first and la
-000107e0: 7374 206e 616d 6573 2061 7265 2063 6f6e  st names are con
-000107f0: 6675 7365 640a 2020 2020 2020 2020 2020  fused.          
-00010800: 2020 2020 2020 6175 7468 6f72 5f6e 616d        author_nam
-00010810: 655f 7374 7269 6e67 203d 2070 6172 7365  e_string = parse
-00010820: 645f 6e61 6d65 2e66 6972 7374 202b 2022  d_name.first + "
-00010830: 2c20 2220 2b20 7061 7273 6564 5f6e 616d  , " + parsed_nam
-00010840: 652e 6c61 7374 0a20 2020 2020 2020 2020  e.last.         
-00010850: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00010860: 2020 2020 2020 2020 2070 6172 7365 645f           parsed_
-00010870: 6e61 6d65 2e73 7472 696e 675f 666f 726d  name.string_form
-00010880: 6174 203d 2022 7b6c 6173 747d 207b 7375  at = "{last} {su
-00010890: 6666 6978 7d2c 207b 6669 7273 747d 207b  ffix}, {first} {
-000108a0: 6d69 6464 6c65 7d22 0a20 2020 2020 2020  middle}".       
-000108b0: 2020 2020 2020 2020 2023 2027 7b6c 6173           # '{las
-000108c0: 747d 207b 7375 6666 6978 7d2c 207b 6669  t} {suffix}, {fi
-000108d0: 7273 747d 2028 7b6e 6963 6b6e 616d 657d  rst} ({nickname}
-000108e0: 2920 7b6d 6964 646c 657d 270a 2020 2020  ) {middle}'.    
-000108f0: 2020 2020 2020 2020 2020 2020 6175 7468              auth
-00010900: 6f72 5f6e 616d 655f 7374 7269 6e67 203d  or_name_string =
-00010910: 2073 7472 2870 6172 7365 645f 6e61 6d65   str(parsed_name
-00010920: 292e 7265 706c 6163 6528 2220 2c20 222c  ).replace(" , ",
-00010930: 2022 2c20 2229 0a20 2020 2020 2020 2020   ", ").         
-00010940: 2020 2020 2020 2023 204e 6f74 653a 2074         # Note: t
-00010950: 6865 7265 2061 7265 2065 7272 6f72 7320  here are errors 
-00010960: 666f 7220 7468 6520 666f 6c6c 6f77 696e  for the followin
-00010970: 6720 6175 7468 6f72 3a0a 2020 2020 2020  g author:.      
-00010980: 2020 2020 2020 2020 2020 2320 4a52 2043            # JR C
-00010990: 726f 6d77 656c 6c20 616e 6420 484b 2047  romwell and HK G
-000109a0: 6172 646e 6572 0a20 2020 2020 2020 2020  ardner.         
-000109b0: 2020 2020 2020 2023 2054 6865 204a 5220         # The JR 
-000109c0: 6973 2070 726f 6261 626c 7920 7265 636f  is probably reco
-000109d0: 676e 697a 6564 2061 7320 4a75 6e69 6f72  gnized as Junior
-000109e0: 2e0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000109f0: 2020 2320 4368 6563 6b20 7768 6574 6865    # Check whethe
-00010a00: 7220 7468 6973 2069 7320 6669 7865 6420  r this is fixed 
-00010a10: 696e 2074 6865 2047 726f 6269 6420 6e61  in the Grobid na
-00010a20: 6d65 2070 6172 7365 720a 0a20 2020 2020  me parser..     
-00010a30: 2020 2020 2020 2069 6620 6175 7468 6f72         if author
-00010a40: 5f73 7472 696e 6720 3d3d 2022 223a 0a20  _string == "":. 
-00010a50: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-00010a60: 7574 686f 725f 7374 7269 6e67 203d 2061  uthor_string = a
-00010a70: 7574 686f 725f 6e61 6d65 5f73 7472 696e  uthor_name_strin
-00010a80: 670a 2020 2020 2020 2020 2020 2020 656c  g.            el
-00010a90: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00010aa0: 2020 2020 6175 7468 6f72 5f73 7472 696e      author_strin
-00010ab0: 6720 3d20 6175 7468 6f72 5f73 7472 696e  g = author_strin
-00010ac0: 6720 2b20 2220 616e 6420 2220 2b20 6175  g + " and " + au
-00010ad0: 7468 6f72 5f6e 616d 655f 7374 7269 6e67  thor_name_string
-00010ae0: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-00010af0: 2061 7574 686f 725f 7374 7269 6e67 0a0a   author_string..
-00010b00: 2020 2020 4063 6c61 7373 6d65 7468 6f64      @classmethod
-00010b10: 0a20 2020 2064 6566 205f 5f66 6f72 6d61  .    def __forma
-00010b20: 745f 6175 7468 6f72 735f 7374 7269 6e67  t_authors_string
-00010b30: 5f66 6f72 5f63 6f6d 7061 7269 736f 6e28  _for_comparison(
-00010b40: 636c 732c 202a 2c20 7265 636f 7264 3a20  cls, *, record: 
-00010b50: 5265 636f 7264 2920 2d3e 204e 6f6e 653a  Record) -> None:
-00010b60: 0a20 2020 2020 2020 2069 6620 2261 7574  .        if "aut
-00010b70: 686f 7222 206e 6f74 2069 6e20 7265 636f  hor" not in reco
-00010b80: 7264 2e64 6174 613a 0a20 2020 2020 2020  rd.data:.       
-00010b90: 2020 2020 2072 6574 7572 6e0a 2020 2020       return.    
-00010ba0: 2020 2020 6175 7468 6f72 7320 3d20 7265      authors = re
-00010bb0: 636f 7264 2e64 6174 615b 2261 7574 686f  cord.data["autho
-00010bc0: 7222 5d0a 2020 2020 2020 2020 6175 7468  r"].        auth
-00010bd0: 6f72 7320 3d20 7374 7228 6175 7468 6f72  ors = str(author
-00010be0: 7329 2e6c 6f77 6572 2829 0a20 2020 2020  s).lower().     
-00010bf0: 2020 2061 7574 686f 7273 5f73 7472 696e     authors_strin
-00010c00: 6720 3d20 2222 0a20 2020 2020 2020 2061  g = "".        a
-00010c10: 7574 686f 7273 203d 2063 6f6c 7265 762e  uthors = colrev.
-00010c20: 656e 762e 7574 696c 732e 7265 6d6f 7665  env.utils.remove
-00010c30: 5f61 6363 656e 7473 2869 6e70 7574 5f73  _accents(input_s
-00010c40: 7472 3d61 7574 686f 7273 290a 0a20 2020  tr=authors)..   
-00010c50: 2020 2020 2023 2061 6262 7265 7669 6174       # abbreviat
-00010c60: 6520 6669 7273 7420 6e61 6d65 730a 2020  e first names.  
-00010c70: 2020 2020 2020 2320 2257 6562 7374 6572        # "Webster
-00010c80: 2c20 4a61 6e65 2220 2d3e 2022 5765 6273  , Jane" -> "Webs
-00010c90: 7465 722c 204a 220a 2020 2020 2020 2020  ter, J".        
-00010ca0: 2320 616c 736f 2072 656d 6f76 6520 616c  # also remove al
-00010cb0: 6c20 7370 6563 6961 6c20 6368 6172 6163  l special charac
-00010cc0: 7465 7273 2061 6e64 2064 6f20 6e6f 7420  ters and do not 
-00010cd0: 696e 636c 7564 6520 7365 7061 7261 746f  include separato
-00010ce0: 7273 2028 616e 6429 0a20 2020 2020 2020  rs (and).       
-00010cf0: 2066 6f72 2061 7574 686f 7220 696e 2061   for author in a
-00010d00: 7574 686f 7273 2e73 706c 6974 2822 2061  uthors.split(" a
-00010d10: 6e64 2022 293a 0a20 2020 2020 2020 2020  nd "):.         
-00010d20: 2020 2069 6620 222c 2220 696e 2061 7574     if "," in aut
-00010d30: 686f 723a 0a20 2020 2020 2020 2020 2020  hor:.           
-00010d40: 2020 2020 206c 6173 745f 6e61 6d65 7320       last_names 
-00010d50: 3d20 5b0a 2020 2020 2020 2020 2020 2020  = [.            
-00010d60: 2020 2020 2020 2020 776f 7264 5b30 5d20          word[0] 
-00010d70: 666f 7220 776f 7264 2069 6e20 6175 7468  for word in auth
-00010d80: 6f72 2e73 706c 6974 2822 2c22 295b 315d  or.split(",")[1]
-00010d90: 2e73 706c 6974 2822 2022 2920 6966 206c  .split(" ") if l
-00010da0: 656e 2877 6f72 6429 203e 2030 0a20 2020  en(word) > 0.   
-00010db0: 2020 2020 2020 2020 2020 2020 205d 0a20               ]. 
-00010dc0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-00010dd0: 7574 686f 7273 5f73 7472 696e 6720 3d20  uthors_string = 
-00010de0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00010df0: 2020 2020 2020 6175 7468 6f72 735f 7374        authors_st
-00010e00: 7269 6e67 0a20 2020 2020 2020 2020 2020  ring.           
-00010e10: 2020 2020 2020 2020 202b 2061 7574 686f           + autho
-00010e20: 722e 7370 6c69 7428 222c 2229 5b30 5d0a  r.split(",")[0].
-00010e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010e40: 2020 2020 2b20 2220 220a 2020 2020 2020      + " ".      
-00010e50: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-00010e60: 2220 222e 6a6f 696e 286c 6173 745f 6e61  " ".join(last_na
-00010e70: 6d65 7329 0a20 2020 2020 2020 2020 2020  mes).           
-00010e80: 2020 2020 2020 2020 202b 2022 2022 0a20           + " ". 
-00010e90: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00010ea0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-00010eb0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00010ec0: 2020 2061 7574 686f 7273 5f73 7472 696e     authors_strin
-00010ed0: 6720 3d20 6175 7468 6f72 735f 7374 7269  g = authors_stri
-00010ee0: 6e67 202b 2061 7574 686f 7220 2b20 2220  ng + author + " 
-00010ef0: 220a 2020 2020 2020 2020 6175 7468 6f72  ".        author
-00010f00: 735f 7374 7269 6e67 203d 2072 652e 7375  s_string = re.su
-00010f10: 6228 7222 5b5e 412d 5a61 2d7a 302d 392c  b(r"[^A-Za-z0-9,
-00010f20: 205d 2b22 2c20 2222 2c20 6175 7468 6f72   ]+", "", author
-00010f30: 735f 7374 7269 6e67 2e72 7374 7269 7028  s_string.rstrip(
-00010f40: 2929 0a20 2020 2020 2020 2072 6563 6f72  )).        recor
-00010f50: 642e 6461 7461 5b22 6175 7468 6f72 225d  d.data["author"]
-00010f60: 203d 2061 7574 686f 7273 5f73 7472 696e   = authors_strin
-00010f70: 670a 0a20 2020 2064 6566 2063 6f6e 7461  g..    def conta
-00010f80: 696e 6572 5f69 735f 6162 6272 6576 6961  iner_is_abbrevia
-00010f90: 7465 6428 7365 6c66 2920 2d3e 2062 6f6f  ted(self) -> boo
-00010fa0: 6c3a 0a20 2020 2020 2020 2022 2222 4368  l:.        """Ch
-00010fb0: 6563 6b20 7768 6574 6865 7220 7468 6520  eck whether the 
-00010fc0: 636f 6e74 6169 6e65 7220 7469 746c 6520  container title 
-00010fd0: 6973 2061 6262 7265 7669 6174 6564 2222  is abbreviated""
-00010fe0: 220a 2020 2020 2020 2020 6966 2022 6a6f  ".        if "jo
-00010ff0: 7572 6e61 6c22 2069 6e20 7365 6c66 2e64  urnal" in self.d
-00011000: 6174 613a 0a20 2020 2020 2020 2020 2020  ata:.           
-00011010: 2069 6620 7365 6c66 2e64 6174 615b 226a   if self.data["j
-00011020: 6f75 726e 616c 225d 2e63 6f75 6e74 2822  ournal"].count("
-00011030: 2e22 2920 3e20 323a 0a20 2020 2020 2020  .") > 2:.       
-00011040: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00011050: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
-00011060: 2069 6620 7365 6c66 2e64 6174 615b 226a   if self.data["j
-00011070: 6f75 726e 616c 225d 2e69 7375 7070 6572  ournal"].isupper
-00011080: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
-00011090: 2020 2020 7265 7475 726e 2054 7275 650a      return True.
-000110a0: 2020 2020 2020 2020 6966 2022 626f 6f6b          if "book
-000110b0: 7469 746c 6522 2069 6e20 7365 6c66 2e64  title" in self.d
-000110c0: 6174 613a 0a20 2020 2020 2020 2020 2020  ata:.           
-000110d0: 2069 6620 7365 6c66 2e64 6174 615b 2262   if self.data["b
-000110e0: 6f6f 6b74 6974 6c65 225d 2e63 6f75 6e74  ooktitle"].count
-000110f0: 2822 2e22 2920 3e20 323a 0a20 2020 2020  (".") > 2:.     
-00011100: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00011110: 6e20 5472 7565 0a20 2020 2020 2020 2020  n True.         
-00011120: 2020 2069 6620 7365 6c66 2e64 6174 615b     if self.data[
-00011130: 2262 6f6f 6b74 6974 6c65 225d 2e69 7375  "booktitle"].isu
-00011140: 7070 6572 2829 3a0a 2020 2020 2020 2020  pper():.        
-00011150: 2020 2020 2020 2020 7265 7475 726e 2054          return T
-00011160: 7275 650a 2020 2020 2020 2020 2320 6164  rue.        # ad
-00011170: 6420 6865 7572 6973 7469 6373 3f20 2865  d heuristics? (e
-00011180: 2e67 2e2c 2048 6177 6169 6920 496e 7420  .g., Hawaii Int 
-00011190: 436f 6e66 2053 7973 7420 5363 6929 0a20  Conf Syst Sci). 
-000111a0: 2020 2020 2020 2072 6574 7572 6e20 4661         return Fa
-000111b0: 6c73 650a 0a20 2020 2040 636c 6173 736d  lse..    @classm
-000111c0: 6574 686f 640a 2020 2020 6465 6620 5f5f  ethod.    def __
-000111d0: 6162 6272 6576 6961 7465 5f63 6f6e 7461  abbreviate_conta
-000111e0: 696e 6572 5f74 6974 6c65 7328 0a20 2020  iner_titles(.   
-000111f0: 2020 2020 2063 6c73 2c0a 2020 2020 2020       cls,.      
-00011200: 2020 2a2c 0a20 2020 2020 2020 2072 6563    *,.        rec
-00011210: 6f72 643a 2063 6f6c 7265 762e 7265 636f  ord: colrev.reco
-00011220: 7264 2e50 7265 7052 6563 6f72 642c 0a20  rd.PrepRecord,. 
-00011230: 2020 2020 2020 2072 6574 7269 6576 6564         retrieved
-00011240: 5f72 6563 6f72 643a 2063 6f6c 7265 762e  _record: colrev.
-00011250: 7265 636f 7264 2e50 7265 7052 6563 6f72  record.PrepRecor
-00011260: 642c 0a20 2020 2029 202d 3e20 4e6f 6e65  d,.    ) -> None
-00011270: 3a0a 2020 2020 2020 2020 6465 6620 6162  :.        def ab
-00011280: 6272 6576 6961 7465 5f63 6f6e 7461 696e  breviate_contain
-00011290: 6572 282a 2c20 7265 636f 7264 3a20 636f  er(*, record: co
-000112a0: 6c72 6576 2e72 6563 6f72 642e 5265 636f  lrev.record.Reco
-000112b0: 7264 2c20 6d69 6e5f 6c65 6e3a 2069 6e74  rd, min_len: int
-000112c0: 2920 2d3e 204e 6f6e 653a 0a20 2020 2020  ) -> None:.     
-000112d0: 2020 2020 2020 2069 6620 226a 6f75 726e         if "journ
-000112e0: 616c 2220 696e 2072 6563 6f72 642e 6461  al" in record.da
-000112f0: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
-00011300: 2020 2020 7265 636f 7264 2e64 6174 615b      record.data[
-00011310: 226a 6f75 726e 616c 225d 203d 2022 2022  "journal"] = " "
-00011320: 2e6a 6f69 6e28 0a20 2020 2020 2020 2020  .join(.         
-00011330: 2020 2020 2020 2020 2020 205b 785b 3a6d             [x[:m
-00011340: 696e 5f6c 656e 5d20 666f 7220 7820 696e  in_len] for x in
-00011350: 2072 6563 6f72 642e 6461 7461 5b22 6a6f   record.data["jo
-00011360: 7572 6e61 6c22 5d2e 7370 6c69 7428 2220  urnal"].split(" 
-00011370: 2229 5d0a 2020 2020 2020 2020 2020 2020  ")].            
-00011380: 2020 2020 290a 0a20 2020 2020 2020 2064      )..        d
-00011390: 6566 2067 6574 5f61 6262 7265 765f 636f  ef get_abbrev_co
-000113a0: 6e74 6169 6e65 725f 6d69 6e5f 6c65 6e28  ntainer_min_len(
-000113b0: 2a2c 2072 6563 6f72 643a 2063 6f6c 7265  *, record: colre
-000113c0: 762e 7265 636f 7264 2e52 6563 6f72 6429  v.record.Record)
-000113d0: 202d 3e20 696e 743a 0a20 2020 2020 2020   -> int:.       
-000113e0: 2020 2020 206d 696e 5f6c 656e 203d 202d       min_len = -
-000113f0: 310a 2020 2020 2020 2020 2020 2020 6966  1.            if
-00011400: 2022 6a6f 7572 6e61 6c22 2069 6e20 7265   "journal" in re
-00011410: 636f 7264 2e64 6174 613a 0a20 2020 2020  cord.data:.     
-00011420: 2020 2020 2020 2020 2020 206d 696e 5f6c             min_l
-00011430: 656e 203d 206d 696e 280a 2020 2020 2020  en = min(.      
-00011440: 2020 2020 2020 2020 2020 2020 2020 6c65                le
-00011450: 6e28 7829 2066 6f72 2078 2069 6e20 7265  n(x) for x in re
-00011460: 636f 7264 2e64 6174 615b 226a 6f75 726e  cord.data["journ
-00011470: 616c 225d 2e72 6570 6c61 6365 2822 2e22  al"].replace("."
-00011480: 2c20 2222 292e 7370 6c69 7428 2220 2229  , "").split(" ")
-00011490: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000114a0: 2029 0a20 2020 2020 2020 2020 2020 2069   ).            i
-000114b0: 6620 2262 6f6f 6b74 6974 6c65 2220 696e  f "booktitle" in
-000114c0: 2072 6563 6f72 642e 6461 7461 3a0a 2020   record.data:.  
-000114d0: 2020 2020 2020 2020 2020 2020 2020 6d69                mi
-000114e0: 6e5f 6c65 6e20 3d20 6d69 6e28 0a20 2020  n_len = min(.   
-000114f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011500: 206c 656e 2878 2920 666f 7220 7820 696e   len(x) for x in
-00011510: 2072 6563 6f72 642e 6461 7461 5b22 626f   record.data["bo
-00011520: 6f6b 7469 746c 6522 5d2e 7265 706c 6163  oktitle"].replac
-00011530: 6528 222e 222c 2022 2229 2e73 706c 6974  e(".", "").split
-00011540: 2822 2022 290a 2020 2020 2020 2020 2020  (" ").          
-00011550: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-00011560: 2020 2020 7265 7475 726e 206d 696e 5f6c      return min_l
-00011570: 656e 0a0a 2020 2020 2020 2020 6966 2072  en..        if r
-00011580: 6563 6f72 642e 636f 6e74 6169 6e65 725f  ecord.container_
-00011590: 6973 5f61 6262 7265 7669 6174 6564 2829  is_abbreviated()
-000115a0: 3a0a 2020 2020 2020 2020 2020 2020 6d69  :.            mi
-000115b0: 6e5f 6c65 6e20 3d20 6765 745f 6162 6272  n_len = get_abbr
-000115c0: 6576 5f63 6f6e 7461 696e 6572 5f6d 696e  ev_container_min
-000115d0: 5f6c 656e 2872 6563 6f72 643d 7265 636f  _len(record=reco
-000115e0: 7264 290a 2020 2020 2020 2020 2020 2020  rd).            
-000115f0: 6162 6272 6576 6961 7465 5f63 6f6e 7461  abbreviate_conta
-00011600: 696e 6572 2872 6563 6f72 643d 7265 7472  iner(record=retr
-00011610: 6965 7665 645f 7265 636f 7264 2c20 6d69  ieved_record, mi
-00011620: 6e5f 6c65 6e3d 6d69 6e5f 6c65 6e29 0a20  n_len=min_len). 
-00011630: 2020 2020 2020 2020 2020 2061 6262 7265             abbre
-00011640: 7669 6174 655f 636f 6e74 6169 6e65 7228  viate_container(
-00011650: 7265 636f 7264 3d72 6563 6f72 642c 206d  record=record, m
-00011660: 696e 5f6c 656e 3d6d 696e 5f6c 656e 290a  in_len=min_len).
-00011670: 2020 2020 2020 2020 6966 2072 6574 7269          if retri
-00011680: 6576 6564 5f72 6563 6f72 642e 636f 6e74  eved_record.cont
-00011690: 6169 6e65 725f 6973 5f61 6262 7265 7669  ainer_is_abbrevi
-000116a0: 6174 6564 2829 3a0a 2020 2020 2020 2020  ated():.        
-000116b0: 2020 2020 6d69 6e5f 6c65 6e20 3d20 6765      min_len = ge
-000116c0: 745f 6162 6272 6576 5f63 6f6e 7461 696e  t_abbrev_contain
-000116d0: 6572 5f6d 696e 5f6c 656e 2872 6563 6f72  er_min_len(recor
-000116e0: 643d 7265 7472 6965 7665 645f 7265 636f  d=retrieved_reco
-000116f0: 7264 290a 2020 2020 2020 2020 2020 2020  rd).            
-00011700: 6162 6272 6576 6961 7465 5f63 6f6e 7461  abbreviate_conta
-00011710: 696e 6572 2872 6563 6f72 643d 7265 636f  iner(record=reco
-00011720: 7264 2c20 6d69 6e5f 6c65 6e3d 6d69 6e5f  rd, min_len=min_
-00011730: 6c65 6e29 0a20 2020 2020 2020 2020 2020  len).           
-00011740: 2061 6262 7265 7669 6174 655f 636f 6e74   abbreviate_cont
-00011750: 6169 6e65 7228 7265 636f 7264 3d72 6574  ainer(record=ret
-00011760: 7269 6576 6564 5f72 6563 6f72 642c 206d  rieved_record, m
-00011770: 696e 5f6c 656e 3d6d 696e 5f6c 656e 290a  in_len=min_len).
-00011780: 0a20 2020 2040 636c 6173 736d 6574 686f  .    @classmetho
-00011790: 640a 2020 2020 6465 6620 5f5f 7072 6570  d.    def __prep
-000117a0: 5f72 6563 6f72 6473 5f66 6f72 5f73 696d  _records_for_sim
-000117b0: 696c 6172 6974 7928 0a20 2020 2020 2020  ilarity(.       
-000117c0: 2063 6c73 2c0a 2020 2020 2020 2020 2a2c   cls,.        *,
-000117d0: 0a20 2020 2020 2020 2072 6563 6f72 643a  .        record:
-000117e0: 2063 6f6c 7265 762e 7265 636f 7264 2e50   colrev.record.P
-000117f0: 7265 7052 6563 6f72 642c 0a20 2020 2020  repRecord,.     
-00011800: 2020 2072 6574 7269 6576 6564 5f72 6563     retrieved_rec
-00011810: 6f72 643a 2063 6f6c 7265 762e 7265 636f  ord: colrev.reco
-00011820: 7264 2e50 7265 7052 6563 6f72 642c 0a20  rd.PrepRecord,. 
-00011830: 2020 2029 202d 3e20 4e6f 6e65 3a0a 2020     ) -> None:.  
-00011840: 2020 2020 2020 636c 732e 5f5f 6162 6272        cls.__abbr
-00011850: 6576 6961 7465 5f63 6f6e 7461 696e 6572  eviate_container
-00011860: 5f74 6974 6c65 7328 0a20 2020 2020 2020  _titles(.       
-00011870: 2020 2020 2072 6563 6f72 643d 7265 636f       record=reco
-00011880: 7264 2c20 7265 7472 6965 7665 645f 7265  rd, retrieved_re
-00011890: 636f 7264 3d72 6574 7269 6576 6564 5f72  cord=retrieved_r
-000118a0: 6563 6f72 640a 2020 2020 2020 2020 290a  ecord.        ).
-000118b0: 0a20 2020 2020 2020 2069 6620 2274 6974  .        if "tit
-000118c0: 6c65 2220 696e 2072 6563 6f72 642e 6461  le" in record.da
-000118d0: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
-000118e0: 7265 636f 7264 2e64 6174 615b 2274 6974  record.data["tit
-000118f0: 6c65 225d 203d 2072 6563 6f72 642e 6461  le"] = record.da
-00011900: 7461 5b22 7469 746c 6522 5d5b 3a39 305d  ta["title"][:90]
-00011910: 0a20 2020 2020 2020 2069 6620 2274 6974  .        if "tit
-00011920: 6c65 2220 696e 2072 6574 7269 6576 6564  le" in retrieved
-00011930: 5f72 6563 6f72 642e 6461 7461 3a0a 2020  _record.data:.  
-00011940: 2020 2020 2020 2020 2020 7265 7472 6965            retrie
-00011950: 7665 645f 7265 636f 7264 2e64 6174 615b  ved_record.data[
-00011960: 2274 6974 6c65 225d 203d 2072 6574 7269  "title"] = retri
-00011970: 6576 6564 5f72 6563 6f72 642e 6461 7461  eved_record.data
-00011980: 5b22 7469 746c 6522 5d5b 3a39 305d 0a0a  ["title"][:90]..
-00011990: 2020 2020 2020 2020 6966 2022 6175 7468          if "auth
-000119a0: 6f72 2220 696e 2072 6563 6f72 642e 6461  or" in record.da
-000119b0: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
-000119c0: 636c 732e 5f5f 666f 726d 6174 5f61 7574  cls.__format_aut
-000119d0: 686f 7273 5f73 7472 696e 675f 666f 725f  hors_string_for_
-000119e0: 636f 6d70 6172 6973 6f6e 2872 6563 6f72  comparison(recor
-000119f0: 643d 7265 636f 7264 290a 2020 2020 2020  d=record).      
-00011a00: 2020 2020 2020 7265 636f 7264 2e64 6174        record.dat
-00011a10: 615b 2261 7574 686f 7222 5d20 3d20 7265  a["author"] = re
-00011a20: 636f 7264 2e64 6174 615b 2261 7574 686f  cord.data["autho
-00011a30: 7222 5d5b 3a34 355d 0a20 2020 2020 2020  r"][:45].       
-00011a40: 2069 6620 2261 7574 686f 7222 2069 6e20   if "author" in 
-00011a50: 7265 7472 6965 7665 645f 7265 636f 7264  retrieved_record
-00011a60: 2e64 6174 613a 0a20 2020 2020 2020 2020  .data:.         
-00011a70: 2020 2063 6c73 2e5f 5f66 6f72 6d61 745f     cls.__format_
-00011a80: 6175 7468 6f72 735f 7374 7269 6e67 5f66  authors_string_f
-00011a90: 6f72 5f63 6f6d 7061 7269 736f 6e28 7265  or_comparison(re
-00011aa0: 636f 7264 3d72 6574 7269 6576 6564 5f72  cord=retrieved_r
-00011ab0: 6563 6f72 6429 0a20 2020 2020 2020 2020  ecord).         
-00011ac0: 2020 2072 6574 7269 6576 6564 5f72 6563     retrieved_rec
-00011ad0: 6f72 642e 6461 7461 5b22 6175 7468 6f72  ord.data["author
-00011ae0: 225d 203d 2072 6574 7269 6576 6564 5f72  "] = retrieved_r
-00011af0: 6563 6f72 642e 6461 7461 5b22 6175 7468  ecord.data["auth
-00011b00: 6f72 225d 5b3a 3435 5d0a 2020 2020 2020  or"][:45].      
-00011b10: 2020 6966 206e 6f74 2028 2276 6f6c 756d    if not ("volum
-00011b20: 6522 2069 6e20 7265 636f 7264 2e64 6174  e" in record.dat
-00011b30: 6120 616e 6420 2276 6f6c 756d 6522 2069  a and "volume" i
-00011b40: 6e20 7265 7472 6965 7665 645f 7265 636f  n retrieved_reco
-00011b50: 7264 2e64 6174 6129 3a0a 2020 2020 2020  rd.data):.      
-00011b60: 2020 2020 2020 7265 636f 7264 2e64 6174        record.dat
-00011b70: 615b 2276 6f6c 756d 6522 5d20 3d20 226e  a["volume"] = "n
-00011b80: 616e 220a 2020 2020 2020 2020 2020 2020  an".            
-00011b90: 7265 7472 6965 7665 645f 7265 636f 7264  retrieved_record
-00011ba0: 2e64 6174 615b 2276 6f6c 756d 6522 5d20  .data["volume"] 
-00011bb0: 3d20 226e 616e 220a 2020 2020 2020 2020  = "nan".        
-00011bc0: 6966 206e 6f74 2028 226e 756d 6265 7222  if not ("number"
-00011bd0: 2069 6e20 7265 636f 7264 2e64 6174 6120   in record.data 
-00011be0: 616e 6420 226e 756d 6265 7222 2069 6e20  and "number" in 
-00011bf0: 7265 7472 6965 7665 645f 7265 636f 7264  retrieved_record
-00011c00: 2e64 6174 6129 3a0a 2020 2020 2020 2020  .data):.        
-00011c10: 2020 2020 7265 636f 7264 2e64 6174 615b      record.data[
-00011c20: 226e 756d 6265 7222 5d20 3d20 226e 616e  "number"] = "nan
-00011c30: 220a 2020 2020 2020 2020 2020 2020 7265  ".            re
-00011c40: 7472 6965 7665 645f 7265 636f 7264 2e64  trieved_record.d
-00011c50: 6174 615b 226e 756d 6265 7222 5d20 3d20  ata["number"] = 
-00011c60: 226e 616e 220a 2020 2020 2020 2020 6966  "nan".        if
-00011c70: 206e 6f74 2028 2270 6167 6573 2220 696e   not ("pages" in
-00011c80: 2072 6563 6f72 642e 6461 7461 2061 6e64   record.data and
-00011c90: 2022 7061 6765 7322 2069 6e20 7265 7472   "pages" in retr
-00011ca0: 6965 7665 645f 7265 636f 7264 2e64 6174  ieved_record.dat
-00011cb0: 6129 3a0a 2020 2020 2020 2020 2020 2020  a):.            
-00011cc0: 7265 636f 7264 2e64 6174 615b 2270 6167  record.data["pag
-00011cd0: 6573 225d 203d 2022 6e61 6e22 0a20 2020  es"] = "nan".   
-00011ce0: 2020 2020 2020 2020 2072 6574 7269 6576           retriev
-00011cf0: 6564 5f72 6563 6f72 642e 6461 7461 5b22  ed_record.data["
-00011d00: 7061 6765 7322 5d20 3d20 226e 616e 220a  pages"] = "nan".
-00011d10: 2020 2020 2020 2020 2320 536f 6d65 7469          # Someti
-00011d20: 6d65 732c 2074 6865 206e 756d 6265 7220  mes, the number 
-00011d30: 6f66 2070 6167 6573 2069 7320 7072 6f76  of pages is prov
-00011d40: 6964 6564 2028 6e6f 7420 7468 6520 7261  ided (not the ra
-00011d50: 6e67 6529 0a20 2020 2020 2020 2065 6c69  nge).        eli
-00011d60: 6620 6e6f 7420 280a 2020 2020 2020 2020  f not (.        
-00011d70: 2020 2020 222d 2d22 2069 6e20 7265 636f      "--" in reco
-00011d80: 7264 2e64 6174 615b 2270 6167 6573 225d  rd.data["pages"]
-00011d90: 2061 6e64 2022 2d2d 2220 696e 2072 6574   and "--" in ret
-00011da0: 7269 6576 6564 5f72 6563 6f72 642e 6461  rieved_record.da
-00011db0: 7461 5b22 7061 6765 7322 5d0a 2020 2020  ta["pages"].    
-00011dc0: 2020 2020 293a 0a20 2020 2020 2020 2020      ):.         
-00011dd0: 2020 2072 6563 6f72 642e 6461 7461 5b22     record.data["
-00011de0: 7061 6765 7322 5d20 3d20 226e 616e 220a  pages"] = "nan".
-00011df0: 2020 2020 2020 2020 2020 2020 7265 7472              retr
-00011e00: 6965 7665 645f 7265 636f 7264 2e64 6174  ieved_record.dat
-00011e10: 615b 2270 6167 6573 225d 203d 2022 6e61  a["pages"] = "na
-00011e20: 6e22 0a0a 2020 2020 2020 2020 6966 2022  n"..        if "
-00011e30: 7965 6172 2220 696e 2072 6563 6f72 642e  year" in record.
-00011e40: 6461 7461 2061 6e64 2022 7965 6172 2220  data and "year" 
-00011e50: 696e 2072 6574 7269 6576 6564 5f72 6563  in retrieved_rec
-00011e60: 6f72 642e 6461 7461 3a0a 2020 2020 2020  ord.data:.      
-00011e70: 2020 2020 2020 6966 2072 6563 6f72 642e        if record.
-00011e80: 6461 7461 5b22 7965 6172 225d 203d 3d20  data["year"] == 
-00011e90: 2266 6f72 7468 636f 6d69 6e67 223a 0a20  "forthcoming":. 
-00011ea0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00011eb0: 6563 6f72 642e 6461 7461 5b22 7965 6172  ecord.data["year
-00011ec0: 225d 203d 2072 6574 7269 6576 6564 5f72  "] = retrieved_r
-00011ed0: 6563 6f72 642e 6461 7461 5b22 7965 6172  ecord.data["year
-00011ee0: 225d 0a20 2020 2020 2020 2020 2020 2069  "].            i
-00011ef0: 6620 7265 7472 6965 7665 645f 7265 636f  f retrieved_reco
-00011f00: 7264 2e64 6174 615b 2279 6561 7222 5d20  rd.data["year"] 
-00011f10: 3d3d 2022 666f 7274 6863 6f6d 696e 6722  == "forthcoming"
-00011f20: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00011f30: 2020 7265 7472 6965 7665 645f 7265 636f    retrieved_reco
-00011f40: 7264 2e64 6174 615b 2279 6561 7222 5d20  rd.data["year"] 
-00011f50: 3d20 7265 636f 7264 2e64 6174 615b 2279  = record.data["y
-00011f60: 6561 7222 5d0a 0a20 2020 2040 636c 6173  ear"]..    @clas
-00011f70: 736d 6574 686f 640a 2020 2020 6465 6620  smethod.    def 
-00011f80: 6765 745f 7265 7472 6965 7661 6c5f 7369  get_retrieval_si
-00011f90: 6d69 6c61 7269 7479 280a 2020 2020 2020  milarity(.      
-00011fa0: 2020 636c 732c 0a20 2020 2020 2020 202a    cls,.        *
-00011fb0: 2c0a 2020 2020 2020 2020 7265 636f 7264  ,.        record
-00011fc0: 5f6f 7269 6769 6e61 6c3a 2052 6563 6f72  _original: Recor
-00011fd0: 642c 0a20 2020 2020 2020 2072 6574 7269  d,.        retri
-00011fe0: 6576 6564 5f72 6563 6f72 645f 6f72 6967  eved_record_orig
-00011ff0: 696e 616c 3a20 5265 636f 7264 2c0a 2020  inal: Record,.  
-00012000: 2020 2020 2020 7361 6d65 5f72 6563 6f72        same_recor
-00012010: 645f 7479 7065 5f72 6571 7569 7265 643a  d_type_required:
-00012020: 2062 6f6f 6c20 3d20 5472 7565 2c0a 2020   bool = True,.  
-00012030: 2020 2920 2d3e 2066 6c6f 6174 3a0a 2020    ) -> float:.  
-00012040: 2020 2020 2020 2222 2247 6574 2074 6865        """Get the
-00012050: 2072 6574 7269 6576 616c 2073 696d 696c   retrieval simil
-00012060: 6172 6974 7920 6265 7477 6565 6e20 7468  arity between th
-00012070: 6520 7265 636f 7264 2061 6e64 2061 2072  e record and a r
-00012080: 6574 7269 6576 6564 2072 6563 6f72 6422  etrieved record"
-00012090: 2222 0a0a 2020 2020 2020 2020 6966 2073  ""..        if s
-000120a0: 616d 655f 7265 636f 7264 5f74 7970 655f  ame_record_type_
-000120b0: 7265 7175 6972 6564 3a0a 2020 2020 2020  required:.      
-000120c0: 2020 2020 2020 6966 2072 6563 6f72 645f        if record_
-000120d0: 6f72 6967 696e 616c 2e64 6174 612e 6765  original.data.ge
-000120e0: 7428 0a20 2020 2020 2020 2020 2020 2020  t(.             
-000120f0: 2020 2022 454e 5452 5954 5950 4522 2c20     "ENTRYTYPE", 
-00012100: 2261 220a 2020 2020 2020 2020 2020 2020  "a".            
-00012110: 2920 213d 2072 6574 7269 6576 6564 5f72  ) != retrieved_r
-00012120: 6563 6f72 645f 6f72 6967 696e 616c 2e64  ecord_original.d
-00012130: 6174 612e 6765 7428 2245 4e54 5259 5459  ata.get("ENTRYTY
-00012140: 5045 222c 2022 6222 293a 0a20 2020 2020  PE", "b"):.     
-00012150: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00012160: 6e20 302e 300a 0a20 2020 2020 2020 2072  n 0.0..        r
-00012170: 6563 6f72 6420 3d20 7265 636f 7264 5f6f  ecord = record_o
-00012180: 7269 6769 6e61 6c2e 636f 7079 5f70 7265  riginal.copy_pre
-00012190: 705f 7265 6328 290a 2020 2020 2020 2020  p_rec().        
-000121a0: 7265 7472 6965 7665 645f 7265 636f 7264  retrieved_record
-000121b0: 203d 2072 6574 7269 6576 6564 5f72 6563   = retrieved_rec
-000121c0: 6f72 645f 6f72 6967 696e 616c 2e63 6f70  ord_original.cop
-000121d0: 795f 7072 6570 5f72 6563 2829 0a0a 2020  y_prep_rec()..  
-000121e0: 2020 2020 2020 636c 732e 5f5f 7072 6570        cls.__prep
-000121f0: 5f72 6563 6f72 6473 5f66 6f72 5f73 696d  _records_for_sim
-00012200: 696c 6172 6974 7928 0a20 2020 2020 2020  ilarity(.       
-00012210: 2020 2020 2072 6563 6f72 643d 7265 636f       record=reco
-00012220: 7264 2c20 7265 7472 6965 7665 645f 7265  rd, retrieved_re
-00012230: 636f 7264 3d72 6574 7269 6576 6564 5f72  cord=retrieved_r
-00012240: 6563 6f72 640a 2020 2020 2020 2020 290a  ecord.        ).
-00012250: 0a20 2020 2020 2020 2069 6620 2265 6469  .        if "edi
-00012260: 746f 7269 616c 2220 696e 2072 6563 6f72  torial" in recor
-00012270: 642e 6461 7461 2e67 6574 2822 7469 746c  d.data.get("titl
-00012280: 6522 2c20 224e 4122 292e 6c6f 7765 7228  e", "NA").lower(
-00012290: 293a 0a20 2020 2020 2020 2020 2020 2069  ):.            i
-000122a0: 6620 6e6f 7420 616c 6c28 7820 696e 2072  f not all(x in r
-000122b0: 6563 6f72 642e 6461 7461 2066 6f72 2078  ecord.data for x
-000122c0: 2069 6e20 5b22 766f 6c75 6d65 222c 2022   in ["volume", "
-000122d0: 6e75 6d62 6572 225d 293a 0a20 2020 2020  number"]):.     
-000122e0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-000122f0: 6e20 302e 300a 0a20 2020 2020 2020 2073  n 0.0..        s
-00012300: 696d 696c 6172 6974 7920 3d20 5265 636f  imilarity = Reco
-00012310: 7264 2e67 6574 5f72 6563 6f72 645f 7369  rd.get_record_si
-00012320: 6d69 6c61 7269 7479 280a 2020 2020 2020  milarity(.      
-00012330: 2020 2020 2020 7265 636f 7264 5f61 3d72        record_a=r
-00012340: 6563 6f72 642c 2072 6563 6f72 645f 623d  ecord, record_b=
-00012350: 7265 7472 6965 7665 645f 7265 636f 7264  retrieved_record
-00012360: 0a20 2020 2020 2020 2029 0a20 2020 2020  .        ).     
-00012370: 2020 2072 6574 7572 6e20 7369 6d69 6c61     return simila
-00012380: 7269 7479 0a0a 2020 2020 6465 6620 666f  rity..    def fo
-00012390: 726d 6174 5f69 665f 6d6f 7374 6c79 5f75  rmat_if_mostly_u
-000123a0: 7070 6572 2873 656c 662c 202a 2c20 6b65  pper(self, *, ke
-000123b0: 793a 2073 7472 2c20 6361 7365 3a20 7374  y: str, case: st
-000123c0: 7220 3d20 2273 656e 7465 6e63 6522 2920  r = "sentence") 
-000123d0: 2d3e 204e 6f6e 653a 0a20 2020 2020 2020  -> None:.       
-000123e0: 2022 2222 466f 726d 6174 2074 6865 2066   """Format the f
-000123f0: 6965 6c64 2069 6620 6974 2069 7320 6d6f  ield if it is mo
-00012400: 7374 6c79 2069 6e20 7570 7065 7220 6361  stly in upper ca
-00012410: 7365 2222 220a 0a20 2020 2020 2020 2069  se"""..        i
-00012420: 6620 6b65 7920 6e6f 7420 696e 2073 656c  f key not in sel
-00012430: 662e 6461 7461 206f 7220 7365 6c66 2e64  f.data or self.d
-00012440: 6174 615b 6b65 795d 203d 3d20 2255 4e4b  ata[key] == "UNK
-00012450: 4e4f 574e 223a 0a20 2020 2020 2020 2020  NOWN":.         
-00012460: 2020 2072 6574 7572 6e0a 0a20 2020 2020     return..     
-00012470: 2020 2069 6620 636f 6c72 6576 2e65 6e76     if colrev.env
-00012480: 2e75 7469 6c73 2e70 6572 6365 6e74 5f75  .utils.percent_u
-00012490: 7070 6572 5f63 6861 7273 2873 656c 662e  pper_chars(self.
-000124a0: 6461 7461 5b6b 6579 5d29 203c 2030 2e36  data[key]) < 0.6
-000124b0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-000124c0: 7475 726e 0a0a 2020 2020 2020 2020 2320  turn..        # 
-000124d0: 4e6f 7465 3a20 7468 6520 7472 7565 6361  Note: the trueca
-000124e0: 7365 2070 6163 6b61 6765 2069 7320 6e6f  se package is no
-000124f0: 7420 7665 7279 2072 656c 6961 626c 6520  t very reliable 
-00012500: 2879 6574 290a 0a20 2020 2020 2020 2073  (yet)..        s
-00012510: 656c 662e 6461 7461 5b6b 6579 5d20 3d20  elf.data[key] = 
-00012520: 7365 6c66 2e64 6174 615b 6b65 795d 2e72  self.data[key].r
-00012530: 6570 6c61 6365 2822 5c6e 222c 2022 2022  eplace("\n", " "
-00012540: 290a 0a20 2020 2020 2020 2069 6620 6361  )..        if ca
-00012550: 7365 203d 3d20 2273 656e 7465 6e63 6522  se == "sentence"
-00012560: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
-00012570: 6c66 2e64 6174 615b 6b65 795d 203d 2073  lf.data[key] = s
-00012580: 656c 662e 6461 7461 5b6b 6579 5d2e 6361  elf.data[key].ca
-00012590: 7069 7461 6c69 7a65 2829 0a20 2020 2020  pitalize().     
-000125a0: 2020 2065 6c69 6620 6361 7365 203d 3d20     elif case == 
-000125b0: 2274 6974 6c65 223a 0a20 2020 2020 2020  "title":.       
-000125c0: 2020 2020 2073 656c 662e 6461 7461 5b6b       self.data[k
-000125d0: 6579 5d20 3d20 7365 6c66 2e64 6174 615b  ey] = self.data[
-000125e0: 6b65 795d 2e74 6974 6c65 2829 0a20 2020  key].title().   
-000125f0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00012600: 2020 2020 2020 2072 6169 7365 2063 6f6c         raise col
-00012610: 7265 765f 6578 6365 7074 696f 6e73 2e50  rev_exceptions.P
-00012620: 6172 616d 6574 6572 4572 726f 7228 0a20  arameterError(. 
-00012630: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00012640: 6172 616d 6574 6572 3d22 6361 7365 222c  arameter="case",
-00012650: 2076 616c 7565 3d63 6173 652c 206f 7074   value=case, opt
-00012660: 696f 6e73 3d5b 2273 656e 7465 6e63 6522  ions=["sentence"
-00012670: 2c20 2274 6974 6c65 225d 0a20 2020 2020  , "title"].     
-00012680: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
-00012690: 2020 7365 6c66 2e64 6174 615b 6b65 795d    self.data[key]
-000126a0: 203d 2070 7265 705f 7574 696c 732e 6361   = prep_utils.ca
-000126b0: 7069 7461 6c69 7a65 5f65 6e74 6974 6965  pitalize_entitie
-000126c0: 7328 7365 6c66 2e64 6174 615b 6b65 795d  s(self.data[key]
-000126d0: 290a 0a20 2020 2020 2020 2069 6620 6b65  )..        if ke
-000126e0: 7920 696e 2073 656c 662e 6461 7461 2e67  y in self.data.g
-000126f0: 6574 2822 636f 6c72 6576 5f6d 6173 7465  et("colrev_maste
-00012700: 7264 6174 615f 7072 6f76 656e 616e 6365  rdata_provenance
-00012710: 222c 207b 7d29 3a0a 2020 2020 2020 2020  ", {}):.        
-00012720: 2020 2020 6e6f 7465 203d 2073 656c 662e      note = self.
-00012730: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
-00012740: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-00012750: 6365 225d 5b6b 6579 5d5b 226e 6f74 6522  ce"][key]["note"
-00012760: 5d0a 2020 2020 2020 2020 2020 2020 6966  ].            if
-00012770: 2022 7175 616c 6974 795f 6465 6665 6374   "quality_defect
-00012780: 2220 696e 206e 6f74 653a 0a20 2020 2020  " in note:.     
-00012790: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-000127a0: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
-000127b0: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
-000127c0: 6365 225d 5b6b 6579 5d5b 226e 6f74 6522  ce"][key]["note"
-000127d0: 5d20 3d20 6e6f 7465 2e72 6570 6c61 6365  ] = note.replace
-000127e0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-000127f0: 2020 2020 2020 2271 7561 6c69 7479 5f64        "quality_d
-00012800: 6566 6563 7422 2c20 2222 0a20 2020 2020  efect", "".     
-00012810: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
-00012820: 2020 6465 6620 7265 6e61 6d65 5f66 6965    def rename_fie
-00012830: 6c64 735f 6261 7365 645f 6f6e 5f6d 6170  lds_based_on_map
-00012840: 7069 6e67 2873 656c 662c 202a 2c20 6d61  ping(self, *, ma
-00012850: 7070 696e 673a 2064 6963 7429 202d 3e20  pping: dict) -> 
-00012860: 4e6f 6e65 3a0a 2020 2020 2020 2020 2222  None:.        ""
-00012870: 2243 6f6e 7665 6e69 656e 6365 2066 756e  "Convenience fun
-00012880: 6374 696f 6e20 666f 7220 7468 6520 7072  ction for the pr
-00012890: 6570 2073 6372 6970 7473 2028 746f 2072  ep scripts (to r
-000128a0: 656e 616d 6520 6669 656c 6473 2922 2222  ename fields)"""
-000128b0: 0a0a 2020 2020 2020 2020 6d61 7070 696e  ..        mappin
-000128c0: 6720 3d20 7b6b 2e6c 6f77 6572 2829 3a20  g = {k.lower(): 
-000128d0: 762e 6c6f 7765 7228 2920 666f 7220 6b2c  v.lower() for k,
-000128e0: 2076 2069 6e20 6d61 7070 696e 672e 6974   v in mapping.it
-000128f0: 656d 7328 297d 0a20 2020 2020 2020 2070  ems()}.        p
-00012900: 7269 6f72 5f6b 6579 7320 3d20 6c69 7374  rior_keys = list
-00012910: 2873 656c 662e 6461 7461 2e6b 6579 7328  (self.data.keys(
-00012920: 2929 0a20 2020 2020 2020 2023 204e 6f74  )).        # Not
-00012930: 6520 3a20 7761 726e 696e 673a 2064 6f20  e : warning: do 
-00012940: 6e6f 7420 6372 6561 7465 2061 206e 6577  not create a new
-00012950: 2064 6963 742e 0a20 2020 2020 2020 2066   dict..        f
-00012960: 6f72 206b 6579 2069 6e20 7072 696f 725f  or key in prior_
-00012970: 6b65 7973 3a0a 2020 2020 2020 2020 2020  keys:.          
-00012980: 2020 6966 206b 6579 2e6c 6f77 6572 2829    if key.lower()
-00012990: 2069 6e20 6d61 7070 696e 673a 0a20 2020   in mapping:.   
-000129a0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-000129b0: 662e 7265 6e61 6d65 5f66 6965 6c64 286b  f.rename_field(k
-000129c0: 6579 3d6b 6579 2c20 6e65 775f 6b65 793d  ey=key, new_key=
-000129d0: 6d61 7070 696e 675b 6b65 792e 6c6f 7765  mapping[key.lowe
-000129e0: 7228 295d 290a 0a20 2020 2064 6566 2075  r()])..    def u
-000129f0: 6e69 6679 5f70 6167 6573 5f66 6965 6c64  nify_pages_field
-00012a00: 2873 656c 6629 202d 3e20 4e6f 6e65 3a0a  (self) -> None:.
-00012a10: 2020 2020 2020 2020 2222 2255 6e69 6679          """Unify
-00012a20: 2074 6865 2066 6f72 6d61 7420 6f66 2074   the format of t
-00012a30: 6865 2070 6167 6520 6669 656c 6422 2222  he page field"""
-00012a40: 0a20 2020 2020 2020 2069 6620 2270 6167  .        if "pag
-00012a50: 6573 2220 6e6f 7420 696e 2073 656c 662e  es" not in self.
-00012a60: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
-00012a70: 2020 7265 7475 726e 0a20 2020 2020 2020    return.       
-00012a80: 2069 6620 6e6f 7420 6973 696e 7374 616e   if not isinstan
-00012a90: 6365 2873 656c 662e 6461 7461 5b22 7061  ce(self.data["pa
-00012aa0: 6765 7322 5d2c 2073 7472 293a 0a20 2020  ges"], str):.   
-00012ab0: 2020 2020 2020 2020 2072 6574 7572 6e0a           return.
-00012ac0: 2020 2020 2020 2020 6966 2031 203d 3d20          if 1 == 
-00012ad0: 7365 6c66 2e64 6174 615b 2270 6167 6573  self.data["pages
-00012ae0: 225d 2e63 6f75 6e74 2822 2d22 293a 0a20  "].count("-"):. 
-00012af0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00012b00: 6461 7461 5b22 7061 6765 7322 5d20 3d20  data["pages"] = 
-00012b10: 7365 6c66 2e64 6174 615b 2270 6167 6573  self.data["pages
-00012b20: 225d 2e72 6570 6c61 6365 2822 2d22 2c20  "].replace("-", 
-00012b30: 222d 2d22 290a 2020 2020 2020 2020 7365  "--").        se
-00012b40: 6c66 2e64 6174 615b 2270 6167 6573 225d  lf.data["pages"]
-00012b50: 203d 2028 0a20 2020 2020 2020 2020 2020   = (.           
-00012b60: 2073 656c 662e 6461 7461 5b22 7061 6765   self.data["page
-00012b70: 7322 5d0a 2020 2020 2020 2020 2020 2020  s"].            
-00012b80: 2e72 6570 6c61 6365 2822 e280 9322 2c20  .replace("...", 
-00012b90: 222d 2d22 290a 2020 2020 2020 2020 2020  "--").          
-00012ba0: 2020 2e72 6570 6c61 6365 2822 2d2d 2d2d    .replace("----
-00012bb0: 222c 2022 2d2d 2229 0a20 2020 2020 2020  ", "--").       
-00012bc0: 2020 2020 202e 7265 706c 6163 6528 2220       .replace(" 
-00012bd0: 2d2d 2022 2c20 222d 2d22 290a 2020 2020  -- ", "--").    
-00012be0: 2020 2020 2020 2020 2e72 7374 7269 7028          .rstrip(
-00012bf0: 222e 2229 0a20 2020 2020 2020 2029 0a0a  ".").        )..
-00012c00: 2020 2020 6465 6620 7072 6570 6172 6174      def preparat
-00012c10: 696f 6e5f 7361 7665 5f63 6f6e 6469 7469  ion_save_conditi
-00012c20: 6f6e 2873 656c 6629 202d 3e20 626f 6f6c  on(self) -> bool
-00012c30: 3a0a 2020 2020 2020 2020 2222 2243 6865  :.        """Che
-00012c40: 636b 2077 6865 7468 6572 2074 6865 2073  ck whether the s
-00012c50: 6176 6520 636f 6e64 6974 696f 6e20 666f  ave condition fo
-00012c60: 7220 7468 6520 7072 6570 206f 7065 7261  r the prep opera
-00012c70: 7469 6f6e 2069 7320 6769 7665 6e22 2222  tion is given"""
-00012c80: 0a0a 2020 2020 2020 2020 6966 2073 656c  ..        if sel
-00012c90: 662e 6461 7461 2e67 6574 2822 636f 6c72  f.data.get("colr
-00012ca0: 6576 5f73 7461 7475 7322 2c20 224e 4122  ev_status", "NA"
-00012cb0: 2920 696e 205b 0a20 2020 2020 2020 2020  ) in [.         
-00012cc0: 2020 2052 6563 6f72 6453 7461 7465 2e72     RecordState.r
-00012cd0: 6576 5f70 7265 7363 7265 656e 5f65 7863  ev_prescreen_exc
-00012ce0: 6c75 6465 642c 0a20 2020 2020 2020 2020  luded,.         
-00012cf0: 2020 2052 6563 6f72 6453 7461 7465 2e6d     RecordState.m
-00012d00: 645f 7072 6570 6172 6564 2c0a 2020 2020  d_prepared,.    
-00012d10: 2020 2020 5d3a 0a20 2020 2020 2020 2020      ]:.         
-00012d20: 2020 2072 6574 7572 6e20 5472 7565 0a0a     return True..
-00012d30: 2020 2020 2020 2020 6966 2061 6e79 280a          if any(.
-00012d40: 2020 2020 2020 2020 2020 2020 2264 6973              "dis
-00012d50: 6167 7265 656d 656e 7420 7769 7468 2022  agreement with "
-00012d60: 2069 6e20 785b 226e 6f74 6522 5d0a 2020   in x["note"].  
-00012d70: 2020 2020 2020 2020 2020 666f 7220 7820            for x 
-00012d80: 696e 2073 656c 662e 6461 7461 2e67 6574  in self.data.get
-00012d90: 2822 636f 6c72 6576 5f6d 6173 7465 7264  ("colrev_masterd
-00012da0: 6174 615f 7072 6f76 656e 616e 6365 222c  ata_provenance",
-00012db0: 207b 7d29 2e76 616c 7565 7328 290a 2020   {}).values().  
-00012dc0: 2020 2020 2020 2920 6f72 2061 6e79 280a        ) or any(.
-00012dd0: 2020 2020 2020 2020 2020 2020 2272 6563              "rec
-00012de0: 6f72 645f 6e6f 745f 696e 5f74 6f63 2220  ord_not_in_toc" 
-00012df0: 696e 2078 5b22 6e6f 7465 225d 0a20 2020  in x["note"].   
-00012e00: 2020 2020 2020 2020 2066 6f72 2078 2069           for x i
-00012e10: 6e20 7365 6c66 2e64 6174 612e 6765 7428  n self.data.get(
-00012e20: 2263 6f6c 7265 765f 6d61 7374 6572 6461  "colrev_masterda
-00012e30: 7461 5f70 726f 7665 6e61 6e63 6522 2c20  ta_provenance", 
-00012e40: 7b7d 292e 7661 6c75 6573 2829 0a20 2020  {}).values().   
-00012e50: 2020 2020 2029 3a0a 2020 2020 2020 2020       ):.        
-00012e60: 2020 2020 7265 7475 726e 2054 7275 650a      return True.
-00012e70: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00012e80: 4661 6c73 650a 0a20 2020 2064 6566 2070  False..    def p
-00012e90: 7265 7061 7261 7469 6f6e 5f62 7265 616b  reparation_break
-00012ea0: 5f63 6f6e 6469 7469 6f6e 2873 656c 6629  _condition(self)
-00012eb0: 202d 3e20 626f 6f6c 3a0a 2020 2020 2020   -> bool:.      
-00012ec0: 2020 2222 2243 6865 636b 2077 6865 7468    """Check wheth
-00012ed0: 6572 2074 6865 2062 7265 616b 2063 6f6e  er the break con
-00012ee0: 6469 7469 6f6e 2066 6f72 2074 6865 2070  dition for the p
-00012ef0: 7265 7020 6f70 6572 6174 696f 6e20 6973  rep operation is
-00012f00: 2067 6976 656e 2222 220a 2020 2020 2020   given""".      
-00012f10: 2020 6966 2061 6e79 280a 2020 2020 2020    if any(.      
-00012f20: 2020 2020 2020 2264 6973 6167 7265 656d        "disagreem
-00012f30: 656e 7420 7769 7468 2022 2069 6e20 785b  ent with " in x[
-00012f40: 226e 6f74 6522 5d0a 2020 2020 2020 2020  "note"].        
-00012f50: 2020 2020 666f 7220 7820 696e 2073 656c      for x in sel
-00012f60: 662e 6461 7461 2e67 6574 2822 636f 6c72  f.data.get("colr
-00012f70: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
-00012f80: 6f76 656e 616e 6365 222c 207b 7d29 2e76  ovenance", {}).v
-00012f90: 616c 7565 7328 290a 2020 2020 2020 2020  alues().        
-00012fa0: 2920 6f72 2061 6e79 280a 2020 2020 2020  ) or any(.      
-00012fb0: 2020 2020 2020 2272 6563 6f72 645f 6e6f        "record_no
-00012fc0: 745f 696e 5f74 6f63 2220 696e 2078 5b22  t_in_toc" in x["
-00012fd0: 6e6f 7465 225d 0a20 2020 2020 2020 2020  note"].         
-00012fe0: 2020 2066 6f72 2078 2069 6e20 7365 6c66     for x in self
-00012ff0: 2e64 6174 612e 6765 7428 2263 6f6c 7265  .data.get("colre
-00013000: 765f 6d61 7374 6572 6461 7461 5f70 726f  v_masterdata_pro
-00013010: 7665 6e61 6e63 6522 2c20 7b7d 292e 7661  venance", {}).va
-00013020: 6c75 6573 2829 0a20 2020 2020 2020 2029  lues().        )
-00013030: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00013040: 7475 726e 2054 7275 650a 0a20 2020 2020  turn True..     
-00013050: 2020 2069 6620 7365 6c66 2e64 6174 612e     if self.data.
-00013060: 6765 7428 2263 6f6c 7265 765f 7374 6174  get("colrev_stat
-00013070: 7573 222c 2022 4e41 2229 2069 6e20 5b0a  us", "NA") in [.
-00013080: 2020 2020 2020 2020 2020 2020 5265 636f              Reco
-00013090: 7264 5374 6174 652e 7265 765f 7072 6573  rdState.rev_pres
-000130a0: 6372 6565 6e5f 6578 636c 7564 6564 2c0a  creen_excluded,.
-000130b0: 2020 2020 2020 2020 5d3a 0a20 2020 2020          ]:.     
-000130c0: 2020 2020 2020 2072 6574 7572 6e20 5472         return Tr
-000130d0: 7565 0a20 2020 2020 2020 2072 6574 7572  ue.        retur
-000130e0: 6e20 4661 6c73 650a 0a20 2020 2064 6566  n False..    def
-000130f0: 2073 7461 7475 735f 746f 5f70 7265 7061   status_to_prepa
-00013100: 7265 2873 656c 6629 202d 3e20 626f 6f6c  re(self) -> bool
-00013110: 3a0a 2020 2020 2020 2020 2222 2243 6865  :.        """Che
-00013120: 636b 2077 6865 7468 6572 2074 6865 2072  ck whether the r
-00013130: 6563 6f72 6420 6e65 6564 7320 746f 2062  ecord needs to b
-00013140: 6520 7072 6570 6172 6564 2222 220a 2020  e prepared""".  
-00013150: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00013160: 662e 6461 7461 2e67 6574 2822 636f 6c72  f.data.get("colr
-00013170: 6576 5f73 7461 7475 7322 2c20 224e 4122  ev_status", "NA"
-00013180: 2920 696e 205b 0a20 2020 2020 2020 2020  ) in [.         
-00013190: 2020 2052 6563 6f72 6453 7461 7465 2e6d     RecordState.m
-000131a0: 645f 6e65 6564 735f 6d61 6e75 616c 5f70  d_needs_manual_p
-000131b0: 7265 7061 7261 7469 6f6e 2c0a 2020 2020  reparation,.    
-000131c0: 2020 2020 2020 2020 5265 636f 7264 5374          RecordSt
-000131d0: 6174 652e 6d64 5f69 6d70 6f72 7465 642c  ate.md_imported,
-000131e0: 0a20 2020 2020 2020 2020 2020 2052 6563  .            Rec
-000131f0: 6f72 6453 7461 7465 2e6d 645f 7072 6570  ordState.md_prep
-00013200: 6172 6564 2c0a 2020 2020 2020 2020 5d0a  ared,.        ].
-00013210: 0a20 2020 2064 6566 2075 7064 6174 655f  .    def update_
-00013220: 6d65 7461 6461 7461 5f73 7461 7475 7328  metadata_status(
-00013230: 0a20 2020 2020 2020 2073 656c 662c 0a20  .        self,. 
-00013240: 2020 2029 202d 3e20 4e6f 6e65 3a0a 2020     ) -> None:.  
-00013250: 2020 2020 2020 2222 2255 7064 6174 6520        """Update 
-00013260: 7468 6520 6d65 7461 6461 7461 2073 7461  the metadata sta
-00013270: 7475 7320 2872 6574 7261 6374 732c 2069  tus (retracts, i
-00013280: 6e63 6f6d 706c 6574 656e 6573 732c 2069  ncompleteness, i
-00013290: 6e63 6f6e 7369 7374 656e 6369 6573 2c20  nconsistencies, 
-000132a0: 6574 632e 290a 2020 2020 2020 2020 616e  etc.).        an
-000132b0: 6420 7365 7474 696e 6720 7468 6520 7374  d setting the st
-000132c0: 6174 7573 2061 6363 6f72 6469 6e67 6c79  atus accordingly
-000132d0: 2222 220a 0a20 2020 2020 2020 2073 656c  """..        sel
-000132e0: 662e 6368 6563 6b5f 706f 7465 6e74 6961  f.check_potentia
-000132f0: 6c5f 7265 7472 6163 7473 2829 0a0a 2020  l_retracts()..  
-00013300: 2020 2020 2020 6966 2028 0a20 2020 2020        if (.     
-00013310: 2020 2020 2020 2063 6f6c 7265 762e 7265         colrev.re
-00013320: 636f 7264 2e52 6563 6f72 6453 7461 7465  cord.RecordState
-00013330: 2e72 6576 5f70 7265 7363 7265 656e 5f65  .rev_prescreen_e
-00013340: 7863 6c75 6465 640a 2020 2020 2020 2020  xcluded.        
-00013350: 2020 2020 3d3d 2073 656c 662e 6461 7461      == self.data
-00013360: 5b22 636f 6c72 6576 5f73 7461 7475 7322  ["colrev_status"
-00013370: 5d0a 2020 2020 2020 2020 293a 0a20 2020  ].        ):.   
-00013380: 2020 2020 2020 2020 2072 6574 7572 6e0a           return.
-00013390: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-000133a0: 2e6d 6173 7465 7264 6174 615f 6973 5f63  .masterdata_is_c
-000133b0: 7572 6174 6564 2829 3a0a 2020 2020 2020  urated():.      
-000133c0: 2020 2020 2020 7365 6c66 2e73 6574 5f73        self.set_s
-000133d0: 7461 7475 7328 7461 7267 6574 5f73 7461  tatus(target_sta
-000133e0: 7465 3d52 6563 6f72 6453 7461 7465 2e6d  te=RecordState.m
-000133f0: 645f 7072 6570 6172 6564 290a 2020 2020  d_prepared).    
-00013400: 2020 2020 2020 2020 7265 7475 726e 0a0a          return..
-00013410: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-00013420: 6861 735f 7175 616c 6974 795f 6465 6665  has_quality_defe
-00013430: 6374 7328 293a 0a20 2020 2020 2020 2020  cts():.         
-00013440: 2020 2073 656c 662e 7365 745f 7374 6174     self.set_stat
-00013450: 7573 2874 6172 6765 745f 7374 6174 653d  us(target_state=
-00013460: 5265 636f 7264 5374 6174 652e 6d64 5f6e  RecordState.md_n
-00013470: 6565 6473 5f6d 616e 7561 6c5f 7072 6570  eeds_manual_prep
-00013480: 6172 6174 696f 6e29 0a20 2020 2020 2020  aration).       
-00013490: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-000134a0: 2020 2073 656c 662e 7365 745f 7374 6174     self.set_stat
-000134b0: 7573 2874 6172 6765 745f 7374 6174 653d  us(target_state=
-000134c0: 5265 636f 7264 5374 6174 652e 6d64 5f70  RecordState.md_p
-000134d0: 7265 7061 7265 6429 0a0a 0a63 6c61 7373  repared)...class
-000134e0: 2052 6563 6f72 6453 7461 7465 2845 6e75   RecordState(Enu
-000134f0: 6d29 3a0a 2020 2020 2222 2254 6865 2070  m):.    """The p
-00013500: 6f73 7369 626c 6520 5265 636f 7264 5374  ossible RecordSt
-00013510: 6174 6573 2073 746f 7265 6420 696e 2074  ates stored in t
-00013520: 6865 2063 6f6c 7265 765f 7374 6174 7573  he colrev_status
-00013530: 2066 6965 6c64 0a20 2020 2028 636f 7272   field.    (corr
-00013540: 6573 706f 6e64 696e 6720 746f 2074 6865  esponding to the
-00013550: 2052 6563 6f72 6453 7461 7465 4d6f 6465   RecordStateMode
-00013560: 6c29 2222 220a 0a20 2020 2023 2070 796c  l)"""..    # pyl
-00013570: 696e 743a 2064 6973 6162 6c65 3d69 6e76  int: disable=inv
-00013580: 616c 6964 2d6e 616d 650a 0a20 2020 2023  alid-name..    #
-00013590: 2077 6974 686f 7574 2074 6865 206d 645f   without the md_
-000135a0: 7265 7472 6965 7665 6420 7374 6174 652c  retrieved state,
-000135b0: 2077 6520 636f 756c 6420 6e6f 7420 6469   we could not di
-000135c0: 7370 6c61 7920 7468 6520 6c6f 6164 2074  splay the load t
-000135d0: 7261 6e73 6974 696f 6e0a 2020 2020 6d64  ransition.    md
-000135e0: 5f72 6574 7269 6576 6564 203d 2031 0a20  _retrieved = 1. 
-000135f0: 2020 2022 2222 5265 636f 7264 2069 7320     """Record is 
-00013600: 7265 7472 6965 7665 6420 616e 6420 7374  retrieved and st
-00013610: 6f72 6564 2069 6e20 7468 6520 2e2f 7365  ored in the ./se
-00013620: 6172 6368 2064 6972 6563 746f 7279 2222  arch directory""
-00013630: 220a 2020 2020 6d64 5f69 6d70 6f72 7465  ".    md_importe
-00013640: 6420 3d20 320a 2020 2020 2222 2252 6563  d = 2.    """Rec
-00013650: 6f72 6420 6973 2069 6d70 6f72 7465 6420  ord is imported 
-00013660: 696e 746f 2074 6865 2052 4543 4f52 4453  into the RECORDS
-00013670: 5f46 494c 4522 2222 0a20 2020 206d 645f  _FILE""".    md_
-00013680: 6e65 6564 735f 6d61 6e75 616c 5f70 7265  needs_manual_pre
-00013690: 7061 7261 7469 6f6e 203d 2033 0a20 2020  paration = 3.   
-000136a0: 2022 2222 5265 636f 7264 2072 6571 7569   """Record requi
-000136b0: 7265 7320 6d61 6e75 616c 2070 7265 7061  res manual prepa
-000136c0: 7261 7469 6f6e 0a20 2020 2028 636f 6c72  ration.    (colr
-000136d0: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
-000136e0: 6f76 656e 616e 6365 2070 726f 7669 6465  ovenance provide
-000136f0: 7320 6869 6e74 7329 2222 220a 2020 2020  s hints)""".    
-00013700: 6d64 5f70 7265 7061 7265 6420 3d20 340a  md_prepared = 4.
-00013710: 2020 2020 2222 2252 6563 6f72 6420 6973      """Record is
-00013720: 2070 7265 7061 7265 6420 286e 6f20 6d69   prepared (no mi
-00013730: 7373 696e 6720 6f72 2069 6e63 6f6d 706c  ssing or incompl
-00013740: 6574 6520 6669 656c 6473 2c20 696e 636f  ete fields, inco
-00013750: 6e73 6973 7465 6e63 6965 7320 6368 6563  nsistencies chec
-00013760: 6b65 6429 2222 220a 2020 2020 6d64 5f70  ked)""".    md_p
-00013770: 726f 6365 7373 6564 203d 2035 0a20 2020  rocessed = 5.   
-00013780: 2022 2222 5265 636f 7264 2068 6173 2062   """Record has b
-00013790: 6565 6e20 6368 6563 6b65 6420 666f 7220  een checked for 
-000137a0: 6475 706c 6963 6174 6520 6173 736f 6369  duplicate associ
-000137b0: 6174 696f 6e73 0a20 2020 2077 6974 6820  ations.    with 
-000137c0: 616e 7920 7265 636f 7264 2069 6e20 5265  any record in Re
-000137d0: 636f 7264 5374 6174 6520 6d64 5f70 726f  cordState md_pro
-000137e0: 6365 7373 6564 206f 7220 6c61 7465 7222  cessed or later"
-000137f0: 2222 0a20 2020 2072 6576 5f70 7265 7363  "".    rev_presc
-00013800: 7265 656e 5f65 7863 6c75 6465 6420 3d20  reen_excluded = 
-00013810: 360a 2020 2020 2222 2252 6563 6f72 6420  6.    """Record 
-00013820: 7761 7320 6578 636c 7564 6564 2069 6e20  was excluded in 
-00013830: 7468 6520 7072 6573 6372 6565 6e20 2862  the prescreen (b
-00013840: 6173 6564 206f 6e20 7469 746c 6573 2f61  ased on titles/a
-00013850: 6273 7472 6163 7473 2922 2222 0a20 2020  bstracts)""".   
-00013860: 2072 6576 5f70 7265 7363 7265 656e 5f69   rev_prescreen_i
-00013870: 6e63 6c75 6465 6420 3d20 370a 2020 2020  ncluded = 7.    
-00013880: 2222 2252 6563 6f72 6420 7761 7320 696e  """Record was in
-00013890: 636c 7564 6564 2069 6e20 7468 6520 7072  cluded in the pr
-000138a0: 6573 6372 6565 6e20 2862 6173 6564 206f  escreen (based o
-000138b0: 6e20 7469 746c 6573 2f61 6273 7472 6163  n titles/abstrac
-000138c0: 7473 2922 2222 0a20 2020 2070 6466 5f6e  ts)""".    pdf_n
-000138d0: 6565 6473 5f6d 616e 7561 6c5f 7265 7472  eeds_manual_retr
-000138e0: 6965 7661 6c20 3d20 380a 2020 2020 2222  ieval = 8.    ""
-000138f0: 2252 6563 6f72 6420 6d61 726b 6564 2066  "Record marked f
-00013900: 6f72 206d 616e 7561 6c20 5044 4620 7265  or manual PDF re
-00013910: 7472 6965 7661 6c22 2222 0a20 2020 2070  trieval""".    p
-00013920: 6466 5f69 6d70 6f72 7465 6420 3d20 390a  df_imported = 9.
-00013930: 2020 2020 2222 2250 4446 2069 6d70 6f72      """PDF impor
-00013940: 7465 6420 616e 6420 6d61 726b 6564 2066  ted and marked f
-00013950: 6f72 2070 7265 7061 7261 7469 6f6e 2222  or preparation""
-00013960: 220a 2020 2020 7064 665f 6e6f 745f 6176  ".    pdf_not_av
-00013970: 6169 6c61 626c 6520 3d20 3130 0a20 2020  ailable = 10.   
-00013980: 2022 2222 5044 4620 6973 206e 6f74 2061   """PDF is not a
-00013990: 7661 696c 6162 6c65 2222 220a 2020 2020  vailable""".    
-000139a0: 7064 665f 6e65 6564 735f 6d61 6e75 616c  pdf_needs_manual
-000139b0: 5f70 7265 7061 7261 7469 6f6e 203d 2031  _preparation = 1
-000139c0: 310a 2020 2020 2222 2250 4446 206d 6172  1.    """PDF mar
-000139d0: 6b65 6420 666f 7220 6d61 6e75 616c 2070  ked for manual p
-000139e0: 7265 7061 7261 7469 6f6e 2222 220a 2020  reparation""".  
-000139f0: 2020 7064 665f 7072 6570 6172 6564 203d    pdf_prepared =
-00013a00: 2031 320a 2020 2020 2222 2250 4446 2070   12.    """PDF p
-00013a10: 7265 7061 7265 6422 2222 0a20 2020 2072  repared""".    r
-00013a20: 6576 5f65 7863 6c75 6465 6420 3d20 3133  ev_excluded = 13
-00013a30: 0a20 2020 2022 2222 5265 636f 7264 2065  .    """Record e
-00013a40: 7863 6c75 6465 6420 696e 2073 6372 6565  xcluded in scree
-00013a50: 6e20 2866 756c 6c2d 7465 7874 2922 2222  n (full-text)"""
-00013a60: 0a20 2020 2072 6576 5f69 6e63 6c75 6465  .    rev_include
-00013a70: 6420 3d20 3134 0a20 2020 2022 2222 5265  d = 14.    """Re
-00013a80: 636f 7264 2069 6e63 6c75 6465 6420 696e  cord included in
-00013a90: 2073 6372 6565 6e20 2866 756c 6c2d 7465   screen (full-te
-00013aa0: 7874 2922 2222 0a20 2020 2072 6576 5f73  xt)""".    rev_s
-00013ab0: 796e 7468 6573 697a 6564 203d 2031 350a  ynthesized = 15.
-00013ac0: 2020 2020 2222 2252 6563 6f72 6420 7379      """Record sy
-00013ad0: 6e74 6865 7369 7a65 6422 2222 0a20 2020  nthesized""".   
-00013ae0: 2023 204e 6f74 6520 3a20 5442 443a 2072   # Note : TBD: r
-00013af0: 6576 5f63 6f64 6564 0a0a 2020 2020 6465  ev_coded..    de
-00013b00: 6620 5f5f 7374 725f 5f28 7365 6c66 2920  f __str__(self) 
-00013b10: 2d3e 2073 7472 3a0a 2020 2020 2020 2020  -> str:.        
-00013b20: 7265 7475 726e 2066 227b 7365 6c66 2e6e  return f"{self.n
-00013b30: 616d 657d 220a 0a20 2020 2064 6566 205f  ame}"..    def _
-00013b40: 5f6c 745f 5f28 7365 6c66 2c20 6f74 6865  _lt__(self, othe
-00013b50: 7229 202d 3e20 626f 6f6c 3a20 2023 2074  r) -> bool:  # t
-00013b60: 7970 653a 2069 676e 6f72 650a 2020 2020  ype: ignore.    
-00013b70: 2020 2020 6966 2073 656c 662e 5f5f 636c      if self.__cl
-00013b80: 6173 735f 5f20 3d3d 2052 6563 6f72 6453  ass__ == RecordS
-00013b90: 7461 7465 2061 6e64 206f 7468 6572 2e5f  tate and other._
-00013ba0: 5f63 6c61 7373 5f5f 203d 3d20 5265 636f  _class__ == Reco
-00013bb0: 7264 5374 6174 653a 0a20 2020 2020 2020  rdState:.       
-00013bc0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00013bd0: 2e76 616c 7565 203c 206f 7468 6572 2e76  .value < other.v
-00013be0: 616c 7565 0a20 2020 2020 2020 2072 6169  alue.        rai
-00013bf0: 7365 204e 6f74 496d 706c 656d 656e 7465  se NotImplemente
-00013c00: 6445 7272 6f72 0a0a 2020 2020 4063 6c61  dError..    @cla
-00013c10: 7373 6d65 7468 6f64 0a20 2020 2064 6566  ssmethod.    def
-00013c20: 2067 6574 5f6e 6f6e 5f70 726f 6365 7373   get_non_process
-00013c30: 6564 5f73 7461 7465 7328 636c 7329 202d  ed_states(cls) -
-00013c40: 3e20 6c69 7374 3a0a 2020 2020 2020 2020  > list:.        
-00013c50: 2222 2247 6574 2074 6865 2073 7461 7465  """Get the state
-00013c60: 7320 7468 6174 2063 6f72 7265 7370 6f6e  s that correspon
-00013c70: 6420 746f 206e 6f74 2d79 6574 2d70 726f  d to not-yet-pro
-00013c80: 6365 7373 6564 2222 220a 2020 2020 2020  cessed""".      
-00013c90: 2020 7265 7475 726e 205b 0a20 2020 2020    return [.     
-00013ca0: 2020 2020 2020 2063 6f6c 7265 762e 7265         colrev.re
-00013cb0: 636f 7264 2e52 6563 6f72 6453 7461 7465  cord.RecordState
-00013cc0: 2e6d 645f 7265 7472 6965 7665 642c 0a20  .md_retrieved,. 
-00013cd0: 2020 2020 2020 2020 2020 2063 6f6c 7265             colre
-00013ce0: 762e 7265 636f 7264 2e52 6563 6f72 6453  v.record.RecordS
-00013cf0: 7461 7465 2e6d 645f 696d 706f 7274 6564  tate.md_imported
-00013d00: 2c0a 2020 2020 2020 2020 2020 2020 636f  ,.            co
-00013d10: 6c72 6576 2e72 6563 6f72 642e 5265 636f  lrev.record.Reco
-00013d20: 7264 5374 6174 652e 6d64 5f70 7265 7061  rdState.md_prepa
-00013d30: 7265 642c 0a20 2020 2020 2020 2020 2020  red,.           
-00013d40: 2063 6f6c 7265 762e 7265 636f 7264 2e52   colrev.record.R
-00013d50: 6563 6f72 6453 7461 7465 2e6d 645f 6e65  ecordState.md_ne
-00013d60: 6564 735f 6d61 6e75 616c 5f70 7265 7061  eds_manual_prepa
-00013d70: 7261 7469 6f6e 2c0a 2020 2020 2020 2020  ration,.        
-00013d80: 5d0a 0a20 2020 2040 636c 6173 736d 6574  ]..    @classmet
-00013d90: 686f 640a 2020 2020 6465 6620 6765 745f  hod.    def get_
-00013da0: 706f 7374 5f78 5f73 7461 7465 7328 636c  post_x_states(cl
-00013db0: 732c 202a 2c20 7374 6174 653a 2052 6563  s, *, state: Rec
-00013dc0: 6f72 6453 7461 7465 2920 2d3e 2074 7970  ordState) -> typ
-00013dd0: 696e 672e 5365 745b 5265 636f 7264 5374  ing.Set[RecordSt
-00013de0: 6174 655d 3a0a 2020 2020 2020 2020 2222  ate]:.        ""
-00013df0: 2247 6574 2074 6865 2073 7461 7465 7320  "Get the states 
-00013e00: 6166 7465 7220 7374 6174 6520 7820 2870  after state x (p
-00013e10: 6173 7365 6420 6173 2061 2070 6172 616d  assed as a param
-00013e20: 6574 6572 2922 2222 0a20 2020 2020 2020  eter)""".       
-00013e30: 2069 6620 7374 6174 6520 3d3d 2052 6563   if state == Rec
-00013e40: 6f72 6453 7461 7465 2e6d 645f 7072 6570  ordState.md_prep
-00013e50: 6172 6564 3a0a 2020 2020 2020 2020 2020  ared:.          
-00013e60: 2020 7265 7475 726e 207b 0a20 2020 2020    return {.     
-00013e70: 2020 2020 2020 2020 2020 2052 6563 6f72             Recor
-00013e80: 6453 7461 7465 2e6d 645f 7072 6570 6172  dState.md_prepar
-00013e90: 6564 2c0a 2020 2020 2020 2020 2020 2020  ed,.            
-00013ea0: 2020 2020 5265 636f 7264 5374 6174 652e      RecordState.
-00013eb0: 6d64 5f70 726f 6365 7373 6564 2c0a 2020  md_processed,.  
-00013ec0: 2020 2020 2020 2020 2020 2020 2020 5265                Re
-00013ed0: 636f 7264 5374 6174 652e 7265 765f 7072  cordState.rev_pr
-00013ee0: 6573 6372 6565 6e5f 696e 636c 7564 6564  escreen_included
-00013ef0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00013f00: 2020 5265 636f 7264 5374 6174 652e 7265    RecordState.re
-00013f10: 765f 7072 6573 6372 6565 6e5f 6578 636c  v_prescreen_excl
-00013f20: 7564 6564 2c0a 2020 2020 2020 2020 2020  uded,.          
-00013f30: 2020 2020 2020 5265 636f 7264 5374 6174        RecordStat
-00013f40: 652e 7064 665f 6e65 6564 735f 6d61 6e75  e.pdf_needs_manu
-00013f50: 616c 5f72 6574 7269 6576 616c 2c0a 2020  al_retrieval,.  
-00013f60: 2020 2020 2020 2020 2020 2020 2020 5265                Re
-00013f70: 636f 7264 5374 6174 652e 7064 665f 696d  cordState.pdf_im
-00013f80: 706f 7274 6564 2c0a 2020 2020 2020 2020  ported,.        
-00013f90: 2020 2020 2020 2020 5265 636f 7264 5374          RecordSt
-00013fa0: 6174 652e 7064 665f 6e6f 745f 6176 6169  ate.pdf_not_avai
-00013fb0: 6c61 626c 652c 0a20 2020 2020 2020 2020  lable,.         
-00013fc0: 2020 2020 2020 2052 6563 6f72 6453 7461         RecordSta
-00013fd0: 7465 2e70 6466 5f6e 6565 6473 5f6d 616e  te.pdf_needs_man
-00013fe0: 7561 6c5f 7072 6570 6172 6174 696f 6e2c  ual_preparation,
-00013ff0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014000: 2052 6563 6f72 6453 7461 7465 2e70 6466   RecordState.pdf
-00014010: 5f70 7265 7061 7265 642c 0a20 2020 2020  _prepared,.     
-00014020: 2020 2020 2020 2020 2020 2052 6563 6f72             Recor
-00014030: 6453 7461 7465 2e72 6576 5f65 7863 6c75  dState.rev_exclu
-00014040: 6465 642c 0a20 2020 2020 2020 2020 2020  ded,.           
-00014050: 2020 2020 2052 6563 6f72 6453 7461 7465       RecordState
-00014060: 2e72 6576 5f69 6e63 6c75 6465 642c 0a20  .rev_included,. 
-00014070: 2020 2020 2020 2020 2020 2020 2020 2052                 R
-00014080: 6563 6f72 6453 7461 7465 2e72 6576 5f73  ecordState.rev_s
-00014090: 796e 7468 6573 697a 6564 2c0a 2020 2020  ynthesized,.    
-000140a0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
-000140b0: 2020 6966 2073 7461 7465 203d 3d20 5265    if state == Re
-000140c0: 636f 7264 5374 6174 652e 6d64 5f70 726f  cordState.md_pro
-000140d0: 6365 7373 6564 3a0a 2020 2020 2020 2020  cessed:.        
-000140e0: 2020 2020 7265 7475 726e 207b 0a20 2020      return {.   
-000140f0: 2020 2020 2020 2020 2020 2020 2052 6563               Rec
-00014100: 6f72 6453 7461 7465 2e6d 645f 7072 6f63  ordState.md_proc
-00014110: 6573 7365 642c 0a20 2020 2020 2020 2020  essed,.         
-00014120: 2020 2020 2020 2052 6563 6f72 6453 7461         RecordSta
-00014130: 7465 2e72 6576 5f70 7265 7363 7265 656e  te.rev_prescreen
-00014140: 5f69 6e63 6c75 6465 642c 0a20 2020 2020  _included,.     
-00014150: 2020 2020 2020 2020 2020 2052 6563 6f72             Recor
-00014160: 6453 7461 7465 2e72 6576 5f70 7265 7363  dState.rev_presc
-00014170: 7265 656e 5f65 7863 6c75 6465 642c 0a20  reen_excluded,. 
-00014180: 2020 2020 2020 2020 2020 2020 2020 2052                 R
-00014190: 6563 6f72 6453 7461 7465 2e70 6466 5f6e  ecordState.pdf_n
-000141a0: 6565 6473 5f6d 616e 7561 6c5f 7265 7472  eeds_manual_retr
-000141b0: 6965 7661 6c2c 0a20 2020 2020 2020 2020  ieval,.         
-000141c0: 2020 2020 2020 2052 6563 6f72 6453 7461         RecordSta
-000141d0: 7465 2e70 6466 5f69 6d70 6f72 7465 642c  te.pdf_imported,
-000141e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000141f0: 2052 6563 6f72 6453 7461 7465 2e70 6466   RecordState.pdf
-00014200: 5f6e 6f74 5f61 7661 696c 6162 6c65 2c0a  _not_available,.
-00014210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014220: 5265 636f 7264 5374 6174 652e 7064 665f  RecordState.pdf_
-00014230: 6e65 6564 735f 6d61 6e75 616c 5f70 7265  needs_manual_pre
-00014240: 7061 7261 7469 6f6e 2c0a 2020 2020 2020  paration,.      
-00014250: 2020 2020 2020 2020 2020 5265 636f 7264            Record
-00014260: 5374 6174 652e 7064 665f 7072 6570 6172  State.pdf_prepar
-00014270: 6564 2c0a 2020 2020 2020 2020 2020 2020  ed,.            
-00014280: 2020 2020 5265 636f 7264 5374 6174 652e      RecordState.
-00014290: 7265 765f 6578 636c 7564 6564 2c0a 2020  rev_excluded,.  
-000142a0: 2020 2020 2020 2020 2020 2020 2020 5265                Re
-000142b0: 636f 7264 5374 6174 652e 7265 765f 696e  cordState.rev_in
-000142c0: 636c 7564 6564 2c0a 2020 2020 2020 2020  cluded,.        
-000142d0: 2020 2020 2020 2020 5265 636f 7264 5374          RecordSt
-000142e0: 6174 652e 7265 765f 7379 6e74 6865 7369  ate.rev_synthesi
-000142f0: 7a65 642c 0a20 2020 2020 2020 2020 2020  zed,.           
-00014300: 207d 0a20 2020 2020 2020 2069 6620 7374   }.        if st
-00014310: 6174 6520 3d3d 2052 6563 6f72 6453 7461  ate == RecordSta
-00014320: 7465 2e72 6576 5f70 7265 7363 7265 656e  te.rev_prescreen
-00014330: 5f69 6e63 6c75 6465 643a 0a20 2020 2020  _included:.     
-00014340: 2020 2020 2020 2072 6574 7572 6e20 7b0a         return {.
-00014350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014360: 5265 636f 7264 5374 6174 652e 7265 765f  RecordState.rev_
-00014370: 7072 6573 6372 6565 6e5f 696e 636c 7564  prescreen_includ
-00014380: 6564 2c0a 2020 2020 2020 2020 2020 2020  ed,.            
-00014390: 2020 2020 5265 636f 7264 5374 6174 652e      RecordState.
-000143a0: 7265 765f 7072 6573 6372 6565 6e5f 6578  rev_prescreen_ex
-000143b0: 636c 7564 6564 2c0a 2020 2020 2020 2020  cluded,.        
-000143c0: 2020 2020 2020 2020 5265 636f 7264 5374          RecordSt
-000143d0: 6174 652e 7064 665f 6e65 6564 735f 6d61  ate.pdf_needs_ma
-000143e0: 6e75 616c 5f72 6574 7269 6576 616c 2c0a  nual_retrieval,.
-000143f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014400: 5265 636f 7264 5374 6174 652e 7064 665f  RecordState.pdf_
-00014410: 696d 706f 7274 6564 2c0a 2020 2020 2020  imported,.      
-00014420: 2020 2020 2020 2020 2020 5265 636f 7264            Record
-00014430: 5374 6174 652e 7064 665f 6e6f 745f 6176  State.pdf_not_av
-00014440: 6169 6c61 626c 652c 0a20 2020 2020 2020  ailable,.       
-00014450: 2020 2020 2020 2020 2052 6563 6f72 6453           RecordS
-00014460: 7461 7465 2e70 6466 5f6e 6565 6473 5f6d  tate.pdf_needs_m
-00014470: 616e 7561 6c5f 7072 6570 6172 6174 696f  anual_preparatio
-00014480: 6e2c 0a20 2020 2020 2020 2020 2020 2020  n,.             
-00014490: 2020 2052 6563 6f72 6453 7461 7465 2e70     RecordState.p
-000144a0: 6466 5f70 7265 7061 7265 642c 0a20 2020  df_prepared,.   
-000144b0: 2020 2020 2020 2020 2020 2020 2052 6563               Rec
-000144c0: 6f72 6453 7461 7465 2e72 6576 5f65 7863  ordState.rev_exc
-000144d0: 6c75 6465 642c 0a20 2020 2020 2020 2020  luded,.         
-000144e0: 2020 2020 2020 2052 6563 6f72 6453 7461         RecordSta
-000144f0: 7465 2e72 6576 5f69 6e63 6c75 6465 642c  te.rev_included,
-00014500: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014510: 2052 6563 6f72 6453 7461 7465 2e72 6576   RecordState.rev
-00014520: 5f73 796e 7468 6573 697a 6564 2c0a 2020  _synthesized,.  
-00014530: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-00014540: 2020 2020 6966 2073 7461 7465 203d 3d20      if state == 
-00014550: 5265 636f 7264 5374 6174 652e 7064 665f  RecordState.pdf_
-00014560: 7072 6570 6172 6564 3a0a 2020 2020 2020  prepared:.      
-00014570: 2020 2020 2020 7265 7475 726e 207b 0a20        return {. 
-00014580: 2020 2020 2020 2020 2020 2020 2020 2052                 R
-00014590: 6563 6f72 6453 7461 7465 2e70 6466 5f70  ecordState.pdf_p
-000145a0: 7265 7061 7265 642c 0a20 2020 2020 2020  repared,.       
-000145b0: 2020 2020 2020 2020 2052 6563 6f72 6453           RecordS
-000145c0: 7461 7465 2e72 6576 5f65 7863 6c75 6465  tate.rev_exclude
+0000ec60: 2020 2020 2020 2061 6e64 2072 6563 2e67         and rec.g
+0000ec70: 6574 286b 6579 2c20 2222 2920 213d 2022  et(key, "") != "
+0000ec80: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+0000ec90: 2020 2020 2020 2020 2020 616e 6420 7072            and pr
+0000eca0: 6576 5f76 616c 2021 3d20 2222 0a20 2020  ev_val != "".   
+0000ecb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ecc0: 2020 2020 2061 6e64 2072 6563 5b6b 6579       and rec[key
+0000ecd0: 5d20 6973 206e 6f74 204e 6f6e 650a 2020  ] is not None.  
+0000ece0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ecf0: 2020 293a 0a20 2020 2020 2020 2020 2020    ):.           
+0000ed00: 2020 2020 2020 2020 2020 2020 2073 696d               sim
+0000ed10: 696c 6172 6974 7920 3d20 6675 7a7a 2e70  ilarity = fuzz.p
+0000ed20: 6172 7469 616c 5f72 6174 696f 2870 7265  artial_ratio(pre
+0000ed30: 765f 7661 6c2c 2072 6563 5b6b 6579 5d29  v_val, rec[key])
+0000ed40: 202f 2031 3030 0a20 2020 2020 2020 2020   / 100.         
+0000ed50: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000ed60: 204e 6f74 6520 3a20 7468 6520 6675 7a7a   Note : the fuzz
+0000ed70: 2e70 6172 7469 616c 5f72 6174 696f 2077  .partial_ratio w
+0000ed80: 6f72 6b73 2062 6574 7465 7220 666f 7220  orks better for 
+0000ed90: 7061 7274 6961 6c20 7375 6273 7472 696e  partial substrin
+0000eda0: 6773 0a20 2020 2020 2020 2020 2020 2020  gs.             
+0000edb0: 2020 2020 2020 2020 2020 2023 2066 726f             # fro
+0000edc0: 6d20 6469 6666 6c69 6220 696d 706f 7274  m difflib import
+0000edd0: 2053 6571 7565 6e63 654d 6174 6368 6572   SequenceMatcher
+0000ede0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000edf0: 2020 2020 2020 2020 2023 2073 696d 696c           # simil
+0000ee00: 6172 6974 7920 3d20 5365 7175 656e 6365  arity = Sequence
+0000ee10: 4d61 7463 6865 7228 4e6f 6e65 2c20 7072  Matcher(None, pr
+0000ee20: 6576 5f76 616c 2c20 7265 635b 6b65 795d  ev_val, rec[key]
+0000ee30: 292e 7261 7469 6f28 290a 2020 2020 2020  ).ratio().      
+0000ee40: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0000ee50: 2073 696d 696c 6172 6974 7920 3c20 302e   similarity < 0.
+0000ee60: 3520 6f72 206b 6579 2069 6e20 5b0a 2020  5 or key in [.  
+0000ee70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ee80: 2020 2020 2020 2276 6f6c 756d 6522 2c0a        "volume",.
+0000ee90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eea0: 2020 2020 2020 2020 226e 756d 6265 7222          "number"
+0000eeb0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000eec0: 2020 2020 2020 2020 2020 2279 6561 7222            "year"
+0000eed0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000eee0: 2020 2020 2020 5d3a 0a20 2020 2020 2020        ]:.       
+0000eef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ef00: 206c 696e 6520 3d20 6622 7b63 6f6c 6f72   line = f"{color
+0000ef10: 732e 5245 447d 7b72 6563 2e67 6574 286b  s.RED}{rec.get(k
+0000ef20: 6579 2c20 2727 297d 7b63 6f6c 6f72 732e  ey, '')}{colors.
+0000ef30: 454e 447d 220a 2020 2020 2020 2020 2020  END}".          
+0000ef40: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+0000ef50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ef60: 2020 2020 2020 2020 6c69 6e65 203d 2070          line = p
+0000ef70: 7269 6e74 5f64 6966 6628 2870 7265 765f  rint_diff((prev_
+0000ef80: 7661 6c2c 2072 6563 2e67 6574 286b 6579  val, rec.get(key
+0000ef90: 2c20 2222 2929 290a 2020 2020 2020 2020  , ""))).        
+0000efa0: 2020 2020 2020 2020 7072 696e 7428 6622          print(f"
+0000efb0: 7b6b 6579 7d20 3a20 7b6c 696e 657d 2229  {key} : {line}")
+0000efc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000efd0: 2070 7265 765f 7661 6c20 3d20 7265 632e   prev_val = rec.
+0000efe0: 6765 7428 6b65 792c 2022 2229 0a20 2020  get(key, "").   
+0000eff0: 2020 2020 2020 2020 2070 7269 6e74 2829           print()
+0000f000: 0a0a 2020 2020 6465 6620 636c 6561 6e75  ..    def cleanu
+0000f010: 705f 7064 665f 7072 6f63 6573 7369 6e67  p_pdf_processing
+0000f020: 5f66 6965 6c64 7328 7365 6c66 2920 2d3e  _fields(self) ->
+0000f030: 204e 6f6e 653a 0a20 2020 2020 2020 2022   None:.        "
+0000f040: 2222 436c 6561 6e75 7020 7468 6520 5044  ""Cleanup the PD
+0000f050: 4620 7072 6f63 6573 7369 6e67 2066 6965  F processing fie
+0000f060: 6c73 2028 7465 7874 5f66 726f 6d5f 7064  ls (text_from_pd
+0000f070: 662c 2070 6167 6573 5f69 6e5f 6669 6c65  f, pages_in_file
+0000f080: 2922 2222 0a20 2020 2020 2020 2069 6620  )""".        if 
+0000f090: 2274 6578 745f 6672 6f6d 5f70 6466 2220  "text_from_pdf" 
+0000f0a0: 696e 2073 656c 662e 6461 7461 3a0a 2020  in self.data:.  
+0000f0b0: 2020 2020 2020 2020 2020 6465 6c20 7365            del se
+0000f0c0: 6c66 2e64 6174 615b 2274 6578 745f 6672  lf.data["text_fr
+0000f0d0: 6f6d 5f70 6466 225d 0a20 2020 2020 2020  om_pdf"].       
+0000f0e0: 2069 6620 2270 6167 6573 5f69 6e5f 6669   if "pages_in_fi
+0000f0f0: 6c65 2220 696e 2073 656c 662e 6461 7461  le" in self.data
+0000f100: 3a0a 2020 2020 2020 2020 2020 2020 6465  :.            de
+0000f110: 6c20 7365 6c66 2e64 6174 615b 2270 6167  l self.data["pag
+0000f120: 6573 5f69 6e5f 6669 6c65 225d 0a0a 2020  es_in_file"]..  
+0000f130: 2020 6465 6620 7570 6461 7465 5f6d 6173    def update_mas
+0000f140: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
+0000f150: 6365 280a 2020 2020 2020 2020 7365 6c66  ce(.        self
+0000f160: 2c20 2a2c 2071 6d3a 2063 6f6c 7265 762e  , *, qm: colrev.
+0000f170: 716d 2e71 7561 6c69 7479 5f6d 6f64 656c  qm.quality_model
+0000f180: 2e51 7561 6c69 7479 4d6f 6465 6c2c 2073  .QualityModel, s
+0000f190: 6574 5f70 7265 7061 7265 643a 2062 6f6f  et_prepared: boo
+0000f1a0: 6c20 3d20 4661 6c73 650a 2020 2020 2920  l = False.    ) 
+0000f1b0: 2d3e 204e 6f6e 653a 0a20 2020 2020 2020  -> None:.       
+0000f1c0: 2022 2222 5570 6461 7465 2074 6865 206d   """Update the m
+0000f1d0: 6173 7465 7264 6174 6120 7072 6f76 656e  asterdata proven
+0000f1e0: 616e 6365 2222 220a 0a20 2020 2020 2020  ance"""..       
+0000f1f0: 2069 6620 2263 6f6c 7265 765f 6d61 7374   if "colrev_mast
+0000f200: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
+0000f210: 6522 206e 6f74 2069 6e20 7365 6c66 2e64  e" not in self.d
+0000f220: 6174 613a 0a20 2020 2020 2020 2020 2020  ata:.           
+0000f230: 2073 656c 662e 6461 7461 5b22 636f 6c72   self.data["colr
+0000f240: 6576 5f6d 6173 7465 7264 6174 615f 7072  ev_masterdata_pr
+0000f250: 6f76 656e 616e 6365 225d 203d 207b 7d0a  ovenance"] = {}.
+0000f260: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
+0000f270: 2e6d 6173 7465 7264 6174 615f 6973 5f63  .masterdata_is_c
+0000f280: 7572 6174 6564 2829 3a0a 2020 2020 2020  urated():.      
+0000f290: 2020 2020 2020 7265 7475 726e 0a0a 2020        return..  
+0000f2a0: 2020 2020 2020 2320 4170 706c 7920 7468        # Apply th
+0000f2b0: 6520 6368 6563 6b65 7273 2028 696e 636c  e checkers (incl
+0000f2c0: 7564 696e 6720 6669 656c 6420 6b65 7920  uding field key 
+0000f2d0: 7265 7175 6972 656d 656e 7473 2065 7463  requirements etc
+0000f2e0: 2e29 0a20 2020 2020 2020 2071 6d2e 7275  .).        qm.ru
+0000f2f0: 6e28 7265 636f 7264 3d73 656c 6629 0a0a  n(record=self)..
+0000f300: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+0000f310: 6861 735f 7175 616c 6974 795f 6465 6665  has_quality_defe
+0000f320: 6374 7328 293a 0a20 2020 2020 2020 2020  cts():.         
+0000f330: 2020 2073 656c 662e 7365 745f 7374 6174     self.set_stat
+0000f340: 7573 2874 6172 6765 745f 7374 6174 653d  us(target_state=
+0000f350: 5265 636f 7264 5374 6174 652e 6d64 5f6e  RecordState.md_n
+0000f360: 6565 6473 5f6d 616e 7561 6c5f 7072 6570  eeds_manual_prep
+0000f370: 6172 6174 696f 6e29 0a20 2020 2020 2020  aration).       
+0000f380: 2065 6c69 6620 7365 745f 7072 6570 6172   elif set_prepar
+0000f390: 6564 3a0a 2020 2020 2020 2020 2020 2020  ed:.            
+0000f3a0: 7365 6c66 2e73 6574 5f73 7461 7475 7328  self.set_status(
+0000f3b0: 7461 7267 6574 5f73 7461 7465 3d52 6563  target_state=Rec
+0000f3c0: 6f72 6453 7461 7465 2e6d 645f 7072 6570  ordState.md_prep
+0000f3d0: 6172 6564 290a 0a20 2020 2064 6566 2063  ared)..    def c
+0000f3e0: 6865 636b 5f70 6f74 656e 7469 616c 5f72  heck_potential_r
+0000f3f0: 6574 7261 6374 7328 7365 6c66 2920 2d3e  etracts(self) ->
+0000f400: 2062 6f6f 6c3a 0a20 2020 2020 2020 2022   bool:.        "
+0000f410: 2222 4368 6563 6b20 666f 7220 706f 7465  ""Check for pote
+0000f420: 6e74 6961 6c20 7265 7472 6163 7473 2222  ntial retracts""
+0000f430: 220a 2020 2020 2020 2020 2320 4e6f 7465  ".        # Note
+0000f440: 203a 2077 6520 7265 7472 6965 7665 6420   : we retrieved 
+0000f450: 6d65 7461 6461 7461 2069 6e20 6765 745f  metadata in get_
+0000f460: 6d61 7374 6572 6461 7461 5f66 726f 6d5f  masterdata_from_
+0000f470: 6372 6f73 7372 6566 2829 0a20 2020 2020  crossref().     
+0000f480: 2020 2069 6620 7365 6c66 2e64 6174 612e     if self.data.
+0000f490: 6765 7428 2263 726f 7373 6d61 726b 222c  get("crossmark",
+0000f4a0: 2022 2229 203d 3d20 2254 7275 6522 3a0a   "") == "True":.
+0000f4b0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000f4c0: 2e70 7265 7363 7265 656e 5f65 7863 6c75  .prescreen_exclu
+0000f4d0: 6465 2872 6561 736f 6e3d 2272 6574 7261  de(reason="retra
+0000f4e0: 6374 6564 222c 2070 7269 6e74 5f77 6172  cted", print_war
+0000f4f0: 6e69 6e67 3d54 7275 6529 0a20 2020 2020  ning=True).     
+0000f500: 2020 2020 2020 2073 656c 662e 7265 6d6f         self.remo
+0000f510: 7665 5f66 6965 6c64 286b 6579 3d22 6372  ve_field(key="cr
+0000f520: 6f73 736d 6172 6b22 290a 2020 2020 2020  ossmark").      
+0000f530: 2020 2020 2020 7265 7475 726e 2054 7275        return Tru
+0000f540: 650a 2020 2020 2020 2020 6966 2073 656c  e.        if sel
+0000f550: 662e 6461 7461 2e67 6574 2822 7761 726e  f.data.get("warn
+0000f560: 696e 6722 2c20 2222 2920 3d3d 2022 5769  ing", "") == "Wi
+0000f570: 7468 6472 6177 6e20 2861 6363 6f72 6469  thdrawn (accordi
+0000f580: 6e67 2074 6f20 4442 4c50 2922 3a0a 2020  ng to DBLP)":.  
+0000f590: 2020 2020 2020 2020 2020 7365 6c66 2e70            self.p
+0000f5a0: 7265 7363 7265 656e 5f65 7863 6c75 6465  rescreen_exclude
+0000f5b0: 2872 6561 736f 6e3d 2272 6574 7261 6374  (reason="retract
+0000f5c0: 6564 222c 2070 7269 6e74 5f77 6172 6e69  ed", print_warni
+0000f5d0: 6e67 3d54 7275 6529 0a20 2020 2020 2020  ng=True).       
+0000f5e0: 2020 2020 2073 656c 662e 7265 6d6f 7665       self.remove
+0000f5f0: 5f66 6965 6c64 286b 6579 3d22 7761 726e  _field(key="warn
+0000f600: 696e 6722 290a 2020 2020 2020 2020 2020  ing").          
+0000f610: 2020 7265 7475 726e 2054 7275 650a 2020    return True.  
+0000f620: 2020 2020 2020 7265 7475 726e 2046 616c        return Fal
+0000f630: 7365 0a0a 2020 2020 6465 6620 7072 696e  se..    def prin
+0000f640: 745f 7072 6573 6372 6565 6e5f 7265 636f  t_prescreen_reco
+0000f650: 7264 2873 656c 6629 202d 3e20 4e6f 6e65  rd(self) -> None
+0000f660: 3a0a 2020 2020 2020 2020 2222 2250 7269  :.        """Pri
+0000f670: 6e74 2074 6865 2072 6563 6f72 6420 666f  nt the record fo
+0000f680: 7220 7072 6573 6372 6565 6e20 6f70 6572  r prescreen oper
+0000f690: 6174 696f 6e73 2222 220a 0a20 2020 2020  ations"""..     
+0000f6a0: 2020 2072 6574 5f73 7472 203d 2066 2220     ret_str = f" 
+0000f6b0: 2049 443a 207b 7365 6c66 2e64 6174 615b   ID: {self.data[
+0000f6c0: 2749 4427 5d7d 2028 7b73 656c 662e 6461  'ID']} ({self.da
+0000f6d0: 7461 5b27 454e 5452 5954 5950 4527 5d7d  ta['ENTRYTYPE']}
+0000f6e0: 2922 0a20 2020 2020 2020 2072 6574 5f73  )".        ret_s
+0000f6f0: 7472 202b 3d20 280a 2020 2020 2020 2020  tr += (.        
+0000f700: 2020 2020 6622 5c6e 2020 7b63 6f6c 6f72      f"\n  {color
+0000f710: 732e 4752 4545 4e7d 7b73 656c 662e 6461  s.GREEN}{self.da
+0000f720: 7461 2e67 6574 2827 7469 746c 6527 2c20  ta.get('title', 
+0000f730: 276e 6f20 7469 746c 6527 297d 7b63 6f6c  'no title')}{col
+0000f740: 6f72 732e 454e 447d 220a 2020 2020 2020  ors.END}".      
+0000f750: 2020 2020 2020 6622 5c6e 2020 7b73 656c        f"\n  {sel
+0000f760: 662e 6461 7461 2e67 6574 2827 6175 7468  f.data.get('auth
+0000f770: 6f72 272c 2027 6e6f 2d61 7574 686f 7227  or', 'no-author'
+0000f780: 297d 220a 2020 2020 2020 2020 290a 2020  )}".        ).  
+0000f790: 2020 2020 2020 6966 2073 656c 662e 6461        if self.da
+0000f7a0: 7461 5b22 454e 5452 5954 5950 4522 5d20  ta["ENTRYTYPE"] 
+0000f7b0: 3d3d 2022 6172 7469 636c 6522 3a0a 2020  == "article":.  
+0000f7c0: 2020 2020 2020 2020 2020 7265 745f 7374            ret_st
+0000f7d0: 7220 2b3d 2028 0a20 2020 2020 2020 2020  r += (.         
+0000f7e0: 2020 2020 2020 2066 225c 6e20 207b 7365         f"\n  {se
+0000f7f0: 6c66 2e64 6174 612e 6765 7428 276a 6f75  lf.data.get('jou
+0000f800: 726e 616c 272c 2027 6e6f 2d6a 6f75 726e  rnal', 'no-journ
+0000f810: 616c 2729 7d20 220a 2020 2020 2020 2020  al')} ".        
+0000f820: 2020 2020 2020 2020 6622 287b 7365 6c66          f"({self
+0000f830: 2e64 6174 612e 6765 7428 2779 6561 7227  .data.get('year'
+0000f840: 2c20 276e 6f2d 7965 6172 2729 7d29 2022  , 'no-year')}) "
+0000f850: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000f860: 2066 227b 7365 6c66 2e64 6174 612e 6765   f"{self.data.ge
+0000f870: 7428 2776 6f6c 756d 6527 2c20 276e 6f2d  t('volume', 'no-
+0000f880: 766f 6c75 6d65 2729 7d22 0a20 2020 2020  volume')}".     
+0000f890: 2020 2020 2020 2020 2020 2066 2228 7b73             f"({s
+0000f8a0: 656c 662e 6461 7461 2e67 6574 2827 6e75  elf.data.get('nu
+0000f8b0: 6d62 6572 272c 2027 2729 7d29 220a 2020  mber', '')})".  
+0000f8c0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+0000f8d0: 2020 2020 656c 6966 2073 656c 662e 6461      elif self.da
+0000f8e0: 7461 5b22 454e 5452 5954 5950 4522 5d20  ta["ENTRYTYPE"] 
+0000f8f0: 3d3d 2022 696e 7072 6f63 6565 6469 6e67  == "inproceeding
+0000f900: 7322 3a0a 2020 2020 2020 2020 2020 2020  s":.            
+0000f910: 7265 745f 7374 7220 2b3d 2066 225c 6e20  ret_str += f"\n 
+0000f920: 207b 7365 6c66 2e64 6174 612e 6765 7428   {self.data.get(
+0000f930: 2762 6f6f 6b74 6974 6c65 272c 2027 6e6f  'booktitle', 'no
+0000f940: 2d62 6f6f 6b74 6974 6c65 2729 7d22 0a20  -booktitle')}". 
+0000f950: 2020 2020 2020 2069 6620 2261 6273 7472         if "abstr
+0000f960: 6163 7422 2069 6e20 7365 6c66 2e64 6174  act" in self.dat
+0000f970: 613a 0a20 2020 2020 2020 2020 2020 206c  a:.            l
+0000f980: 696e 6573 203d 2074 6578 7477 7261 702e  ines = textwrap.
+0000f990: 7772 6170 2873 656c 662e 6461 7461 5b22  wrap(self.data["
+0000f9a0: 6162 7374 7261 6374 225d 2c20 3130 302c  abstract"], 100,
+0000f9b0: 2062 7265 616b 5f6c 6f6e 675f 776f 7264   break_long_word
+0000f9c0: 733d 4661 6c73 6529 0a20 2020 2020 2020  s=False).       
+0000f9d0: 2020 2020 2069 6620 6c69 6e65 733a 0a20       if lines:. 
+0000f9e0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+0000f9f0: 6574 5f73 7472 202b 3d20 6622 5c6e 2020  et_str += f"\n  
+0000fa00: 4162 7374 7261 6374 3a20 7b6c 696e 6573  Abstract: {lines
+0000fa10: 2e70 6f70 2830 297d 5c6e 220a 2020 2020  .pop(0)}\n".    
+0000fa20: 2020 2020 2020 2020 2020 2020 7265 745f              ret_
+0000fa30: 7374 7220 2b3d 2022 5c6e 2020 222e 6a6f  str += "\n  ".jo
+0000fa40: 696e 286c 696e 6573 2920 2b20 2222 0a0a  in(lines) + ""..
+0000fa50: 2020 2020 2020 2020 6966 2022 7572 6c22          if "url"
+0000fa60: 2069 6e20 7365 6c66 2e64 6174 613a 0a20   in self.data:. 
+0000fa70: 2020 2020 2020 2020 2020 2072 6574 5f73             ret_s
+0000fa80: 7472 202b 3d20 6622 5c6e 2020 7572 6c3a  tr += f"\n  url:
+0000fa90: 207b 7365 6c66 2e64 6174 615b 2775 726c   {self.data['url
+0000faa0: 275d 7d22 0a0a 2020 2020 2020 2020 6966  ']}"..        if
+0000fab0: 2022 6669 6c65 2220 696e 2073 656c 662e   "file" in self.
+0000fac0: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
+0000fad0: 2020 7265 745f 7374 7220 2b3d 2066 225c    ret_str += f"\
+0000fae0: 6e20 2066 696c 653a 207b 7365 6c66 2e64  n  file: {self.d
+0000faf0: 6174 615b 2766 696c 6527 5d7d 220a 0a20  ata['file']}".. 
+0000fb00: 2020 2020 2020 2070 7269 6e74 2872 6574         print(ret
+0000fb10: 5f73 7472 290a 0a20 2020 2064 6566 2070  _str)..    def p
+0000fb20: 7269 6e74 5f70 6466 5f70 7265 705f 6d61  rint_pdf_prep_ma
+0000fb30: 6e28 7365 6c66 2920 2d3e 204e 6f6e 653a  n(self) -> None:
+0000fb40: 0a20 2020 2020 2020 2022 2222 5072 696e  .        """Prin
+0000fb50: 7420 7468 6520 7265 636f 7264 2066 6f72  t the record for
+0000fb60: 2070 6466 2d70 7265 702d 6d61 6e20 6f70   pdf-prep-man op
+0000fb70: 6572 6174 696f 6e73 2222 220a 2020 2020  erations""".    
+0000fb80: 2020 2020 2320 7079 6c69 6e74 3a20 6469      # pylint: di
+0000fb90: 7361 626c 653d 746f 6f2d 6d61 6e79 2d62  sable=too-many-b
+0000fba0: 7261 6e63 6865 730a 2020 2020 2020 2020  ranches.        
+0000fbb0: 7265 745f 7374 7220 3d20 2222 0a20 2020  ret_str = "".   
+0000fbc0: 2020 2020 2069 6620 2266 696c 6522 2069       if "file" i
+0000fbd0: 6e20 7365 6c66 2e64 6174 613a 0a20 2020  n self.data:.   
+0000fbe0: 2020 2020 2020 2020 2072 6574 5f73 7472           ret_str
+0000fbf0: 202b 3d20 6622 5c6e 6669 6c65 3a20 7b63   += f"\nfile: {c
+0000fc00: 6f6c 6f72 732e 4f52 414e 4745 7d7b 7365  olors.ORANGE}{se
+0000fc10: 6c66 2e64 6174 615b 2766 696c 6527 5d7d  lf.data['file']}
+0000fc20: 7b63 6f6c 6f72 732e 454e 447d 5c6e 5c6e  {colors.END}\n\n
+0000fc30: 220a 0a20 2020 2020 2020 2070 6466 5f70  "..        pdf_p
+0000fc40: 7265 705f 6e6f 7465 203d 2073 656c 662e  rep_note = self.
+0000fc50: 6765 745f 6669 656c 645f 7072 6f76 656e  get_field_proven
+0000fc60: 616e 6365 286b 6579 3d22 6669 6c65 2229  ance(key="file")
+0000fc70: 0a0a 2020 2020 2020 2020 6966 2022 6175  ..        if "au
+0000fc80: 7468 6f72 5f6e 6f74 5f69 6e5f 6669 7273  thor_not_in_firs
+0000fc90: 745f 7061 6765 7322 2069 6e20 7064 665f  t_pages" in pdf_
+0000fca0: 7072 6570 5f6e 6f74 655b 226e 6f74 6522  prep_note["note"
+0000fcb0: 5d3a 0a20 2020 2020 2020 2020 2020 2072  ]:.            r
+0000fcc0: 6574 5f73 7472 202b 3d20 280a 2020 2020  et_str += (.    
+0000fcd0: 2020 2020 2020 2020 2020 2020 6622 7b63              f"{c
+0000fce0: 6f6c 6f72 732e 5245 447d 7b73 656c 662e  olors.RED}{self.
+0000fcf0: 6461 7461 2e67 6574 2827 6175 7468 6f72  data.get('author
+0000fd00: 272c 2027 6e6f 2d61 7574 686f 7227 297d  ', 'no-author')}
+0000fd10: 7b63 6f6c 6f72 732e 454e 447d 5c6e 220a  {colors.END}\n".
+0000fd20: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+0000fd30: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000fd40: 2020 2020 2020 2020 7265 745f 7374 7220          ret_str 
+0000fd50: 2b3d 2028 0a20 2020 2020 2020 2020 2020  += (.           
+0000fd60: 2020 2020 2066 227b 636f 6c6f 7273 2e47       f"{colors.G
+0000fd70: 5245 454e 7d7b 7365 6c66 2e64 6174 612e  REEN}{self.data.
+0000fd80: 6765 7428 2761 7574 686f 7227 2c20 276e  get('author', 'n
+0000fd90: 6f2d 6175 7468 6f72 2729 7d7b 636f 6c6f  o-author')}{colo
+0000fda0: 7273 2e45 4e44 7d5c 6e22 0a20 2020 2020  rs.END}\n".     
+0000fdb0: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
+0000fdc0: 2020 6966 2022 7469 746c 655f 6e6f 745f    if "title_not_
+0000fdd0: 696e 5f66 6972 7374 5f70 6167 6573 2220  in_first_pages" 
+0000fde0: 696e 2070 6466 5f70 7265 705f 6e6f 7465  in pdf_prep_note
+0000fdf0: 5b22 6e6f 7465 225d 3a0a 2020 2020 2020  ["note"]:.      
+0000fe00: 2020 2020 2020 7265 745f 7374 7220 2b3d        ret_str +=
+0000fe10: 2066 227b 636f 6c6f 7273 2e52 4544 7d7b   f"{colors.RED}{
+0000fe20: 7365 6c66 2e64 6174 612e 6765 7428 2774  self.data.get('t
+0000fe30: 6974 6c65 272c 2027 6e6f 2074 6974 6c65  itle', 'no title
+0000fe40: 2729 7d7b 636f 6c6f 7273 2e45 4e44 7d5c  ')}{colors.END}\
+0000fe50: 6e22 0a20 2020 2020 2020 2065 6c73 653a  n".        else:
+0000fe60: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0000fe70: 5f73 7472 202b 3d20 280a 2020 2020 2020  _str += (.      
+0000fe80: 2020 2020 2020 2020 2020 6622 7b63 6f6c            f"{col
+0000fe90: 6f72 732e 4752 4545 4e7d 7b73 656c 662e  ors.GREEN}{self.
+0000fea0: 6461 7461 2e67 6574 2827 7469 746c 6527  data.get('title'
+0000feb0: 2c20 276e 6f20 7469 746c 6527 297d 7b63  , 'no title')}{c
+0000fec0: 6f6c 6f72 732e 454e 447d 5c6e 220a 2020  olors.END}\n".  
+0000fed0: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
+0000fee0: 2020 2020 2069 6620 7365 6c66 2e64 6174       if self.dat
+0000fef0: 615b 2245 4e54 5259 5459 5045 225d 203d  a["ENTRYTYPE"] =
+0000ff00: 3d20 2261 7274 6963 6c65 223a 0a20 2020  = "article":.   
+0000ff10: 2020 2020 2020 2020 2072 6574 5f73 7472           ret_str
+0000ff20: 202b 3d20 280a 2020 2020 2020 2020 2020   += (.          
+0000ff30: 2020 2020 2020 6622 7b73 656c 662e 6461        f"{self.da
+0000ff40: 7461 2e67 6574 2827 6a6f 7572 6e61 6c27  ta.get('journal'
+0000ff50: 2c20 276e 6f2d 6a6f 7572 6e61 6c27 297d  , 'no-journal')}
+0000ff60: 2022 0a20 2020 2020 2020 2020 2020 2020   ".             
+0000ff70: 2020 2066 2228 7b73 656c 662e 6461 7461     f"({self.data
+0000ff80: 2e67 6574 2827 7965 6172 272c 2027 6e6f  .get('year', 'no
+0000ff90: 2d79 6561 7227 297d 2920 220a 2020 2020  -year')}) ".    
+0000ffa0: 2020 2020 2020 2020 2020 2020 6622 7b73              f"{s
+0000ffb0: 656c 662e 6461 7461 2e67 6574 2827 766f  elf.data.get('vo
+0000ffc0: 6c75 6d65 272c 2027 6e6f 2d76 6f6c 756d  lume', 'no-volum
+0000ffd0: 6527 297d 220a 2020 2020 2020 2020 2020  e')}".          
+0000ffe0: 2020 2020 2020 6622 287b 7365 6c66 2e64        f"({self.d
+0000fff0: 6174 612e 6765 7428 276e 756d 6265 7227  ata.get('number'
+00010000: 2c20 2727 297d 2922 0a20 2020 2020 2020  , '')})".       
+00010010: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
+00010020: 2020 2069 6620 2270 6167 6573 2220 696e     if "pages" in
+00010030: 2073 656c 662e 6461 7461 3a0a 2020 2020   self.data:.    
+00010040: 2020 2020 2020 2020 2020 2020 6966 2022              if "
+00010050: 6e72 5f70 6167 6573 5f6e 6f74 5f6d 6174  nr_pages_not_mat
+00010060: 6368 696e 6722 2069 6e20 7064 665f 7072  ching" in pdf_pr
+00010070: 6570 5f6e 6f74 655b 226e 6f74 6522 5d3a  ep_note["note"]:
+00010080: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010090: 2020 2020 2072 6574 5f73 7472 202b 3d20       ret_str += 
+000100a0: 6622 2c20 7b63 6f6c 6f72 732e 5245 447d  f", {colors.RED}
+000100b0: 7070 2e7b 7365 6c66 2e64 6174 615b 2770  pp.{self.data['p
+000100c0: 6167 6573 275d 7d7b 636f 6c6f 7273 2e45  ages']}{colors.E
+000100d0: 4e44 7d5c 6e22 0a20 2020 2020 2020 2020  ND}\n".         
+000100e0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+000100f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010100: 2072 6574 5f73 7472 202b 3d20 6622 2c20   ret_str += f", 
+00010110: 7070 2e7b 636f 6c6f 7273 2e47 5245 454e  pp.{colors.GREEN
+00010120: 7d7b 7365 6c66 2e64 6174 615b 2770 6167  }{self.data['pag
+00010130: 6573 275d 7d7b 636f 6c6f 7273 2e45 4e44  es']}{colors.END
+00010140: 7d5c 6e22 0a20 2020 2020 2020 2020 2020  }\n".           
+00010150: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00010160: 2020 2020 2020 2072 6574 5f73 7472 202b         ret_str +
+00010170: 3d20 225c 6e22 0a20 2020 2020 2020 2065  = "\n".        e
+00010180: 6c69 6620 7365 6c66 2e64 6174 615b 2245  lif self.data["E
+00010190: 4e54 5259 5459 5045 225d 203d 3d20 2269  NTRYTYPE"] == "i
+000101a0: 6e70 726f 6365 6564 696e 6773 223a 0a20  nproceedings":. 
+000101b0: 2020 2020 2020 2020 2020 2072 6574 5f73             ret_s
+000101c0: 7472 202b 3d20 6622 7b73 656c 662e 6461  tr += f"{self.da
+000101d0: 7461 2e67 6574 2827 626f 6f6b 7469 746c  ta.get('booktitl
+000101e0: 6527 2c20 276e 6f2d 626f 6f6b 7469 746c  e', 'no-booktitl
+000101f0: 6527 297d 5c6e 220a 2020 2020 2020 2020  e')}\n".        
+00010200: 6966 2022 6162 7374 7261 6374 2220 696e  if "abstract" in
+00010210: 2073 656c 662e 6461 7461 3a0a 2020 2020   self.data:.    
+00010220: 2020 2020 2020 2020 6c69 6e65 7320 3d20          lines = 
+00010230: 7465 7874 7772 6170 2e77 7261 7028 7365  textwrap.wrap(se
+00010240: 6c66 2e64 6174 615b 2261 6273 7472 6163  lf.data["abstrac
+00010250: 7422 5d2c 2031 3030 2c20 6272 6561 6b5f  t"], 100, break_
+00010260: 6c6f 6e67 5f77 6f72 6473 3d46 616c 7365  long_words=False
+00010270: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+00010280: 745f 7374 7220 2b3d 2066 225c 6e41 6273  t_str += f"\nAbs
+00010290: 7472 6163 743a 207b 6c69 6e65 732e 706f  tract: {lines.po
+000102a0: 7028 3029 7d5c 6e22 0a20 2020 2020 2020  p(0)}\n".       
+000102b0: 2020 2020 2072 6574 5f73 7472 202b 3d20       ret_str += 
+000102c0: 225c 6e22 2e6a 6f69 6e28 6c69 6e65 7329  "\n".join(lines)
+000102d0: 202b 2022 5c6e 220a 0a20 2020 2020 2020   + "\n"..       
+000102e0: 2069 6620 2275 726c 2220 696e 2073 656c   if "url" in sel
+000102f0: 662e 6461 7461 3a0a 2020 2020 2020 2020  f.data:.        
+00010300: 2020 2020 7265 745f 7374 7220 2b3d 2066      ret_str += f
+00010310: 225c 6e75 726c 3a20 7b73 656c 662e 6461  "\nurl: {self.da
+00010320: 7461 5b27 7572 6c27 5d7d 5c6e 220a 0a20  ta['url']}\n".. 
+00010330: 2020 2020 2020 2070 7269 6e74 2872 6574         print(ret
+00010340: 5f73 7472 290a 0a0a 636c 6173 7320 5072  _str)...class Pr
+00010350: 6570 5265 636f 7264 2852 6563 6f72 6429  epRecord(Record)
+00010360: 3a0a 2020 2020 2222 2254 6865 2050 7265  :.    """The Pre
+00010370: 7052 6563 6f72 6420 636c 6173 7320 7072  pRecord class pr
+00010380: 6f76 6964 6573 2061 2072 616e 6765 206f  ovides a range o
+00010390: 6620 636f 6e76 656e 6965 6e63 6520 6675  f convenience fu
+000103a0: 6e63 7469 6f6e 7320 666f 7220 7265 636f  nctions for reco
+000103b0: 7264 2070 7265 7061 7261 7469 6f6e 2222  rd preparation""
+000103c0: 220a 0a20 2020 2040 636c 6173 736d 6574  "..    @classmet
+000103d0: 686f 640a 2020 2020 6465 6620 666f 726d  hod.    def form
+000103e0: 6174 5f61 7574 686f 725f 6669 656c 6428  at_author_field(
+000103f0: 636c 732c 202a 2c20 696e 7075 745f 7374  cls, *, input_st
+00010400: 7269 6e67 3a20 7374 7229 202d 3e20 7374  ring: str) -> st
+00010410: 723a 0a20 2020 2020 2020 2022 2222 466f  r:.        """Fo
+00010420: 726d 6174 2074 6865 2061 7574 686f 7220  rmat the author 
+00010430: 6669 656c 6420 2872 6563 6f67 6e69 7a69  field (recognizi
+00010440: 6e67 2066 6972 7374 2f6c 6173 7420 6e61  ng first/last na
+00010450: 6d65 7320 6261 7365 6420 6f6e 2048 756d  mes based on Hum
+00010460: 616e 4e61 6d65 2070 6172 7365 7229 2222  anName parser)""
+00010470: 220a 0a20 2020 2020 2020 2064 6566 206d  "..        def m
+00010480: 6f73 746c 795f 7570 7065 725f 6361 7365  ostly_upper_case
+00010490: 2869 6e70 7574 5f73 7472 696e 673a 2073  (input_string: s
+000104a0: 7472 2920 2d3e 2062 6f6f 6c3a 0a20 2020  tr) -> bool:.   
+000104b0: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
+000104c0: 7265 2e6d 6174 6368 2872 225b 612d 7a41  re.match(r"[a-zA
+000104d0: 2d5a 5d2b 222c 2069 6e70 7574 5f73 7472  -Z]+", input_str
+000104e0: 696e 6729 3a0a 2020 2020 2020 2020 2020  ing):.          
+000104f0: 2020 2020 2020 7265 7475 726e 2046 616c        return Fal
+00010500: 7365 0a20 2020 2020 2020 2020 2020 2069  se.            i
+00010510: 6e70 7574 5f73 7472 696e 6720 3d20 696e  nput_string = in
+00010520: 7075 745f 7374 7269 6e67 2e72 6570 6c61  put_string.repla
+00010530: 6365 2822 2e22 2c20 2222 292e 7265 706c  ce(".", "").repl
+00010540: 6163 6528 222c 222c 2022 2229 0a20 2020  ace(",", "").   
+00010550: 2020 2020 2020 2020 2077 6f72 6473 203d           words =
+00010560: 2069 6e70 7574 5f73 7472 696e 672e 7370   input_string.sp
+00010570: 6c69 7428 290a 2020 2020 2020 2020 2020  lit().          
+00010580: 2020 7265 7475 726e 2073 756d 2877 6f72    return sum(wor
+00010590: 642e 6973 7570 7065 7228 2920 666f 7220  d.isupper() for 
+000105a0: 776f 7264 2069 6e20 776f 7264 7329 202f  word in words) /
+000105b0: 206c 656e 2877 6f72 6473 2920 3e20 302e   len(words) > 0.
+000105c0: 380a 0a20 2020 2020 2020 2069 6e70 7574  8..        input
+000105d0: 5f73 7472 696e 6720 3d20 696e 7075 745f  _string = input_
+000105e0: 7374 7269 6e67 2e72 6570 6c61 6365 2822  string.replace("
+000105f0: 5c6e 222c 2022 2022 290a 2020 2020 2020  \n", " ").      
+00010600: 2020 2320 4442 4c50 2061 7070 656e 6473    # DBLP appends
+00010610: 2069 6465 6e74 6966 6965 7273 2074 6f20   identifiers to 
+00010620: 6e6f 6e2d 756e 6971 7565 2061 7574 686f  non-unique autho
+00010630: 7273 0a20 2020 2020 2020 2069 6e70 7574  rs.        input
+00010640: 5f73 7472 696e 6720 3d20 7374 7228 7265  _string = str(re
+00010650: 2e73 7562 2872 225b 302d 395d 7b34 7d22  .sub(r"[0-9]{4}"
+00010660: 2c20 2222 2c20 696e 7075 745f 7374 7269  , "", input_stri
+00010670: 6e67 2929 0a0a 2020 2020 2020 2020 6966  ng))..        if
+00010680: 2022 2061 6e64 2022 2069 6e20 696e 7075   " and " in inpu
+00010690: 745f 7374 7269 6e67 3a0a 2020 2020 2020  t_string:.      
+000106a0: 2020 2020 2020 6e61 6d65 7320 3d20 696e        names = in
+000106b0: 7075 745f 7374 7269 6e67 2e73 706c 6974  put_string.split
+000106c0: 2822 2061 6e64 2022 290a 2020 2020 2020  (" and ").      
+000106d0: 2020 656c 6966 2069 6e70 7574 5f73 7472    elif input_str
+000106e0: 696e 672e 636f 756e 7428 222c 2229 203e  ing.count(",") >
+000106f0: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
+00010700: 6e61 6d65 7320 3d20 696e 7075 745f 7374  names = input_st
+00010710: 7269 6e67 2e73 706c 6974 2822 2c20 2229  ring.split(", ")
+00010720: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+00010730: 2020 2020 2020 2020 2020 206e 616d 6573             names
+00010740: 203d 205b 696e 7075 745f 7374 7269 6e67   = [input_string
+00010750: 5d0a 2020 2020 2020 2020 6175 7468 6f72  ].        author
+00010760: 5f73 7472 696e 6720 3d20 2222 0a20 2020  _string = "".   
+00010770: 2020 2020 2066 6f72 206e 616d 6520 696e       for name in
+00010780: 206e 616d 6573 3a0a 2020 2020 2020 2020   names:.        
+00010790: 2020 2020 2320 4e6f 7465 3a20 6874 7470      # Note: http
+000107a0: 733a 2f2f 6769 7468 7562 2e63 6f6d 2f64  s://github.com/d
+000107b0: 6572 656b 3733 2f70 7974 686f 6e2d 6e61  erek73/python-na
+000107c0: 6d65 7061 7273 6572 0a20 2020 2020 2020  meparser.       
+000107d0: 2020 2020 2023 2069 7320 7665 7279 2065       # is very e
+000107e0: 6666 6563 7469 7665 2028 6d61 7962 6520  ffective (maybe 
+000107f0: 6e6f 7420 7065 7266 6563 7429 0a0a 2020  not perfect)..  
+00010800: 2020 2020 2020 2020 2020 7061 7273 6564            parsed
+00010810: 5f6e 616d 6520 3d20 4875 6d61 6e4e 616d  _name = HumanNam
+00010820: 6528 6e61 6d65 290a 2020 2020 2020 2020  e(name).        
+00010830: 2020 2020 6966 206d 6f73 746c 795f 7570      if mostly_up
+00010840: 7065 725f 6361 7365 2869 6e70 7574 5f73  per_case(input_s
+00010850: 7472 696e 672e 7265 706c 6163 6528 2220  tring.replace(" 
+00010860: 616e 6420 222c 2022 2229 2e72 6570 6c61  and ", "").repla
+00010870: 6365 2822 4a72 222c 2022 2229 293a 0a20  ce("Jr", "")):. 
+00010880: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+00010890: 6172 7365 645f 6e61 6d65 2e63 6170 6974  arsed_name.capit
+000108a0: 616c 697a 6528 666f 7263 653d 5472 7565  alize(force=True
+000108b0: 290a 0a20 2020 2020 2020 2020 2020 2023  )..            #
+000108c0: 2046 6978 2074 7970 6963 616c 2070 6172   Fix typical par
+000108d0: 7365 7220 6572 726f 720a 2020 2020 2020  ser error.      
+000108e0: 2020 2020 2020 6966 2070 6172 7365 645f        if parsed_
+000108f0: 6e61 6d65 2e6c 6173 7420 3d3d 2022 2220  name.last == "" 
+00010900: 616e 6420 7061 7273 6564 5f6e 616d 652e  and parsed_name.
+00010910: 7469 746c 6520 213d 2022 223a 0a20 2020  title != "":.   
+00010920: 2020 2020 2020 2020 2020 2020 2070 6172               par
+00010930: 7365 645f 6e61 6d65 2e6c 6173 7420 3d20  sed_name.last = 
+00010940: 7061 7273 6564 5f6e 616d 652e 7469 746c  parsed_name.titl
+00010950: 650a 0a20 2020 2020 2020 2020 2020 2023  e..            #
+00010960: 2070 796c 696e 743a 2064 6973 6162 6c65   pylint: disable
+00010970: 3d63 6861 696e 6564 2d63 6f6d 7061 7269  =chained-compari
+00010980: 736f 6e0a 2020 2020 2020 2020 2020 2020  son.            
+00010990: 2320 4669 783a 2077 6865 6e20 6669 7273  # Fix: when firs
+000109a0: 7420 6e61 6d65 7320 6172 6520 6162 6272  t names are abbr
+000109b0: 6576 6961 7465 642c 206e 616d 6570 6172  eviated, namepar
+000109c0: 7365 7220 6372 6561 7465 7320 6572 726f  ser creates erro
+000109d0: 7273 3a0a 2020 2020 2020 2020 2020 2020  rs:.            
+000109e0: 6966 2028 0a20 2020 2020 2020 2020 2020  if (.           
+000109f0: 2020 2020 206c 656e 2870 6172 7365 645f       len(parsed_
+00010a00: 6e61 6d65 2e6c 6173 7429 203c 3d20 330a  name.last) <= 3.
+00010a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010a20: 616e 6420 7061 7273 6564 5f6e 616d 652e  and parsed_name.
+00010a30: 6c61 7374 2e69 7375 7070 6572 2829 0a20  last.isupper(). 
+00010a40: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+00010a50: 6e64 206c 656e 2870 6172 7365 645f 6e61  nd len(parsed_na
+00010a60: 6d65 2e66 6972 7374 2920 3e20 330a 2020  me.first) > 3.  
+00010a70: 2020 2020 2020 2020 2020 2020 2020 616e                an
+00010a80: 6420 6e6f 7420 7061 7273 6564 5f6e 616d  d not parsed_nam
+00010a90: 652e 6669 7273 742e 6973 7570 7065 7228  e.first.isupper(
+00010aa0: 290a 2020 2020 2020 2020 2020 2020 293a  ).            ):
+00010ab0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010ac0: 2023 2069 6e20 7468 6573 6520 6361 7365   # in these case
+00010ad0: 6573 2c20 6669 7273 7420 616e 6420 6c61  es, first and la
+00010ae0: 7374 206e 616d 6573 2061 7265 2063 6f6e  st names are con
+00010af0: 6675 7365 640a 2020 2020 2020 2020 2020  fused.          
+00010b00: 2020 2020 2020 6175 7468 6f72 5f6e 616d        author_nam
+00010b10: 655f 7374 7269 6e67 203d 2070 6172 7365  e_string = parse
+00010b20: 645f 6e61 6d65 2e66 6972 7374 202b 2022  d_name.first + "
+00010b30: 2c20 2220 2b20 7061 7273 6564 5f6e 616d  , " + parsed_nam
+00010b40: 652e 6c61 7374 0a20 2020 2020 2020 2020  e.last.         
+00010b50: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00010b60: 2020 2020 2020 2020 2070 6172 7365 645f           parsed_
+00010b70: 6e61 6d65 2e73 7472 696e 675f 666f 726d  name.string_form
+00010b80: 6174 203d 2022 7b6c 6173 747d 207b 7375  at = "{last} {su
+00010b90: 6666 6978 7d2c 207b 6669 7273 747d 207b  ffix}, {first} {
+00010ba0: 6d69 6464 6c65 7d22 0a20 2020 2020 2020  middle}".       
+00010bb0: 2020 2020 2020 2020 2023 2027 7b6c 6173           # '{las
+00010bc0: 747d 207b 7375 6666 6978 7d2c 207b 6669  t} {suffix}, {fi
+00010bd0: 7273 747d 2028 7b6e 6963 6b6e 616d 657d  rst} ({nickname}
+00010be0: 2920 7b6d 6964 646c 657d 270a 2020 2020  ) {middle}'.    
+00010bf0: 2020 2020 2020 2020 2020 2020 6175 7468              auth
+00010c00: 6f72 5f6e 616d 655f 7374 7269 6e67 203d  or_name_string =
+00010c10: 2073 7472 2870 6172 7365 645f 6e61 6d65   str(parsed_name
+00010c20: 292e 7265 706c 6163 6528 2220 2c20 222c  ).replace(" , ",
+00010c30: 2022 2c20 2229 0a20 2020 2020 2020 2020   ", ").         
+00010c40: 2020 2020 2020 2023 204e 6f74 653a 2074         # Note: t
+00010c50: 6865 7265 2061 7265 2065 7272 6f72 7320  here are errors 
+00010c60: 666f 7220 7468 6520 666f 6c6c 6f77 696e  for the followin
+00010c70: 6720 6175 7468 6f72 3a0a 2020 2020 2020  g author:.      
+00010c80: 2020 2020 2020 2020 2020 2320 4a52 2043            # JR C
+00010c90: 726f 6d77 656c 6c20 616e 6420 484b 2047  romwell and HK G
+00010ca0: 6172 646e 6572 0a20 2020 2020 2020 2020  ardner.         
+00010cb0: 2020 2020 2020 2023 2054 6865 204a 5220         # The JR 
+00010cc0: 6973 2070 726f 6261 626c 7920 7265 636f  is probably reco
+00010cd0: 676e 697a 6564 2061 7320 4a75 6e69 6f72  gnized as Junior
+00010ce0: 2e0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00010cf0: 2020 2320 4368 6563 6b20 7768 6574 6865    # Check whethe
+00010d00: 7220 7468 6973 2069 7320 6669 7865 6420  r this is fixed 
+00010d10: 696e 2074 6865 2047 726f 6269 6420 6e61  in the Grobid na
+00010d20: 6d65 2070 6172 7365 720a 0a20 2020 2020  me parser..     
+00010d30: 2020 2020 2020 2069 6620 6175 7468 6f72         if author
+00010d40: 5f73 7472 696e 6720 3d3d 2022 223a 0a20  _string == "":. 
+00010d50: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+00010d60: 7574 686f 725f 7374 7269 6e67 203d 2061  uthor_string = a
+00010d70: 7574 686f 725f 6e61 6d65 5f73 7472 696e  uthor_name_strin
+00010d80: 670a 2020 2020 2020 2020 2020 2020 656c  g.            el
+00010d90: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00010da0: 2020 2020 6175 7468 6f72 5f73 7472 696e      author_strin
+00010db0: 6720 3d20 6175 7468 6f72 5f73 7472 696e  g = author_strin
+00010dc0: 6720 2b20 2220 616e 6420 2220 2b20 6175  g + " and " + au
+00010dd0: 7468 6f72 5f6e 616d 655f 7374 7269 6e67  thor_name_string
+00010de0: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
+00010df0: 2061 7574 686f 725f 7374 7269 6e67 0a0a   author_string..
+00010e00: 2020 2020 4063 6c61 7373 6d65 7468 6f64      @classmethod
+00010e10: 0a20 2020 2064 6566 205f 5f66 6f72 6d61  .    def __forma
+00010e20: 745f 6175 7468 6f72 735f 7374 7269 6e67  t_authors_string
+00010e30: 5f66 6f72 5f63 6f6d 7061 7269 736f 6e28  _for_comparison(
+00010e40: 636c 732c 202a 2c20 7265 636f 7264 3a20  cls, *, record: 
+00010e50: 5265 636f 7264 2920 2d3e 204e 6f6e 653a  Record) -> None:
+00010e60: 0a20 2020 2020 2020 2069 6620 2261 7574  .        if "aut
+00010e70: 686f 7222 206e 6f74 2069 6e20 7265 636f  hor" not in reco
+00010e80: 7264 2e64 6174 613a 0a20 2020 2020 2020  rd.data:.       
+00010e90: 2020 2020 2072 6574 7572 6e0a 2020 2020       return.    
+00010ea0: 2020 2020 6175 7468 6f72 7320 3d20 7265      authors = re
+00010eb0: 636f 7264 2e64 6174 615b 2261 7574 686f  cord.data["autho
+00010ec0: 7222 5d0a 2020 2020 2020 2020 6175 7468  r"].        auth
+00010ed0: 6f72 7320 3d20 7374 7228 6175 7468 6f72  ors = str(author
+00010ee0: 7329 2e6c 6f77 6572 2829 0a20 2020 2020  s).lower().     
+00010ef0: 2020 2061 7574 686f 7273 5f73 7472 696e     authors_strin
+00010f00: 6720 3d20 2222 0a20 2020 2020 2020 2061  g = "".        a
+00010f10: 7574 686f 7273 203d 2063 6f6c 7265 762e  uthors = colrev.
+00010f20: 656e 762e 7574 696c 732e 7265 6d6f 7665  env.utils.remove
+00010f30: 5f61 6363 656e 7473 2869 6e70 7574 5f73  _accents(input_s
+00010f40: 7472 3d61 7574 686f 7273 290a 0a20 2020  tr=authors)..   
+00010f50: 2020 2020 2023 2061 6262 7265 7669 6174       # abbreviat
+00010f60: 6520 6669 7273 7420 6e61 6d65 730a 2020  e first names.  
+00010f70: 2020 2020 2020 2320 2257 6562 7374 6572        # "Webster
+00010f80: 2c20 4a61 6e65 2220 2d3e 2022 5765 6273  , Jane" -> "Webs
+00010f90: 7465 722c 204a 220a 2020 2020 2020 2020  ter, J".        
+00010fa0: 2320 616c 736f 2072 656d 6f76 6520 616c  # also remove al
+00010fb0: 6c20 7370 6563 6961 6c20 6368 6172 6163  l special charac
+00010fc0: 7465 7273 2061 6e64 2064 6f20 6e6f 7420  ters and do not 
+00010fd0: 696e 636c 7564 6520 7365 7061 7261 746f  include separato
+00010fe0: 7273 2028 616e 6429 0a20 2020 2020 2020  rs (and).       
+00010ff0: 2066 6f72 2061 7574 686f 7220 696e 2061   for author in a
+00011000: 7574 686f 7273 2e73 706c 6974 2822 2061  uthors.split(" a
+00011010: 6e64 2022 293a 0a20 2020 2020 2020 2020  nd "):.         
+00011020: 2020 2069 6620 222c 2220 696e 2061 7574     if "," in aut
+00011030: 686f 723a 0a20 2020 2020 2020 2020 2020  hor:.           
+00011040: 2020 2020 206c 6173 745f 6e61 6d65 7320       last_names 
+00011050: 3d20 5b0a 2020 2020 2020 2020 2020 2020  = [.            
+00011060: 2020 2020 2020 2020 776f 7264 5b30 5d20          word[0] 
+00011070: 666f 7220 776f 7264 2069 6e20 6175 7468  for word in auth
+00011080: 6f72 2e73 706c 6974 2822 2c22 295b 315d  or.split(",")[1]
+00011090: 2e73 706c 6974 2822 2022 2920 6966 206c  .split(" ") if l
+000110a0: 656e 2877 6f72 6429 203e 2030 0a20 2020  en(word) > 0.   
+000110b0: 2020 2020 2020 2020 2020 2020 205d 0a20               ]. 
+000110c0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+000110d0: 7574 686f 7273 5f73 7472 696e 6720 3d20  uthors_string = 
+000110e0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+000110f0: 2020 2020 2020 6175 7468 6f72 735f 7374        authors_st
+00011100: 7269 6e67 0a20 2020 2020 2020 2020 2020  ring.           
+00011110: 2020 2020 2020 2020 202b 2061 7574 686f           + autho
+00011120: 722e 7370 6c69 7428 222c 2229 5b30 5d0a  r.split(",")[0].
+00011130: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011140: 2020 2020 2b20 2220 220a 2020 2020 2020      + " ".      
+00011150: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
+00011160: 2220 222e 6a6f 696e 286c 6173 745f 6e61  " ".join(last_na
+00011170: 6d65 7329 0a20 2020 2020 2020 2020 2020  mes).           
+00011180: 2020 2020 2020 2020 202b 2022 2022 0a20           + " ". 
+00011190: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+000111a0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
+000111b0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+000111c0: 2020 2061 7574 686f 7273 5f73 7472 696e     authors_strin
+000111d0: 6720 3d20 6175 7468 6f72 735f 7374 7269  g = authors_stri
+000111e0: 6e67 202b 2061 7574 686f 7220 2b20 2220  ng + author + " 
+000111f0: 220a 2020 2020 2020 2020 6175 7468 6f72  ".        author
+00011200: 735f 7374 7269 6e67 203d 2072 652e 7375  s_string = re.su
+00011210: 6228 7222 5b5e 412d 5a61 2d7a 302d 392c  b(r"[^A-Za-z0-9,
+00011220: 205d 2b22 2c20 2222 2c20 6175 7468 6f72   ]+", "", author
+00011230: 735f 7374 7269 6e67 2e72 7374 7269 7028  s_string.rstrip(
+00011240: 2929 0a20 2020 2020 2020 2072 6563 6f72  )).        recor
+00011250: 642e 6461 7461 5b22 6175 7468 6f72 225d  d.data["author"]
+00011260: 203d 2061 7574 686f 7273 5f73 7472 696e   = authors_strin
+00011270: 670a 0a20 2020 2064 6566 2063 6f6e 7461  g..    def conta
+00011280: 696e 6572 5f69 735f 6162 6272 6576 6961  iner_is_abbrevia
+00011290: 7465 6428 7365 6c66 2920 2d3e 2062 6f6f  ted(self) -> boo
+000112a0: 6c3a 0a20 2020 2020 2020 2022 2222 4368  l:.        """Ch
+000112b0: 6563 6b20 7768 6574 6865 7220 7468 6520  eck whether the 
+000112c0: 636f 6e74 6169 6e65 7220 7469 746c 6520  container title 
+000112d0: 6973 2061 6262 7265 7669 6174 6564 2222  is abbreviated""
+000112e0: 220a 2020 2020 2020 2020 6966 2022 6a6f  ".        if "jo
+000112f0: 7572 6e61 6c22 2069 6e20 7365 6c66 2e64  urnal" in self.d
+00011300: 6174 613a 0a20 2020 2020 2020 2020 2020  ata:.           
+00011310: 2069 6620 7365 6c66 2e64 6174 615b 226a   if self.data["j
+00011320: 6f75 726e 616c 225d 2e63 6f75 6e74 2822  ournal"].count("
+00011330: 2e22 2920 3e20 323a 0a20 2020 2020 2020  .") > 2:.       
+00011340: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00011350: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
+00011360: 2069 6620 7365 6c66 2e64 6174 615b 226a   if self.data["j
+00011370: 6f75 726e 616c 225d 2e69 7375 7070 6572  ournal"].isupper
+00011380: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
+00011390: 2020 2020 7265 7475 726e 2054 7275 650a      return True.
+000113a0: 2020 2020 2020 2020 6966 2022 626f 6f6b          if "book
+000113b0: 7469 746c 6522 2069 6e20 7365 6c66 2e64  title" in self.d
+000113c0: 6174 613a 0a20 2020 2020 2020 2020 2020  ata:.           
+000113d0: 2069 6620 7365 6c66 2e64 6174 615b 2262   if self.data["b
+000113e0: 6f6f 6b74 6974 6c65 225d 2e63 6f75 6e74  ooktitle"].count
+000113f0: 2822 2e22 2920 3e20 323a 0a20 2020 2020  (".") > 2:.     
+00011400: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00011410: 6e20 5472 7565 0a20 2020 2020 2020 2020  n True.         
+00011420: 2020 2069 6620 7365 6c66 2e64 6174 615b     if self.data[
+00011430: 2262 6f6f 6b74 6974 6c65 225d 2e69 7375  "booktitle"].isu
+00011440: 7070 6572 2829 3a0a 2020 2020 2020 2020  pper():.        
+00011450: 2020 2020 2020 2020 7265 7475 726e 2054          return T
+00011460: 7275 650a 2020 2020 2020 2020 2320 6164  rue.        # ad
+00011470: 6420 6865 7572 6973 7469 6373 3f20 2865  d heuristics? (e
+00011480: 2e67 2e2c 2048 6177 6169 6920 496e 7420  .g., Hawaii Int 
+00011490: 436f 6e66 2053 7973 7420 5363 6929 0a20  Conf Syst Sci). 
+000114a0: 2020 2020 2020 2072 6574 7572 6e20 4661         return Fa
+000114b0: 6c73 650a 0a20 2020 2040 636c 6173 736d  lse..    @classm
+000114c0: 6574 686f 640a 2020 2020 6465 6620 5f5f  ethod.    def __
+000114d0: 6162 6272 6576 6961 7465 5f63 6f6e 7461  abbreviate_conta
+000114e0: 696e 6572 5f74 6974 6c65 7328 0a20 2020  iner_titles(.   
+000114f0: 2020 2020 2063 6c73 2c0a 2020 2020 2020       cls,.      
+00011500: 2020 2a2c 0a20 2020 2020 2020 2072 6563    *,.        rec
+00011510: 6f72 643a 2063 6f6c 7265 762e 7265 636f  ord: colrev.reco
+00011520: 7264 2e50 7265 7052 6563 6f72 642c 0a20  rd.PrepRecord,. 
+00011530: 2020 2020 2020 2072 6574 7269 6576 6564         retrieved
+00011540: 5f72 6563 6f72 643a 2063 6f6c 7265 762e  _record: colrev.
+00011550: 7265 636f 7264 2e50 7265 7052 6563 6f72  record.PrepRecor
+00011560: 642c 0a20 2020 2029 202d 3e20 4e6f 6e65  d,.    ) -> None
+00011570: 3a0a 2020 2020 2020 2020 6465 6620 6162  :.        def ab
+00011580: 6272 6576 6961 7465 5f63 6f6e 7461 696e  breviate_contain
+00011590: 6572 282a 2c20 7265 636f 7264 3a20 636f  er(*, record: co
+000115a0: 6c72 6576 2e72 6563 6f72 642e 5265 636f  lrev.record.Reco
+000115b0: 7264 2c20 6d69 6e5f 6c65 6e3a 2069 6e74  rd, min_len: int
+000115c0: 2920 2d3e 204e 6f6e 653a 0a20 2020 2020  ) -> None:.     
+000115d0: 2020 2020 2020 2069 6620 226a 6f75 726e         if "journ
+000115e0: 616c 2220 696e 2072 6563 6f72 642e 6461  al" in record.da
+000115f0: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
+00011600: 2020 2020 7265 636f 7264 2e64 6174 615b      record.data[
+00011610: 226a 6f75 726e 616c 225d 203d 2022 2022  "journal"] = " "
+00011620: 2e6a 6f69 6e28 0a20 2020 2020 2020 2020  .join(.         
+00011630: 2020 2020 2020 2020 2020 205b 785b 3a6d             [x[:m
+00011640: 696e 5f6c 656e 5d20 666f 7220 7820 696e  in_len] for x in
+00011650: 2072 6563 6f72 642e 6461 7461 5b22 6a6f   record.data["jo
+00011660: 7572 6e61 6c22 5d2e 7370 6c69 7428 2220  urnal"].split(" 
+00011670: 2229 5d0a 2020 2020 2020 2020 2020 2020  ")].            
+00011680: 2020 2020 290a 0a20 2020 2020 2020 2064      )..        d
+00011690: 6566 2067 6574 5f61 6262 7265 765f 636f  ef get_abbrev_co
+000116a0: 6e74 6169 6e65 725f 6d69 6e5f 6c65 6e28  ntainer_min_len(
+000116b0: 2a2c 2072 6563 6f72 643a 2063 6f6c 7265  *, record: colre
+000116c0: 762e 7265 636f 7264 2e52 6563 6f72 6429  v.record.Record)
+000116d0: 202d 3e20 696e 743a 0a20 2020 2020 2020   -> int:.       
+000116e0: 2020 2020 206d 696e 5f6c 656e 203d 202d       min_len = -
+000116f0: 310a 2020 2020 2020 2020 2020 2020 6966  1.            if
+00011700: 2022 6a6f 7572 6e61 6c22 2069 6e20 7265   "journal" in re
+00011710: 636f 7264 2e64 6174 613a 0a20 2020 2020  cord.data:.     
+00011720: 2020 2020 2020 2020 2020 206d 696e 5f6c             min_l
+00011730: 656e 203d 206d 696e 280a 2020 2020 2020  en = min(.      
+00011740: 2020 2020 2020 2020 2020 2020 2020 6c65                le
+00011750: 6e28 7829 2066 6f72 2078 2069 6e20 7265  n(x) for x in re
+00011760: 636f 7264 2e64 6174 615b 226a 6f75 726e  cord.data["journ
+00011770: 616c 225d 2e72 6570 6c61 6365 2822 2e22  al"].replace("."
+00011780: 2c20 2222 292e 7370 6c69 7428 2220 2229  , "").split(" ")
+00011790: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000117a0: 2029 0a20 2020 2020 2020 2020 2020 2069   ).            i
+000117b0: 6620 2262 6f6f 6b74 6974 6c65 2220 696e  f "booktitle" in
+000117c0: 2072 6563 6f72 642e 6461 7461 3a0a 2020   record.data:.  
+000117d0: 2020 2020 2020 2020 2020 2020 2020 6d69                mi
+000117e0: 6e5f 6c65 6e20 3d20 6d69 6e28 0a20 2020  n_len = min(.   
+000117f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011800: 206c 656e 2878 2920 666f 7220 7820 696e   len(x) for x in
+00011810: 2072 6563 6f72 642e 6461 7461 5b22 626f   record.data["bo
+00011820: 6f6b 7469 746c 6522 5d2e 7265 706c 6163  oktitle"].replac
+00011830: 6528 222e 222c 2022 2229 2e73 706c 6974  e(".", "").split
+00011840: 2822 2022 290a 2020 2020 2020 2020 2020  (" ").          
+00011850: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00011860: 2020 2020 7265 7475 726e 206d 696e 5f6c      return min_l
+00011870: 656e 0a0a 2020 2020 2020 2020 6966 2072  en..        if r
+00011880: 6563 6f72 642e 636f 6e74 6169 6e65 725f  ecord.container_
+00011890: 6973 5f61 6262 7265 7669 6174 6564 2829  is_abbreviated()
+000118a0: 3a0a 2020 2020 2020 2020 2020 2020 6d69  :.            mi
+000118b0: 6e5f 6c65 6e20 3d20 6765 745f 6162 6272  n_len = get_abbr
+000118c0: 6576 5f63 6f6e 7461 696e 6572 5f6d 696e  ev_container_min
+000118d0: 5f6c 656e 2872 6563 6f72 643d 7265 636f  _len(record=reco
+000118e0: 7264 290a 2020 2020 2020 2020 2020 2020  rd).            
+000118f0: 6162 6272 6576 6961 7465 5f63 6f6e 7461  abbreviate_conta
+00011900: 696e 6572 2872 6563 6f72 643d 7265 7472  iner(record=retr
+00011910: 6965 7665 645f 7265 636f 7264 2c20 6d69  ieved_record, mi
+00011920: 6e5f 6c65 6e3d 6d69 6e5f 6c65 6e29 0a20  n_len=min_len). 
+00011930: 2020 2020 2020 2020 2020 2061 6262 7265             abbre
+00011940: 7669 6174 655f 636f 6e74 6169 6e65 7228  viate_container(
+00011950: 7265 636f 7264 3d72 6563 6f72 642c 206d  record=record, m
+00011960: 696e 5f6c 656e 3d6d 696e 5f6c 656e 290a  in_len=min_len).
+00011970: 2020 2020 2020 2020 6966 2072 6574 7269          if retri
+00011980: 6576 6564 5f72 6563 6f72 642e 636f 6e74  eved_record.cont
+00011990: 6169 6e65 725f 6973 5f61 6262 7265 7669  ainer_is_abbrevi
+000119a0: 6174 6564 2829 3a0a 2020 2020 2020 2020  ated():.        
+000119b0: 2020 2020 6d69 6e5f 6c65 6e20 3d20 6765      min_len = ge
+000119c0: 745f 6162 6272 6576 5f63 6f6e 7461 696e  t_abbrev_contain
+000119d0: 6572 5f6d 696e 5f6c 656e 2872 6563 6f72  er_min_len(recor
+000119e0: 643d 7265 7472 6965 7665 645f 7265 636f  d=retrieved_reco
+000119f0: 7264 290a 2020 2020 2020 2020 2020 2020  rd).            
+00011a00: 6162 6272 6576 6961 7465 5f63 6f6e 7461  abbreviate_conta
+00011a10: 696e 6572 2872 6563 6f72 643d 7265 636f  iner(record=reco
+00011a20: 7264 2c20 6d69 6e5f 6c65 6e3d 6d69 6e5f  rd, min_len=min_
+00011a30: 6c65 6e29 0a20 2020 2020 2020 2020 2020  len).           
+00011a40: 2061 6262 7265 7669 6174 655f 636f 6e74   abbreviate_cont
+00011a50: 6169 6e65 7228 7265 636f 7264 3d72 6574  ainer(record=ret
+00011a60: 7269 6576 6564 5f72 6563 6f72 642c 206d  rieved_record, m
+00011a70: 696e 5f6c 656e 3d6d 696e 5f6c 656e 290a  in_len=min_len).
+00011a80: 0a20 2020 2040 636c 6173 736d 6574 686f  .    @classmetho
+00011a90: 640a 2020 2020 6465 6620 5f5f 7072 6570  d.    def __prep
+00011aa0: 5f72 6563 6f72 6473 5f66 6f72 5f73 696d  _records_for_sim
+00011ab0: 696c 6172 6974 7928 0a20 2020 2020 2020  ilarity(.       
+00011ac0: 2063 6c73 2c0a 2020 2020 2020 2020 2a2c   cls,.        *,
+00011ad0: 0a20 2020 2020 2020 2072 6563 6f72 643a  .        record:
+00011ae0: 2063 6f6c 7265 762e 7265 636f 7264 2e50   colrev.record.P
+00011af0: 7265 7052 6563 6f72 642c 0a20 2020 2020  repRecord,.     
+00011b00: 2020 2072 6574 7269 6576 6564 5f72 6563     retrieved_rec
+00011b10: 6f72 643a 2063 6f6c 7265 762e 7265 636f  ord: colrev.reco
+00011b20: 7264 2e50 7265 7052 6563 6f72 642c 0a20  rd.PrepRecord,. 
+00011b30: 2020 2029 202d 3e20 4e6f 6e65 3a0a 2020     ) -> None:.  
+00011b40: 2020 2020 2020 636c 732e 5f5f 6162 6272        cls.__abbr
+00011b50: 6576 6961 7465 5f63 6f6e 7461 696e 6572  eviate_container
+00011b60: 5f74 6974 6c65 7328 0a20 2020 2020 2020  _titles(.       
+00011b70: 2020 2020 2072 6563 6f72 643d 7265 636f       record=reco
+00011b80: 7264 2c20 7265 7472 6965 7665 645f 7265  rd, retrieved_re
+00011b90: 636f 7264 3d72 6574 7269 6576 6564 5f72  cord=retrieved_r
+00011ba0: 6563 6f72 640a 2020 2020 2020 2020 290a  ecord.        ).
+00011bb0: 0a20 2020 2020 2020 2069 6620 2274 6974  .        if "tit
+00011bc0: 6c65 2220 696e 2072 6563 6f72 642e 6461  le" in record.da
+00011bd0: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
+00011be0: 7265 636f 7264 2e64 6174 615b 2274 6974  record.data["tit
+00011bf0: 6c65 225d 203d 2072 6563 6f72 642e 6461  le"] = record.da
+00011c00: 7461 5b22 7469 746c 6522 5d5b 3a39 305d  ta["title"][:90]
+00011c10: 0a20 2020 2020 2020 2069 6620 2274 6974  .        if "tit
+00011c20: 6c65 2220 696e 2072 6574 7269 6576 6564  le" in retrieved
+00011c30: 5f72 6563 6f72 642e 6461 7461 3a0a 2020  _record.data:.  
+00011c40: 2020 2020 2020 2020 2020 7265 7472 6965            retrie
+00011c50: 7665 645f 7265 636f 7264 2e64 6174 615b  ved_record.data[
+00011c60: 2274 6974 6c65 225d 203d 2072 6574 7269  "title"] = retri
+00011c70: 6576 6564 5f72 6563 6f72 642e 6461 7461  eved_record.data
+00011c80: 5b22 7469 746c 6522 5d5b 3a39 305d 0a0a  ["title"][:90]..
+00011c90: 2020 2020 2020 2020 6966 2022 6175 7468          if "auth
+00011ca0: 6f72 2220 696e 2072 6563 6f72 642e 6461  or" in record.da
+00011cb0: 7461 3a0a 2020 2020 2020 2020 2020 2020  ta:.            
+00011cc0: 636c 732e 5f5f 666f 726d 6174 5f61 7574  cls.__format_aut
+00011cd0: 686f 7273 5f73 7472 696e 675f 666f 725f  hors_string_for_
+00011ce0: 636f 6d70 6172 6973 6f6e 2872 6563 6f72  comparison(recor
+00011cf0: 643d 7265 636f 7264 290a 2020 2020 2020  d=record).      
+00011d00: 2020 2020 2020 7265 636f 7264 2e64 6174        record.dat
+00011d10: 615b 2261 7574 686f 7222 5d20 3d20 7265  a["author"] = re
+00011d20: 636f 7264 2e64 6174 615b 2261 7574 686f  cord.data["autho
+00011d30: 7222 5d5b 3a34 355d 0a20 2020 2020 2020  r"][:45].       
+00011d40: 2069 6620 2261 7574 686f 7222 2069 6e20   if "author" in 
+00011d50: 7265 7472 6965 7665 645f 7265 636f 7264  retrieved_record
+00011d60: 2e64 6174 613a 0a20 2020 2020 2020 2020  .data:.         
+00011d70: 2020 2063 6c73 2e5f 5f66 6f72 6d61 745f     cls.__format_
+00011d80: 6175 7468 6f72 735f 7374 7269 6e67 5f66  authors_string_f
+00011d90: 6f72 5f63 6f6d 7061 7269 736f 6e28 7265  or_comparison(re
+00011da0: 636f 7264 3d72 6574 7269 6576 6564 5f72  cord=retrieved_r
+00011db0: 6563 6f72 6429 0a20 2020 2020 2020 2020  ecord).         
+00011dc0: 2020 2072 6574 7269 6576 6564 5f72 6563     retrieved_rec
+00011dd0: 6f72 642e 6461 7461 5b22 6175 7468 6f72  ord.data["author
+00011de0: 225d 203d 2072 6574 7269 6576 6564 5f72  "] = retrieved_r
+00011df0: 6563 6f72 642e 6461 7461 5b22 6175 7468  ecord.data["auth
+00011e00: 6f72 225d 5b3a 3435 5d0a 2020 2020 2020  or"][:45].      
+00011e10: 2020 6966 206e 6f74 2028 2276 6f6c 756d    if not ("volum
+00011e20: 6522 2069 6e20 7265 636f 7264 2e64 6174  e" in record.dat
+00011e30: 6120 616e 6420 2276 6f6c 756d 6522 2069  a and "volume" i
+00011e40: 6e20 7265 7472 6965 7665 645f 7265 636f  n retrieved_reco
+00011e50: 7264 2e64 6174 6129 3a0a 2020 2020 2020  rd.data):.      
+00011e60: 2020 2020 2020 7265 636f 7264 2e64 6174        record.dat
+00011e70: 615b 2276 6f6c 756d 6522 5d20 3d20 226e  a["volume"] = "n
+00011e80: 616e 220a 2020 2020 2020 2020 2020 2020  an".            
+00011e90: 7265 7472 6965 7665 645f 7265 636f 7264  retrieved_record
+00011ea0: 2e64 6174 615b 2276 6f6c 756d 6522 5d20  .data["volume"] 
+00011eb0: 3d20 226e 616e 220a 2020 2020 2020 2020  = "nan".        
+00011ec0: 6966 206e 6f74 2028 226e 756d 6265 7222  if not ("number"
+00011ed0: 2069 6e20 7265 636f 7264 2e64 6174 6120   in record.data 
+00011ee0: 616e 6420 226e 756d 6265 7222 2069 6e20  and "number" in 
+00011ef0: 7265 7472 6965 7665 645f 7265 636f 7264  retrieved_record
+00011f00: 2e64 6174 6129 3a0a 2020 2020 2020 2020  .data):.        
+00011f10: 2020 2020 7265 636f 7264 2e64 6174 615b      record.data[
+00011f20: 226e 756d 6265 7222 5d20 3d20 226e 616e  "number"] = "nan
+00011f30: 220a 2020 2020 2020 2020 2020 2020 7265  ".            re
+00011f40: 7472 6965 7665 645f 7265 636f 7264 2e64  trieved_record.d
+00011f50: 6174 615b 226e 756d 6265 7222 5d20 3d20  ata["number"] = 
+00011f60: 226e 616e 220a 2020 2020 2020 2020 6966  "nan".        if
+00011f70: 206e 6f74 2028 2270 6167 6573 2220 696e   not ("pages" in
+00011f80: 2072 6563 6f72 642e 6461 7461 2061 6e64   record.data and
+00011f90: 2022 7061 6765 7322 2069 6e20 7265 7472   "pages" in retr
+00011fa0: 6965 7665 645f 7265 636f 7264 2e64 6174  ieved_record.dat
+00011fb0: 6129 3a0a 2020 2020 2020 2020 2020 2020  a):.            
+00011fc0: 7265 636f 7264 2e64 6174 615b 2270 6167  record.data["pag
+00011fd0: 6573 225d 203d 2022 6e61 6e22 0a20 2020  es"] = "nan".   
+00011fe0: 2020 2020 2020 2020 2072 6574 7269 6576           retriev
+00011ff0: 6564 5f72 6563 6f72 642e 6461 7461 5b22  ed_record.data["
+00012000: 7061 6765 7322 5d20 3d20 226e 616e 220a  pages"] = "nan".
+00012010: 2020 2020 2020 2020 2320 536f 6d65 7469          # Someti
+00012020: 6d65 732c 2074 6865 206e 756d 6265 7220  mes, the number 
+00012030: 6f66 2070 6167 6573 2069 7320 7072 6f76  of pages is prov
+00012040: 6964 6564 2028 6e6f 7420 7468 6520 7261  ided (not the ra
+00012050: 6e67 6529 0a20 2020 2020 2020 2065 6c69  nge).        eli
+00012060: 6620 6e6f 7420 280a 2020 2020 2020 2020  f not (.        
+00012070: 2020 2020 222d 2d22 2069 6e20 7265 636f      "--" in reco
+00012080: 7264 2e64 6174 615b 2270 6167 6573 225d  rd.data["pages"]
+00012090: 2061 6e64 2022 2d2d 2220 696e 2072 6574   and "--" in ret
+000120a0: 7269 6576 6564 5f72 6563 6f72 642e 6461  rieved_record.da
+000120b0: 7461 5b22 7061 6765 7322 5d0a 2020 2020  ta["pages"].    
+000120c0: 2020 2020 293a 0a20 2020 2020 2020 2020      ):.         
+000120d0: 2020 2072 6563 6f72 642e 6461 7461 5b22     record.data["
+000120e0: 7061 6765 7322 5d20 3d20 226e 616e 220a  pages"] = "nan".
+000120f0: 2020 2020 2020 2020 2020 2020 7265 7472              retr
+00012100: 6965 7665 645f 7265 636f 7264 2e64 6174  ieved_record.dat
+00012110: 615b 2270 6167 6573 225d 203d 2022 6e61  a["pages"] = "na
+00012120: 6e22 0a0a 2020 2020 2020 2020 6966 2022  n"..        if "
+00012130: 7965 6172 2220 696e 2072 6563 6f72 642e  year" in record.
+00012140: 6461 7461 2061 6e64 2022 7965 6172 2220  data and "year" 
+00012150: 696e 2072 6574 7269 6576 6564 5f72 6563  in retrieved_rec
+00012160: 6f72 642e 6461 7461 3a0a 2020 2020 2020  ord.data:.      
+00012170: 2020 2020 2020 6966 2072 6563 6f72 642e        if record.
+00012180: 6461 7461 5b22 7965 6172 225d 203d 3d20  data["year"] == 
+00012190: 2266 6f72 7468 636f 6d69 6e67 223a 0a20  "forthcoming":. 
+000121a0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+000121b0: 6563 6f72 642e 6461 7461 5b22 7965 6172  ecord.data["year
+000121c0: 225d 203d 2072 6574 7269 6576 6564 5f72  "] = retrieved_r
+000121d0: 6563 6f72 642e 6461 7461 5b22 7965 6172  ecord.data["year
+000121e0: 225d 0a20 2020 2020 2020 2020 2020 2069  "].            i
+000121f0: 6620 7265 7472 6965 7665 645f 7265 636f  f retrieved_reco
+00012200: 7264 2e64 6174 615b 2279 6561 7222 5d20  rd.data["year"] 
+00012210: 3d3d 2022 666f 7274 6863 6f6d 696e 6722  == "forthcoming"
+00012220: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00012230: 2020 7265 7472 6965 7665 645f 7265 636f    retrieved_reco
+00012240: 7264 2e64 6174 615b 2279 6561 7222 5d20  rd.data["year"] 
+00012250: 3d20 7265 636f 7264 2e64 6174 615b 2279  = record.data["y
+00012260: 6561 7222 5d0a 0a20 2020 2040 636c 6173  ear"]..    @clas
+00012270: 736d 6574 686f 640a 2020 2020 6465 6620  smethod.    def 
+00012280: 6765 745f 7265 7472 6965 7661 6c5f 7369  get_retrieval_si
+00012290: 6d69 6c61 7269 7479 280a 2020 2020 2020  milarity(.      
+000122a0: 2020 636c 732c 0a20 2020 2020 2020 202a    cls,.        *
+000122b0: 2c0a 2020 2020 2020 2020 7265 636f 7264  ,.        record
+000122c0: 5f6f 7269 6769 6e61 6c3a 2052 6563 6f72  _original: Recor
+000122d0: 642c 0a20 2020 2020 2020 2072 6574 7269  d,.        retri
+000122e0: 6576 6564 5f72 6563 6f72 645f 6f72 6967  eved_record_orig
+000122f0: 696e 616c 3a20 5265 636f 7264 2c0a 2020  inal: Record,.  
+00012300: 2020 2020 2020 7361 6d65 5f72 6563 6f72        same_recor
+00012310: 645f 7479 7065 5f72 6571 7569 7265 643a  d_type_required:
+00012320: 2062 6f6f 6c20 3d20 5472 7565 2c0a 2020   bool = True,.  
+00012330: 2020 2920 2d3e 2066 6c6f 6174 3a0a 2020    ) -> float:.  
+00012340: 2020 2020 2020 2222 2247 6574 2074 6865        """Get the
+00012350: 2072 6574 7269 6576 616c 2073 696d 696c   retrieval simil
+00012360: 6172 6974 7920 6265 7477 6565 6e20 7468  arity between th
+00012370: 6520 7265 636f 7264 2061 6e64 2061 2072  e record and a r
+00012380: 6574 7269 6576 6564 2072 6563 6f72 6422  etrieved record"
+00012390: 2222 0a0a 2020 2020 2020 2020 6966 2073  ""..        if s
+000123a0: 616d 655f 7265 636f 7264 5f74 7970 655f  ame_record_type_
+000123b0: 7265 7175 6972 6564 3a0a 2020 2020 2020  required:.      
+000123c0: 2020 2020 2020 6966 2072 6563 6f72 645f        if record_
+000123d0: 6f72 6967 696e 616c 2e64 6174 612e 6765  original.data.ge
+000123e0: 7428 0a20 2020 2020 2020 2020 2020 2020  t(.             
+000123f0: 2020 2022 454e 5452 5954 5950 4522 2c20     "ENTRYTYPE", 
+00012400: 2261 220a 2020 2020 2020 2020 2020 2020  "a".            
+00012410: 2920 213d 2072 6574 7269 6576 6564 5f72  ) != retrieved_r
+00012420: 6563 6f72 645f 6f72 6967 696e 616c 2e64  ecord_original.d
+00012430: 6174 612e 6765 7428 2245 4e54 5259 5459  ata.get("ENTRYTY
+00012440: 5045 222c 2022 6222 293a 0a20 2020 2020  PE", "b"):.     
+00012450: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00012460: 6e20 302e 300a 0a20 2020 2020 2020 2072  n 0.0..        r
+00012470: 6563 6f72 6420 3d20 7265 636f 7264 5f6f  ecord = record_o
+00012480: 7269 6769 6e61 6c2e 636f 7079 5f70 7265  riginal.copy_pre
+00012490: 705f 7265 6328 290a 2020 2020 2020 2020  p_rec().        
+000124a0: 7265 7472 6965 7665 645f 7265 636f 7264  retrieved_record
+000124b0: 203d 2072 6574 7269 6576 6564 5f72 6563   = retrieved_rec
+000124c0: 6f72 645f 6f72 6967 696e 616c 2e63 6f70  ord_original.cop
+000124d0: 795f 7072 6570 5f72 6563 2829 0a0a 2020  y_prep_rec()..  
+000124e0: 2020 2020 2020 636c 732e 5f5f 7072 6570        cls.__prep
+000124f0: 5f72 6563 6f72 6473 5f66 6f72 5f73 696d  _records_for_sim
+00012500: 696c 6172 6974 7928 0a20 2020 2020 2020  ilarity(.       
+00012510: 2020 2020 2072 6563 6f72 643d 7265 636f       record=reco
+00012520: 7264 2c20 7265 7472 6965 7665 645f 7265  rd, retrieved_re
+00012530: 636f 7264 3d72 6574 7269 6576 6564 5f72  cord=retrieved_r
+00012540: 6563 6f72 640a 2020 2020 2020 2020 290a  ecord.        ).
+00012550: 0a20 2020 2020 2020 2069 6620 2265 6469  .        if "edi
+00012560: 746f 7269 616c 2220 696e 2072 6563 6f72  torial" in recor
+00012570: 642e 6461 7461 2e67 6574 2822 7469 746c  d.data.get("titl
+00012580: 6522 2c20 224e 4122 292e 6c6f 7765 7228  e", "NA").lower(
+00012590: 293a 0a20 2020 2020 2020 2020 2020 2069  ):.            i
+000125a0: 6620 6e6f 7420 616c 6c28 7820 696e 2072  f not all(x in r
+000125b0: 6563 6f72 642e 6461 7461 2066 6f72 2078  ecord.data for x
+000125c0: 2069 6e20 5b22 766f 6c75 6d65 222c 2022   in ["volume", "
+000125d0: 6e75 6d62 6572 225d 293a 0a20 2020 2020  number"]):.     
+000125e0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+000125f0: 6e20 302e 300a 0a20 2020 2020 2020 2073  n 0.0..        s
+00012600: 696d 696c 6172 6974 7920 3d20 5265 636f  imilarity = Reco
+00012610: 7264 2e67 6574 5f72 6563 6f72 645f 7369  rd.get_record_si
+00012620: 6d69 6c61 7269 7479 280a 2020 2020 2020  milarity(.      
+00012630: 2020 2020 2020 7265 636f 7264 5f61 3d72        record_a=r
+00012640: 6563 6f72 642c 2072 6563 6f72 645f 623d  ecord, record_b=
+00012650: 7265 7472 6965 7665 645f 7265 636f 7264  retrieved_record
+00012660: 0a20 2020 2020 2020 2029 0a20 2020 2020  .        ).     
+00012670: 2020 2072 6574 7572 6e20 7369 6d69 6c61     return simila
+00012680: 7269 7479 0a0a 2020 2020 6465 6620 666f  rity..    def fo
+00012690: 726d 6174 5f69 665f 6d6f 7374 6c79 5f75  rmat_if_mostly_u
+000126a0: 7070 6572 2873 656c 662c 202a 2c20 6b65  pper(self, *, ke
+000126b0: 793a 2073 7472 2c20 6361 7365 3a20 7374  y: str, case: st
+000126c0: 7220 3d20 2273 656e 7465 6e63 6522 2920  r = "sentence") 
+000126d0: 2d3e 204e 6f6e 653a 0a20 2020 2020 2020  -> None:.       
+000126e0: 2022 2222 466f 726d 6174 2074 6865 2066   """Format the f
+000126f0: 6965 6c64 2069 6620 6974 2069 7320 6d6f  ield if it is mo
+00012700: 7374 6c79 2069 6e20 7570 7065 7220 6361  stly in upper ca
+00012710: 7365 2222 220a 0a20 2020 2020 2020 2069  se"""..        i
+00012720: 6620 6b65 7920 6e6f 7420 696e 2073 656c  f key not in sel
+00012730: 662e 6461 7461 206f 7220 7365 6c66 2e64  f.data or self.d
+00012740: 6174 615b 6b65 795d 203d 3d20 2255 4e4b  ata[key] == "UNK
+00012750: 4e4f 574e 223a 0a20 2020 2020 2020 2020  NOWN":.         
+00012760: 2020 2072 6574 7572 6e0a 0a20 2020 2020     return..     
+00012770: 2020 2069 6620 636f 6c72 6576 2e65 6e76     if colrev.env
+00012780: 2e75 7469 6c73 2e70 6572 6365 6e74 5f75  .utils.percent_u
+00012790: 7070 6572 5f63 6861 7273 2873 656c 662e  pper_chars(self.
+000127a0: 6461 7461 5b6b 6579 5d29 203c 2030 2e36  data[key]) < 0.6
+000127b0: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+000127c0: 7475 726e 0a0a 2020 2020 2020 2020 2320  turn..        # 
+000127d0: 4e6f 7465 3a20 7468 6520 7472 7565 6361  Note: the trueca
+000127e0: 7365 2070 6163 6b61 6765 2069 7320 6e6f  se package is no
+000127f0: 7420 7665 7279 2072 656c 6961 626c 6520  t very reliable 
+00012800: 2879 6574 290a 0a20 2020 2020 2020 2073  (yet)..        s
+00012810: 656c 662e 6461 7461 5b6b 6579 5d20 3d20  elf.data[key] = 
+00012820: 7365 6c66 2e64 6174 615b 6b65 795d 2e72  self.data[key].r
+00012830: 6570 6c61 6365 2822 5c6e 222c 2022 2022  eplace("\n", " "
+00012840: 290a 0a20 2020 2020 2020 2069 6620 6361  )..        if ca
+00012850: 7365 203d 3d20 2273 656e 7465 6e63 6522  se == "sentence"
+00012860: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+00012870: 6c66 2e64 6174 615b 6b65 795d 203d 2073  lf.data[key] = s
+00012880: 656c 662e 6461 7461 5b6b 6579 5d2e 6361  elf.data[key].ca
+00012890: 7069 7461 6c69 7a65 2829 0a20 2020 2020  pitalize().     
+000128a0: 2020 2065 6c69 6620 6361 7365 203d 3d20     elif case == 
+000128b0: 2274 6974 6c65 223a 0a20 2020 2020 2020  "title":.       
+000128c0: 2020 2020 2073 656c 662e 6461 7461 5b6b       self.data[k
+000128d0: 6579 5d20 3d20 7365 6c66 2e64 6174 615b  ey] = self.data[
+000128e0: 6b65 795d 2e74 6974 6c65 2829 0a20 2020  key].title().   
+000128f0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00012900: 2020 2020 2020 2072 6169 7365 2063 6f6c         raise col
+00012910: 7265 765f 6578 6365 7074 696f 6e73 2e50  rev_exceptions.P
+00012920: 6172 616d 6574 6572 4572 726f 7228 0a20  arameterError(. 
+00012930: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+00012940: 6172 616d 6574 6572 3d22 6361 7365 222c  arameter="case",
+00012950: 2076 616c 7565 3d63 6173 652c 206f 7074   value=case, opt
+00012960: 696f 6e73 3d5b 2273 656e 7465 6e63 6522  ions=["sentence"
+00012970: 2c20 2274 6974 6c65 225d 0a20 2020 2020  , "title"].     
+00012980: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
+00012990: 2020 7365 6c66 2e64 6174 615b 6b65 795d    self.data[key]
+000129a0: 203d 2070 7265 705f 7574 696c 732e 6361   = prep_utils.ca
+000129b0: 7069 7461 6c69 7a65 5f65 6e74 6974 6965  pitalize_entitie
+000129c0: 7328 7365 6c66 2e64 6174 615b 6b65 795d  s(self.data[key]
+000129d0: 290a 0a20 2020 2020 2020 2069 6620 6b65  )..        if ke
+000129e0: 7920 696e 2073 656c 662e 6461 7461 2e67  y in self.data.g
+000129f0: 6574 2822 636f 6c72 6576 5f6d 6173 7465  et("colrev_maste
+00012a00: 7264 6174 615f 7072 6f76 656e 616e 6365  rdata_provenance
+00012a10: 222c 207b 7d29 3a0a 2020 2020 2020 2020  ", {}):.        
+00012a20: 2020 2020 6e6f 7465 203d 2073 656c 662e      note = self.
+00012a30: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
+00012a40: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
+00012a50: 6365 225d 5b6b 6579 5d5b 226e 6f74 6522  ce"][key]["note"
+00012a60: 5d0a 2020 2020 2020 2020 2020 2020 6966  ].            if
+00012a70: 2022 7175 616c 6974 795f 6465 6665 6374   "quality_defect
+00012a80: 2220 696e 206e 6f74 653a 0a20 2020 2020  " in note:.     
+00012a90: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00012aa0: 6461 7461 5b22 636f 6c72 6576 5f6d 6173  data["colrev_mas
+00012ab0: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
+00012ac0: 6365 225d 5b6b 6579 5d5b 226e 6f74 6522  ce"][key]["note"
+00012ad0: 5d20 3d20 6e6f 7465 2e72 6570 6c61 6365  ] = note.replace
+00012ae0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00012af0: 2020 2020 2020 2271 7561 6c69 7479 5f64        "quality_d
+00012b00: 6566 6563 7422 2c20 2222 0a20 2020 2020  efect", "".     
+00012b10: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
+00012b20: 2020 6465 6620 7265 6e61 6d65 5f66 6965    def rename_fie
+00012b30: 6c64 735f 6261 7365 645f 6f6e 5f6d 6170  lds_based_on_map
+00012b40: 7069 6e67 2873 656c 662c 202a 2c20 6d61  ping(self, *, ma
+00012b50: 7070 696e 673a 2064 6963 7429 202d 3e20  pping: dict) -> 
+00012b60: 4e6f 6e65 3a0a 2020 2020 2020 2020 2222  None:.        ""
+00012b70: 2243 6f6e 7665 6e69 656e 6365 2066 756e  "Convenience fun
+00012b80: 6374 696f 6e20 666f 7220 7468 6520 7072  ction for the pr
+00012b90: 6570 2073 6372 6970 7473 2028 746f 2072  ep scripts (to r
+00012ba0: 656e 616d 6520 6669 656c 6473 2922 2222  ename fields)"""
+00012bb0: 0a0a 2020 2020 2020 2020 6d61 7070 696e  ..        mappin
+00012bc0: 6720 3d20 7b6b 2e6c 6f77 6572 2829 3a20  g = {k.lower(): 
+00012bd0: 762e 6c6f 7765 7228 2920 666f 7220 6b2c  v.lower() for k,
+00012be0: 2076 2069 6e20 6d61 7070 696e 672e 6974   v in mapping.it
+00012bf0: 656d 7328 297d 0a20 2020 2020 2020 2070  ems()}.        p
+00012c00: 7269 6f72 5f6b 6579 7320 3d20 6c69 7374  rior_keys = list
+00012c10: 2873 656c 662e 6461 7461 2e6b 6579 7328  (self.data.keys(
+00012c20: 2929 0a20 2020 2020 2020 2023 204e 6f74  )).        # Not
+00012c30: 6520 3a20 7761 726e 696e 673a 2064 6f20  e : warning: do 
+00012c40: 6e6f 7420 6372 6561 7465 2061 206e 6577  not create a new
+00012c50: 2064 6963 742e 0a20 2020 2020 2020 2066   dict..        f
+00012c60: 6f72 206b 6579 2069 6e20 7072 696f 725f  or key in prior_
+00012c70: 6b65 7973 3a0a 2020 2020 2020 2020 2020  keys:.          
+00012c80: 2020 6966 206b 6579 2e6c 6f77 6572 2829    if key.lower()
+00012c90: 2069 6e20 6d61 7070 696e 673a 0a20 2020   in mapping:.   
+00012ca0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+00012cb0: 662e 7265 6e61 6d65 5f66 6965 6c64 286b  f.rename_field(k
+00012cc0: 6579 3d6b 6579 2c20 6e65 775f 6b65 793d  ey=key, new_key=
+00012cd0: 6d61 7070 696e 675b 6b65 792e 6c6f 7765  mapping[key.lowe
+00012ce0: 7228 295d 290a 0a20 2020 2064 6566 2075  r()])..    def u
+00012cf0: 6e69 6679 5f70 6167 6573 5f66 6965 6c64  nify_pages_field
+00012d00: 2873 656c 6629 202d 3e20 4e6f 6e65 3a0a  (self) -> None:.
+00012d10: 2020 2020 2020 2020 2222 2255 6e69 6679          """Unify
+00012d20: 2074 6865 2066 6f72 6d61 7420 6f66 2074   the format of t
+00012d30: 6865 2070 6167 6520 6669 656c 6422 2222  he page field"""
+00012d40: 0a20 2020 2020 2020 2069 6620 2270 6167  .        if "pag
+00012d50: 6573 2220 6e6f 7420 696e 2073 656c 662e  es" not in self.
+00012d60: 6461 7461 3a0a 2020 2020 2020 2020 2020  data:.          
+00012d70: 2020 7265 7475 726e 0a20 2020 2020 2020    return.       
+00012d80: 2069 6620 6e6f 7420 6973 696e 7374 616e   if not isinstan
+00012d90: 6365 2873 656c 662e 6461 7461 5b22 7061  ce(self.data["pa
+00012da0: 6765 7322 5d2c 2073 7472 293a 0a20 2020  ges"], str):.   
+00012db0: 2020 2020 2020 2020 2072 6574 7572 6e0a           return.
+00012dc0: 2020 2020 2020 2020 6966 2031 203d 3d20          if 1 == 
+00012dd0: 7365 6c66 2e64 6174 615b 2270 6167 6573  self.data["pages
+00012de0: 225d 2e63 6f75 6e74 2822 2d22 293a 0a20  "].count("-"):. 
+00012df0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00012e00: 6461 7461 5b22 7061 6765 7322 5d20 3d20  data["pages"] = 
+00012e10: 7365 6c66 2e64 6174 615b 2270 6167 6573  self.data["pages
+00012e20: 225d 2e72 6570 6c61 6365 2822 2d22 2c20  "].replace("-", 
+00012e30: 222d 2d22 290a 2020 2020 2020 2020 7365  "--").        se
+00012e40: 6c66 2e64 6174 615b 2270 6167 6573 225d  lf.data["pages"]
+00012e50: 203d 2028 0a20 2020 2020 2020 2020 2020   = (.           
+00012e60: 2073 656c 662e 6461 7461 5b22 7061 6765   self.data["page
+00012e70: 7322 5d0a 2020 2020 2020 2020 2020 2020  s"].            
+00012e80: 2e72 6570 6c61 6365 2822 e280 9322 2c20  .replace("...", 
+00012e90: 222d 2d22 290a 2020 2020 2020 2020 2020  "--").          
+00012ea0: 2020 2e72 6570 6c61 6365 2822 2d2d 2d2d    .replace("----
+00012eb0: 222c 2022 2d2d 2229 0a20 2020 2020 2020  ", "--").       
+00012ec0: 2020 2020 202e 7265 706c 6163 6528 2220       .replace(" 
+00012ed0: 2d2d 2022 2c20 222d 2d22 290a 2020 2020  -- ", "--").    
+00012ee0: 2020 2020 2020 2020 2e72 7374 7269 7028          .rstrip(
+00012ef0: 222e 2229 0a20 2020 2020 2020 2029 0a20  ".").        ). 
+00012f00: 2020 2020 2020 2069 6620 7265 2e6d 6174         if re.mat
+00012f10: 6368 2872 225e 5c64 2b5c 2d5c 2d5c 642b  ch(r"^\d+\-\-\d+
+00012f20: 2422 2c20 7365 6c66 2e64 6174 615b 2270  $", self.data["p
+00012f30: 6167 6573 225d 293a 0a20 2020 2020 2020  ages"]):.       
+00012f40: 2020 2020 2066 726f 6d5f 7061 6765 2c20       from_page, 
+00012f50: 746f 5f70 6167 6520 3d20 7265 2e66 696e  to_page = re.fin
+00012f60: 6461 6c6c 2872 2228 5c64 2b29 222c 2073  dall(r"(\d+)", s
+00012f70: 656c 662e 6461 7461 5b22 7061 6765 7322  elf.data["pages"
+00012f80: 5d29 0a20 2020 2020 2020 2020 2020 2069  ]).            i
+00012f90: 6620 696e 7428 6672 6f6d 5f70 6167 6529  f int(from_page)
+00012fa0: 203e 2069 6e74 2874 6f5f 7061 6765 2920   > int(to_page) 
+00012fb0: 616e 6420 6c65 6e28 6672 6f6d 5f70 6167  and len(from_pag
+00012fc0: 6529 203e 206c 656e 2874 6f5f 7061 6765  e) > len(to_page
+00012fd0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+00012fe0: 2020 2073 656c 662e 6461 7461 5b0a 2020     self.data[.  
+00012ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013000: 2020 2270 6167 6573 220a 2020 2020 2020    "pages".      
+00013010: 2020 2020 2020 2020 2020 5d20 3d20 6622            ] = f"
+00013020: 7b66 726f 6d5f 7061 6765 7d2d 2d7b 6672  {from_page}--{fr
+00013030: 6f6d 5f70 6167 655b 3a2d 6c65 6e28 746f  om_page[:-len(to
+00013040: 5f70 6167 6529 5d7d 7b74 6f5f 7061 6765  _page)]}{to_page
+00013050: 7d22 0a0a 2020 2020 6465 6620 7072 6570  }"..    def prep
+00013060: 6172 6174 696f 6e5f 7361 7665 5f63 6f6e  aration_save_con
+00013070: 6469 7469 6f6e 2873 656c 6629 202d 3e20  dition(self) -> 
+00013080: 626f 6f6c 3a0a 2020 2020 2020 2020 2222  bool:.        ""
+00013090: 2243 6865 636b 2077 6865 7468 6572 2074  "Check whether t
+000130a0: 6865 2073 6176 6520 636f 6e64 6974 696f  he save conditio
+000130b0: 6e20 666f 7220 7468 6520 7072 6570 206f  n for the prep o
+000130c0: 7065 7261 7469 6f6e 2069 7320 6769 7665  peration is give
+000130d0: 6e22 2222 0a0a 2020 2020 2020 2020 6966  n"""..        if
+000130e0: 2073 656c 662e 6461 7461 2e67 6574 2822   self.data.get("
+000130f0: 636f 6c72 6576 5f73 7461 7475 7322 2c20  colrev_status", 
+00013100: 224e 4122 2920 696e 205b 0a20 2020 2020  "NA") in [.     
+00013110: 2020 2020 2020 2052 6563 6f72 6453 7461         RecordSta
+00013120: 7465 2e72 6576 5f70 7265 7363 7265 656e  te.rev_prescreen
+00013130: 5f65 7863 6c75 6465 642c 0a20 2020 2020  _excluded,.     
+00013140: 2020 2020 2020 2052 6563 6f72 6453 7461         RecordSta
+00013150: 7465 2e6d 645f 7072 6570 6172 6564 2c0a  te.md_prepared,.
+00013160: 2020 2020 2020 2020 5d3a 0a20 2020 2020          ]:.     
+00013170: 2020 2020 2020 2072 6574 7572 6e20 5472         return Tr
+00013180: 7565 0a0a 2020 2020 2020 2020 6966 2061  ue..        if a
+00013190: 6e79 280a 2020 2020 2020 2020 2020 2020  ny(.            
+000131a0: 2264 6973 6167 7265 656d 656e 7420 7769  "disagreement wi
+000131b0: 7468 2022 2069 6e20 785b 226e 6f74 6522  th " in x["note"
+000131c0: 5d0a 2020 2020 2020 2020 2020 2020 666f  ].            fo
+000131d0: 7220 7820 696e 2073 656c 662e 6461 7461  r x in self.data
+000131e0: 2e67 6574 2822 636f 6c72 6576 5f6d 6173  .get("colrev_mas
+000131f0: 7465 7264 6174 615f 7072 6f76 656e 616e  terdata_provenan
+00013200: 6365 222c 207b 7d29 2e76 616c 7565 7328  ce", {}).values(
+00013210: 290a 2020 2020 2020 2020 2920 6f72 2061  ).        ) or a
+00013220: 6e79 280a 2020 2020 2020 2020 2020 2020  ny(.            
+00013230: 2272 6563 6f72 645f 6e6f 745f 696e 5f74  "record_not_in_t
+00013240: 6f63 2220 696e 2078 5b22 6e6f 7465 225d  oc" in x["note"]
+00013250: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
+00013260: 2078 2069 6e20 7365 6c66 2e64 6174 612e   x in self.data.
+00013270: 6765 7428 2263 6f6c 7265 765f 6d61 7374  get("colrev_mast
+00013280: 6572 6461 7461 5f70 726f 7665 6e61 6e63  erdata_provenanc
+00013290: 6522 2c20 7b7d 292e 7661 6c75 6573 2829  e", {}).values()
+000132a0: 0a20 2020 2020 2020 2029 3a0a 2020 2020  .        ):.    
+000132b0: 2020 2020 2020 2020 7265 7475 726e 2054          return T
+000132c0: 7275 650a 0a20 2020 2020 2020 2072 6574  rue..        ret
+000132d0: 7572 6e20 4661 6c73 650a 0a20 2020 2064  urn False..    d
+000132e0: 6566 2070 7265 7061 7261 7469 6f6e 5f62  ef preparation_b
+000132f0: 7265 616b 5f63 6f6e 6469 7469 6f6e 2873  reak_condition(s
+00013300: 656c 6629 202d 3e20 626f 6f6c 3a0a 2020  elf) -> bool:.  
+00013310: 2020 2020 2020 2222 2243 6865 636b 2077        """Check w
+00013320: 6865 7468 6572 2074 6865 2062 7265 616b  hether the break
+00013330: 2063 6f6e 6469 7469 6f6e 2066 6f72 2074   condition for t
+00013340: 6865 2070 7265 7020 6f70 6572 6174 696f  he prep operatio
+00013350: 6e20 6973 2067 6976 656e 2222 220a 2020  n is given""".  
+00013360: 2020 2020 2020 6966 2061 6e79 280a 2020        if any(.  
+00013370: 2020 2020 2020 2020 2020 2264 6973 6167            "disag
+00013380: 7265 656d 656e 7420 7769 7468 2022 2069  reement with " i
+00013390: 6e20 785b 226e 6f74 6522 5d0a 2020 2020  n x["note"].    
+000133a0: 2020 2020 2020 2020 666f 7220 7820 696e          for x in
+000133b0: 2073 656c 662e 6461 7461 2e67 6574 2822   self.data.get("
+000133c0: 636f 6c72 6576 5f6d 6173 7465 7264 6174  colrev_masterdat
+000133d0: 615f 7072 6f76 656e 616e 6365 222c 207b  a_provenance", {
+000133e0: 7d29 2e76 616c 7565 7328 290a 2020 2020  }).values().    
+000133f0: 2020 2020 2920 6f72 2061 6e79 280a 2020      ) or any(.  
+00013400: 2020 2020 2020 2020 2020 2272 6563 6f72            "recor
+00013410: 645f 6e6f 745f 696e 5f74 6f63 2220 696e  d_not_in_toc" in
+00013420: 2078 5b22 6e6f 7465 225d 0a20 2020 2020   x["note"].     
+00013430: 2020 2020 2020 2066 6f72 2078 2069 6e20         for x in 
+00013440: 7365 6c66 2e64 6174 612e 6765 7428 2263  self.data.get("c
+00013450: 6f6c 7265 765f 6d61 7374 6572 6461 7461  olrev_masterdata
+00013460: 5f70 726f 7665 6e61 6e63 6522 2c20 7b7d  _provenance", {}
+00013470: 292e 7661 6c75 6573 2829 0a20 2020 2020  ).values().     
+00013480: 2020 2029 3a0a 2020 2020 2020 2020 2020     ):.          
+00013490: 2020 7265 7475 726e 2054 7275 650a 0a20    return True.. 
+000134a0: 2020 2020 2020 2069 6620 7365 6c66 2e64         if self.d
+000134b0: 6174 612e 6765 7428 2263 6f6c 7265 765f  ata.get("colrev_
+000134c0: 7374 6174 7573 222c 2022 4e41 2229 2069  status", "NA") i
+000134d0: 6e20 5b0a 2020 2020 2020 2020 2020 2020  n [.            
+000134e0: 5265 636f 7264 5374 6174 652e 7265 765f  RecordState.rev_
+000134f0: 7072 6573 6372 6565 6e5f 6578 636c 7564  prescreen_exclud
+00013500: 6564 2c0a 2020 2020 2020 2020 5d3a 0a20  ed,.        ]:. 
+00013510: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00013520: 6e20 5472 7565 0a20 2020 2020 2020 2072  n True.        r
+00013530: 6574 7572 6e20 4661 6c73 650a 0a20 2020  eturn False..   
+00013540: 2064 6566 2073 7461 7475 735f 746f 5f70   def status_to_p
+00013550: 7265 7061 7265 2873 656c 6629 202d 3e20  repare(self) -> 
+00013560: 626f 6f6c 3a0a 2020 2020 2020 2020 2222  bool:.        ""
+00013570: 2243 6865 636b 2077 6865 7468 6572 2074  "Check whether t
+00013580: 6865 2072 6563 6f72 6420 6e65 6564 7320  he record needs 
+00013590: 746f 2062 6520 7072 6570 6172 6564 2222  to be prepared""
+000135a0: 220a 2020 2020 2020 2020 7265 7475 726e  ".        return
+000135b0: 2073 656c 662e 6461 7461 2e67 6574 2822   self.data.get("
+000135c0: 636f 6c72 6576 5f73 7461 7475 7322 2c20  colrev_status", 
+000135d0: 224e 4122 2920 696e 205b 0a20 2020 2020  "NA") in [.     
+000135e0: 2020 2020 2020 2052 6563 6f72 6453 7461         RecordSta
+000135f0: 7465 2e6d 645f 6e65 6564 735f 6d61 6e75  te.md_needs_manu
+00013600: 616c 5f70 7265 7061 7261 7469 6f6e 2c0a  al_preparation,.
+00013610: 2020 2020 2020 2020 2020 2020 5265 636f              Reco
+00013620: 7264 5374 6174 652e 6d64 5f69 6d70 6f72  rdState.md_impor
+00013630: 7465 642c 0a20 2020 2020 2020 2020 2020  ted,.           
+00013640: 2052 6563 6f72 6453 7461 7465 2e6d 645f   RecordState.md_
+00013650: 7072 6570 6172 6564 2c0a 2020 2020 2020  prepared,.      
+00013660: 2020 5d0a 0a20 2020 2064 6566 2075 7064    ]..    def upd
+00013670: 6174 655f 6d65 7461 6461 7461 5f73 7461  ate_metadata_sta
+00013680: 7475 7328 0a20 2020 2020 2020 2073 656c  tus(.        sel
+00013690: 662c 0a20 2020 2029 202d 3e20 4e6f 6e65  f,.    ) -> None
+000136a0: 3a0a 2020 2020 2020 2020 2222 2255 7064  :.        """Upd
+000136b0: 6174 6520 7468 6520 6d65 7461 6461 7461  ate the metadata
+000136c0: 2073 7461 7475 7320 2872 6574 7261 6374   status (retract
+000136d0: 732c 2069 6e63 6f6d 706c 6574 656e 6573  s, incompletenes
+000136e0: 732c 2069 6e63 6f6e 7369 7374 656e 6369  s, inconsistenci
+000136f0: 6573 2c20 6574 632e 290a 2020 2020 2020  es, etc.).      
+00013700: 2020 616e 6420 7365 7474 696e 6720 7468    and setting th
+00013710: 6520 7374 6174 7573 2061 6363 6f72 6469  e status accordi
+00013720: 6e67 6c79 2222 220a 0a20 2020 2020 2020  ngly"""..       
+00013730: 2073 656c 662e 6368 6563 6b5f 706f 7465   self.check_pote
+00013740: 6e74 6961 6c5f 7265 7472 6163 7473 2829  ntial_retracts()
+00013750: 0a0a 2020 2020 2020 2020 6966 2028 0a20  ..        if (. 
+00013760: 2020 2020 2020 2020 2020 2063 6f6c 7265             colre
+00013770: 762e 7265 636f 7264 2e52 6563 6f72 6453  v.record.RecordS
+00013780: 7461 7465 2e72 6576 5f70 7265 7363 7265  tate.rev_prescre
+00013790: 656e 5f65 7863 6c75 6465 640a 2020 2020  en_excluded.    
+000137a0: 2020 2020 2020 2020 3d3d 2073 656c 662e          == self.
+000137b0: 6461 7461 5b22 636f 6c72 6576 5f73 7461  data["colrev_sta
+000137c0: 7475 7322 5d0a 2020 2020 2020 2020 293a  tus"].        ):
+000137d0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+000137e0: 7572 6e0a 0a20 2020 2020 2020 2069 6620  urn..        if 
+000137f0: 7365 6c66 2e6d 6173 7465 7264 6174 615f  self.masterdata_
+00013800: 6973 5f63 7572 6174 6564 2829 3a0a 2020  is_curated():.  
+00013810: 2020 2020 2020 2020 2020 7365 6c66 2e73            self.s
+00013820: 6574 5f73 7461 7475 7328 7461 7267 6574  et_status(target
+00013830: 5f73 7461 7465 3d52 6563 6f72 6453 7461  _state=RecordSta
+00013840: 7465 2e6d 645f 7072 6570 6172 6564 290a  te.md_prepared).
+00013850: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00013860: 726e 0a0a 2020 2020 2020 2020 6966 2073  rn..        if s
+00013870: 656c 662e 6861 735f 7175 616c 6974 795f  elf.has_quality_
+00013880: 6465 6665 6374 7328 293a 0a20 2020 2020  defects():.     
+00013890: 2020 2020 2020 2073 656c 662e 7365 745f         self.set_
+000138a0: 7374 6174 7573 2874 6172 6765 745f 7374  status(target_st
+000138b0: 6174 653d 5265 636f 7264 5374 6174 652e  ate=RecordState.
+000138c0: 6d64 5f6e 6565 6473 5f6d 616e 7561 6c5f  md_needs_manual_
+000138d0: 7072 6570 6172 6174 696f 6e29 0a20 2020  preparation).   
+000138e0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+000138f0: 2020 2020 2020 2073 656c 662e 7365 745f         self.set_
+00013900: 7374 6174 7573 2874 6172 6765 745f 7374  status(target_st
+00013910: 6174 653d 5265 636f 7264 5374 6174 652e  ate=RecordState.
+00013920: 6d64 5f70 7265 7061 7265 6429 0a0a 0a63  md_prepared)...c
+00013930: 6c61 7373 2052 6563 6f72 6453 7461 7465  lass RecordState
+00013940: 2845 6e75 6d29 3a0a 2020 2020 2222 2254  (Enum):.    """T
+00013950: 6865 2070 6f73 7369 626c 6520 5265 636f  he possible Reco
+00013960: 7264 5374 6174 6573 2073 746f 7265 6420  rdStates stored 
+00013970: 696e 2074 6865 2063 6f6c 7265 765f 7374  in the colrev_st
+00013980: 6174 7573 2066 6965 6c64 0a20 2020 2028  atus field.    (
+00013990: 636f 7272 6573 706f 6e64 696e 6720 746f  corresponding to
+000139a0: 2074 6865 2052 6563 6f72 6453 7461 7465   the RecordState
+000139b0: 4d6f 6465 6c29 2222 220a 0a20 2020 2023  Model)"""..    #
+000139c0: 2070 796c 696e 743a 2064 6973 6162 6c65   pylint: disable
+000139d0: 3d69 6e76 616c 6964 2d6e 616d 650a 0a20  =invalid-name.. 
+000139e0: 2020 2023 2077 6974 686f 7574 2074 6865     # without the
+000139f0: 206d 645f 7265 7472 6965 7665 6420 7374   md_retrieved st
+00013a00: 6174 652c 2077 6520 636f 756c 6420 6e6f  ate, we could no
+00013a10: 7420 6469 7370 6c61 7920 7468 6520 6c6f  t display the lo
+00013a20: 6164 2074 7261 6e73 6974 696f 6e0a 2020  ad transition.  
+00013a30: 2020 6d64 5f72 6574 7269 6576 6564 203d    md_retrieved =
+00013a40: 2031 0a20 2020 2022 2222 5265 636f 7264   1.    """Record
+00013a50: 2069 7320 7265 7472 6965 7665 6420 616e   is retrieved an
+00013a60: 6420 7374 6f72 6564 2069 6e20 7468 6520  d stored in the 
+00013a70: 2e2f 7365 6172 6368 2064 6972 6563 746f  ./search directo
+00013a80: 7279 2222 220a 2020 2020 6d64 5f69 6d70  ry""".    md_imp
+00013a90: 6f72 7465 6420 3d20 320a 2020 2020 2222  orted = 2.    ""
+00013aa0: 2252 6563 6f72 6420 6973 2069 6d70 6f72  "Record is impor
+00013ab0: 7465 6420 696e 746f 2074 6865 2052 4543  ted into the REC
+00013ac0: 4f52 4453 5f46 494c 4522 2222 0a20 2020  ORDS_FILE""".   
+00013ad0: 206d 645f 6e65 6564 735f 6d61 6e75 616c   md_needs_manual
+00013ae0: 5f70 7265 7061 7261 7469 6f6e 203d 2033  _preparation = 3
+00013af0: 0a20 2020 2022 2222 5265 636f 7264 2072  .    """Record r
+00013b00: 6571 7569 7265 7320 6d61 6e75 616c 2070  equires manual p
+00013b10: 7265 7061 7261 7469 6f6e 0a20 2020 2028  reparation.    (
+00013b20: 636f 6c72 6576 5f6d 6173 7465 7264 6174  colrev_masterdat
+00013b30: 615f 7072 6f76 656e 616e 6365 2070 726f  a_provenance pro
+00013b40: 7669 6465 7320 6869 6e74 7329 2222 220a  vides hints)""".
+00013b50: 2020 2020 6d64 5f70 7265 7061 7265 6420      md_prepared 
+00013b60: 3d20 340a 2020 2020 2222 2252 6563 6f72  = 4.    """Recor
+00013b70: 6420 6973 2070 7265 7061 7265 6420 286e  d is prepared (n
+00013b80: 6f20 6d69 7373 696e 6720 6f72 2069 6e63  o missing or inc
+00013b90: 6f6d 706c 6574 6520 6669 656c 6473 2c20  omplete fields, 
+00013ba0: 696e 636f 6e73 6973 7465 6e63 6965 7320  inconsistencies 
+00013bb0: 6368 6563 6b65 6429 2222 220a 2020 2020  checked)""".    
+00013bc0: 6d64 5f70 726f 6365 7373 6564 203d 2035  md_processed = 5
+00013bd0: 0a20 2020 2022 2222 5265 636f 7264 2068  .    """Record h
+00013be0: 6173 2062 6565 6e20 6368 6563 6b65 6420  as been checked 
+00013bf0: 666f 7220 6475 706c 6963 6174 6520 6173  for duplicate as
+00013c00: 736f 6369 6174 696f 6e73 0a20 2020 2077  sociations.    w
+00013c10: 6974 6820 616e 7920 7265 636f 7264 2069  ith any record i
+00013c20: 6e20 5265 636f 7264 5374 6174 6520 6d64  n RecordState md
+00013c30: 5f70 726f 6365 7373 6564 206f 7220 6c61  _processed or la
+00013c40: 7465 7222 2222 0a20 2020 2072 6576 5f70  ter""".    rev_p
+00013c50: 7265 7363 7265 656e 5f65 7863 6c75 6465  rescreen_exclude
+00013c60: 6420 3d20 360a 2020 2020 2222 2252 6563  d = 6.    """Rec
+00013c70: 6f72 6420 7761 7320 6578 636c 7564 6564  ord was excluded
+00013c80: 2069 6e20 7468 6520 7072 6573 6372 6565   in the prescree
+00013c90: 6e20 2862 6173 6564 206f 6e20 7469 746c  n (based on titl
+00013ca0: 6573 2f61 6273 7472 6163 7473 2922 2222  es/abstracts)"""
+00013cb0: 0a20 2020 2072 6576 5f70 7265 7363 7265  .    rev_prescre
+00013cc0: 656e 5f69 6e63 6c75 6465 6420 3d20 370a  en_included = 7.
+00013cd0: 2020 2020 2222 2252 6563 6f72 6420 7761      """Record wa
+00013ce0: 7320 696e 636c 7564 6564 2069 6e20 7468  s included in th
+00013cf0: 6520 7072 6573 6372 6565 6e20 2862 6173  e prescreen (bas
+00013d00: 6564 206f 6e20 7469 746c 6573 2f61 6273  ed on titles/abs
+00013d10: 7472 6163 7473 2922 2222 0a20 2020 2070  tracts)""".    p
+00013d20: 6466 5f6e 6565 6473 5f6d 616e 7561 6c5f  df_needs_manual_
+00013d30: 7265 7472 6965 7661 6c20 3d20 380a 2020  retrieval = 8.  
+00013d40: 2020 2222 2252 6563 6f72 6420 6d61 726b    """Record mark
+00013d50: 6564 2066 6f72 206d 616e 7561 6c20 5044  ed for manual PD
+00013d60: 4620 7265 7472 6965 7661 6c22 2222 0a20  F retrieval""". 
+00013d70: 2020 2070 6466 5f69 6d70 6f72 7465 6420     pdf_imported 
+00013d80: 3d20 390a 2020 2020 2222 2250 4446 2069  = 9.    """PDF i
+00013d90: 6d70 6f72 7465 6420 616e 6420 6d61 726b  mported and mark
+00013da0: 6564 2066 6f72 2070 7265 7061 7261 7469  ed for preparati
+00013db0: 6f6e 2222 220a 2020 2020 7064 665f 6e6f  on""".    pdf_no
+00013dc0: 745f 6176 6169 6c61 626c 6520 3d20 3130  t_available = 10
+00013dd0: 0a20 2020 2022 2222 5044 4620 6973 206e  .    """PDF is n
+00013de0: 6f74 2061 7661 696c 6162 6c65 2222 220a  ot available""".
+00013df0: 2020 2020 7064 665f 6e65 6564 735f 6d61      pdf_needs_ma
+00013e00: 6e75 616c 5f70 7265 7061 7261 7469 6f6e  nual_preparation
+00013e10: 203d 2031 310a 2020 2020 2222 2250 4446   = 11.    """PDF
+00013e20: 206d 6172 6b65 6420 666f 7220 6d61 6e75   marked for manu
+00013e30: 616c 2070 7265 7061 7261 7469 6f6e 2222  al preparation""
+00013e40: 220a 2020 2020 7064 665f 7072 6570 6172  ".    pdf_prepar
+00013e50: 6564 203d 2031 320a 2020 2020 2222 2250  ed = 12.    """P
+00013e60: 4446 2070 7265 7061 7265 6422 2222 0a20  DF prepared""". 
+00013e70: 2020 2072 6576 5f65 7863 6c75 6465 6420     rev_excluded 
+00013e80: 3d20 3133 0a20 2020 2022 2222 5265 636f  = 13.    """Reco
+00013e90: 7264 2065 7863 6c75 6465 6420 696e 2073  rd excluded in s
+00013ea0: 6372 6565 6e20 2866 756c 6c2d 7465 7874  creen (full-text
+00013eb0: 2922 2222 0a20 2020 2072 6576 5f69 6e63  )""".    rev_inc
+00013ec0: 6c75 6465 6420 3d20 3134 0a20 2020 2022  luded = 14.    "
+00013ed0: 2222 5265 636f 7264 2069 6e63 6c75 6465  ""Record include
+00013ee0: 6420 696e 2073 6372 6565 6e20 2866 756c  d in screen (ful
+00013ef0: 6c2d 7465 7874 2922 2222 0a20 2020 2072  l-text)""".    r
+00013f00: 6576 5f73 796e 7468 6573 697a 6564 203d  ev_synthesized =
+00013f10: 2031 350a 2020 2020 2222 2252 6563 6f72   15.    """Recor
+00013f20: 6420 7379 6e74 6865 7369 7a65 6422 2222  d synthesized"""
+00013f30: 0a20 2020 2023 204e 6f74 6520 3a20 5442  .    # Note : TB
+00013f40: 443a 2072 6576 5f63 6f64 6564 0a0a 2020  D: rev_coded..  
+00013f50: 2020 6465 6620 5f5f 7374 725f 5f28 7365    def __str__(se
+00013f60: 6c66 2920 2d3e 2073 7472 3a0a 2020 2020  lf) -> str:.    
+00013f70: 2020 2020 7265 7475 726e 2066 227b 7365      return f"{se
+00013f80: 6c66 2e6e 616d 657d 220a 0a20 2020 2064  lf.name}"..    d
+00013f90: 6566 205f 5f6c 745f 5f28 7365 6c66 2c20  ef __lt__(self, 
+00013fa0: 6f74 6865 7229 202d 3e20 626f 6f6c 3a20  other) -> bool: 
+00013fb0: 2023 2074 7970 653a 2069 676e 6f72 650a   # type: ignore.
+00013fc0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+00013fd0: 5f5f 636c 6173 735f 5f20 3d3d 2052 6563  __class__ == Rec
+00013fe0: 6f72 6453 7461 7465 2061 6e64 206f 7468  ordState and oth
+00013ff0: 6572 2e5f 5f63 6c61 7373 5f5f 203d 3d20  er.__class__ == 
+00014000: 5265 636f 7264 5374 6174 653a 0a20 2020  RecordState:.   
+00014010: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00014020: 7365 6c66 2e76 616c 7565 203c 206f 7468  self.value < oth
+00014030: 6572 2e76 616c 7565 0a20 2020 2020 2020  er.value.       
+00014040: 2072 6169 7365 204e 6f74 496d 706c 656d   raise NotImplem
+00014050: 656e 7465 6445 7272 6f72 0a0a 2020 2020  entedError..    
+00014060: 4063 6c61 7373 6d65 7468 6f64 0a20 2020  @classmethod.   
+00014070: 2064 6566 2067 6574 5f6e 6f6e 5f70 726f   def get_non_pro
+00014080: 6365 7373 6564 5f73 7461 7465 7328 636c  cessed_states(cl
+00014090: 7329 202d 3e20 6c69 7374 3a0a 2020 2020  s) -> list:.    
+000140a0: 2020 2020 2222 2247 6574 2074 6865 2073      """Get the s
+000140b0: 7461 7465 7320 7468 6174 2063 6f72 7265  tates that corre
+000140c0: 7370 6f6e 6420 746f 206e 6f74 2d79 6574  spond to not-yet
+000140d0: 2d70 726f 6365 7373 6564 2222 220a 2020  -processed""".  
+000140e0: 2020 2020 2020 7265 7475 726e 205b 0a20        return [. 
+000140f0: 2020 2020 2020 2020 2020 2063 6f6c 7265             colre
+00014100: 762e 7265 636f 7264 2e52 6563 6f72 6453  v.record.RecordS
+00014110: 7461 7465 2e6d 645f 7265 7472 6965 7665  tate.md_retrieve
+00014120: 642c 0a20 2020 2020 2020 2020 2020 2063  d,.            c
+00014130: 6f6c 7265 762e 7265 636f 7264 2e52 6563  olrev.record.Rec
+00014140: 6f72 6453 7461 7465 2e6d 645f 696d 706f  ordState.md_impo
+00014150: 7274 6564 2c0a 2020 2020 2020 2020 2020  rted,.          
+00014160: 2020 636f 6c72 6576 2e72 6563 6f72 642e    colrev.record.
+00014170: 5265 636f 7264 5374 6174 652e 6d64 5f70  RecordState.md_p
+00014180: 7265 7061 7265 642c 0a20 2020 2020 2020  repared,.       
+00014190: 2020 2020 2063 6f6c 7265 762e 7265 636f       colrev.reco
+000141a0: 7264 2e52 6563 6f72 6453 7461 7465 2e6d  rd.RecordState.m
+000141b0: 645f 6e65 6564 735f 6d61 6e75 616c 5f70  d_needs_manual_p
+000141c0: 7265 7061 7261 7469 6f6e 2c0a 2020 2020  reparation,.    
+000141d0: 2020 2020 5d0a 0a20 2020 2040 636c 6173      ]..    @clas
+000141e0: 736d 6574 686f 640a 2020 2020 6465 6620  smethod.    def 
+000141f0: 6765 745f 706f 7374 5f78 5f73 7461 7465  get_post_x_state
+00014200: 7328 636c 732c 202a 2c20 7374 6174 653a  s(cls, *, state:
+00014210: 2052 6563 6f72 6453 7461 7465 2920 2d3e   RecordState) ->
+00014220: 2074 7970 696e 672e 5365 745b 5265 636f   typing.Set[Reco
+00014230: 7264 5374 6174 655d 3a0a 2020 2020 2020  rdState]:.      
+00014240: 2020 2222 2247 6574 2074 6865 2073 7461    """Get the sta
+00014250: 7465 7320 6166 7465 7220 7374 6174 6520  tes after state 
+00014260: 7820 2870 6173 7365 6420 6173 2061 2070  x (passed as a p
+00014270: 6172 616d 6574 6572 2922 2222 0a20 2020  arameter)""".   
+00014280: 2020 2020 2069 6620 7374 6174 6520 3d3d       if state ==
+00014290: 2052 6563 6f72 6453 7461 7465 2e6d 645f   RecordState.md_
+000142a0: 7072 6570 6172 6564 3a0a 2020 2020 2020  prepared:.      
+000142b0: 2020 2020 2020 7265 7475 726e 207b 0a20        return {. 
+000142c0: 2020 2020 2020 2020 2020 2020 2020 2052                 R
+000142d0: 6563 6f72 6453 7461 7465 2e6d 645f 7072  ecordState.md_pr
+000142e0: 6570 6172 6564 2c0a 2020 2020 2020 2020  epared,.        
+000142f0: 2020 2020 2020 2020 5265 636f 7264 5374          RecordSt
+00014300: 6174 652e 6d64 5f70 726f 6365 7373 6564  ate.md_processed
+00014310: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00014320: 2020 5265 636f 7264 5374 6174 652e 7265    RecordState.re
+00014330: 765f 7072 6573 6372 6565 6e5f 696e 636c  v_prescreen_incl
+00014340: 7564 6564 2c0a 2020 2020 2020 2020 2020  uded,.          
+00014350: 2020 2020 2020 5265 636f 7264 5374 6174        RecordStat
+00014360: 652e 7265 765f 7072 6573 6372 6565 6e5f  e.rev_prescreen_
+00014370: 6578 636c 7564 6564 2c0a 2020 2020 2020  excluded,.      
+00014380: 2020 2020 2020 2020 2020 5265 636f 7264            Record
+00014390: 5374 6174 652e 7064 665f 6e65 6564 735f  State.pdf_needs_
+000143a0: 6d61 6e75 616c 5f72 6574 7269 6576 616c  manual_retrieval
+000143b0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000143c0: 2020 5265 636f 7264 5374 6174 652e 7064    RecordState.pd
+000143d0: 665f 696d 706f 7274 6564 2c0a 2020 2020  f_imported,.    
+000143e0: 2020 2020 2020 2020 2020 2020 5265 636f              Reco
+000143f0: 7264 5374 6174 652e 7064 665f 6e6f 745f  rdState.pdf_not_
+00014400: 6176 6169 6c61 626c 652c 0a20 2020 2020  available,.     
+00014410: 2020 2020 2020 2020 2020 2052 6563 6f72             Recor
+00014420: 6453 7461 7465 2e70 6466 5f6e 6565 6473  dState.pdf_needs
+00014430: 5f6d 616e 7561 6c5f 7072 6570 6172 6174  _manual_preparat
+00014440: 696f 6e2c 0a20 2020 2020 2020 2020 2020  ion,.           
+00014450: 2020 2020 2052 6563 6f72 6453 7461 7465       RecordState
+00014460: 2e70 6466 5f70 7265 7061 7265 642c 0a20  .pdf_prepared,. 
+00014470: 2020 2020 2020 2020 2020 2020 2020 2052                 R
+00014480: 6563 6f72 6453 7461 7465 2e72 6576 5f65  ecordState.rev_e
+00014490: 7863 6c75 6465 642c 0a20 2020 2020 2020  xcluded,.       
+000144a0: 2020 2020 2020 2020 2052 6563 6f72 6453           RecordS
+000144b0: 7461 7465 2e72 6576 5f69 6e63 6c75 6465  tate.rev_include
+000144c0: 642c 0a20 2020 2020 2020 2020 2020 2020  d,.             
+000144d0: 2020 2052 6563 6f72 6453 7461 7465 2e72     RecordState.r
+000144e0: 6576 5f73 796e 7468 6573 697a 6564 2c0a  ev_synthesized,.
+000144f0: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
+00014500: 2020 2020 2020 6966 2073 7461 7465 203d        if state =
+00014510: 3d20 5265 636f 7264 5374 6174 652e 6d64  = RecordState.md
+00014520: 5f70 726f 6365 7373 6564 3a0a 2020 2020  _processed:.    
+00014530: 2020 2020 2020 2020 7265 7475 726e 207b          return {
+00014540: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014550: 2052 6563 6f72 6453 7461 7465 2e6d 645f   RecordState.md_
+00014560: 7072 6f63 6573 7365 642c 0a20 2020 2020  processed,.     
+00014570: 2020 2020 2020 2020 2020 2052 6563 6f72             Recor
+00014580: 6453 7461 7465 2e72 6576 5f70 7265 7363  dState.rev_presc
+00014590: 7265 656e 5f69 6e63 6c75 6465 642c 0a20  reen_included,. 
+000145a0: 2020 2020 2020 2020 2020 2020 2020 2052                 R
+000145b0: 6563 6f72 6453 7461 7465 2e72 6576 5f70  ecordState.rev_p
+000145c0: 7265 7363 7265 656e 5f65 7863 6c75 6465  rescreen_exclude
 000145d0: 642c 0a20 2020 2020 2020 2020 2020 2020  d,.             
-000145e0: 2020 2052 6563 6f72 6453 7461 7465 2e72     RecordState.r
-000145f0: 6576 5f69 6e63 6c75 6465 642c 0a20 2020  ev_included,.   
-00014600: 2020 2020 2020 2020 2020 2020 2052 6563               Rec
-00014610: 6f72 6453 7461 7465 2e72 6576 5f73 796e  ordState.rev_syn
-00014620: 7468 6573 697a 6564 2c0a 2020 2020 2020  thesized,.      
-00014630: 2020 2020 2020 7d0a 0a20 2020 2020 2020        }..       
-00014640: 2069 6620 7374 6174 6520 3d3d 2052 6563   if state == Rec
-00014650: 6f72 6453 7461 7465 2e72 6576 5f69 6e63  ordState.rev_inc
-00014660: 6c75 6465 643a 0a20 2020 2020 2020 2020  luded:.         
-00014670: 2020 2072 6574 7572 6e20 7b0a 2020 2020     return {.    
-00014680: 2020 2020 2020 2020 2020 2020 5265 636f              Reco
-00014690: 7264 5374 6174 652e 7265 765f 6578 636c  rdState.rev_excl
-000146a0: 7564 6564 2c0a 2020 2020 2020 2020 2020  uded,.          
-000146b0: 2020 2020 2020 5265 636f 7264 5374 6174        RecordStat
-000146c0: 652e 7265 765f 696e 636c 7564 6564 2c0a  e.rev_included,.
-000146d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000146e0: 5265 636f 7264 5374 6174 652e 7265 765f  RecordState.rev_
-000146f0: 7379 6e74 6865 7369 7a65 642c 0a20 2020  synthesized,.   
-00014700: 2020 2020 2020 2020 207d 0a0a 2020 2020           }..    
-00014710: 2020 2020 2320 7079 6c69 6e74 3a20 6469      # pylint: di
-00014720: 7361 626c 653d 6e6f 2d6d 656d 6265 720a  sable=no-member.
-00014730: 2020 2020 2020 2020 7261 6973 6520 636f          raise co
-00014740: 6c72 6576 5f65 7863 6570 7469 6f6e 732e  lrev_exceptions.
-00014750: 5061 7261 6d65 7465 7245 7272 6f72 280a  ParameterError(.
-00014760: 2020 2020 2020 2020 2020 2020 7061 7261              para
-00014770: 6d65 7465 723d 2273 7461 7465 222c 2076  meter="state", v
-00014780: 616c 7565 3d22 7374 6174 6522 2c20 6f70  alue="state", op
-00014790: 7469 6f6e 733d 636c 732e 5f6d 656d 6265  tions=cls._membe
-000147a0: 725f 6e61 6d65 735f 0a20 2020 2020 2020  r_names_.       
-000147b0: 2029 0a0a 0a6e 6f6e 5f70 726f 6365 7373   )...non_process
-000147c0: 696e 675f 7472 616e 7369 7469 6f6e 7320  ing_transitions 
-000147d0: 3d20 5b0a 2020 2020 5b0a 2020 2020 2020  = [.    [.      
-000147e0: 2020 7b0a 2020 2020 2020 2020 2020 2020    {.            
-000147f0: 2274 7269 6767 6572 223a 2022 666f 726d  "trigger": "form
-00014800: 6174 222c 0a20 2020 2020 2020 2020 2020  at",.           
-00014810: 2022 736f 7572 6365 223a 2073 7461 7465   "source": state
-00014820: 2c0a 2020 2020 2020 2020 2020 2020 2264  ,.            "d
-00014830: 6573 7422 3a20 7374 6174 652c 0a20 2020  est": state,.   
-00014840: 2020 2020 207d 2c0a 2020 2020 2020 2020       },.        
-00014850: 7b0a 2020 2020 2020 2020 2020 2020 2274  {.            "t
-00014860: 7269 6767 6572 223a 2022 6578 706c 6f72  rigger": "explor
-00014870: 6522 2c0a 2020 2020 2020 2020 2020 2020  e",.            
-00014880: 2273 6f75 7263 6522 3a20 7374 6174 652c  "source": state,
-00014890: 0a20 2020 2020 2020 2020 2020 2022 6465  .            "de
-000148a0: 7374 223a 2073 7461 7465 2c0a 2020 2020  st": state,.    
-000148b0: 2020 2020 7d2c 0a20 2020 2020 2020 207b      },.        {
-000148c0: 0a20 2020 2020 2020 2020 2020 2022 7472  .            "tr
-000148d0: 6967 6765 7222 3a20 2263 6865 636b 222c  igger": "check",
-000148e0: 0a20 2020 2020 2020 2020 2020 2022 736f  .            "so
-000148f0: 7572 6365 223a 2073 7461 7465 2c0a 2020  urce": state,.  
-00014900: 2020 2020 2020 2020 2020 2264 6573 7422            "dest"
-00014910: 3a20 7374 6174 652c 0a20 2020 2020 2020  : state,.       
-00014920: 207d 2c0a 2020 2020 5d0a 2020 2020 666f   },.    ].    fo
-00014930: 7220 7374 6174 6520 696e 206c 6973 7428  r state in list(
-00014940: 5265 636f 7264 5374 6174 6529 0a5d 0a0a  RecordState).]..
-00014950: 0a63 6c61 7373 2052 6563 6f72 6453 7461  .class RecordSta
-00014960: 7465 4d6f 6465 6c3a 0a20 2020 2022 2222  teModel:.    """
-00014970: 5468 6520 5265 636f 7264 5374 6174 654d  The RecordStateM
-00014980: 6f64 656c 2064 6573 6372 6962 6573 2074  odel describes t
-00014990: 7261 6e73 6974 696f 6e73 2062 6574 7765  ransitions betwe
-000149a0: 656e 2052 6563 6f72 6453 7461 7465 7322  en RecordStates"
-000149b0: 2222 0a0a 2020 2020 7472 616e 7369 7469  ""..    transiti
-000149c0: 6f6e 7320 3d20 5b0a 2020 2020 2020 2020  ons = [.        
-000149d0: 7b0a 2020 2020 2020 2020 2020 2020 2274  {.            "t
-000149e0: 7269 6767 6572 223a 2022 6c6f 6164 222c  rigger": "load",
-000149f0: 0a20 2020 2020 2020 2020 2020 2022 736f  .            "so
-00014a00: 7572 6365 223a 2052 6563 6f72 6453 7461  urce": RecordSta
-00014a10: 7465 2e6d 645f 7265 7472 6965 7665 642c  te.md_retrieved,
-00014a20: 0a20 2020 2020 2020 2020 2020 2022 6465  .            "de
-00014a30: 7374 223a 2052 6563 6f72 6453 7461 7465  st": RecordState
-00014a40: 2e6d 645f 696d 706f 7274 6564 2c0a 2020  .md_imported,.  
-00014a50: 2020 2020 2020 7d2c 0a20 2020 2020 2020        },.       
-00014a60: 207b 0a20 2020 2020 2020 2020 2020 2022   {.            "
-00014a70: 7472 6967 6765 7222 3a20 2270 7265 7022  trigger": "prep"
-00014a80: 2c0a 2020 2020 2020 2020 2020 2020 2273  ,.            "s
-00014a90: 6f75 7263 6522 3a20 5265 636f 7264 5374  ource": RecordSt
-00014aa0: 6174 652e 6d64 5f69 6d70 6f72 7465 642c  ate.md_imported,
-00014ab0: 0a20 2020 2020 2020 2020 2020 2022 6465  .            "de
-00014ac0: 7374 223a 2052 6563 6f72 6453 7461 7465  st": RecordState
-00014ad0: 2e6d 645f 6e65 6564 735f 6d61 6e75 616c  .md_needs_manual
-00014ae0: 5f70 7265 7061 7261 7469 6f6e 2c0a 2020  _preparation,.  
-00014af0: 2020 2020 2020 7d2c 0a20 2020 2020 2020        },.       
-00014b00: 207b 0a20 2020 2020 2020 2020 2020 2022   {.            "
-00014b10: 7472 6967 6765 7222 3a20 2270 7265 7022  trigger": "prep"
-00014b20: 2c0a 2020 2020 2020 2020 2020 2020 2273  ,.            "s
-00014b30: 6f75 7263 6522 3a20 5265 636f 7264 5374  ource": RecordSt
-00014b40: 6174 652e 6d64 5f69 6d70 6f72 7465 642c  ate.md_imported,
-00014b50: 0a20 2020 2020 2020 2020 2020 2022 6465  .            "de
-00014b60: 7374 223a 2052 6563 6f72 6453 7461 7465  st": RecordState
-00014b70: 2e6d 645f 7072 6570 6172 6564 2c0a 2020  .md_prepared,.  
-00014b80: 2020 2020 2020 7d2c 0a20 2020 2020 2020        },.       
-00014b90: 207b 0a20 2020 2020 2020 2020 2020 2022   {.            "
-00014ba0: 7472 6967 6765 7222 3a20 2270 7265 705f  trigger": "prep_
-00014bb0: 6d61 6e22 2c0a 2020 2020 2020 2020 2020  man",.          
-00014bc0: 2020 2273 6f75 7263 6522 3a20 5265 636f    "source": Reco
-00014bd0: 7264 5374 6174 652e 6d64 5f6e 6565 6473  rdState.md_needs
-00014be0: 5f6d 616e 7561 6c5f 7072 6570 6172 6174  _manual_preparat
-00014bf0: 696f 6e2c 0a20 2020 2020 2020 2020 2020  ion,.           
-00014c00: 2022 6465 7374 223a 2052 6563 6f72 6453   "dest": RecordS
-00014c10: 7461 7465 2e6d 645f 7072 6570 6172 6564  tate.md_prepared
-00014c20: 2c0a 2020 2020 2020 2020 7d2c 0a20 2020  ,.        },.   
-00014c30: 2020 2020 207b 0a20 2020 2020 2020 2020       {.         
-00014c40: 2020 2022 7472 6967 6765 7222 3a20 2264     "trigger": "d
-00014c50: 6564 7570 6522 2c0a 2020 2020 2020 2020  edupe",.        
-00014c60: 2020 2020 2273 6f75 7263 6522 3a20 5265      "source": Re
-00014c70: 636f 7264 5374 6174 652e 6d64 5f70 7265  cordState.md_pre
-00014c80: 7061 7265 642c 0a20 2020 2020 2020 2020  pared,.         
-00014c90: 2020 2022 6465 7374 223a 2052 6563 6f72     "dest": Recor
-00014ca0: 6453 7461 7465 2e6d 645f 7072 6f63 6573  dState.md_proces
-00014cb0: 7365 642c 0a20 2020 2020 2020 207d 2c0a  sed,.        },.
-00014cc0: 2020 2020 2020 2020 7b0a 2020 2020 2020          {.      
-00014cd0: 2020 2020 2020 2274 7269 6767 6572 223a        "trigger":
-00014ce0: 2022 7072 6573 6372 6565 6e22 2c0a 2020   "prescreen",.  
-00014cf0: 2020 2020 2020 2020 2020 2273 6f75 7263            "sourc
-00014d00: 6522 3a20 5265 636f 7264 5374 6174 652e  e": RecordState.
-00014d10: 6d64 5f70 726f 6365 7373 6564 2c0a 2020  md_processed,.  
-00014d20: 2020 2020 2020 2020 2020 2264 6573 7422            "dest"
-00014d30: 3a20 5265 636f 7264 5374 6174 652e 7265  : RecordState.re
-00014d40: 765f 7072 6573 6372 6565 6e5f 6578 636c  v_prescreen_excl
-00014d50: 7564 6564 2c0a 2020 2020 2020 2020 7d2c  uded,.        },
-00014d60: 0a20 2020 2020 2020 207b 0a20 2020 2020  .        {.     
-00014d70: 2020 2020 2020 2022 7472 6967 6765 7222         "trigger"
-00014d80: 3a20 2270 7265 7363 7265 656e 222c 0a20  : "prescreen",. 
-00014d90: 2020 2020 2020 2020 2020 2022 736f 7572             "sour
-00014da0: 6365 223a 2052 6563 6f72 6453 7461 7465  ce": RecordState
-00014db0: 2e6d 645f 7072 6f63 6573 7365 642c 0a20  .md_processed,. 
-00014dc0: 2020 2020 2020 2020 2020 2022 6465 7374             "dest
-00014dd0: 223a 2052 6563 6f72 6453 7461 7465 2e72  ": RecordState.r
-00014de0: 6576 5f70 7265 7363 7265 656e 5f69 6e63  ev_prescreen_inc
-00014df0: 6c75 6465 642c 0a20 2020 2020 2020 207d  luded,.        }
-00014e00: 2c0a 2020 2020 2020 2020 7b0a 2020 2020  ,.        {.    
-00014e10: 2020 2020 2020 2020 2274 7269 6767 6572          "trigger
-00014e20: 223a 2022 7064 665f 6765 7422 2c0a 2020  ": "pdf_get",.  
-00014e30: 2020 2020 2020 2020 2020 2273 6f75 7263            "sourc
-00014e40: 6522 3a20 5265 636f 7264 5374 6174 652e  e": RecordState.
-00014e50: 7265 765f 7072 6573 6372 6565 6e5f 696e  rev_prescreen_in
-00014e60: 636c 7564 6564 2c0a 2020 2020 2020 2020  cluded,.        
-00014e70: 2020 2020 2264 6573 7422 3a20 5265 636f      "dest": Reco
-00014e80: 7264 5374 6174 652e 7064 665f 696d 706f  rdState.pdf_impo
-00014e90: 7274 6564 2c0a 2020 2020 2020 2020 7d2c  rted,.        },
-00014ea0: 0a20 2020 2020 2020 207b 0a20 2020 2020  .        {.     
-00014eb0: 2020 2020 2020 2022 7472 6967 6765 7222         "trigger"
-00014ec0: 3a20 2270 6466 5f67 6574 222c 0a20 2020  : "pdf_get",.   
-00014ed0: 2020 2020 2020 2020 2022 736f 7572 6365           "source
-00014ee0: 223a 2052 6563 6f72 6453 7461 7465 2e72  ": RecordState.r
-00014ef0: 6576 5f70 7265 7363 7265 656e 5f69 6e63  ev_prescreen_inc
-00014f00: 6c75 6465 642c 0a20 2020 2020 2020 2020  luded,.         
-00014f10: 2020 2022 6465 7374 223a 2052 6563 6f72     "dest": Recor
-00014f20: 6453 7461 7465 2e70 6466 5f6e 6565 6473  dState.pdf_needs
-00014f30: 5f6d 616e 7561 6c5f 7265 7472 6965 7661  _manual_retrieva
-00014f40: 6c2c 0a20 2020 2020 2020 207d 2c0a 2020  l,.        },.  
-00014f50: 2020 2020 2020 7b0a 2020 2020 2020 2020        {.        
-00014f60: 2020 2020 2274 7269 6767 6572 223a 2022      "trigger": "
-00014f70: 7064 665f 6765 745f 6d61 6e22 2c0a 2020  pdf_get_man",.  
-00014f80: 2020 2020 2020 2020 2020 2273 6f75 7263            "sourc
-00014f90: 6522 3a20 5265 636f 7264 5374 6174 652e  e": RecordState.
-00014fa0: 7064 665f 6e65 6564 735f 6d61 6e75 616c  pdf_needs_manual
-00014fb0: 5f72 6574 7269 6576 616c 2c0a 2020 2020  _retrieval,.    
-00014fc0: 2020 2020 2020 2020 2264 6573 7422 3a20          "dest": 
-00014fd0: 5265 636f 7264 5374 6174 652e 7064 665f  RecordState.pdf_
-00014fe0: 6e6f 745f 6176 6169 6c61 626c 652c 0a20  not_available,. 
-00014ff0: 2020 2020 2020 207d 2c0a 2020 2020 2020         },.      
-00015000: 2020 7b0a 2020 2020 2020 2020 2020 2020    {.            
-00015010: 2274 7269 6767 6572 223a 2022 7064 665f  "trigger": "pdf_
-00015020: 6765 745f 6d61 6e22 2c0a 2020 2020 2020  get_man",.      
-00015030: 2020 2020 2020 2273 6f75 7263 6522 3a20        "source": 
-00015040: 5265 636f 7264 5374 6174 652e 7064 665f  RecordState.pdf_
-00015050: 6e65 6564 735f 6d61 6e75 616c 5f72 6574  needs_manual_ret
-00015060: 7269 6576 616c 2c0a 2020 2020 2020 2020  rieval,.        
-00015070: 2020 2020 2264 6573 7422 3a20 5265 636f      "dest": Reco
-00015080: 7264 5374 6174 652e 7064 665f 696d 706f  rdState.pdf_impo
-00015090: 7274 6564 2c0a 2020 2020 2020 2020 7d2c  rted,.        },
-000150a0: 0a20 2020 2020 2020 207b 0a20 2020 2020  .        {.     
-000150b0: 2020 2020 2020 2022 7472 6967 6765 7222         "trigger"
-000150c0: 3a20 2270 6466 5f70 7265 7022 2c0a 2020  : "pdf_prep",.  
-000150d0: 2020 2020 2020 2020 2020 2273 6f75 7263            "sourc
-000150e0: 6522 3a20 5265 636f 7264 5374 6174 652e  e": RecordState.
-000150f0: 7064 665f 696d 706f 7274 6564 2c0a 2020  pdf_imported,.  
-00015100: 2020 2020 2020 2020 2020 2264 6573 7422            "dest"
-00015110: 3a20 5265 636f 7264 5374 6174 652e 7064  : RecordState.pd
-00015120: 665f 6e65 6564 735f 6d61 6e75 616c 5f70  f_needs_manual_p
-00015130: 7265 7061 7261 7469 6f6e 2c0a 2020 2020  reparation,.    
-00015140: 2020 2020 7d2c 0a20 2020 2020 2020 207b      },.        {
-00015150: 0a20 2020 2020 2020 2020 2020 2022 7472  .            "tr
-00015160: 6967 6765 7222 3a20 2270 6466 5f70 7265  igger": "pdf_pre
-00015170: 7022 2c0a 2020 2020 2020 2020 2020 2020  p",.            
-00015180: 2273 6f75 7263 6522 3a20 5265 636f 7264  "source": Record
-00015190: 5374 6174 652e 7064 665f 696d 706f 7274  State.pdf_import
-000151a0: 6564 2c0a 2020 2020 2020 2020 2020 2020  ed,.            
-000151b0: 2264 6573 7422 3a20 5265 636f 7264 5374  "dest": RecordSt
-000151c0: 6174 652e 7064 665f 7072 6570 6172 6564  ate.pdf_prepared
-000151d0: 2c0a 2020 2020 2020 2020 7d2c 0a20 2020  ,.        },.   
-000151e0: 2020 2020 207b 0a20 2020 2020 2020 2020       {.         
-000151f0: 2020 2022 7472 6967 6765 7222 3a20 2270     "trigger": "p
-00015200: 6466 5f70 7265 705f 6d61 6e22 2c0a 2020  df_prep_man",.  
-00015210: 2020 2020 2020 2020 2020 2273 6f75 7263            "sourc
-00015220: 6522 3a20 5265 636f 7264 5374 6174 652e  e": RecordState.
-00015230: 7064 665f 6e65 6564 735f 6d61 6e75 616c  pdf_needs_manual
-00015240: 5f70 7265 7061 7261 7469 6f6e 2c0a 2020  _preparation,.  
-00015250: 2020 2020 2020 2020 2020 2264 6573 7422            "dest"
-00015260: 3a20 5265 636f 7264 5374 6174 652e 7064  : RecordState.pd
-00015270: 665f 7072 6570 6172 6564 2c0a 2020 2020  f_prepared,.    
-00015280: 2020 2020 7d2c 0a20 2020 2020 2020 207b      },.        {
-00015290: 0a20 2020 2020 2020 2020 2020 2022 7472  .            "tr
-000152a0: 6967 6765 7222 3a20 2273 6372 6565 6e22  igger": "screen"
-000152b0: 2c0a 2020 2020 2020 2020 2020 2020 2273  ,.            "s
-000152c0: 6f75 7263 6522 3a20 5265 636f 7264 5374  ource": RecordSt
-000152d0: 6174 652e 7064 665f 7072 6570 6172 6564  ate.pdf_prepared
-000152e0: 2c0a 2020 2020 2020 2020 2020 2020 2264  ,.            "d
-000152f0: 6573 7422 3a20 5265 636f 7264 5374 6174  est": RecordStat
-00015300: 652e 7265 765f 6578 636c 7564 6564 2c0a  e.rev_excluded,.
-00015310: 2020 2020 2020 2020 7d2c 0a20 2020 2020          },.     
-00015320: 2020 207b 0a20 2020 2020 2020 2020 2020     {.           
-00015330: 2022 7472 6967 6765 7222 3a20 2273 6372   "trigger": "scr
-00015340: 6565 6e22 2c0a 2020 2020 2020 2020 2020  een",.          
-00015350: 2020 2273 6f75 7263 6522 3a20 5265 636f    "source": Reco
-00015360: 7264 5374 6174 652e 7064 665f 7072 6570  rdState.pdf_prep
-00015370: 6172 6564 2c0a 2020 2020 2020 2020 2020  ared,.          
-00015380: 2020 2264 6573 7422 3a20 5265 636f 7264    "dest": Record
-00015390: 5374 6174 652e 7265 765f 696e 636c 7564  State.rev_includ
-000153a0: 6564 2c0a 2020 2020 2020 2020 7d2c 0a20  ed,.        },. 
-000153b0: 2020 2020 2020 207b 0a20 2020 2020 2020         {.       
-000153c0: 2020 2020 2022 7472 6967 6765 7222 3a20       "trigger": 
-000153d0: 2264 6174 6122 2c0a 2020 2020 2020 2020  "data",.        
-000153e0: 2020 2020 2273 6f75 7263 6522 3a20 5265      "source": Re
-000153f0: 636f 7264 5374 6174 652e 7265 765f 696e  cordState.rev_in
-00015400: 636c 7564 6564 2c0a 2020 2020 2020 2020  cluded,.        
-00015410: 2020 2020 2264 6573 7422 3a20 5265 636f      "dest": Reco
-00015420: 7264 5374 6174 652e 7265 765f 7379 6e74  rdState.rev_synt
-00015430: 6865 7369 7a65 642c 0a20 2020 2020 2020  hesized,.       
-00015440: 207d 2c0a 2020 2020 5d0a 0a20 2020 2074   },.    ]..    t
-00015450: 7261 6e73 6974 696f 6e73 5f6e 6f6e 5f70  ransitions_non_p
-00015460: 726f 6365 7373 696e 6720 3d20 5b0a 2020  rocessing = [.  
-00015470: 2020 2020 2020 6974 656d 2066 6f72 2073        item for s
-00015480: 7562 6c69 7374 2069 6e20 6e6f 6e5f 7072  ublist in non_pr
-00015490: 6f63 6573 7369 6e67 5f74 7261 6e73 6974  ocessing_transit
-000154a0: 696f 6e73 2066 6f72 2069 7465 6d20 696e  ions for item in
-000154b0: 2073 7562 6c69 7374 0a20 2020 205d 0a0a   sublist.    ]..
-000154c0: 2020 2020 2320 6672 6f6d 2074 7261 6e73      # from trans
-000154d0: 6974 696f 6e73 2069 6d70 6f72 7420 4d61  itions import Ma
-000154e0: 6368 696e 650a 2020 2020 2320 6465 6620  chine.    # def 
-000154f0: 5f5f 696e 6974 5f5f 280a 2020 2020 2320  __init__(.    # 
-00015500: 2020 2020 7365 6c66 2c0a 2020 2020 2320      self,.    # 
-00015510: 2020 2020 2a2c 0a20 2020 2023 2020 2020      *,.    #    
-00015520: 2073 7461 7465 3a20 5265 636f 7264 5374   state: RecordSt
-00015530: 6174 652c 0a20 2020 2023 2029 202d 3e20  ate,.    # ) -> 
-00015540: 4e6f 6e65 3a0a 2020 2020 2320 2020 2020  None:.    #     
-00015550: 7365 6c66 2e73 7461 7465 203d 2073 7461  self.state = sta
-00015560: 7465 0a0a 2020 2020 2320 2020 2020 7365  te..    #     se
-00015570: 6c66 2e6d 6163 6869 6e65 203d 204d 6163  lf.machine = Mac
-00015580: 6869 6e65 280a 2020 2020 2320 2020 2020  hine(.    #     
-00015590: 2020 2020 6d6f 6465 6c3d 7365 6c66 2c0a      model=self,.
-000155a0: 2020 2020 2320 2020 2020 2020 2020 7374      #         st
-000155b0: 6174 6573 3d52 6563 6f72 6453 7461 7465  ates=RecordState
-000155c0: 2c0a 2020 2020 2320 2020 2020 2020 2020  ,.    #         
-000155d0: 7472 616e 7369 7469 6f6e 733d 7365 6c66  transitions=self
-000155e0: 2e74 7261 6e73 6974 696f 6e73 202b 2073  .transitions + s
-000155f0: 656c 662e 7472 616e 7369 7469 6f6e 735f  elf.transitions_
-00015600: 6e6f 6e5f 7072 6f63 6573 7369 6e67 2c0a  non_processing,.
-00015610: 2020 2020 2320 2020 2020 2020 2020 696e      #         in
-00015620: 6974 6961 6c3d 7365 6c66 2e73 7461 7465  itial=self.state
-00015630: 2c0a 2020 2020 2320 2020 2020 290a 0a20  ,.    #     ).. 
-00015640: 2020 2040 636c 6173 736d 6574 686f 640a     @classmethod.
-00015650: 2020 2020 6465 6620 6765 745f 7661 6c69      def get_vali
-00015660: 645f 7472 616e 7369 7469 6f6e 7328 636c  d_transitions(cl
-00015670: 732c 202a 2c20 7374 6174 653a 2052 6563  s, *, state: Rec
-00015680: 6f72 6453 7461 7465 2920 2d3e 2073 6574  ordState) -> set
-00015690: 3a0a 2020 2020 2020 2020 2222 2247 6574  :.        """Get
-000156a0: 2074 6865 206c 6973 7420 6f66 2076 616c   the list of val
-000156b0: 6964 2074 7261 6e73 6974 696f 6e73 2222  id transitions""
-000156c0: 220a 2020 2020 2020 2020 6c6f 6767 696e  ".        loggin
-000156d0: 672e 6765 744c 6f67 6765 7228 2274 7261  g.getLogger("tra
-000156e0: 6e73 6974 696f 6e73 2229 2e73 6574 4c65  nsitions").setLe
-000156f0: 7665 6c28 6c6f 6767 696e 672e 5741 524e  vel(logging.WARN
-00015700: 494e 4729 0a20 2020 2020 2020 2072 6574  ING).        ret
-00015710: 7572 6e20 7365 7428 7b78 5b22 7472 6967  urn set({x["trig
-00015720: 6765 7222 5d20 666f 7220 7820 696e 2063  ger"] for x in c
-00015730: 6c73 2e74 7261 6e73 6974 696f 6e73 2069  ls.transitions i
-00015740: 6620 785b 2273 6f75 7263 6522 5d20 3d3d  f x["source"] ==
-00015750: 2073 7461 7465 7d29 0a0a 2020 2020 4063   state})..    @c
-00015760: 6c61 7373 6d65 7468 6f64 0a20 2020 2064  lassmethod.    d
-00015770: 6566 2067 6574 5f70 7265 6365 6469 6e67  ef get_preceding
-00015780: 5f73 7461 7465 7328 636c 732c 202a 2c20  _states(cls, *, 
-00015790: 7374 6174 653a 2052 6563 6f72 6453 7461  state: RecordSta
-000157a0: 7465 2920 2d3e 2073 6574 3a0a 2020 2020  te) -> set:.    
-000157b0: 2020 2020 2222 2247 6574 2074 6865 2073      """Get the s
-000157c0: 7461 7465 7320 7072 6563 6564 696e 6720  tates preceding 
-000157d0: 7468 6520 7374 6174 6520 7468 6174 2069  the state that i
-000157e0: 7320 6769 7665 6e20 6173 2061 2070 6172  s given as a par
-000157f0: 616d 6574 6572 2222 220a 0a20 2020 2020  ameter"""..     
-00015800: 2020 206c 6f67 6769 6e67 2e67 6574 4c6f     logging.getLo
-00015810: 6767 6572 2822 7472 616e 7369 7469 6f6e  gger("transition
-00015820: 7322 292e 7365 744c 6576 656c 286c 6f67  s").setLevel(log
-00015830: 6769 6e67 2e57 4152 4e49 4e47 290a 2020  ging.WARNING).  
-00015840: 2020 2020 2020 7072 6563 6564 696e 675f        preceding_
-00015850: 7374 6174 6573 3a20 7365 745b 5265 636f  states: set[Reco
-00015860: 7264 5374 6174 655d 203d 2073 6574 2829  rdState] = set()
-00015870: 0a20 2020 2020 2020 2061 6464 6564 203d  .        added =
-00015880: 2054 7275 650a 2020 2020 2020 2020 7768   True.        wh
-00015890: 696c 6520 6164 6465 643a 0a20 2020 2020  ile added:.     
-000158a0: 2020 2020 2020 2070 7265 6365 6469 6e67         preceding
-000158b0: 5f73 7461 7465 735f 7369 7a65 203d 206c  _states_size = l
-000158c0: 656e 2870 7265 6365 6469 6e67 5f73 7461  en(preceding_sta
-000158d0: 7465 7329 0a20 2020 2020 2020 2020 2020  tes).           
-000158e0: 2066 6f72 2074 7261 6e73 6974 696f 6e20   for transition 
-000158f0: 696e 2052 6563 6f72 6453 7461 7465 4d6f  in RecordStateMo
-00015900: 6465 6c2e 7472 616e 7369 7469 6f6e 733a  del.transitions:
-00015910: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015920: 2069 6620 280a 2020 2020 2020 2020 2020   if (.          
-00015930: 2020 2020 2020 2020 2020 7472 616e 7369            transi
-00015940: 7469 6f6e 5b22 6465 7374 225d 2069 6e20  tion["dest"] in 
-00015950: 7072 6563 6564 696e 675f 7374 6174 6573  preceding_states
-00015960: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015970: 2020 2020 206f 7220 7374 6174 6520 3d3d       or state ==
-00015980: 2074 7261 6e73 6974 696f 6e5b 2264 6573   transition["des
-00015990: 7422 5d0a 2020 2020 2020 2020 2020 2020  t"].            
-000159a0: 2020 2020 293a 0a20 2020 2020 2020 2020      ):.         
-000159b0: 2020 2020 2020 2020 2020 2070 7265 6365             prece
-000159c0: 6469 6e67 5f73 7461 7465 732e 6164 6428  ding_states.add(
-000159d0: 7472 616e 7369 7469 6f6e 5b22 736f 7572  transition["sour
-000159e0: 6365 225d 2920 2023 2074 7970 653a 2069  ce"])  # type: i
-000159f0: 676e 6f72 650a 2020 2020 2020 2020 2020  gnore.          
-00015a00: 2020 6966 2070 7265 6365 6469 6e67 5f73    if preceding_s
-00015a10: 7461 7465 735f 7369 7a65 203d 3d20 6c65  tates_size == le
-00015a20: 6e28 7072 6563 6564 696e 675f 7374 6174  n(preceding_stat
-00015a30: 6573 293a 0a20 2020 2020 2020 2020 2020  es):.           
-00015a40: 2020 2020 2061 6464 6564 203d 2046 616c       added = Fal
-00015a50: 7365 0a20 2020 2020 2020 2072 6574 7572  se.        retur
-00015a60: 6e20 7072 6563 6564 696e 675f 7374 6174  n preceding_stat
-00015a70: 6573 0a0a 2020 2020 4063 6c61 7373 6d65  es..    @classme
-00015a80: 7468 6f64 0a20 2020 2064 6566 2063 6865  thod.    def che
-00015a90: 636b 5f6f 7065 7261 7469 6f6e 5f70 7265  ck_operation_pre
-00015aa0: 636f 6e64 6974 696f 6e28 0a20 2020 2020  condition(.     
-00015ab0: 2020 2063 6c73 2c20 2a2c 206f 7065 7261     cls, *, opera
-00015ac0: 7469 6f6e 3a20 636f 6c72 6576 2e6f 7065  tion: colrev.ope
-00015ad0: 7261 7469 6f6e 2e4f 7065 7261 7469 6f6e  ration.Operation
-00015ae0: 0a20 2020 2029 202d 3e20 4e6f 6e65 3a0a  .    ) -> None:.
-00015af0: 2020 2020 2020 2020 2222 2243 6865 636b          """Check
-00015b00: 2074 6865 2070 7265 636f 6e64 6974 696f   the preconditio
-00015b10: 6e73 2066 6f72 2061 6e20 6f70 6572 6174  ns for an operat
-00015b20: 696f 6e22 2222 0a0a 2020 2020 2020 2020  ion"""..        
-00015b30: 6465 6620 6765 745f 7374 6174 6573 5f73  def get_states_s
-00015b40: 6574 2829 202d 3e20 7365 743a 0a20 2020  et() -> set:.   
-00015b50: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
-00015b60: 6f70 6572 6174 696f 6e2e 7265 7669 6577  operation.review
-00015b70: 5f6d 616e 6167 6572 2e64 6174 6173 6574  _manager.dataset
-00015b80: 2e72 6563 6f72 6473 5f66 696c 652e 6973  .records_file.is
-00015b90: 5f66 696c 6528 293a 0a20 2020 2020 2020  _file():.       
-00015ba0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-00015bb0: 7365 7428 290a 2020 2020 2020 2020 2020  set().          
-00015bc0: 2020 7265 636f 7264 735f 6865 6164 6572    records_header
-00015bd0: 7320 3d20 6f70 6572 6174 696f 6e2e 7265  s = operation.re
-00015be0: 7669 6577 5f6d 616e 6167 6572 2e64 6174  view_manager.dat
-00015bf0: 6173 6574 2e6c 6f61 645f 7265 636f 7264  aset.load_record
-00015c00: 735f 6469 6374 280a 2020 2020 2020 2020  s_dict(.        
-00015c10: 2020 2020 2020 2020 6865 6164 6572 5f6f          header_o
-00015c20: 6e6c 793d 5472 7565 0a20 2020 2020 2020  nly=True.       
-00015c30: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-00015c40: 2020 2072 6563 6f72 645f 6865 6164 6572     record_header
-00015c50: 5f6c 6973 7420 3d20 6c69 7374 2872 6563  _list = list(rec
-00015c60: 6f72 6473 5f68 6561 6465 7273 2e76 616c  ords_headers.val
-00015c70: 7565 7328 2929 0a0a 2020 2020 2020 2020  ues())..        
-00015c80: 2020 2020 7265 7475 726e 207b 656c 5b22      return {el["
-00015c90: 636f 6c72 6576 5f73 7461 7475 7322 5d20  colrev_status"] 
-00015ca0: 666f 7220 656c 2069 6e20 7265 636f 7264  for el in record
-00015cb0: 5f68 6561 6465 725f 6c69 7374 7d0a 0a20  _header_list}.. 
-00015cc0: 2020 2020 2020 2069 6620 6f70 6572 6174         if operat
-00015cd0: 696f 6e2e 7265 7669 6577 5f6d 616e 6167  ion.review_manag
-00015ce0: 6572 2e73 6574 7469 6e67 732e 7072 6f6a  er.settings.proj
-00015cf0: 6563 742e 6465 6c61 795f 6175 746f 6d61  ect.delay_automa
-00015d00: 7465 645f 7072 6f63 6573 7369 6e67 3a0a  ted_processing:.
-00015d10: 2020 2020 2020 2020 2020 2020 7374 6172              star
-00015d20: 745f 7374 6174 6573 3a20 6c69 7374 5b73  t_states: list[s
-00015d30: 7472 5d20 3d20 5b0a 2020 2020 2020 2020  tr] = [.        
-00015d40: 2020 2020 2020 2020 7374 7228 785b 2273          str(x["s
-00015d50: 6f75 7263 6522 5d29 0a20 2020 2020 2020  ource"]).       
-00015d60: 2020 2020 2020 2020 2066 6f72 2078 2069           for x i
-00015d70: 6e20 636f 6c72 6576 2e72 6563 6f72 642e  n colrev.record.
-00015d80: 5265 636f 7264 5374 6174 654d 6f64 656c  RecordStateModel
-00015d90: 2e74 7261 6e73 6974 696f 6e73 0a20 2020  .transitions.   
-00015da0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00015db0: 7374 7228 6f70 6572 6174 696f 6e2e 7479  str(operation.ty
-00015dc0: 7065 2920 3d3d 2078 5b22 7472 6967 6765  pe) == x["trigge
-00015dd0: 7222 5d0a 2020 2020 2020 2020 2020 2020  r"].            
-00015de0: 5d0a 2020 2020 2020 2020 2020 2020 7374  ].            st
-00015df0: 6174 6520 3d20 636f 6c72 6576 2e72 6563  ate = colrev.rec
-00015e00: 6f72 642e 5265 636f 7264 5374 6174 655b  ord.RecordState[
-00015e10: 7374 6172 745f 7374 6174 6573 5b30 5d5d  start_states[0]]
-00015e20: 0a0a 2020 2020 2020 2020 2020 2020 6375  ..            cu
-00015e30: 725f 7374 6174 655f 6c69 7374 203d 2067  r_state_list = g
-00015e40: 6574 5f73 7461 7465 735f 7365 7428 290a  et_states_set().
-00015e50: 2020 2020 2020 2020 2020 2020 2320 7365              # se
-00015e60: 6c66 2e72 6576 6965 775f 6d61 6e61 6765  lf.review_manage
-00015e70: 722e 6c6f 6767 6572 2e64 6562 7567 2866  r.logger.debug(f
-00015e80: 2263 7572 5f73 7461 7465 5f6c 6973 743a  "cur_state_list:
-00015e90: 207b 6375 725f 7374 6174 655f 6c69 7374   {cur_state_list
-00015ea0: 7d22 290a 2020 2020 2020 2020 2020 2020  }").            
-00015eb0: 2320 7365 6c66 2e72 6576 6965 775f 6d61  # self.review_ma
-00015ec0: 6e61 6765 722e 6c6f 6767 6572 2e64 6562  nager.logger.deb
-00015ed0: 7567 2866 2270 7265 636f 6e64 6974 696f  ug(f"preconditio
-00015ee0: 6e3a 207b 7365 6c66 2e73 7461 7465 7d22  n: {self.state}"
-00015ef0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
-00015f00: 7175 6972 6564 5f61 6273 656e 7420 3d20  quired_absent = 
-00015f10: 636c 732e 6765 745f 7072 6563 6564 696e  cls.get_precedin
-00015f20: 675f 7374 6174 6573 2873 7461 7465 3d73  g_states(state=s
-00015f30: 7461 7465 290a 2020 2020 2020 2020 2020  tate).          
-00015f40: 2020 2320 7365 6c66 2e72 6576 6965 775f    # self.review_
-00015f50: 6d61 6e61 6765 722e 6c6f 6767 6572 2e64  manager.logger.d
-00015f60: 6562 7567 2866 2272 6571 7569 7265 645f  ebug(f"required_
-00015f70: 6162 7365 6e74 3a20 7b72 6571 7569 7265  absent: {require
-00015f80: 645f 6162 7365 6e74 7d22 290a 2020 2020  d_absent}").    
-00015f90: 2020 2020 2020 2020 696e 7465 7273 6563          intersec
-00015fa0: 7469 6f6e 203d 2063 7572 5f73 7461 7465  tion = cur_state
-00015fb0: 5f6c 6973 742e 696e 7465 7273 6563 7469  _list.intersecti
-00015fc0: 6f6e 2872 6571 7569 7265 645f 6162 7365  on(required_abse
-00015fd0: 6e74 290a 2020 2020 2020 2020 2020 2020  nt).            
-00015fe0: 6966 2028 0a20 2020 2020 2020 2020 2020  if (.           
-00015ff0: 2020 2020 206c 656e 2863 7572 5f73 7461       len(cur_sta
-00016000: 7465 5f6c 6973 7429 203d 3d20 300a 2020  te_list) == 0.  
-00016010: 2020 2020 2020 2020 2020 2020 2020 616e                an
-00016020: 6420 6e6f 7420 6f70 6572 6174 696f 6e2e  d not operation.
-00016030: 7479 7065 2e6e 616d 6520 3d3d 2022 6c6f  type.name == "lo
-00016040: 6164 2220 2023 2074 7970 653a 2069 676e  ad"  # type: ign
-00016050: 6f72 650a 2020 2020 2020 2020 2020 2020  ore.            
-00016060: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-00016070: 2020 2072 6169 7365 2063 6f6c 7265 765f     raise colrev_
-00016080: 6578 6365 7074 696f 6e73 2e4e 6f52 6563  exceptions.NoRec
-00016090: 6f72 6473 4572 726f 7228 290a 2020 2020  ordsError().    
-000160a0: 2020 2020 2020 2020 6966 206c 656e 2869          if len(i
-000160b0: 6e74 6572 7365 6374 696f 6e29 2021 3d20  ntersection) != 
-000160c0: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
-000160d0: 2020 2072 6169 7365 2063 6f6c 7265 765f     raise colrev_
-000160e0: 6578 6365 7074 696f 6e73 2e50 726f 6365  exceptions.Proce
-000160f0: 7373 4f72 6465 7256 696f 6c61 7469 6f6e  ssOrderViolation
-00016100: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00016110: 2020 2020 2020 6f70 6572 6174 696f 6e2e        operation.
-00016120: 7479 7065 2e6e 616d 652c 2073 7472 2873  type.name, str(s
-00016130: 7461 7465 292c 206c 6973 7428 696e 7465  tate), list(inte
-00016140: 7273 6563 7469 6f6e 290a 2020 2020 2020  rsection).      
-00016150: 2020 2020 2020 2020 2020 290a                      ).
+000145e0: 2020 2052 6563 6f72 6453 7461 7465 2e70     RecordState.p
+000145f0: 6466 5f6e 6565 6473 5f6d 616e 7561 6c5f  df_needs_manual_
+00014600: 7265 7472 6965 7661 6c2c 0a20 2020 2020  retrieval,.     
+00014610: 2020 2020 2020 2020 2020 2052 6563 6f72             Recor
+00014620: 6453 7461 7465 2e70 6466 5f69 6d70 6f72  dState.pdf_impor
+00014630: 7465 642c 0a20 2020 2020 2020 2020 2020  ted,.           
+00014640: 2020 2020 2052 6563 6f72 6453 7461 7465       RecordState
+00014650: 2e70 6466 5f6e 6f74 5f61 7661 696c 6162  .pdf_not_availab
+00014660: 6c65 2c0a 2020 2020 2020 2020 2020 2020  le,.            
+00014670: 2020 2020 5265 636f 7264 5374 6174 652e      RecordState.
+00014680: 7064 665f 6e65 6564 735f 6d61 6e75 616c  pdf_needs_manual
+00014690: 5f70 7265 7061 7261 7469 6f6e 2c0a 2020  _preparation,.  
+000146a0: 2020 2020 2020 2020 2020 2020 2020 5265                Re
+000146b0: 636f 7264 5374 6174 652e 7064 665f 7072  cordState.pdf_pr
+000146c0: 6570 6172 6564 2c0a 2020 2020 2020 2020  epared,.        
+000146d0: 2020 2020 2020 2020 5265 636f 7264 5374          RecordSt
+000146e0: 6174 652e 7265 765f 6578 636c 7564 6564  ate.rev_excluded
+000146f0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00014700: 2020 5265 636f 7264 5374 6174 652e 7265    RecordState.re
+00014710: 765f 696e 636c 7564 6564 2c0a 2020 2020  v_included,.    
+00014720: 2020 2020 2020 2020 2020 2020 5265 636f              Reco
+00014730: 7264 5374 6174 652e 7265 765f 7379 6e74  rdState.rev_synt
+00014740: 6865 7369 7a65 642c 0a20 2020 2020 2020  hesized,.       
+00014750: 2020 2020 207d 0a20 2020 2020 2020 2069       }.        i
+00014760: 6620 7374 6174 6520 3d3d 2052 6563 6f72  f state == Recor
+00014770: 6453 7461 7465 2e72 6576 5f70 7265 7363  dState.rev_presc
+00014780: 7265 656e 5f69 6e63 6c75 6465 643a 0a20  reen_included:. 
+00014790: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+000147a0: 6e20 7b0a 2020 2020 2020 2020 2020 2020  n {.            
+000147b0: 2020 2020 5265 636f 7264 5374 6174 652e      RecordState.
+000147c0: 7265 765f 7072 6573 6372 6565 6e5f 696e  rev_prescreen_in
+000147d0: 636c 7564 6564 2c0a 2020 2020 2020 2020  cluded,.        
+000147e0: 2020 2020 2020 2020 5265 636f 7264 5374          RecordSt
+000147f0: 6174 652e 7265 765f 7072 6573 6372 6565  ate.rev_prescree
+00014800: 6e5f 6578 636c 7564 6564 2c0a 2020 2020  n_excluded,.    
+00014810: 2020 2020 2020 2020 2020 2020 5265 636f              Reco
+00014820: 7264 5374 6174 652e 7064 665f 6e65 6564  rdState.pdf_need
+00014830: 735f 6d61 6e75 616c 5f72 6574 7269 6576  s_manual_retriev
+00014840: 616c 2c0a 2020 2020 2020 2020 2020 2020  al,.            
+00014850: 2020 2020 5265 636f 7264 5374 6174 652e      RecordState.
+00014860: 7064 665f 696d 706f 7274 6564 2c0a 2020  pdf_imported,.  
+00014870: 2020 2020 2020 2020 2020 2020 2020 5265                Re
+00014880: 636f 7264 5374 6174 652e 7064 665f 6e6f  cordState.pdf_no
+00014890: 745f 6176 6169 6c61 626c 652c 0a20 2020  t_available,.   
+000148a0: 2020 2020 2020 2020 2020 2020 2052 6563               Rec
+000148b0: 6f72 6453 7461 7465 2e70 6466 5f6e 6565  ordState.pdf_nee
+000148c0: 6473 5f6d 616e 7561 6c5f 7072 6570 6172  ds_manual_prepar
+000148d0: 6174 696f 6e2c 0a20 2020 2020 2020 2020  ation,.         
+000148e0: 2020 2020 2020 2052 6563 6f72 6453 7461         RecordSta
+000148f0: 7465 2e70 6466 5f70 7265 7061 7265 642c  te.pdf_prepared,
+00014900: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014910: 2052 6563 6f72 6453 7461 7465 2e72 6576   RecordState.rev
+00014920: 5f65 7863 6c75 6465 642c 0a20 2020 2020  _excluded,.     
+00014930: 2020 2020 2020 2020 2020 2052 6563 6f72             Recor
+00014940: 6453 7461 7465 2e72 6576 5f69 6e63 6c75  dState.rev_inclu
+00014950: 6465 642c 0a20 2020 2020 2020 2020 2020  ded,.           
+00014960: 2020 2020 2052 6563 6f72 6453 7461 7465       RecordState
+00014970: 2e72 6576 5f73 796e 7468 6573 697a 6564  .rev_synthesized
+00014980: 2c0a 2020 2020 2020 2020 2020 2020 7d0a  ,.            }.
+00014990: 2020 2020 2020 2020 6966 2073 7461 7465          if state
+000149a0: 203d 3d20 5265 636f 7264 5374 6174 652e   == RecordState.
+000149b0: 7064 665f 7072 6570 6172 6564 3a0a 2020  pdf_prepared:.  
+000149c0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+000149d0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
+000149e0: 2020 2052 6563 6f72 6453 7461 7465 2e70     RecordState.p
+000149f0: 6466 5f70 7265 7061 7265 642c 0a20 2020  df_prepared,.   
+00014a00: 2020 2020 2020 2020 2020 2020 2052 6563               Rec
+00014a10: 6f72 6453 7461 7465 2e72 6576 5f65 7863  ordState.rev_exc
+00014a20: 6c75 6465 642c 0a20 2020 2020 2020 2020  luded,.         
+00014a30: 2020 2020 2020 2052 6563 6f72 6453 7461         RecordSta
+00014a40: 7465 2e72 6576 5f69 6e63 6c75 6465 642c  te.rev_included,
+00014a50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014a60: 2052 6563 6f72 6453 7461 7465 2e72 6576   RecordState.rev
+00014a70: 5f73 796e 7468 6573 697a 6564 2c0a 2020  _synthesized,.  
+00014a80: 2020 2020 2020 2020 2020 7d0a 0a20 2020            }..   
+00014a90: 2020 2020 2069 6620 7374 6174 6520 3d3d       if state ==
+00014aa0: 2052 6563 6f72 6453 7461 7465 2e72 6576   RecordState.rev
+00014ab0: 5f69 6e63 6c75 6465 643a 0a20 2020 2020  _included:.     
+00014ac0: 2020 2020 2020 2072 6574 7572 6e20 7b0a         return {.
+00014ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014ae0: 5265 636f 7264 5374 6174 652e 7265 765f  RecordState.rev_
+00014af0: 6578 636c 7564 6564 2c0a 2020 2020 2020  excluded,.      
+00014b00: 2020 2020 2020 2020 2020 5265 636f 7264            Record
+00014b10: 5374 6174 652e 7265 765f 696e 636c 7564  State.rev_includ
+00014b20: 6564 2c0a 2020 2020 2020 2020 2020 2020  ed,.            
+00014b30: 2020 2020 5265 636f 7264 5374 6174 652e      RecordState.
+00014b40: 7265 765f 7379 6e74 6865 7369 7a65 642c  rev_synthesized,
+00014b50: 0a20 2020 2020 2020 2020 2020 207d 0a0a  .            }..
+00014b60: 2020 2020 2020 2020 2320 7079 6c69 6e74          # pylint
+00014b70: 3a20 6469 7361 626c 653d 6e6f 2d6d 656d  : disable=no-mem
+00014b80: 6265 720a 2020 2020 2020 2020 7261 6973  ber.        rais
+00014b90: 6520 636f 6c72 6576 5f65 7863 6570 7469  e colrev_excepti
+00014ba0: 6f6e 732e 5061 7261 6d65 7465 7245 7272  ons.ParameterErr
+00014bb0: 6f72 280a 2020 2020 2020 2020 2020 2020  or(.            
+00014bc0: 7061 7261 6d65 7465 723d 2273 7461 7465  parameter="state
+00014bd0: 222c 2076 616c 7565 3d22 7374 6174 6522  ", value="state"
+00014be0: 2c20 6f70 7469 6f6e 733d 636c 732e 5f6d  , options=cls._m
+00014bf0: 656d 6265 725f 6e61 6d65 735f 0a20 2020  ember_names_.   
+00014c00: 2020 2020 2029 0a0a 0a6e 6f6e 5f70 726f       )...non_pro
+00014c10: 6365 7373 696e 675f 7472 616e 7369 7469  cessing_transiti
+00014c20: 6f6e 7320 3d20 5b0a 2020 2020 5b0a 2020  ons = [.    [.  
+00014c30: 2020 2020 2020 7b0a 2020 2020 2020 2020        {.        
+00014c40: 2020 2020 2274 7269 6767 6572 223a 2022      "trigger": "
+00014c50: 666f 726d 6174 222c 0a20 2020 2020 2020  format",.       
+00014c60: 2020 2020 2022 736f 7572 6365 223a 2073       "source": s
+00014c70: 7461 7465 2c0a 2020 2020 2020 2020 2020  tate,.          
+00014c80: 2020 2264 6573 7422 3a20 7374 6174 652c    "dest": state,
+00014c90: 0a20 2020 2020 2020 207d 2c0a 2020 2020  .        },.    
+00014ca0: 2020 2020 7b0a 2020 2020 2020 2020 2020      {.          
+00014cb0: 2020 2274 7269 6767 6572 223a 2022 6578    "trigger": "ex
+00014cc0: 706c 6f72 6522 2c0a 2020 2020 2020 2020  plore",.        
+00014cd0: 2020 2020 2273 6f75 7263 6522 3a20 7374      "source": st
+00014ce0: 6174 652c 0a20 2020 2020 2020 2020 2020  ate,.           
+00014cf0: 2022 6465 7374 223a 2073 7461 7465 2c0a   "dest": state,.
+00014d00: 2020 2020 2020 2020 7d2c 0a20 2020 2020          },.     
+00014d10: 2020 207b 0a20 2020 2020 2020 2020 2020     {.           
+00014d20: 2022 7472 6967 6765 7222 3a20 2263 6865   "trigger": "che
+00014d30: 636b 222c 0a20 2020 2020 2020 2020 2020  ck",.           
+00014d40: 2022 736f 7572 6365 223a 2073 7461 7465   "source": state
+00014d50: 2c0a 2020 2020 2020 2020 2020 2020 2264  ,.            "d
+00014d60: 6573 7422 3a20 7374 6174 652c 0a20 2020  est": state,.   
+00014d70: 2020 2020 207d 2c0a 2020 2020 5d0a 2020       },.    ].  
+00014d80: 2020 666f 7220 7374 6174 6520 696e 206c    for state in l
+00014d90: 6973 7428 5265 636f 7264 5374 6174 6529  ist(RecordState)
+00014da0: 0a5d 0a0a 0a63 6c61 7373 2052 6563 6f72  .]...class Recor
+00014db0: 6453 7461 7465 4d6f 6465 6c3a 0a20 2020  dStateModel:.   
+00014dc0: 2022 2222 5468 6520 5265 636f 7264 5374   """The RecordSt
+00014dd0: 6174 654d 6f64 656c 2064 6573 6372 6962  ateModel describ
+00014de0: 6573 2074 7261 6e73 6974 696f 6e73 2062  es transitions b
+00014df0: 6574 7765 656e 2052 6563 6f72 6453 7461  etween RecordSta
+00014e00: 7465 7322 2222 0a0a 2020 2020 7472 616e  tes"""..    tran
+00014e10: 7369 7469 6f6e 7320 3d20 5b0a 2020 2020  sitions = [.    
+00014e20: 2020 2020 7b0a 2020 2020 2020 2020 2020      {.          
+00014e30: 2020 2274 7269 6767 6572 223a 2022 6c6f    "trigger": "lo
+00014e40: 6164 222c 0a20 2020 2020 2020 2020 2020  ad",.           
+00014e50: 2022 736f 7572 6365 223a 2052 6563 6f72   "source": Recor
+00014e60: 6453 7461 7465 2e6d 645f 7265 7472 6965  dState.md_retrie
+00014e70: 7665 642c 0a20 2020 2020 2020 2020 2020  ved,.           
+00014e80: 2022 6465 7374 223a 2052 6563 6f72 6453   "dest": RecordS
+00014e90: 7461 7465 2e6d 645f 696d 706f 7274 6564  tate.md_imported
+00014ea0: 2c0a 2020 2020 2020 2020 7d2c 0a20 2020  ,.        },.   
+00014eb0: 2020 2020 207b 0a20 2020 2020 2020 2020       {.         
+00014ec0: 2020 2022 7472 6967 6765 7222 3a20 2270     "trigger": "p
+00014ed0: 7265 7022 2c0a 2020 2020 2020 2020 2020  rep",.          
+00014ee0: 2020 2273 6f75 7263 6522 3a20 5265 636f    "source": Reco
+00014ef0: 7264 5374 6174 652e 6d64 5f69 6d70 6f72  rdState.md_impor
+00014f00: 7465 642c 0a20 2020 2020 2020 2020 2020  ted,.           
+00014f10: 2022 6465 7374 223a 2052 6563 6f72 6453   "dest": RecordS
+00014f20: 7461 7465 2e6d 645f 6e65 6564 735f 6d61  tate.md_needs_ma
+00014f30: 6e75 616c 5f70 7265 7061 7261 7469 6f6e  nual_preparation
+00014f40: 2c0a 2020 2020 2020 2020 7d2c 0a20 2020  ,.        },.   
+00014f50: 2020 2020 207b 0a20 2020 2020 2020 2020       {.         
+00014f60: 2020 2022 7472 6967 6765 7222 3a20 2270     "trigger": "p
+00014f70: 7265 7022 2c0a 2020 2020 2020 2020 2020  rep",.          
+00014f80: 2020 2273 6f75 7263 6522 3a20 5265 636f    "source": Reco
+00014f90: 7264 5374 6174 652e 6d64 5f69 6d70 6f72  rdState.md_impor
+00014fa0: 7465 642c 0a20 2020 2020 2020 2020 2020  ted,.           
+00014fb0: 2022 6465 7374 223a 2052 6563 6f72 6453   "dest": RecordS
+00014fc0: 7461 7465 2e6d 645f 7072 6570 6172 6564  tate.md_prepared
+00014fd0: 2c0a 2020 2020 2020 2020 7d2c 0a20 2020  ,.        },.   
+00014fe0: 2020 2020 207b 0a20 2020 2020 2020 2020       {.         
+00014ff0: 2020 2022 7472 6967 6765 7222 3a20 2270     "trigger": "p
+00015000: 7265 705f 6d61 6e22 2c0a 2020 2020 2020  rep_man",.      
+00015010: 2020 2020 2020 2273 6f75 7263 6522 3a20        "source": 
+00015020: 5265 636f 7264 5374 6174 652e 6d64 5f6e  RecordState.md_n
+00015030: 6565 6473 5f6d 616e 7561 6c5f 7072 6570  eeds_manual_prep
+00015040: 6172 6174 696f 6e2c 0a20 2020 2020 2020  aration,.       
+00015050: 2020 2020 2022 6465 7374 223a 2052 6563       "dest": Rec
+00015060: 6f72 6453 7461 7465 2e6d 645f 7072 6570  ordState.md_prep
+00015070: 6172 6564 2c0a 2020 2020 2020 2020 7d2c  ared,.        },
+00015080: 0a20 2020 2020 2020 207b 0a20 2020 2020  .        {.     
+00015090: 2020 2020 2020 2022 7472 6967 6765 7222         "trigger"
+000150a0: 3a20 2264 6564 7570 6522 2c0a 2020 2020  : "dedupe",.    
+000150b0: 2020 2020 2020 2020 2273 6f75 7263 6522          "source"
+000150c0: 3a20 5265 636f 7264 5374 6174 652e 6d64  : RecordState.md
+000150d0: 5f70 7265 7061 7265 642c 0a20 2020 2020  _prepared,.     
+000150e0: 2020 2020 2020 2022 6465 7374 223a 2052         "dest": R
+000150f0: 6563 6f72 6453 7461 7465 2e6d 645f 7072  ecordState.md_pr
+00015100: 6f63 6573 7365 642c 0a20 2020 2020 2020  ocessed,.       
+00015110: 207d 2c0a 2020 2020 2020 2020 7b0a 2020   },.        {.  
+00015120: 2020 2020 2020 2020 2020 2274 7269 6767            "trigg
+00015130: 6572 223a 2022 7072 6573 6372 6565 6e22  er": "prescreen"
+00015140: 2c0a 2020 2020 2020 2020 2020 2020 2273  ,.            "s
+00015150: 6f75 7263 6522 3a20 5265 636f 7264 5374  ource": RecordSt
+00015160: 6174 652e 6d64 5f70 726f 6365 7373 6564  ate.md_processed
+00015170: 2c0a 2020 2020 2020 2020 2020 2020 2264  ,.            "d
+00015180: 6573 7422 3a20 5265 636f 7264 5374 6174  est": RecordStat
+00015190: 652e 7265 765f 7072 6573 6372 6565 6e5f  e.rev_prescreen_
+000151a0: 6578 636c 7564 6564 2c0a 2020 2020 2020  excluded,.      
+000151b0: 2020 7d2c 0a20 2020 2020 2020 207b 0a20    },.        {. 
+000151c0: 2020 2020 2020 2020 2020 2022 7472 6967             "trig
+000151d0: 6765 7222 3a20 2270 7265 7363 7265 656e  ger": "prescreen
+000151e0: 222c 0a20 2020 2020 2020 2020 2020 2022  ",.            "
+000151f0: 736f 7572 6365 223a 2052 6563 6f72 6453  source": RecordS
+00015200: 7461 7465 2e6d 645f 7072 6f63 6573 7365  tate.md_processe
+00015210: 642c 0a20 2020 2020 2020 2020 2020 2022  d,.            "
+00015220: 6465 7374 223a 2052 6563 6f72 6453 7461  dest": RecordSta
+00015230: 7465 2e72 6576 5f70 7265 7363 7265 656e  te.rev_prescreen
+00015240: 5f69 6e63 6c75 6465 642c 0a20 2020 2020  _included,.     
+00015250: 2020 207d 2c0a 2020 2020 2020 2020 7b0a     },.        {.
+00015260: 2020 2020 2020 2020 2020 2020 2274 7269              "tri
+00015270: 6767 6572 223a 2022 7064 665f 6765 7422  gger": "pdf_get"
+00015280: 2c0a 2020 2020 2020 2020 2020 2020 2273  ,.            "s
+00015290: 6f75 7263 6522 3a20 5265 636f 7264 5374  ource": RecordSt
+000152a0: 6174 652e 7265 765f 7072 6573 6372 6565  ate.rev_prescree
+000152b0: 6e5f 696e 636c 7564 6564 2c0a 2020 2020  n_included,.    
+000152c0: 2020 2020 2020 2020 2264 6573 7422 3a20          "dest": 
+000152d0: 5265 636f 7264 5374 6174 652e 7064 665f  RecordState.pdf_
+000152e0: 696d 706f 7274 6564 2c0a 2020 2020 2020  imported,.      
+000152f0: 2020 7d2c 0a20 2020 2020 2020 207b 0a20    },.        {. 
+00015300: 2020 2020 2020 2020 2020 2022 7472 6967             "trig
+00015310: 6765 7222 3a20 2270 6466 5f67 6574 222c  ger": "pdf_get",
+00015320: 0a20 2020 2020 2020 2020 2020 2022 736f  .            "so
+00015330: 7572 6365 223a 2052 6563 6f72 6453 7461  urce": RecordSta
+00015340: 7465 2e72 6576 5f70 7265 7363 7265 656e  te.rev_prescreen
+00015350: 5f69 6e63 6c75 6465 642c 0a20 2020 2020  _included,.     
+00015360: 2020 2020 2020 2022 6465 7374 223a 2052         "dest": R
+00015370: 6563 6f72 6453 7461 7465 2e70 6466 5f6e  ecordState.pdf_n
+00015380: 6565 6473 5f6d 616e 7561 6c5f 7265 7472  eeds_manual_retr
+00015390: 6965 7661 6c2c 0a20 2020 2020 2020 207d  ieval,.        }
+000153a0: 2c0a 2020 2020 2020 2020 7b0a 2020 2020  ,.        {.    
+000153b0: 2020 2020 2020 2020 2274 7269 6767 6572          "trigger
+000153c0: 223a 2022 7064 665f 6765 745f 6d61 6e22  ": "pdf_get_man"
+000153d0: 2c0a 2020 2020 2020 2020 2020 2020 2273  ,.            "s
+000153e0: 6f75 7263 6522 3a20 5265 636f 7264 5374  ource": RecordSt
+000153f0: 6174 652e 7064 665f 6e65 6564 735f 6d61  ate.pdf_needs_ma
+00015400: 6e75 616c 5f72 6574 7269 6576 616c 2c0a  nual_retrieval,.
+00015410: 2020 2020 2020 2020 2020 2020 2264 6573              "des
+00015420: 7422 3a20 5265 636f 7264 5374 6174 652e  t": RecordState.
+00015430: 7064 665f 6e6f 745f 6176 6169 6c61 626c  pdf_not_availabl
+00015440: 652c 0a20 2020 2020 2020 207d 2c0a 2020  e,.        },.  
+00015450: 2020 2020 2020 7b0a 2020 2020 2020 2020        {.        
+00015460: 2020 2020 2274 7269 6767 6572 223a 2022      "trigger": "
+00015470: 7064 665f 6765 745f 6d61 6e22 2c0a 2020  pdf_get_man",.  
+00015480: 2020 2020 2020 2020 2020 2273 6f75 7263            "sourc
+00015490: 6522 3a20 5265 636f 7264 5374 6174 652e  e": RecordState.
+000154a0: 7064 665f 6e65 6564 735f 6d61 6e75 616c  pdf_needs_manual
+000154b0: 5f72 6574 7269 6576 616c 2c0a 2020 2020  _retrieval,.    
+000154c0: 2020 2020 2020 2020 2264 6573 7422 3a20          "dest": 
+000154d0: 5265 636f 7264 5374 6174 652e 7064 665f  RecordState.pdf_
+000154e0: 696d 706f 7274 6564 2c0a 2020 2020 2020  imported,.      
+000154f0: 2020 7d2c 0a20 2020 2020 2020 207b 0a20    },.        {. 
+00015500: 2020 2020 2020 2020 2020 2022 7472 6967             "trig
+00015510: 6765 7222 3a20 2270 6466 5f70 7265 7022  ger": "pdf_prep"
+00015520: 2c0a 2020 2020 2020 2020 2020 2020 2273  ,.            "s
+00015530: 6f75 7263 6522 3a20 5265 636f 7264 5374  ource": RecordSt
+00015540: 6174 652e 7064 665f 696d 706f 7274 6564  ate.pdf_imported
+00015550: 2c0a 2020 2020 2020 2020 2020 2020 2264  ,.            "d
+00015560: 6573 7422 3a20 5265 636f 7264 5374 6174  est": RecordStat
+00015570: 652e 7064 665f 6e65 6564 735f 6d61 6e75  e.pdf_needs_manu
+00015580: 616c 5f70 7265 7061 7261 7469 6f6e 2c0a  al_preparation,.
+00015590: 2020 2020 2020 2020 7d2c 0a20 2020 2020          },.     
+000155a0: 2020 207b 0a20 2020 2020 2020 2020 2020     {.           
+000155b0: 2022 7472 6967 6765 7222 3a20 2270 6466   "trigger": "pdf
+000155c0: 5f70 7265 7022 2c0a 2020 2020 2020 2020  _prep",.        
+000155d0: 2020 2020 2273 6f75 7263 6522 3a20 5265      "source": Re
+000155e0: 636f 7264 5374 6174 652e 7064 665f 696d  cordState.pdf_im
+000155f0: 706f 7274 6564 2c0a 2020 2020 2020 2020  ported,.        
+00015600: 2020 2020 2264 6573 7422 3a20 5265 636f      "dest": Reco
+00015610: 7264 5374 6174 652e 7064 665f 7072 6570  rdState.pdf_prep
+00015620: 6172 6564 2c0a 2020 2020 2020 2020 7d2c  ared,.        },
+00015630: 0a20 2020 2020 2020 207b 0a20 2020 2020  .        {.     
+00015640: 2020 2020 2020 2022 7472 6967 6765 7222         "trigger"
+00015650: 3a20 2270 6466 5f70 7265 705f 6d61 6e22  : "pdf_prep_man"
+00015660: 2c0a 2020 2020 2020 2020 2020 2020 2273  ,.            "s
+00015670: 6f75 7263 6522 3a20 5265 636f 7264 5374  ource": RecordSt
+00015680: 6174 652e 7064 665f 6e65 6564 735f 6d61  ate.pdf_needs_ma
+00015690: 6e75 616c 5f70 7265 7061 7261 7469 6f6e  nual_preparation
+000156a0: 2c0a 2020 2020 2020 2020 2020 2020 2264  ,.            "d
+000156b0: 6573 7422 3a20 5265 636f 7264 5374 6174  est": RecordStat
+000156c0: 652e 7064 665f 7072 6570 6172 6564 2c0a  e.pdf_prepared,.
+000156d0: 2020 2020 2020 2020 7d2c 0a20 2020 2020          },.     
+000156e0: 2020 207b 0a20 2020 2020 2020 2020 2020     {.           
+000156f0: 2022 7472 6967 6765 7222 3a20 2273 6372   "trigger": "scr
+00015700: 6565 6e22 2c0a 2020 2020 2020 2020 2020  een",.          
+00015710: 2020 2273 6f75 7263 6522 3a20 5265 636f    "source": Reco
+00015720: 7264 5374 6174 652e 7064 665f 7072 6570  rdState.pdf_prep
+00015730: 6172 6564 2c0a 2020 2020 2020 2020 2020  ared,.          
+00015740: 2020 2264 6573 7422 3a20 5265 636f 7264    "dest": Record
+00015750: 5374 6174 652e 7265 765f 6578 636c 7564  State.rev_exclud
+00015760: 6564 2c0a 2020 2020 2020 2020 7d2c 0a20  ed,.        },. 
+00015770: 2020 2020 2020 207b 0a20 2020 2020 2020         {.       
+00015780: 2020 2020 2022 7472 6967 6765 7222 3a20       "trigger": 
+00015790: 2273 6372 6565 6e22 2c0a 2020 2020 2020  "screen",.      
+000157a0: 2020 2020 2020 2273 6f75 7263 6522 3a20        "source": 
+000157b0: 5265 636f 7264 5374 6174 652e 7064 665f  RecordState.pdf_
+000157c0: 7072 6570 6172 6564 2c0a 2020 2020 2020  prepared,.      
+000157d0: 2020 2020 2020 2264 6573 7422 3a20 5265        "dest": Re
+000157e0: 636f 7264 5374 6174 652e 7265 765f 696e  cordState.rev_in
+000157f0: 636c 7564 6564 2c0a 2020 2020 2020 2020  cluded,.        
+00015800: 7d2c 0a20 2020 2020 2020 207b 0a20 2020  },.        {.   
+00015810: 2020 2020 2020 2020 2022 7472 6967 6765           "trigge
+00015820: 7222 3a20 2264 6174 6122 2c0a 2020 2020  r": "data",.    
+00015830: 2020 2020 2020 2020 2273 6f75 7263 6522          "source"
+00015840: 3a20 5265 636f 7264 5374 6174 652e 7265  : RecordState.re
+00015850: 765f 696e 636c 7564 6564 2c0a 2020 2020  v_included,.    
+00015860: 2020 2020 2020 2020 2264 6573 7422 3a20          "dest": 
+00015870: 5265 636f 7264 5374 6174 652e 7265 765f  RecordState.rev_
+00015880: 7379 6e74 6865 7369 7a65 642c 0a20 2020  synthesized,.   
+00015890: 2020 2020 207d 2c0a 2020 2020 5d0a 0a20       },.    ].. 
+000158a0: 2020 2074 7261 6e73 6974 696f 6e73 5f6e     transitions_n
+000158b0: 6f6e 5f70 726f 6365 7373 696e 6720 3d20  on_processing = 
+000158c0: 5b0a 2020 2020 2020 2020 6974 656d 2066  [.        item f
+000158d0: 6f72 2073 7562 6c69 7374 2069 6e20 6e6f  or sublist in no
+000158e0: 6e5f 7072 6f63 6573 7369 6e67 5f74 7261  n_processing_tra
+000158f0: 6e73 6974 696f 6e73 2066 6f72 2069 7465  nsitions for ite
+00015900: 6d20 696e 2073 7562 6c69 7374 0a20 2020  m in sublist.   
+00015910: 205d 0a0a 2020 2020 2320 6672 6f6d 2074   ]..    # from t
+00015920: 7261 6e73 6974 696f 6e73 2069 6d70 6f72  ransitions impor
+00015930: 7420 4d61 6368 696e 650a 2020 2020 2320  t Machine.    # 
+00015940: 6465 6620 5f5f 696e 6974 5f5f 280a 2020  def __init__(.  
+00015950: 2020 2320 2020 2020 7365 6c66 2c0a 2020    #     self,.  
+00015960: 2020 2320 2020 2020 2a2c 0a20 2020 2023    #     *,.    #
+00015970: 2020 2020 2073 7461 7465 3a20 5265 636f       state: Reco
+00015980: 7264 5374 6174 652c 0a20 2020 2023 2029  rdState,.    # )
+00015990: 202d 3e20 4e6f 6e65 3a0a 2020 2020 2320   -> None:.    # 
+000159a0: 2020 2020 7365 6c66 2e73 7461 7465 203d      self.state =
+000159b0: 2073 7461 7465 0a0a 2020 2020 2320 2020   state..    #   
+000159c0: 2020 7365 6c66 2e6d 6163 6869 6e65 203d    self.machine =
+000159d0: 204d 6163 6869 6e65 280a 2020 2020 2320   Machine(.    # 
+000159e0: 2020 2020 2020 2020 6d6f 6465 6c3d 7365          model=se
+000159f0: 6c66 2c0a 2020 2020 2320 2020 2020 2020  lf,.    #       
+00015a00: 2020 7374 6174 6573 3d52 6563 6f72 6453    states=RecordS
+00015a10: 7461 7465 2c0a 2020 2020 2320 2020 2020  tate,.    #     
+00015a20: 2020 2020 7472 616e 7369 7469 6f6e 733d      transitions=
+00015a30: 7365 6c66 2e74 7261 6e73 6974 696f 6e73  self.transitions
+00015a40: 202b 2073 656c 662e 7472 616e 7369 7469   + self.transiti
+00015a50: 6f6e 735f 6e6f 6e5f 7072 6f63 6573 7369  ons_non_processi
+00015a60: 6e67 2c0a 2020 2020 2320 2020 2020 2020  ng,.    #       
+00015a70: 2020 696e 6974 6961 6c3d 7365 6c66 2e73    initial=self.s
+00015a80: 7461 7465 2c0a 2020 2020 2320 2020 2020  tate,.    #     
+00015a90: 290a 0a20 2020 2040 636c 6173 736d 6574  )..    @classmet
+00015aa0: 686f 640a 2020 2020 6465 6620 6765 745f  hod.    def get_
+00015ab0: 7661 6c69 645f 7472 616e 7369 7469 6f6e  valid_transition
+00015ac0: 7328 636c 732c 202a 2c20 7374 6174 653a  s(cls, *, state:
+00015ad0: 2052 6563 6f72 6453 7461 7465 2920 2d3e   RecordState) ->
+00015ae0: 2073 6574 3a0a 2020 2020 2020 2020 2222   set:.        ""
+00015af0: 2247 6574 2074 6865 206c 6973 7420 6f66  "Get the list of
+00015b00: 2076 616c 6964 2074 7261 6e73 6974 696f   valid transitio
+00015b10: 6e73 2222 220a 2020 2020 2020 2020 6c6f  ns""".        lo
+00015b20: 6767 696e 672e 6765 744c 6f67 6765 7228  gging.getLogger(
+00015b30: 2274 7261 6e73 6974 696f 6e73 2229 2e73  "transitions").s
+00015b40: 6574 4c65 7665 6c28 6c6f 6767 696e 672e  etLevel(logging.
+00015b50: 5741 524e 494e 4729 0a20 2020 2020 2020  WARNING).       
+00015b60: 2072 6574 7572 6e20 7365 7428 7b78 5b22   return set({x["
+00015b70: 7472 6967 6765 7222 5d20 666f 7220 7820  trigger"] for x 
+00015b80: 696e 2063 6c73 2e74 7261 6e73 6974 696f  in cls.transitio
+00015b90: 6e73 2069 6620 785b 2273 6f75 7263 6522  ns if x["source"
+00015ba0: 5d20 3d3d 2073 7461 7465 7d29 0a0a 2020  ] == state})..  
+00015bb0: 2020 4063 6c61 7373 6d65 7468 6f64 0a20    @classmethod. 
+00015bc0: 2020 2064 6566 2067 6574 5f70 7265 6365     def get_prece
+00015bd0: 6469 6e67 5f73 7461 7465 7328 636c 732c  ding_states(cls,
+00015be0: 202a 2c20 7374 6174 653a 2052 6563 6f72   *, state: Recor
+00015bf0: 6453 7461 7465 2920 2d3e 2073 6574 3a0a  dState) -> set:.
+00015c00: 2020 2020 2020 2020 2222 2247 6574 2074          """Get t
+00015c10: 6865 2073 7461 7465 7320 7072 6563 6564  he states preced
+00015c20: 696e 6720 7468 6520 7374 6174 6520 7468  ing the state th
+00015c30: 6174 2069 7320 6769 7665 6e20 6173 2061  at is given as a
+00015c40: 2070 6172 616d 6574 6572 2222 220a 0a20   parameter""".. 
+00015c50: 2020 2020 2020 206c 6f67 6769 6e67 2e67         logging.g
+00015c60: 6574 4c6f 6767 6572 2822 7472 616e 7369  etLogger("transi
+00015c70: 7469 6f6e 7322 292e 7365 744c 6576 656c  tions").setLevel
+00015c80: 286c 6f67 6769 6e67 2e57 4152 4e49 4e47  (logging.WARNING
+00015c90: 290a 2020 2020 2020 2020 7072 6563 6564  ).        preced
+00015ca0: 696e 675f 7374 6174 6573 3a20 7365 745b  ing_states: set[
+00015cb0: 5265 636f 7264 5374 6174 655d 203d 2073  RecordState] = s
+00015cc0: 6574 2829 0a20 2020 2020 2020 2061 6464  et().        add
+00015cd0: 6564 203d 2054 7275 650a 2020 2020 2020  ed = True.      
+00015ce0: 2020 7768 696c 6520 6164 6465 643a 0a20    while added:. 
+00015cf0: 2020 2020 2020 2020 2020 2070 7265 6365             prece
+00015d00: 6469 6e67 5f73 7461 7465 735f 7369 7a65  ding_states_size
+00015d10: 203d 206c 656e 2870 7265 6365 6469 6e67   = len(preceding
+00015d20: 5f73 7461 7465 7329 0a20 2020 2020 2020  _states).       
+00015d30: 2020 2020 2066 6f72 2074 7261 6e73 6974       for transit
+00015d40: 696f 6e20 696e 2052 6563 6f72 6453 7461  ion in RecordSta
+00015d50: 7465 4d6f 6465 6c2e 7472 616e 7369 7469  teModel.transiti
+00015d60: 6f6e 733a 0a20 2020 2020 2020 2020 2020  ons:.           
+00015d70: 2020 2020 2069 6620 280a 2020 2020 2020       if (.      
+00015d80: 2020 2020 2020 2020 2020 2020 2020 7472                tr
+00015d90: 616e 7369 7469 6f6e 5b22 6465 7374 225d  ansition["dest"]
+00015da0: 2069 6e20 7072 6563 6564 696e 675f 7374   in preceding_st
+00015db0: 6174 6573 0a20 2020 2020 2020 2020 2020  ates.           
+00015dc0: 2020 2020 2020 2020 206f 7220 7374 6174           or stat
+00015dd0: 6520 3d3d 2074 7261 6e73 6974 696f 6e5b  e == transition[
+00015de0: 2264 6573 7422 5d0a 2020 2020 2020 2020  "dest"].        
+00015df0: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
+00015e00: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+00015e10: 7265 6365 6469 6e67 5f73 7461 7465 732e  receding_states.
+00015e20: 6164 6428 7472 616e 7369 7469 6f6e 5b22  add(transition["
+00015e30: 736f 7572 6365 225d 2920 2023 2074 7970  source"])  # typ
+00015e40: 653a 2069 676e 6f72 650a 2020 2020 2020  e: ignore.      
+00015e50: 2020 2020 2020 6966 2070 7265 6365 6469        if precedi
+00015e60: 6e67 5f73 7461 7465 735f 7369 7a65 203d  ng_states_size =
+00015e70: 3d20 6c65 6e28 7072 6563 6564 696e 675f  = len(preceding_
+00015e80: 7374 6174 6573 293a 0a20 2020 2020 2020  states):.       
+00015e90: 2020 2020 2020 2020 2061 6464 6564 203d           added =
+00015ea0: 2046 616c 7365 0a20 2020 2020 2020 2072   False.        r
+00015eb0: 6574 7572 6e20 7072 6563 6564 696e 675f  eturn preceding_
+00015ec0: 7374 6174 6573 0a0a 2020 2020 4063 6c61  states..    @cla
+00015ed0: 7373 6d65 7468 6f64 0a20 2020 2064 6566  ssmethod.    def
+00015ee0: 2063 6865 636b 5f6f 7065 7261 7469 6f6e   check_operation
+00015ef0: 5f70 7265 636f 6e64 6974 696f 6e28 0a20  _precondition(. 
+00015f00: 2020 2020 2020 2063 6c73 2c20 2a2c 206f         cls, *, o
+00015f10: 7065 7261 7469 6f6e 3a20 636f 6c72 6576  peration: colrev
+00015f20: 2e6f 7065 7261 7469 6f6e 2e4f 7065 7261  .operation.Opera
+00015f30: 7469 6f6e 0a20 2020 2029 202d 3e20 4e6f  tion.    ) -> No
+00015f40: 6e65 3a0a 2020 2020 2020 2020 2222 2243  ne:.        """C
+00015f50: 6865 636b 2074 6865 2070 7265 636f 6e64  heck the precond
+00015f60: 6974 696f 6e73 2066 6f72 2061 6e20 6f70  itions for an op
+00015f70: 6572 6174 696f 6e22 2222 0a0a 2020 2020  eration"""..    
+00015f80: 2020 2020 6465 6620 6765 745f 7374 6174      def get_stat
+00015f90: 6573 5f73 6574 2829 202d 3e20 7365 743a  es_set() -> set:
+00015fa0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00015fb0: 6e6f 7420 6f70 6572 6174 696f 6e2e 7265  not operation.re
+00015fc0: 7669 6577 5f6d 616e 6167 6572 2e64 6174  view_manager.dat
+00015fd0: 6173 6574 2e72 6563 6f72 6473 5f66 696c  aset.records_fil
+00015fe0: 652e 6973 5f66 696c 6528 293a 0a20 2020  e.is_file():.   
+00015ff0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00016000: 7572 6e20 7365 7428 290a 2020 2020 2020  urn set().      
+00016010: 2020 2020 2020 7265 636f 7264 735f 6865        records_he
+00016020: 6164 6572 7320 3d20 6f70 6572 6174 696f  aders = operatio
+00016030: 6e2e 7265 7669 6577 5f6d 616e 6167 6572  n.review_manager
+00016040: 2e64 6174 6173 6574 2e6c 6f61 645f 7265  .dataset.load_re
+00016050: 636f 7264 735f 6469 6374 280a 2020 2020  cords_dict(.    
+00016060: 2020 2020 2020 2020 2020 2020 6865 6164              head
+00016070: 6572 5f6f 6e6c 793d 5472 7565 0a20 2020  er_only=True.   
+00016080: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00016090: 2020 2020 2020 2072 6563 6f72 645f 6865         record_he
+000160a0: 6164 6572 5f6c 6973 7420 3d20 6c69 7374  ader_list = list
+000160b0: 2872 6563 6f72 6473 5f68 6561 6465 7273  (records_headers
+000160c0: 2e76 616c 7565 7328 2929 0a0a 2020 2020  .values())..    
+000160d0: 2020 2020 2020 2020 7265 7475 726e 207b          return {
+000160e0: 656c 5b22 636f 6c72 6576 5f73 7461 7475  el["colrev_statu
+000160f0: 7322 5d20 666f 7220 656c 2069 6e20 7265  s"] for el in re
+00016100: 636f 7264 5f68 6561 6465 725f 6c69 7374  cord_header_list
+00016110: 7d0a 0a20 2020 2020 2020 2069 6620 6f70  }..        if op
+00016120: 6572 6174 696f 6e2e 7265 7669 6577 5f6d  eration.review_m
+00016130: 616e 6167 6572 2e73 6574 7469 6e67 732e  anager.settings.
+00016140: 7072 6f6a 6563 742e 6465 6c61 795f 6175  project.delay_au
+00016150: 746f 6d61 7465 645f 7072 6f63 6573 7369  tomated_processi
+00016160: 6e67 3a0a 2020 2020 2020 2020 2020 2020  ng:.            
+00016170: 7374 6172 745f 7374 6174 6573 3a20 6c69  start_states: li
+00016180: 7374 5b73 7472 5d20 3d20 5b0a 2020 2020  st[str] = [.    
+00016190: 2020 2020 2020 2020 2020 2020 7374 7228              str(
+000161a0: 785b 2273 6f75 7263 6522 5d29 0a20 2020  x["source"]).   
+000161b0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+000161c0: 2078 2069 6e20 636f 6c72 6576 2e72 6563   x in colrev.rec
+000161d0: 6f72 642e 5265 636f 7264 5374 6174 654d  ord.RecordStateM
+000161e0: 6f64 656c 2e74 7261 6e73 6974 696f 6e73  odel.transitions
+000161f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00016200: 2069 6620 7374 7228 6f70 6572 6174 696f   if str(operatio
+00016210: 6e2e 7479 7065 2920 3d3d 2078 5b22 7472  n.type) == x["tr
+00016220: 6967 6765 7222 5d0a 2020 2020 2020 2020  igger"].        
+00016230: 2020 2020 5d0a 2020 2020 2020 2020 2020      ].          
+00016240: 2020 7374 6174 6520 3d20 636f 6c72 6576    state = colrev
+00016250: 2e72 6563 6f72 642e 5265 636f 7264 5374  .record.RecordSt
+00016260: 6174 655b 7374 6172 745f 7374 6174 6573  ate[start_states
+00016270: 5b30 5d5d 0a0a 2020 2020 2020 2020 2020  [0]]..          
+00016280: 2020 6375 725f 7374 6174 655f 6c69 7374    cur_state_list
+00016290: 203d 2067 6574 5f73 7461 7465 735f 7365   = get_states_se
+000162a0: 7428 290a 2020 2020 2020 2020 2020 2020  t().            
+000162b0: 2320 7365 6c66 2e72 6576 6965 775f 6d61  # self.review_ma
+000162c0: 6e61 6765 722e 6c6f 6767 6572 2e64 6562  nager.logger.deb
+000162d0: 7567 2866 2263 7572 5f73 7461 7465 5f6c  ug(f"cur_state_l
+000162e0: 6973 743a 207b 6375 725f 7374 6174 655f  ist: {cur_state_
+000162f0: 6c69 7374 7d22 290a 2020 2020 2020 2020  list}").        
+00016300: 2020 2020 2320 7365 6c66 2e72 6576 6965      # self.revie
+00016310: 775f 6d61 6e61 6765 722e 6c6f 6767 6572  w_manager.logger
+00016320: 2e64 6562 7567 2866 2270 7265 636f 6e64  .debug(f"precond
+00016330: 6974 696f 6e3a 207b 7365 6c66 2e73 7461  ition: {self.sta
+00016340: 7465 7d22 290a 2020 2020 2020 2020 2020  te}").          
+00016350: 2020 7265 7175 6972 6564 5f61 6273 656e    required_absen
+00016360: 7420 3d20 636c 732e 6765 745f 7072 6563  t = cls.get_prec
+00016370: 6564 696e 675f 7374 6174 6573 2873 7461  eding_states(sta
+00016380: 7465 3d73 7461 7465 290a 2020 2020 2020  te=state).      
+00016390: 2020 2020 2020 2320 7365 6c66 2e72 6576        # self.rev
+000163a0: 6965 775f 6d61 6e61 6765 722e 6c6f 6767  iew_manager.logg
+000163b0: 6572 2e64 6562 7567 2866 2272 6571 7569  er.debug(f"requi
+000163c0: 7265 645f 6162 7365 6e74 3a20 7b72 6571  red_absent: {req
+000163d0: 7569 7265 645f 6162 7365 6e74 7d22 290a  uired_absent}").
+000163e0: 2020 2020 2020 2020 2020 2020 696e 7465              inte
+000163f0: 7273 6563 7469 6f6e 203d 2063 7572 5f73  rsection = cur_s
+00016400: 7461 7465 5f6c 6973 742e 696e 7465 7273  tate_list.inters
+00016410: 6563 7469 6f6e 2872 6571 7569 7265 645f  ection(required_
+00016420: 6162 7365 6e74 290a 2020 2020 2020 2020  absent).        
+00016430: 2020 2020 6966 2028 0a20 2020 2020 2020      if (.       
+00016440: 2020 2020 2020 2020 206c 656e 2863 7572           len(cur
+00016450: 5f73 7461 7465 5f6c 6973 7429 203d 3d20  _state_list) == 
+00016460: 300a 2020 2020 2020 2020 2020 2020 2020  0.              
+00016470: 2020 616e 6420 6e6f 7420 6f70 6572 6174    and not operat
+00016480: 696f 6e2e 7479 7065 2e6e 616d 6520 3d3d  ion.type.name ==
+00016490: 2022 6c6f 6164 2220 2023 2074 7970 653a   "load"  # type:
+000164a0: 2069 676e 6f72 650a 2020 2020 2020 2020   ignore.        
+000164b0: 2020 2020 293a 0a20 2020 2020 2020 2020      ):.         
+000164c0: 2020 2020 2020 2072 6169 7365 2063 6f6c         raise col
+000164d0: 7265 765f 6578 6365 7074 696f 6e73 2e4e  rev_exceptions.N
+000164e0: 6f52 6563 6f72 6473 4572 726f 7228 290a  oRecordsError().
+000164f0: 2020 2020 2020 2020 2020 2020 6966 206c              if l
+00016500: 656e 2869 6e74 6572 7365 6374 696f 6e29  en(intersection)
+00016510: 2021 3d20 303a 0a20 2020 2020 2020 2020   != 0:.         
+00016520: 2020 2020 2020 2072 6169 7365 2063 6f6c         raise col
+00016530: 7265 765f 6578 6365 7074 696f 6e73 2e50  rev_exceptions.P
+00016540: 726f 6365 7373 4f72 6465 7256 696f 6c61  rocessOrderViola
+00016550: 7469 6f6e 280a 2020 2020 2020 2020 2020  tion(.          
+00016560: 2020 2020 2020 2020 2020 6f70 6572 6174            operat
+00016570: 696f 6e2e 7479 7065 2e6e 616d 652c 2073  ion.type.name, s
+00016580: 7472 2873 7461 7465 292c 206c 6973 7428  tr(state), list(
+00016590: 696e 7465 7273 6563 7469 6f6e 290a 2020  intersection).  
+000165a0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
```

### Comparing `colrev-0.9.0/colrev/review_manager.py` & `colrev-0.9.2/colrev/review_manager.py`

 * *Files 2% similar despite different names*

```diff
@@ -111,30 +111,17 @@
         try:
             if self.settings_path.is_file():
                 self.data_dir.mkdir(exist_ok=True)
                 self.search_dir.mkdir(exist_ok=True)
                 self.pdf_dir.mkdir(exist_ok=True)
                 self.output_dir.mkdir(exist_ok=True)
 
-            if self.debug_mode:
-                self.report_logger = colrev.logger.setup_report_logger(
-                    review_manager=self, level=logging.DEBUG
-                )
-                """Logger for the commit report"""
-                self.logger = colrev.logger.setup_logger(
-                    review_manager=self, level=logging.DEBUG
-                )
-                """Logger for processing information"""
-            else:
-                self.report_logger = colrev.logger.setup_report_logger(
-                    review_manager=self, level=logging.INFO
-                )
-                self.logger = colrev.logger.setup_logger(
-                    review_manager=self, level=logging.INFO
-                )
+            report_logger, logger = self.get_loggers_by_debug_mode()
+            self.report_logger = report_logger
+            self.logger = logger
 
             self.environment_manager = self.get_environment_manager()
 
             self.p_printer = pprint.PrettyPrinter(indent=4, width=140, compact=False)
             # run update before settings/data (which may require changes/fail without update)
             if not skip_upgrade:
                 self.__check_update()
@@ -150,14 +137,47 @@
                     )
 
             if not force_mode:
                 raise exc
             if debug_mode:
                 self.logger.debug(exc)
 
+    def update_config(
+        self,
+        *,
+        force_mode: bool = False,
+        verbose_mode: bool = False,
+        debug_mode: bool = False,
+        high_level_operation: bool = False,
+        exact_call: str = "",
+    ) -> None:
+        """Update review_manager's state"""
+        self.force_mode = force_mode
+        # Force mode variable (bool)
+        self.verbose_mode = verbose_mode
+        # Verbose mode variable (bool)
+        self.debug_mode = debug_mode
+        # Debug mode variable (bool)
+        self.high_level_operation = high_level_operation
+        # A high-level operation was called (bool)
+        self.exact_call = exact_call
+        report_logger, logger = self.get_loggers_by_debug_mode()
+        self.report_logger = report_logger
+        self.logger = logger
+
+    def get_loggers_by_debug_mode(self) -> typing.Tuple[logging.Logger, logging.Logger]:
+        """return loggers"""
+        if self.debug_mode:
+            return colrev.logger.setup_report_logger(
+                review_manager=self, level=logging.DEBUG
+            ), colrev.logger.setup_logger(review_manager=self, level=logging.DEBUG)
+        return colrev.logger.setup_report_logger(
+            review_manager=self, level=logging.INFO
+        ), colrev.logger.setup_logger(review_manager=self, level=logging.INFO)
+
     def __check_update(self) -> None:
         # Once the following has run for all repositories,
         # it should only be called when the versions differ.
         # last_version, current_version = self.get_colrev_versions()
         # if last_version != current_version:
         upgrade_operation = self.get_upgrade()
         upgrade_operation.main()
```

### Comparing `colrev-0.9.0/colrev/service.py` & `colrev-0.9.2/colrev/service.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,14 +12,15 @@
 
 from watchdog.events import FileSystemEvent
 from watchdog.events import LoggingEventHandler
 from watchdog.observers import Observer
 
 import colrev.ops.status
 import colrev.ui_cli.cli_colors as colors
+import colrev.ui_cli.cli_load
 
 # pylint: disable=too-few-public-methods
 
 
 class Event(LoggingEventHandler):
     """Service event for changed files"""
 
@@ -177,19 +178,20 @@
 
         print()
         if item["cmd"] == "colrev retrieve":
             search_operation = self.review_manager.get_search_operation()
             search_operation.main(rerun=False)
 
             load_operation = self.review_manager.get_load_operation()
-            new_sources = load_operation.get_new_sources(skip_query=True)
-            load_operation = self.review_manager.get_load_operation()
-            load_operation.main(
-                new_sources=new_sources, keep_ids=False, combine_commits=False
+            heuristic_list = load_operation.get_new_sources_heuristic_list()
+            new_sources = colrev.ui_cli.cli_load.select_new_source(
+                heuristic_result_list=heuristic_list, skip_query=True
             )
+            load_operation = self.review_manager.get_load_operation()
+            load_operation.main(new_sources=new_sources, keep_ids=False)
 
             prep_operation = self.review_manager.get_prep_operation()
             prep_operation.main()
 
             dedupe_operation = self.review_manager.get_dedupe_operation()
             dedupe_operation.main()
 
@@ -200,15 +202,19 @@
         elif item["cmd"] == "colrev load":
             if len(list(self.review_manager.search_dir.glob("*"))) > 0:
                 self.logger.info("Running %s", item["name"])
 
                 load_operation = self.review_manager.get_load_operation()
                 print()
 
-                new_sources = load_operation.get_new_sources(skip_query=True)
+                heuristic_list = load_operation.get_new_sources_heuristic_list()
+                new_sources = colrev.ui_cli.cli_load.select_new_source(
+                    heuristic_result_list=heuristic_list, skip_query=True
+                )
+
                 load_operation.main(
                     new_sources=new_sources, keep_ids=False, combine_commits=False
                 )
             else:
                 self.service_queue.task_done()
                 return
```

### Comparing `colrev-0.9.0/colrev/settings.py` & `colrev-0.9.2/colrev/settings.py`

 * *Files 2% similar despite different names*

```diff
@@ -20,14 +20,15 @@
 from dataclasses_jsonschema import JsonSchemaMixin
 
 import colrev.env.utils
 import colrev.exceptions as colrev_exceptions
 
 if TYPE_CHECKING:
     import colrev.review_manager
+    import colrev.ops.search_feed
 
 
 # Note : to avoid performance issues on startup (ReviewManager, parsing settings)
 # the settings dataclasses should be in one file (13s compared to 0.3s)
 
 
 # Project
@@ -160,38 +161,37 @@
 
     # pylint: disable=too-many-instance-attributes
 
     endpoint: str
     filename: Path
     search_type: SearchType
     search_parameters: dict
-    load_conversion_package_endpoint: dict
     comment: typing.Optional[str]
 
     def get_corresponding_bib_file(self) -> Path:
         """Get the corresponding bib file"""
 
         return self.filename.with_suffix(".bib")
 
     def setup_for_load(
         self,
         *,
-        record_list: typing.List[typing.Dict],
+        source_records_list: typing.List[typing.Dict],
         imported_origins: typing.List[str],
     ) -> None:
         """Set the SearchSource up for the load process (initialize statistics)"""
         # pylint: disable=attribute-defined-outside-init
         # Note : define outside init because the following
         # attributes are temporary. They should not be
         # saved to settings.json.
 
-        self.to_import = len(record_list)
+        self.to_import = len(source_records_list)
         self.imported_origins: typing.List[str] = imported_origins
         self.len_before = len(imported_origins)
-        self.source_records_list: typing.List[typing.Dict] = record_list
+        self.source_records_list: typing.List[typing.Dict] = source_records_list
 
     def get_origin_prefix(self) -> str:
         """Get the corresponding origin prefix"""
         return (
             str(self.get_corresponding_bib_file().name)
             .replace(str(colrev.review_manager.ReviewManager.SEARCHDIR_RELATIVE), "")
             .lstrip("/")
@@ -223,37 +223,35 @@
         return exported_dict
 
     def get_feed(
         self,
         review_manager: colrev.review_manager.ReviewManager,
         source_identifier: str,
         update_only: bool,
-    ) -> colrev.ops.search.GeneralOriginFeed:
+    ) -> colrev.ops.search_feed.GeneralOriginFeed:
         """Get a feed to add and update records"""
         # pylint: disable=import-outside-toplevel
         # pylint: disable=cyclic-import
-        import colrev.ops.search
+        import colrev.ops.search_feed
 
-        return colrev.ops.search.GeneralOriginFeed(
+        return colrev.ops.search_feed.GeneralOriginFeed(
             review_manager=review_manager,
             search_source=self,
             source_identifier=source_identifier,
             update_only=update_only,
         )
 
     def __str__(self) -> str:
         optional_comment = ""
         if self.comment:
             optional_comment = f"\n   comment:             {self.comment}"
         return (
             f"{self.endpoint} (type: {self.search_type}, "
             + f"filename: {self.filename})\n"
             + f"   search parameters:   {self.search_parameters}"
-            # + "   load_conversion_package_endpoint:   "
-            # + f"{self.load_conversion_package_endpoint['endpoint']}"
             + optional_comment
         )
 
 
 @dataclass
 class SearchSettings(JsonSchemaMixin):
     """Search settings"""
@@ -578,18 +576,14 @@
         JsonSchemaMixin.register_field_encoders({Path: PathField()})
 
         with warnings.catch_warnings():
             warnings.simplefilter("ignore")
             schema = cls.json_schema()
 
         sdefs = schema["definitions"]
-        sdefs["SearchSource"]["properties"]["load_conversion_package_endpoint"] = {  # type: ignore
-            "package_endpoint_type": "load_conversion",
-            "type": "package_endpoint",
-        }
 
         # pylint: disable=unused-variable
         sdefs["PrepRound"]["properties"]["prep_package_endpoints"] = {  # type: ignore # noqa: F841
             "package_endpoint_type": "prep",
             "type": "package_endpoint_array",
         }
         sdefs["PrepSettings"]["properties"]["prep_man_package_endpoints"] = {  # type: ignore
```

### Comparing `colrev-0.9.0/colrev/template/custom_scripts/custom_data_script.py` & `colrev-0.9.2/colrev/template/custom_scripts/custom_data_script.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/custom_scripts/custom_pdf_get_script.py` & `colrev-0.9.2/colrev/template/custom_scripts/custom_pdf_get_script.py`

 * *Files 1% similar despite different names*

```diff
@@ -34,10 +34,10 @@
         self,
         pdf_get_operation: colrev.ops.pdf_get.PDFGet,  # pylint: disable=unused-argument
         record: colrev.record.Record,
     ) -> colrev.record.Record:
         """Get the PDF"""
 
         record.data["file"] = "filepath"
-        pdf_get_operation.import_file(record=record)
+        pdf_get_operation.import_pdf(record=record)
 
         return record
```

### Comparing `colrev-0.9.0/colrev/template/custom_scripts/custom_pdf_prep_script.py` & `colrev-0.9.2/colrev/template/custom_scripts/custom_pdf_prep_script.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/custom_scripts/custom_prep_script.py` & `colrev-0.9.2/colrev/template/custom_scripts/custom_prep_script.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/custom_scripts/custom_prescreen_script.py` & `colrev-0.9.2/colrev/template/custom_scripts/custom_prescreen_script.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/custom_scripts/custom_screen_script.py` & `colrev-0.9.2/colrev/template/custom_scripts/custom_screen_script.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/example/30_example_records.bib` & `colrev-0.9.2/colrev/template/example/30_example_records.bib`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/github_pages/index.html` & `colrev-0.9.2/colrev/template/github_pages/index.html`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/init/LICENSE-CC-BY-4.0.txt` & `colrev-0.9.2/colrev/template/init/LICENSE-CC-BY-4.0.txt`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/init/colrev_update.yml` & `colrev-0.9.2/colrev/template/init/colrev_update.yml`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/init/colrev_update_curation.yml` & `colrev-0.9.2/colrev/template/init/colrev_update_curation.yml`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/init/pre-commit-config.yaml` & `colrev-0.9.2/colrev/template/init/pre-commit-config.yaml`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/init/settings.json` & `colrev-0.9.2/colrev/template/init/settings.json`

 * *Files 3% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9867424242424243%*

 * *Differences: {"'prescreen'": "{'prescreen_package_endpoints': {delete: [0]}}",*

 * * "'sources'": "{0: {delete: ['load_conversion_package_endpoint']}}"}*

```diff
@@ -130,20 +130,14 @@
             }
         ]
     },
     "prescreen": {
         "explanation": "",
         "prescreen_package_endpoints": [
             {
-                "LanguageScope": [
-                    "eng"
-                ],
-                "endpoint": "colrev.scope_prescreen"
-            },
-            {
                 "endpoint": "colrev.colrev_cli_prescreen"
             }
         ]
     },
     "project": {
         "authors": [],
         "auto_upgrade": true,
@@ -168,17 +162,14 @@
         "retrieve_forthcoming": true
     },
     "sources": [
         {
             "comment": "",
             "endpoint": "colrev.pdfs_dir",
             "filename": "data/search/pdfs.bib",
-            "load_conversion_package_endpoint": {
-                "endpoint": "colrev.bibtex"
-            },
             "search_parameters": {
                 "scope": {
                     "path": "data/pdfs"
                 }
             },
             "search_type": "PDFS"
         }
```

### Comparing `colrev-0.9.0/colrev/template/ops/commit_report_details.txt` & `colrev-0.9.2/colrev/template/ops/commit_report_details.txt`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/ops/prep_man_curation.ipynb` & `colrev-0.9.2/colrev/template/ops/prep_man_curation.ipynb`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/ops/status.txt` & `colrev-0.9.2/colrev/template/ops/status.txt`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/package_endpoints.json` & `colrev-0.9.2/colrev/template/package_endpoints.json`

 * *Files 2% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9050618921308575%*

 * *Differences: {"'prep'": "{insert: [(0, OrderedDict([('package_endpoint_identifier', "*

 * *           "'colrev.add_journal_ranking'), ('endpoint', "*

 * *           "'colrev.ops.built_in.prep.add_journal_ranking.AddJournalRanking'), ('status', "*

 * *           "'|EXPERIMENTAL|'), ('status_linked', '|EXPERIMENTAL|'), ('short_description', 'Class "*

 * *           'for add _journal_ranking (`instructions '*

 * *           "<https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/prep/add_journal_ranking.md>`_)'), "*

 * *            […]*

```diff
@@ -95,64 +95,14 @@
             "endpoint": "colrev.ops.built_in.dedupe.simple_dedupe.SimpleDedupe",
             "package_endpoint_identifier": "colrev.simple_dedupe",
             "short_description": "Simple duplicate identification (for small sample sizes) (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/dedupe/simple_dedupe.md>`_)",
             "status": "|MATURING|",
             "status_linked": "|MATURING|"
         }
     ],
-    "load_conversion": [
-        {
-            "ci_supported": true,
-            "endpoint": "colrev.ops.built_in.load_conversion.bib_pybtex_loader.BibPybtexLoader",
-            "package_endpoint_identifier": "colrev.bibtex",
-            "short_description": "Loads BibTeX files (based on pybtex) (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/load_conversion/bib_pybtex_loader.md>`_)",
-            "status": "|MATURING|",
-            "status_linked": "|MATURING|"
-        },
-        {
-            "ci_supported": true,
-            "endpoint": "colrev.ops.built_in.load_conversion.bibutils_loader.BibutilsLoader",
-            "package_endpoint_identifier": "colrev.bibutils",
-            "short_description": "Loads bibliography files (based on bibutils) (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/load_conversion/bibutils_loader.md>`_)",
-            "status": "|MATURING|",
-            "status_linked": "|MATURING|"
-        },
-        {
-            "ci_supported": true,
-            "endpoint": "colrev.ops.built_in.load_conversion.table_loader.CSVLoader",
-            "package_endpoint_identifier": "colrev.csv",
-            "short_description": "Loads csv files (based on pandas) (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/load_conversion/table_loader.md>`_)",
-            "status": "|MATURING|",
-            "status_linked": "|MATURING|"
-        },
-        {
-            "ci_supported": true,
-            "endpoint": "colrev.ops.built_in.load_conversion.table_loader.ExcelLoader",
-            "package_endpoint_identifier": "colrev.excel",
-            "short_description": "Loads Excel (xls, xlsx) files (based on pandas) (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/load_conversion/table_loader.md>`_)",
-            "status": "|MATURING|",
-            "status_linked": "|MATURING|"
-        },
-        {
-            "ci_supported": false,
-            "endpoint": "colrev.ops.built_in.load_conversion.markdown_loader.MarkdownLoader",
-            "package_endpoint_identifier": "colrev.md_to_bib",
-            "short_description": "Loads reference strings from text (md) files (based on GROBID) (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/load_conversion/markdown_loader.md>`_)",
-            "status": "|MATURING|",
-            "status_linked": "|MATURING|"
-        },
-        {
-            "ci_supported": false,
-            "endpoint": "colrev.ops.built_in.load_conversion.zotero_loader.ZoteroTranslationLoader",
-            "package_endpoint_identifier": "colrev.zotero_translate",
-            "short_description": "Loads bibliography files (based on Zotero). (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/load_conversion/zotero_loader.md>`_)",
-            "status": "|MATURING|",
-            "status_linked": "|MATURING|"
-        }
-    ],
     "pdf_get": [
         {
             "ci_supported": false,
             "endpoint": "colrev.ops.built_in.pdf_get.local_index_pdf_get.LocalIndexPDFGet",
             "package_endpoint_identifier": "colrev.local_index",
             "short_description": "Get PDFs from LocalIndex (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/pdf_get/local_index_pdf_get.md>`_)",
             "status": "|MATURING|",
@@ -243,14 +193,22 @@
             "short_description": "Manually prepare PDFs based on a CLI (not yet implemented) (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/pdf_prep_man/pdf_prep_man_cli.md>`_)",
             "status": "|MATURING|",
             "status_linked": "|MATURING|"
         }
     ],
     "prep": [
         {
+            "ci_supported": false,
+            "endpoint": "colrev.ops.built_in.prep.add_journal_ranking.AddJournalRanking",
+            "package_endpoint_identifier": "colrev.add_journal_ranking",
+            "short_description": "Class for add _journal_ranking (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/prep/add_journal_ranking.md>`_)",
+            "status": "|EXPERIMENTAL|",
+            "status_linked": "|EXPERIMENTAL|"
+        },
+        {
             "ci_supported": true,
             "endpoint": "colrev.ops.built_in.prep.curation_prep.CurationPrep",
             "package_endpoint_identifier": "colrev.curation_prep",
             "short_description": "Preparation of curations (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/prep/curation_prep.md>`_)",
             "status": "|EXPERIMENTAL|",
             "status_linked": "|EXPERIMENTAL|"
         },
@@ -380,14 +338,22 @@
             "package_endpoint_identifier": "colrev.get_year_from_vol_iss_jour",
             "short_description": "Prepares records based on year-volume-issue dependency (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/prep/year_vol_iss_prep.md>`_)",
             "status": "|EXPERIMENTAL|",
             "status_linked": "|EXPERIMENTAL|"
         },
         {
             "ci_supported": true,
+            "endpoint": "colrev.ops.built_in.prep.open_alex_metadata_prep.OpenAlexMetadataPrep",
+            "package_endpoint_identifier": "colrev.open_alex_prep",
+            "short_description": "Prepares records based on OpenAlex metadata (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/prep/open_alex_metadata_prep.md>`_)",
+            "status": "|EXPERIMENTAL|",
+            "status_linked": "|EXPERIMENTAL|"
+        },
+        {
+            "ci_supported": true,
             "endpoint": "colrev.ops.built_in.prep.remove_broken_ids.RemoveBrokenIDPrep",
             "package_endpoint_identifier": "colrev.remove_broken_ids",
             "short_description": "Prepares records by removing invalid IDs DOIs/ISBNs (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/prep/remove_broken_ids.md>`_)",
             "status": "|MATURING|",
             "status_linked": "|MATURING|"
         },
         {
@@ -440,22 +406,14 @@
             "status": "|EXPERIMENTAL|",
             "status_linked": "|EXPERIMENTAL|"
         }
     ],
     "prescreen": [
         {
             "ci_supported": false,
-            "endpoint": "colrev.ops.built_in.prescreen.asreview.ASReviewPrescreen",
-            "package_endpoint_identifier": "colrev.asreview_prescreen",
-            "short_description": "ASReview-based prescreen (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/prescreen/asreview.md>`_)",
-            "status": "|EXPERIMENTAL|",
-            "status_linked": "|EXPERIMENTAL|"
-        },
-        {
-            "ci_supported": false,
             "endpoint": "colrev.ops.built_in.prescreen.prescreen_cli.CoLRevCLIPrescreen",
             "package_endpoint_identifier": "colrev.colrev_cli_prescreen",
             "short_description": "CLI-based prescreen (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/prescreen/prescreen_cli.md>`_)",
             "status": "|MATURING|",
             "status_linked": "|MATURING|"
         },
         {
@@ -477,14 +435,22 @@
         {
             "ci_supported": true,
             "endpoint": "colrev.ops.built_in.prescreen.scope_prescreen.ScopePrescreen",
             "package_endpoint_identifier": "colrev.scope_prescreen",
             "short_description": "Rule-based prescreen (scope) (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/prescreen/scope_prescreen.md>`_)",
             "status": "|MATURING|",
             "status_linked": "|MATURING|"
+        },
+        {
+            "ci_supported": false,
+            "endpoint": "colrev_asreview.colrev_asreview.ASReviewPrescreen",
+            "package_endpoint_identifier": "colrev_asreview.colrev_asreview",
+            "short_description": "ASReview-based prescreen (`instructions <https://github.com/CoLRev-Environment/colrev-asreview>`_)",
+            "status": "|MATURING|",
+            "status_linked": "|MATURING|"
         }
     ],
     "review_type": [
         {
             "ci_supported": true,
             "endpoint": "colrev.ops.built_in.review_types.conceptual_review.ConceptualReview",
             "package_endpoint_identifier": "colrev.conceptual_review",
@@ -645,18 +611,18 @@
             "endpoint": "colrev.ops.built_in.search_sources.ebsco_host.EbscoHostSearchSource",
             "package_endpoint_identifier": "colrev.ebsco_host",
             "short_description": "SearchSource for EBSCOHost (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/search_sources/ebsco_host.md>`_)",
             "status": "|EXPERIMENTAL|",
             "status_linked": "|EXPERIMENTAL|"
         },
         {
-            "ci_supported": false,
+            "ci_supported": true,
             "endpoint": "colrev.ops.built_in.search_sources.eric.ERICSearchSource",
             "package_endpoint_identifier": "colrev.eric",
-            "short_description": "SearchSource for ERIC (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/search_sources/eric.md>`_)",
+            "short_description": "SearchSource for the ERIC API (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/search_sources/eric.md>`_)",
             "status": "|EXPERIMENTAL|",
             "status_linked": "|EXPERIMENTAL|"
         },
         {
             "ci_supported": true,
             "endpoint": "colrev.ops.built_in.search_sources.europe_pmc.EuropePMCSearchSource",
             "package_endpoint_identifier": "colrev.europe_pmc",
@@ -669,15 +635,15 @@
             "endpoint": "colrev.ops.built_in.search_sources.google_scholar.GoogleScholarSearchSource",
             "package_endpoint_identifier": "colrev.google_scholar",
             "short_description": "SearchSource for GoogleScholar (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/search_sources/google_scholar.md>`_)",
             "status": "|EXPERIMENTAL|",
             "status_linked": "|EXPERIMENTAL|"
         },
         {
-            "ci_supported": false,
+            "ci_supported": true,
             "endpoint": "colrev.ops.built_in.search_sources.ieee.IEEEXploreSearchSource",
             "package_endpoint_identifier": "colrev.ieee",
             "short_description": "SearchSource for IEEEXplore (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/search_sources/ieee.md>`_)",
             "status": "|EXPERIMENTAL|",
             "status_linked": "|EXPERIMENTAL|"
         },
         {
@@ -694,14 +660,22 @@
             "package_endpoint_identifier": "colrev.local_index",
             "short_description": "Performs a search in the LocalIndex (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/search_sources/local_index.md>`_)",
             "status": "|MATURING|",
             "status_linked": "|MATURING|"
         },
         {
             "ci_supported": true,
+            "endpoint": "colrev.ops.built_in.search_sources.open_alex.OpenAlexSearchSource",
+            "package_endpoint_identifier": "colrev.open_alex",
+            "short_description": "SearchSource for the OpenAlex API (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/search_sources/open_alex.md>`_)",
+            "status": "|EXPERIMENTAL|",
+            "status_linked": "|EXPERIMENTAL|"
+        },
+        {
+            "ci_supported": true,
             "endpoint": "colrev.ops.built_in.search_sources.open_citations_forward_search.OpenCitationsSearchSource",
             "package_endpoint_identifier": "colrev.open_citations_forward_search",
             "short_description": "Performs a forward search based on OpenCitations (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/search_sources/open_citations_forward_search.md>`_)",
             "status": "|MATURING|",
             "status_linked": "|MATURING|"
         },
         {
@@ -758,17 +732,17 @@
             "package_endpoint_identifier": "colrev.springer_link",
             "short_description": "SearchSource for Springer Link (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/search_sources/springer_link.md>`_)",
             "status": "|EXPERIMENTAL|",
             "status_linked": "|EXPERIMENTAL|"
         },
         {
             "ci_supported": false,
-            "endpoint": "colrev.ops.built_in.search_sources.systematic_review_datasets.SystematicReviewDatasetsSearchSource",
-            "package_endpoint_identifier": "colrev.systematic_review_datasets",
-            "short_description": "SearchSource for systematic-review-datasets (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/search_sources/systematic_review_datasets.md>`_)",
+            "endpoint": "colrev.ops.built_in.search_sources.synergy_datasets.SYNERGYDatasetsSearchSource",
+            "package_endpoint_identifier": "colrev.synergy_datasets",
+            "short_description": "SearchSource for SYNERGY-datasets (`instructions <https://github.com/CoLRev-Environment/colrev/blob/main/colrev/ops/built_in/search_sources/systematic_review_datasets.md>`_)",
             "status": "|EXPERIMENTAL|",
             "status_linked": "|EXPERIMENTAL|"
         },
         {
             "ci_supported": false,
             "endpoint": "colrev.ops.built_in.search_sources.taylor_and_francis.TaylorAndFrancisSearchSource",
             "package_endpoint_identifier": "colrev.taylor_and_francis",
```

### Comparing `colrev-0.9.0/colrev/template/package_status.json` & `colrev-0.9.2/colrev/template/package_status.json`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9105216622458001%*

 * *Differences: {"'prep'": "{insert: [(22, OrderedDict([('package_endpoint_identifier', "*

 * *           "'colrev.add_journal_ranking'), ('status', 'EXPERIMENTAL')])), (23, "*

 * *           "OrderedDict([('package_endpoint_identifier', 'colrev.open_alex_prep'), ('status', "*

 * *           "'EXPERIMENTAL')]))]}",*

 * * "'prescreen'": "{2: {'package_endpoint_identifier': 'colrev.conditional_prescreen', 'status': "*

 * *                "'MATURING'}, 3: {'package_endpoint_identifier': 'colrev.prescreen_table'}, 4: "*

 * *                "{'package_endpo […]*

```diff
@@ -51,40 +51,14 @@
             "status": "EXPERIMENTAL"
         },
         {
             "package_endpoint_identifier": "colrev.curation_missing_dedupe",
             "status": "EXPERIMENTAL"
         }
     ],
-    "load_conversion": [
-        {
-            "package_endpoint_identifier": "colrev.bibtex",
-            "status": "MATURING"
-        },
-        {
-            "package_endpoint_identifier": "colrev.csv",
-            "status": "MATURING"
-        },
-        {
-            "package_endpoint_identifier": "colrev.excel",
-            "status": "MATURING"
-        },
-        {
-            "package_endpoint_identifier": "colrev.zotero_translate",
-            "status": "MATURING"
-        },
-        {
-            "package_endpoint_identifier": "colrev.md_to_bib",
-            "status": "MATURING"
-        },
-        {
-            "package_endpoint_identifier": "colrev.bibutils",
-            "status": "MATURING"
-        }
-    ],
     "pdf_get": [
         {
             "package_endpoint_identifier": "colrev.unpaywall",
             "status": "MATURING"
         },
         {
             "package_endpoint_identifier": "colrev.local_index",
@@ -217,14 +191,22 @@
         {
             "package_endpoint_identifier": "colrev.general_polish",
             "status": "EXPERIMENTAL"
         },
         {
             "package_endpoint_identifier": "colrev.curation_prep",
             "status": "EXPERIMENTAL"
+        },
+        {
+            "package_endpoint_identifier": "colrev.add_journal_ranking",
+            "status": "EXPERIMENTAL"
+        },
+        {
+            "package_endpoint_identifier": "colrev.open_alex_prep",
+            "status": "EXPERIMENTAL"
         }
     ],
     "prep_man": [
         {
             "package_endpoint_identifier": "colrev.export_man_prep",
             "status": "MATURING"
         },
@@ -239,24 +221,24 @@
             "status": "MATURING"
         },
         {
             "package_endpoint_identifier": "colrev.colrev_cli_prescreen",
             "status": "MATURING"
         },
         {
-            "package_endpoint_identifier": "colrev.asreview_prescreen",
-            "status": "EXPERIMENTAL"
-        },
-        {
             "package_endpoint_identifier": "colrev.conditional_prescreen",
             "status": "MATURING"
         },
         {
             "package_endpoint_identifier": "colrev.prescreen_table",
             "status": "MATURING"
+        },
+        {
+            "package_endpoint_identifier": "colrev_asreview.colrev_asreview",
+            "status": "MATURING"
         }
     ],
     "review_type": [
         {
             "package_endpoint_identifier": "colrev.conceptual_review",
             "status": "EXPERIMENTAL"
         },
@@ -321,15 +303,15 @@
             "status": "MATURING"
         },
         {
             "package_endpoint_identifier": "colrev.abi_inform_proquest",
             "status": "EXPERIMENTAL"
         },
         {
-            "package_endpoint_identifier": "colrev.systematic_review_datasets",
+            "package_endpoint_identifier": "colrev.synergy_datasets",
             "status": "EXPERIMENTAL"
         },
         {
             "package_endpoint_identifier": "colrev.taylor_and_francis",
             "status": "EXPERIMENTAL"
         },
         {
@@ -419,10 +401,14 @@
         {
             "package_endpoint_identifier": "colrev.local_index",
             "status": "MATURING"
         },
         {
             "package_endpoint_identifier": "colrev.trid",
             "status": "EXPERIMENTAL"
+        },
+        {
+            "package_endpoint_identifier": "colrev.open_alex",
+            "status": "EXPERIMENTAL"
         }
     ]
 }
```

### Comparing `colrev-0.9.0/colrev/template/paper_md/APA-7.docx` & `colrev-0.9.2/colrev/template/paper_md/APA-7.docx`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/paper_md/paper.md` & `colrev-0.9.2/colrev/template/paper_md/paper.md`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/prisma/PRISMA.csv` & `colrev-0.9.2/colrev/template/prisma/PRISMA.csv`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/prisma/PRISMA_original.csv` & `colrev-0.9.2/colrev/template/prisma/PRISMA_original.csv`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/prisma/prisma-refs.bib` & `colrev-0.9.2/colrev/template/prisma/prisma-refs.bib`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/review_type/curated_masterdata/curations_github_colrev_update.yml` & `colrev-0.9.2/colrev/template/review_type/curated_masterdata/curations_github_colrev_update.yml`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/template/review_type/meta_analysis/paper.md` & `colrev-0.9.2/colrev/template/review_type/meta_analysis/paper.md`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ui_cli/cli.py` & `colrev-0.9.2/colrev/ui_cli/cli.py`

 * *Files 5% similar despite different names*

```diff
@@ -11,35 +11,44 @@
 import webbrowser
 from functools import partial
 from functools import wraps
 from pathlib import Path
 
 import click
 import click_completion.core
+import click_repl
 import pandas as pd
 
+import colrev.env.package_manager
 import colrev.exceptions as colrev_exceptions
 import colrev.record
 import colrev.review_manager
 import colrev.ui_cli.cli_colors as colors
+import colrev.ui_cli.cli_load
 import colrev.ui_cli.cli_status_printer
 import colrev.ui_cli.cli_validation
 import colrev.ui_cli.dedupe_errors
 
+# pylint: disable=too-many-branches
+# pylint: disable=too-many-locals
+# pylint: disable=too-many-return-statements
+# pylint: disable=import-outside-toplevel
 # pylint: disable=too-many-lines
 # pylint: disable=redefined-builtin
 # pylint: disable=redefined-outer-name
 # pylint: disable=too-many-arguments
 # pylint: disable=unused-argument
 # pylint: disable=superfluous-parens
 # Note: autocompletion needs bash/... activation:
 # https://click.palletsprojects.com/en/7.x/bashcomplete/
 
 EXACT_CALL = "colrev " + subprocess.list2cmdline(sys.argv[1:])  # nosec
 
+package_manager = colrev.env.package_manager.PackageManager()
+
 
 def __custom_startswith(string: str, incomplete: str) -> bool:
     """A custom completion matching that supports case insensitive matching"""
     if os.environ.get("_CLICK_COMPLETION_COMMAND_CASE_INSENSITIVE_COMPLETE"):
         string = string.lower()
         incomplete = incomplete.lower()
     return string.startswith(incomplete)
@@ -119,19 +128,92 @@
     pdfs          Get and prepare PDFs
     screen        Include records based on PDFs
     data          Complete selected forms of data analysis and synthesis
 
     \b
     validate      Validate changes in the previous commit
 
+    \b
+    repl          Start interactive terminal
+
     Recommended workflow: colrev status > colrev OPERATION > colrev validate
 
     Documentation:  https://colrev.readthedocs.io/
     """
 
+    try:
+        if ctx.invoked_subcommand == "repl":
+            ctx.obj = {"review_manager": colrev.review_manager.ReviewManager()}
+    except colrev.exceptions.RepoSetupError:
+        pass
+
+
+def get_review_manager(
+    ctx: click.core.Context, review_manager_params: dict
+) -> colrev.review_manager.ReviewManager:
+    """Get review_manager instance. If it's available in ctx object, reuse that
+    if not creates a new one, Once created will update the review_manager with
+    the given parameters. If params requires review_manager to be reloaded, will
+    reload it
+    """
+
+    review_manager_params["exact_call"] = ctx.command_path
+    try:
+        review_manager = ctx.obj["review_manager"]
+        if (
+            "navigate_to_home_dir" in review_manager_params
+            or "path_str" in review_manager_params
+            or "skip_upgrade" in review_manager_params
+        ):
+            print("init review manager object ...")
+            review_manager = colrev.review_manager.ReviewManager(
+                **review_manager_params
+            )
+            ctx.obj["review_manager"] = review_manager
+        else:
+            review_manager.update_config(**review_manager_params)
+        return review_manager
+    except (TypeError, KeyError):
+        review_manager = colrev.review_manager.ReviewManager(**review_manager_params)
+        ctx.obj = {"review_manager": review_manager}
+        return review_manager
+
+
+@main.command(help_priority=100)
+@click.pass_context
+@catch_exception(handle=(colrev_exceptions.CoLRevException))
+def shell(
+    ctx: click.core.Context,
+) -> None:
+    """Starts a interactive terminal"""
+    from prompt_toolkit.history import FileHistory
+
+    print(f"CoLRev version {colrev.__version__}")
+    print("Workflow: status > OPERATION > validate")
+    print("https://colrev.readthedocs.io/en/latest/")
+    print("Type exit to close the shell")
+    print()
+    prompt_kwargs = {"history": FileHistory(".history"), "message": "CoLRev > "}
+    click_repl.repl(ctx, prompt_kwargs=prompt_kwargs)
+
+
+@main.command(help_priority=100)
+@click.pass_context
+@catch_exception(handle=(colrev_exceptions.CoLRevException))
+def exit(
+    ctx: click.core.Context,
+) -> None:
+    """Starts a interactive terminal"""
+    import inspect
+
+    curframe = inspect.currentframe()
+    calframe = inspect.getouterframes(curframe, 2)
+    if calframe[7].function == "shell":
+        raise click_repl.exceptions.ExitReplException
+
 
 @main.command(help_priority=1)
 @click.option(
     "--type",
     type=str,
     default="literature_review",
     help="Review type (e.g., literature_review (default), scoping_review, theoretical_review)",
@@ -177,15 +259,15 @@
     example: bool,
     light: bool,
     local_pdf_collection: bool,
     verbose: bool,
     force: bool,
 ) -> None:
     """Initialize (define review objectives and type)"""
-    # pylint: disable=import-outside-toplevel
+
     import colrev.ops.init
 
     colrev.review_manager.get_init_operation(
         review_type=type,
         example=example,
         light=light,
         local_pdf_collection=local_pdf_collection,
@@ -220,18 +302,18 @@
 def status(
     ctx: click.core.Context,
     analytics: bool,
     verbose: bool,
     force: bool,
 ) -> None:
     """Show status"""
-
     try:
-        review_manager = colrev.review_manager.ReviewManager(
-            force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+        review_manager = get_review_manager(
+            ctx,
+            {"force_mode": force, "verbose_mode": verbose, "exact_call": EXACT_CALL},
         )
         status_operation = review_manager.get_status_operation()
 
         if analytics:
             analytic_results = status_operation.get_analytics()
             for cid, data_item in reversed(analytic_results.items()):
                 print(f"{cid} - {data_item}")
@@ -241,14 +323,42 @@
 
     except KeyboardInterrupt:
         print("Stopped...")
     except colrev_exceptions.RepoSetupError as exc:
         print(exc)
 
 
+# add dashboard operation
+@main.command(help_priority=100)
+@click.option(
+    "-v",
+    "--verbose",
+    is_flag=True,
+    default=False,
+    help="Verbose: printing more infos",
+)
+@click.pass_context
+def dashboard(
+    ctx: click.core.Context,
+    verbose: bool,
+) -> None:
+    """Allows to track project progress through dashboard"""
+    # pylint: disable=import-outside-toplevel
+    import colrev.ops.dashboard
+
+    try:
+        colrev.ops.dashboard.main()
+    except colrev_exceptions.NoRecordsError:
+        print("No records imported yet.")
+    except colrev_exceptions.CoLRevException as exc:
+        if verbose:
+            raise exc
+        print(exc)
+
+
 @main.command(help_priority=3)
 @click.option(
     "-v",
     "--verbose",
     is_flag=True,
     default=False,
     help="Verbose: printing more infos",
@@ -274,16 +384,17 @@
     - Copy files (*.bib, *.ris, *.xlsx, ...) to the directory data/search or
     - Copy PDF files to the directory data/pdfs or
     - Add an API-based search, as described in the documentation:
 
     https://colrev.readthedocs.io/en/latest/manual/metadata_retrieval/search.html
     """
 
-    review_manager = colrev.review_manager.ReviewManager(
-        verbose_mode=verbose, force_mode=force, high_level_operation=True
+    review_manager = get_review_manager(
+        ctx,
+        {"verbose_mode": verbose, "force_mode": force, "high_level_operation": True},
     )
 
     if not any(review_manager.search_dir.iterdir()) and not any(
         review_manager.pdf_dir.iterdir()
     ):
         # Note : API-based searches automatically retrieve files
         # when they are added, i.e., the following message should
@@ -307,17 +418,20 @@
     search_operation = review_manager.get_search_operation()
     search_operation.main(rerun=False)
 
     print()
 
     review_manager.exact_call = "colrev prep"
     load_operation = review_manager.get_load_operation()
-    new_sources = load_operation.get_new_sources(skip_query=True)
+    heuristic_list = load_operation.get_new_sources_heuristic_list()
+    new_sources = colrev.ui_cli.cli_load.select_new_source(
+        heuristic_result_list=heuristic_list, skip_query=True
+    )
     load_operation = review_manager.get_load_operation(hide_load_explanation=True)
-    load_operation.main(new_sources=new_sources, keep_ids=False, combine_commits=False)
+    load_operation.main(new_sources=new_sources, keep_ids=False)
 
     print()
     review_manager.exact_call = "colrev prep"
     prep_operation = review_manager.get_prep_operation()
     prep_operation.main()
 
     print()
@@ -327,17 +441,23 @@
     dedupe_operation.main()
 
 
 @main.command(help_priority=4)
 @click.option(
     "-a",
     "--add",
-    type=str,
+    type=click.Choice(
+        package_manager.discover_packages(
+            package_type=colrev.env.package_manager.PackageEndpointType.search_source,
+            installed_only=True,
+        ),
+        case_sensitive=False,
+    ),
     help="""
-Format: RETRIEVE * FROM crossref WHERE title LIKE '%keyword%'
+Format: colrev search -a colrev.dblp:"https://dblp.org/search?q=microsourcing"
 """,
 )
 @click.option("-v", "--view", is_flag=True, default=False, help="View search sources")
 @click.option(
     "-s",
     "--selected",
     type=str,
@@ -348,14 +468,18 @@
     "--rerun",
     is_flag=True,
     default=False,
     help="Rerun API-based searches, retrieving and updating all records "
     + "(not just the most recent ones)",
 )
 @click.option(
+    "-bws",
+    help="Backward search on a selected paper",
+)
+@click.option(
     "-f",
     "--force",
     is_flag=True,
     default=False,
     help="Force mode",
 )
 @click.option(
@@ -383,67 +507,79 @@
 @catch_exception(handle=(colrev_exceptions.CoLRevException))
 def search(
     ctx: click.core.Context,
     add: str,
     view: bool,
     selected: str,
     rerun: bool,
+    bws: str,
     setup_custom_script: bool,
     verbose: bool,
     force: bool,
 ) -> None:
     """Search for records"""
 
-    # pylint: disable=import-outside-toplevel
     import colrev.ui_cli.add_packages
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+    review_manager = get_review_manager(
+        ctx, {"verbose_mode": verbose, "force_mode": force, "exact_call": EXACT_CALL}
     )
+
     search_operation = review_manager.get_search_operation()
 
     if add:
         colrev.ui_cli.add_packages.add_search_source(
             search_operation=search_operation,
             query=add,
         )
 
     elif view:
-        search_operation.view_sources()
+        for source in search_operation.sources:
+            search_operation.review_manager.p_printer.pprint(source)
 
     elif setup_custom_script:
-        search_operation.setup_custom_script()
+        import colrev.ui_cli.setup_custom_scripts
+
+        colrev.ui_cli.setup_custom_scripts.setup_custom_search_script(
+            review_manager=review_manager
+        )
         print("Activated custom_search_script.py.")
         print("Please update the source in settings.json and commit.")
+    elif bws:
+        import colrev.ui_cli.search_backward_selective
+
+        colrev.ui_cli.search_backward_selective.main(
+            search_operation=search_operation, bws=bws
+        )
 
     else:
         search_operation.main(selection_str=selected, rerun=rerun)
 
 
 @main.command(help_priority=5)
 @click.option(
     "-k",
     "--keep_ids",
     is_flag=True,
     default=False,
     help="Do not change the record IDs. Useful when importing an existing sample.",
 )
 @click.option(
-    "-c",
-    "--combine_commits",
+    "-sq",
+    "--skip_query",
     is_flag=True,
     default=False,
-    help="Combine load of multiple sources in one commit.",
+    help="Skip entering the search query (if applicable)",
 )
 @click.option(
-    "-sq",
-    "--skip_query",
+    "-i",
+    "--include",
     is_flag=True,
     default=False,
-    help="Skip entering the search query (if applicable)",
+    help="Automatically include papers from the new sources.",
 )
 @click.option(
     "-v",
     "--verbose",
     is_flag=True,
     default=False,
     help="Verbose: printing more infos",
@@ -456,38 +592,60 @@
     help="Force mode",
 )
 @click.pass_context
 @catch_exception(handle=(colrev_exceptions.CoLRevException))
 def load(
     ctx: click.core.Context,
     keep_ids: bool,
-    combine_commits: bool,
     skip_query: bool,
+    include: bool,
     verbose: bool,
     force: bool,
 ) -> None:
     """Load records"""
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+    review_manager = get_review_manager(
+        ctx, {"verbose_mode": verbose, "force_mode": force, "exact_call": EXACT_CALL}
     )
-    # already start LocalIndex (for set_ids)
     load_operation = review_manager.get_load_operation()
 
-    new_sources = load_operation.get_new_sources(skip_query=skip_query)
-
-    if combine_commits:
-        logging.info("Combine mode: all search sources will be loaded in one commit")
+    heuristic_list = load_operation.get_new_sources_heuristic_list()
+    new_sources = colrev.ui_cli.cli_load.select_new_source(
+        heuristic_result_list=heuristic_list, skip_query=True
+    )
 
     # Note : reinitialize to load new scripts:
     load_operation = review_manager.get_load_operation(hide_load_explanation=True)
 
-    load_operation.main(
-        new_sources=new_sources, keep_ids=keep_ids, combine_commits=combine_commits
-    )
+    load_operation.main(new_sources=new_sources, keep_ids=keep_ids)
+
+    if include:
+        print()
+        review_manager.logger.info(  # pylint: disable=logging-fstring-interpolation
+            f"{colors.GREEN}Automatically include records from "
+            f"[{', '.join(str(s.filename) for s in new_sources)}]{colors.END}"
+        )
+        print()
+        prep_operation = review_manager.get_prep_operation()
+        prep_operation.main()
+        print()
+        dedupe_operation = review_manager.get_dedupe_operation()
+        dedupe_operation.main()
+        print()
+        prescreen_operation = review_manager.get_prescreen_operation()
+        prescreen_operation.main()
+        print()
+        pdf_get_operation = review_manager.get_pdf_get_operation()
+        pdf_get_operation.main()
+        print()
+        pdf_prep_operation = review_manager.get_pdf_prep_operation()
+        pdf_prep_operation.main()
+        print()
+        screen_operation = review_manager.get_screen_operation()
+        screen_operation.main()
 
 
 @main.command(help_priority=6)
 @click.option(
     "-k",
     "--keep_ids",
     is_flag=True,
@@ -542,14 +700,22 @@
 @click.option(
     "-df",
     "--debug_file",
     type=click.Path(exists=True),
     help="Debug the preparation step for a selected record (in a file).",
 )
 @click.option(
+    "-a",
+    "--add",
+    type=str,
+    help="""
+Format: colrev prep -a colrev.add_journal_ranking
+""",
+)
+@click.option(
     "--skip",
     is_flag=True,
     default=False,
     help="Skip the preparation.",
     hidden=True,
 )
 @click.option(
@@ -575,25 +741,27 @@
     reset_records: str,
     reset_ids: bool,
     set_ids: bool,
     debug: str,
     debug_file: Path,
     cpu: int,
     setup_custom_script: bool,
+    add: str,
     skip: bool,
     verbose: bool,
     force: bool,
 ) -> None:
     """Prepare records"""
 
-    # pylint: disable=too-many-branches
-    # pylint: disable=too-many-locals
+    import colrev.ui_cli.add_packages
+
     try:
-        review_manager = colrev.review_manager.ReviewManager(
-            force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+        review_manager = get_review_manager(
+            ctx,
+            {"verbose_mode": verbose, "force_mode": force, "exact_call": EXACT_CALL},
         )
         prep_operation = review_manager.get_prep_operation()
 
         if reset_records != "NA":
             try:
                 reset_records = str(reset_records)
             except ValueError:
@@ -614,14 +782,20 @@
         if setup_custom_script:
             prep_operation.setup_custom_script()
             print("Activated custom_prep_script.py.")
             print(
                 "Please check and adapt its position in the settings.json and commit."
             )
             return
+        if add:
+            colrev.ui_cli.add_packages.add_prep(
+                prep_operation=prep_operation,
+                query=add,
+            )
+            return
         if skip:
             prep_operation.skip_prep()
 
         prep_operation.main(keep_ids=keep_ids, cpu=cpu, polish=polish)
 
     except colrev_exceptions.ServiceNotAvailableException as exc:
         print(exc)
@@ -661,16 +835,16 @@
 @click.pass_context
 @catch_exception(handle=(colrev_exceptions.CoLRevException))
 def prep_man(
     ctx: click.core.Context, stats: bool, languages: bool, verbose: bool, force: bool
 ) -> None:
     """Prepare records manually"""
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+    review_manager = get_review_manager(
+        ctx, {"verbose_mode": verbose, "force_mode": force, "exact_call": EXACT_CALL}
     )
     prep_man_operation = review_manager.get_prep_man_operation()
     if languages:
         prep_man_operation.prep_man_langs()
         return
 
     if stats:
@@ -741,16 +915,16 @@
     gid: bool,
     view: bool,
     verbose: bool,
     force: bool,
 ) -> None:
     """Deduplicate records"""
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+    review_manager = get_review_manager(
+        ctx, {"verbose_mode": verbose, "force_mode": force, "exact_call": EXACT_CALL}
     )
     state_transition_operation = not view
     dedupe_operation = review_manager.get_dedupe_operation(
         notify_state_transition_operation=state_transition_operation
     )
 
     if merge:
@@ -845,14 +1019,22 @@
 @click.option(
     "-e",
     "--exclude",
     help="Prescreen exclude records based on IDs (ID1,ID2,...).",
     required=False,
 )
 @click.option(
+    "-a",
+    "--add",
+    type=str,
+    help="""
+Format: colrev prescreen -a colrev.scope_prescreen:"TimeScopeFrom=2010"
+""",
+)
+@click.option(
     "-scs",
     "--setup_custom_script",
     is_flag=True,
     default=False,
     help="Setup template for custom search script.",
 )
 @click.option(
@@ -877,23 +1059,25 @@
     include_all_always: bool,
     export_format: str,
     import_table: str,
     create_split: int,
     split: str,
     include: str,
     exclude: str,
+    add: str,
     setup_custom_script: bool,
     verbose: bool,
     force: bool,
 ) -> None:
     """Pre-screen exclusion based on metadata (titles and abstracts)"""
 
-    # pylint: disable=too-many-locals
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+    import colrev.ui_cli.add_packages
+
+    review_manager = get_review_manager(
+        ctx, {"verbose_mode": verbose, "force_mode": force, "exact_call": EXACT_CALL}
     )
     prescreen_operation = review_manager.get_prescreen_operation()
 
     if export_format:
         prescreen_operation.export_table(export_table_format=export_format)
 
     elif import_table:
@@ -912,15 +1096,19 @@
 
     elif exclude:
         prescreen_operation.exclude_records(ids=include)
 
     elif setup_custom_script:
         prescreen_operation.setup_custom_script()
         print("Activated custom_prescreen_script.py.")
-
+    elif add:
+        colrev.ui_cli.add_packages.add_prescreen(
+            prescreen_operation=prescreen_operation,
+            add=add,
+        )
     else:
         review_manager.logger.info("Prescreen")
         review_manager.logger.info(
             "Exclude irrelevant records based on metadata (i.e., titles and abstracts)."
         )
         review_manager.logger.info("Remaining records are retained provisionally")
         review_manager.logger.info(
@@ -1005,16 +1193,16 @@
     split: str,
     setup_custom_script: bool,
     verbose: bool,
     force: bool,
 ) -> None:
     """Screen based on PDFs and inclusion/exclusion criteria"""
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+    review_manager = get_review_manager(
+        ctx, {"verbose_mode": verbose, "force_mode": force, "exact_call": EXACT_CALL}
     )
     screen_operation = review_manager.get_screen_operation()
 
     if include_all or include_all_always:
         screen_operation.include_all_in_screen(persist=include_all_always)
         return
     if add_criterion:
@@ -1032,14 +1220,54 @@
         screen_operation.setup_custom_script()
         print("Activated custom_screen_script.py.")
         return
 
     screen_operation.main(split_str=split)
 
 
+def __extract_coverpage(*, cover: Path) -> None:
+    cp_path = Path.home().joinpath("colrev") / Path(".coverpages")
+    cp_path.mkdir(exist_ok=True)
+
+    assert Path(cover).suffix == ".pdf"
+    record = colrev.record.Record(data={"file": cover})
+    record.extract_pages(
+        pages=[0], project_path=Path(cover).parent, save_to_path=cp_path
+    )
+
+
+@main.command(help_priority=17)
+@click.argument("path", nargs=1, type=click.Path(exists=True))
+@click.pass_context
+@catch_exception(handle=(colrev_exceptions.CoLRevException))
+def pdf(
+    ctx: click.core.Context,
+    path: str,
+) -> None:
+    """Process a PDF"""
+
+    ret = ""
+    while ret in ["c", "h", ""]:
+        ret = input("Option (c: remove cover page, h: show hashes, q: quit)")
+        if ret == "c":
+            __extract_coverpage(cover=Path(path))
+        elif ret == "h":
+            __print_pdf_hashes(pdf_path=Path(path))
+        # elif ret == "o":
+        #     print("TODO : ocr")
+        # elif ret == "r":
+        #     print("TODO: remove comments")
+        # elif ret == "m":
+        #     print("TODO : extract metadata")
+        # elif ret == "t":
+        #     print("TODO : create tei")
+        # elif ret == "i":
+        #     print("TODO: print infos (website / retracted /...)")
+
+
 @main.command(help_priority=11)
 @click.option(
     "--discard",
     is_flag=True,
     default=False,
     help="Discard all missing PDFs as not_available",
 )
@@ -1071,23 +1299,25 @@
     discard: bool,
     dir: bool,
     verbose: bool,
     force: bool,
 ) -> None:
     """Retrieve and prepare PDFs"""
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force,
-        verbose_mode=verbose,
-        high_level_operation=True,
-        exact_call=EXACT_CALL,
+    review_manager = get_review_manager(
+        ctx,
+        {
+            "verbose_mode": verbose,
+            "force_mode": force,
+            "exact_call": EXACT_CALL,
+            "high_level_operation": True,
+        },
     )
 
     if dir:
-        # pylint: disable=import-outside-toplevel
         # pylint: disable=consider-using-with
         # pylint: disable=no-member
 
         path = review_manager.path / Path("data/pdfs")
         webbrowser.open(str(path))
         return
 
@@ -1110,15 +1340,15 @@
         notify_state_transition_operation=True
     )
     pdf_get_operation.main()
 
     print()
 
     pdf_prep_operation = review_manager.get_pdf_prep_operation()
-    pdf_prep_operation.main(batch_size=0)
+    pdf_prep_operation.main()
 
 
 @main.command(help_priority=12)
 @click.option(
     "-c",
     "--copy-to-repo",
     is_flag=True,
@@ -1129,15 +1359,15 @@
     "-r",
     "--rename",
     is_flag=True,
     default=False,
     help="Rename the PDF files according to record IDs",
 )
 @click.option(
-    "--relink_files",
+    "--relink_pdfs",
     is_flag=True,
     default=False,
     help="Recreate links to PDFs based on colrev pdf-IDs (when PDFs were renamed)",
 )
 @click.option(
     "-scs",
     "--setup_custom_script",
@@ -1161,32 +1391,37 @@
 )
 @click.pass_context
 @catch_exception(handle=(colrev_exceptions.CoLRevException))
 def pdf_get(
     ctx: click.core.Context,
     copy_to_repo: bool,
     rename: bool,
-    relink_files: bool,
+    relink_pdfs: bool,
     setup_custom_script: bool,
     verbose: bool,
     force: bool,
 ) -> None:
     """Get PDFs"""
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+    review_manager = get_review_manager(
+        ctx,
+        {
+            "verbose_mode": verbose,
+            "force_mode": force,
+            "exact_call": EXACT_CALL,
+        },
     )
 
-    state_transition_operation = not relink_files and not setup_custom_script
+    state_transition_operation = not relink_pdfs and not setup_custom_script
     pdf_get_operation = review_manager.get_pdf_get_operation(
         notify_state_transition_operation=state_transition_operation
     )
 
-    if relink_files:
-        pdf_get_operation.relink_files()
+    if relink_pdfs:
+        pdf_get_operation.relink_pdfs()
         return
     if copy_to_repo:
         pdf_get_operation.copy_pdfs_to_repo()
         return
     if rename:
         pdf_get_operation.rename_pdfs()
         return
@@ -1233,16 +1468,21 @@
     export: bool,
     discard: bool,
     verbose: bool,
     force: bool,
 ) -> None:
     """Get PDFs manually"""
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+    review_manager = get_review_manager(
+        ctx,
+        {
+            "verbose_mode": verbose,
+            "force_mode": force,
+            "exact_call": EXACT_CALL,
+        },
     )
     pdf_get_man_operation = review_manager.get_pdf_get_man_operation()
 
     if export:
         records = pdf_get_man_operation.review_manager.dataset.load_records_dict()
         pdf_get_man_records = [
             r
@@ -1278,27 +1518,15 @@
     if discard:
         pdf_get_man_operation.discard()
         return
 
     pdf_get_man_operation.main()
 
 
-def __extract_coverpage(*, cover: Path) -> None:
-    cp_path = Path.home().joinpath("colrev") / Path(".coverpages")
-    cp_path.mkdir(exist_ok=True)
-
-    assert Path(cover).suffix == ".pdf"
-    record = colrev.record.Record(data={"file": cover})
-    record.extract_pages(
-        pages=[0], project_path=Path(cover).parent, save_to_path=cp_path
-    )
-
-
 def __print_pdf_hashes(*, pdf_path: Path) -> None:
-    # pylint: disable=import-outside-toplevel
     from PyPDF2 import PdfFileReader
     import colrev.qm.colrev_pdf_id
 
     try:
         pdf_reader = PdfFileReader(str(pdf_path), strict=False)
     except ValueError:
         print("Could not read PDF")
@@ -1355,25 +1583,14 @@
 @click.option(
     "--tei",
     is_flag=True,
     default=False,
     help="Generate TEI documents.",
 )
 @click.option(
-    "-c",
-    "--cover",
-    type=click.Path(exists=True),
-    help="Remove cover page",
-)
-@click.option(
-    "--pdf_hash",
-    type=click.Path(exists=True),
-    help="Get the PDF hash of a page",
-)
-@click.option(
     "-scs",
     "--setup_custom_script",
     is_flag=True,
     default=False,
     help="Setup template for custom search script.",
 )
 @click.option(
@@ -1393,37 +1610,33 @@
 @click.pass_context
 @catch_exception(handle=(colrev_exceptions.CoLRevException))
 def pdf_prep(
     ctx: click.core.Context,
     batch_size: int,
     update_colrev_pdf_ids: bool,
     reprocess: bool,
-    pdf_hash: Path,
     setup_custom_script: bool,
     tei: bool,
-    cover: Path,
     verbose: bool,
     force: bool,
 ) -> None:
     """Prepare PDFs"""
 
-    if cover:
-        __extract_coverpage(cover=cover)
-        return
-
     try:
-        review_manager = colrev.review_manager.ReviewManager(
-            force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+        review_manager = get_review_manager(
+            ctx,
+            {
+                "verbose_mode": verbose,
+                "force_mode": force,
+                "exact_call": EXACT_CALL,
+            },
         )
         pdf_prep_operation = review_manager.get_pdf_prep_operation(reprocess=reprocess)
 
-        if pdf_hash:
-            __print_pdf_hashes(pdf_path=pdf_hash)
-
-        elif update_colrev_pdf_ids:
+        if update_colrev_pdf_ids:
             pdf_prep_operation.update_colrev_pdf_ids()
 
         elif setup_custom_script:
             pdf_prep_operation.setup_custom_script()
             print("Activated custom_pdf_prep_script.py.")
         elif tei:
             pdf_prep_operation.generate_tei()
@@ -1512,16 +1725,21 @@
     extract: bool,
     apply: bool,
     verbose: bool,
     force: bool,
 ) -> None:
     """Prepare PDFs manually"""
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+    review_manager = get_review_manager(
+        ctx,
+        {
+            "verbose_mode": verbose,
+            "force_mode": force,
+            "exact_call": EXACT_CALL,
+        },
     )
     pdf_prep_man_operation = review_manager.get_pdf_prep_man_operation()
 
     if delete_first_page:
         __delete_first_pages_cli(pdf_prep_man_operation, delete_first_page)
         return
     if discard:
@@ -1589,19 +1807,23 @@
     add: str,
     setup_custom_script: bool,
     verbose: bool,
     force: bool,
 ) -> None:
     """Complete selected forms of data analysis and synthesis"""
 
-    # pylint: disable=import-outside-toplevel
     import colrev.ui_cli.add_packages
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=(force or profile), verbose_mode=verbose, exact_call=EXACT_CALL
+    review_manager = get_review_manager(
+        ctx,
+        {
+            "verbose_mode": verbose,
+            "force_mode": (force or profile),
+            "exact_call": EXACT_CALL,
+        },
     )
     data_operation = review_manager.get_data_operation()
 
     if profile:
         data_operation.profile()
         return
     if reading_heuristics:
@@ -1698,16 +1920,21 @@
     - a commit-sha,
     - a commit tree,
     - '.' for the latest commit,
     - HEAD~4 for commit 4 before HEAD
     - a contributor name
     """
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+    review_manager = get_review_manager(
+        ctx,
+        {
+            "verbose_mode": verbose,
+            "force_mode": force,
+            "exact_call": EXACT_CALL,
+        },
     )
     validate_operation = review_manager.get_validate_operation()
 
     validation_details = validate_operation.main(
         scope=scope,
         filter_setting=filter,
         properties=properties,
@@ -1749,16 +1976,21 @@
     ctx: click.core.Context,
     id: str,  # pylint: disable=invalid-name
     verbose: bool,
     force: bool,
 ) -> None:
     """Trace a record"""
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+    review_manager = get_review_manager(
+        ctx,
+        {
+            "verbose_mode": verbose,
+            "force_mode": force,
+            "exact_call": EXACT_CALL,
+        },
     )
     trace_operation = review_manager.get_trace_operation()
     trace_operation.main(record_id=id)
 
 
 def __select_target_repository(environment_registry: list) -> Path:
     while True:
@@ -1797,16 +2029,20 @@
 @click.pass_context
 @catch_exception(handle=(colrev_exceptions.CoLRevException))
 def distribute(ctx: click.core.Context, path: Path, verbose: bool, force: bool) -> None:
     """Distribute records to other local repositories"""
 
     if not path:
         path = Path.cwd()
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=True, verbose_mode=verbose
+    review_manager = get_review_manager(
+        ctx,
+        {
+            "verbose_mode": verbose,
+            "force_mode": force,
+        },
     )
     distribute_operation = review_manager.get_distribute_operation()
     environment_registry = distribute_operation.get_environment_registry()
 
     target = __select_target_repository(environment_registry=environment_registry)
     # Note : add a "distribution mode" option?
     # (whole file -> add as source/load vs. records individually like a prescreen)
@@ -1883,15 +2119,14 @@
     + "(e.g., a curated metadata repository)",
 )
 @click.option("--pull", is_flag=True, default=False, help="Pull curated metadata")
 @click.option(
     "-s", "--status", is_flag=True, default=False, help="Print environment status"
 )
 @click.option("--start", is_flag=True, default=False, help="Start environment services")
-@click.option("--stop", is_flag=True, default=False, help="Stop environment services")
 @click.option(
     "-r",
     "--register",
     is_flag=True,
     default=False,
     help="Register a repository in the CoLRev environment",
 )
@@ -1925,29 +2160,28 @@
 def env(
     ctx: click.core.Context,
     index: bool,
     install: str,
     pull: bool,
     status: bool,
     start: bool,
-    stop: bool,
     register: bool,
     unregister: bool,
     update_package_list: bool,
     verbose: bool,
     force: bool,
 ) -> None:
     """Manage the environment"""
 
-    # pylint: disable=too-many-return-statements
-    # pylint: disable=too-many-branches
-    # pylint: disable=too-many-locals
-
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=True, verbose_mode=verbose
+    review_manager = get_review_manager(
+        ctx,
+        {
+            "verbose_mode": verbose,
+            "force_mode": True,
+        },
     )
 
     if install:
         env_resources = review_manager.get_resources()
         if env_resources.install_curated_resource(curated_resource=install):
             print("Successfully installed curated resource.")
             print("To make it available to other projects, run")
@@ -1956,32 +2190,32 @@
 
     if pull:
         environment_manager = review_manager.get_environment_manager()
         for curated_resource in environment_manager.local_repos():
             curated_resource_path = curated_resource["source_url"]
             if "/curated_metadata/" not in curated_resource_path:
                 continue
-            review_manager = colrev.review_manager.ReviewManager(
-                force_mode=force,
-                verbose_mode=verbose,
-                path_str=curated_resource_path,
+
+            review_manager = get_review_manager(
+                ctx,
+                {
+                    "verbose_mode": verbose,
+                    "force_mode": force,
+                    "path_str": curated_resource_path,
+                },
             )
+
             review_manager.dataset.pull_if_repo_clean()
             print(f"Pulled {curated_resource_path}")
         return
 
     if status:
         __print_environment_status(review_manager)
         return
 
-    if stop:
-        environment_manager = review_manager.get_environment_manager()
-        environment_manager.stop_docker_services()
-        return
-
     if register:
         environment_manager = review_manager.get_environment_manager()
         environment_manager.register_repo(path_to_register=Path.cwd())
         return
 
     if unregister is not None:
         environment_manager = review_manager.get_environment_manager()
@@ -2007,25 +2241,22 @@
             "The following process instantiates objects listed in the "
             + "colrev/template/package_endpoints.json "
             + "(including ones that may not be secure).\n"
             + "Please confirm (y) to proceed."
         ):
             return
 
-        # pylint: disable=import-outside-toplevel
-        import colrev.env.package_manager as p_manager
-
-        package_manager = p_manager.PackageManager()
+        package_manager = colrev.env.package_manager.PackageManager()
         package_manager.update_package_list()
 
     local_index = review_manager.get_local_index()
 
     if index:
         local_index.index()
-
+        local_index.load_journal_rankings()
     elif start:
         print("Started.")
 
 
 @main.command(help_priority=21)
 # @click.option("-v", "--view", is_flag=True, default=False)
 @click.option(
@@ -2068,28 +2299,26 @@
     update_global: str,
     modify: str,
     verbose: bool,
     force: bool,
 ) -> None:
     """Settings of the CoLRev project"""
 
-    # pylint: disable=import-outside-toplevel
     # pylint: disable=reimported
-    # pylint: disable=too-many-locals
 
     from subprocess import check_call  # nosec
     from subprocess import DEVNULL  # nosec
     from subprocess import STDOUT  # nosec
     import json
     import ast
     import glom
-    import colrev.review_manager
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+    review_manager = get_review_manager(
+        ctx,
+        {"verbose_mode": verbose, "force_mode": force},
     )
     if update_hooks:
         print("Update pre-commit hooks")
 
         if review_manager.dataset.has_changes():
             print("Clean repo required. Commit or stash changes.")
             return
@@ -2157,14 +2386,19 @@
     "-a",
     "--add_hook",
     is_flag=True,
     default=False,
     help="Add a sync pre-commit hook",
 )
 @click.option(
+    "-src",
+    type=click.Path(exists=True),
+    help="Sync selected citations from source file.",
+)
+@click.option(
     "-v",
     "--verbose",
     is_flag=True,
     default=False,
     help="Verbose: printing more infos",
 )
 @click.option(
@@ -2174,14 +2408,15 @@
     default=False,
     help="Force mode",
 )
 @click.pass_context
 def sync(
     ctx: click.core.Context,
     add_hook: bool,
+    src: Path,
     verbose: bool,
     force: bool,
 ) -> None:
     """Sync records from CoLRev environment to non-CoLRev repo"""
 
     if add_hook:
         if not Path(".git").is_dir():
@@ -2208,14 +2443,19 @@
         entry: colrev-hooks-update
         language: python
         stages: [commit]
         files: 'records.bib|paper.md'"""
             )
         print("Added pre-commit hook for colrev sync.")
         return
+    if src:
+        sync_operation = colrev.review_manager.ReviewManager.get_sync_operation()
+        sync_operation.get_cited_papers_from_source(src=Path(src))
+        sync_operation.add_to_bib()
+        return
 
     sync_operation = colrev.review_manager.ReviewManager.get_sync_operation()
     sync_operation.get_cited_papers()
 
     if len(sync_operation.non_unique_for_import) > 0:
         print("Non-unique keys to resolve:")
         # Resolve non-unique cases
@@ -2265,16 +2505,17 @@
 def pull(
     ctx: click.core.Context,
     verbose: bool,
     force: bool,
 ) -> None:
     """Pull CoLRev project remote and record updates"""
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+    review_manager = get_review_manager(
+        ctx,
+        {"verbose_mode": verbose, "force_mode": force},
     )
     pull_operation = review_manager.get_pull_operation()
 
     pull_operation.main()
 
 
 @main.command(help_priority=24)
@@ -2352,16 +2593,17 @@
     project_only: bool,
     all: bool,
     verbose: bool,
     force: bool,
 ) -> None:
     """Push CoLRev project remote and record updates"""
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+    review_manager = get_review_manager(
+        ctx,
+        {"verbose_mode": verbose, "force_mode": force},
     )
     push_operation = review_manager.get_push_operation()
 
     push_operation.main(
         records_only=records_only, project_only=project_only, all_records=all
     )
 
@@ -2386,16 +2628,17 @@
     ctx: click.core.Context,
     verbose: bool,
     force: bool,
 ) -> None:
     """Service for real-time reviews"""
 
     try:
-        review_manager = colrev.review_manager.ReviewManager(
-            force_mode=force, verbose_mode=verbose, exact_call=EXACT_CALL
+        review_manager = get_review_manager(
+            ctx,
+            {"verbose_mode": verbose, "force_mode": force},
         )
         review_manager.get_service_operation()
 
     except KeyboardInterrupt:
         print("\nPressed ctrl-c. Shutting down service")
 
     if review_manager.dataset.has_changes():
@@ -2431,26 +2674,25 @@
     ctx: click.core.Context,
     keyword: str,
     verbose: bool,
     force: bool,
     callback=__validate_show,
 ) -> None:
     """Show aspects (sample, ...)"""
-    # pylint: disable=too-many-locals
 
-    # pylint: disable=import-outside-toplevel
     import colrev.operation
     import colrev.ui_cli.show_printer
 
     if keyword == "venv":
         colrev.ui_cli.show_printer.print_venv_notes()
         return
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose
+    review_manager = get_review_manager(
+        ctx,
+        {"verbose_mode": verbose, "force_mode": force},
     )
 
     if keyword == "sample":
         colrev.ui_cli.show_printer.print_sample(review_manager=review_manager)
 
     elif keyword == "settings":
         print(f"Settings:\n{review_manager.settings}")
@@ -2523,15 +2765,15 @@
 # def web(
 #     ctx: click.core.Context,
 #     verbose: bool,
 #     force: bool,
 # ) -> None:
 #     """CoLRev web interface."""
 
-#     # pylint: disable=import-outside-toplevel
+#
 #     import colrev.ui_web.settings_editor
 
 #     review_manager = colrev.review_manager.ReviewManager(
 #         force_mode=force, verbose_mode=verbose
 #     )
 #     se_instance = colrev.ui_web.settings_editor.SettingsEditor(
 #         review_manager=review_manager
@@ -2604,16 +2846,17 @@
 def repare(
     ctx: click.core.Context,
     verbose: bool,
     force: bool,
 ) -> None:
     """Repare file formatting errors in the CoLRev project."""
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=True, verbose_mode=verbose
+    review_manager = get_review_manager(
+        ctx,
+        {"verbose_mode": verbose, "force_mode": force},
     )
     repare_operation = review_manager.get_repare()
     repare_operation.main()
 
 
 @main.command(help_priority=31)
 @click.option(
@@ -2640,16 +2883,17 @@
     ctx: click.core.Context,
     ids: str,
     verbose: bool,
     force: bool,
 ) -> None:
     """Remove records, ... from CoLRev repositories"""
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose
+    review_manager = get_review_manager(
+        ctx,
+        {"verbose_mode": verbose, "force_mode": force},
     )
 
     remove_operation = review_manager.get_remove_operation()
 
     if ids:
         remove_operation.remove_records(ids=ids)
 
@@ -2705,16 +2949,17 @@
     ctx: click.core.Context,
     branch: str,
     verbose: bool,
     force: bool,
 ) -> None:
     """Merge git branches."""
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose
+    review_manager = get_review_manager(
+        ctx,
+        {"verbose_mode": verbose, "force_mode": force},
     )
 
     if not branch:
         colrev.operation.CheckOperation(review_manager=review_manager)
         git_repo = review_manager.dataset.get_repo()
         print(f"possible branches: {','.join([b.name for b in git_repo.heads])}")
         return
@@ -2744,16 +2989,17 @@
     ctx: click.core.Context,
     selection: str,
     verbose: bool,
     force: bool,
 ) -> None:
     """Undo operations."""
 
-    review_manager = colrev.review_manager.ReviewManager(
-        force_mode=force, verbose_mode=verbose
+    review_manager = get_review_manager(
+        ctx,
+        {"verbose_mode": verbose, "force_mode": force},
     )
 
     if selection == "commit":
         colrev.operation.CheckOperation(review_manager=review_manager)
         git_repo = review_manager.dataset.get_repo()
         git_repo.git.reset("--hard", "HEAD~1")
 
@@ -2761,15 +3007,14 @@
 @main.command(help_priority=35)
 @click.pass_context
 def version(
     ctx: click.core.Context,
 ) -> None:
     """Show colrev version."""
 
-    # pylint: disable=import-outside-toplevel
     from importlib.metadata import version
 
     print(f'colrev version {version("colrev")}')
 
 
 @main.command(hidden=True)
 @click.option(
@@ -2810,7 +3055,10 @@
         if case_insensitive
         else {}
     )
     shell, path = click_completion.core.install(  # nosec
         shell=shell, path=path, append=append, extra_env=extra_env
     )
     click.echo(f"{shell} completion installed in {path}")
+
+
+# register_repl(main)
```

### Comparing `colrev-0.9.0/colrev/ui_cli/cli_status_printer.py` & `colrev-0.9.2/colrev/ui_cli/cli_status_printer.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ui_cli/cli_validation.py` & `colrev-0.9.2/colrev/ui_cli/cli_validation.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ui_cli/dedupe_errors.py` & `colrev-0.9.2/colrev/ui_cli/dedupe_errors.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/colrev/ui_cli/show_printer.py` & `colrev-0.9.2/colrev/ui_cli/show_printer.py`

 * *Files identical despite different names*

### Comparing `colrev-0.9.0/pyproject.toml` & `colrev-0.9.2/pyproject.toml`

 * *Files 5% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [tool.poetry]
 name = "colrev"
-version = "0.9.0"
+version = "0.9.2"
 description = "CoLRev: An open-source environment for collaborative reviews"
 authors = ["Gerit Wagner <gerit.wagner@hec.ca>", "Julian Prester <julian.prester@sydney.edu.au>"]
 license = "MIT"
 readme = "README.md"
 homepage="https://colrev.readthedocs.io/en/latest/"
 repository = "https://github.com/CoLRev-Environment/colrev"
 documentation = "https://colrev.readthedocs.io/en/latest/"
@@ -68,17 +68,21 @@
 dataclasses-jsonschema = "^2.15.3"
 watchdog = "^2.2.1"
 openpyxl = "^3.1.2"
 pylint = "^2.17.2"
 pymupdf = "^1.22.0"
 imagehash = "^4.3.1"
 defusedxml = "^0.7.1"
-asreview = "^1.2"
 requests-mock = "^1.10.0"
+dash = "^2.11.1"
 levenshtein = "^0.21.0" # faster implementation of levenshtein distance (for thefuzz)
+pyalex = "^0.10"
+rispy = "^0.7.1"
+colrev-asreview = "^0.1.0"
+click-repl = "^0.3.0"
 
 [tool.poetry.group.docs.dependencies]
 Sphinx = "^5.2.3"
 sphinx-autodoc-typehints = "^1.19.4"
 sphinx-click = "^4.3.0"
 sphinx-rtd-theme = "^1.1.1"
 "sphinxcontrib.datatemplates" = "^0.9.2"
@@ -89,9 +93,10 @@
 pytest = "^7.2.1"
 coverage = "^6.5.0"
 types-click = "^7.1.8"
 pytest-mock = "^3.10.0"
 requests-mock = "^1.10.0"
 
 [build-system]
-requires = ["poetry>=1.2.0b1"]
+# requires = ["poetry>=1.2.0b1"]
+requires = ["poetry-core>=1.0.0"]
 build-backend = "poetry.core.masonry.api"
```

### Comparing `colrev-0.9.0/PKG-INFO` & `colrev-0.9.2/PKG-INFO`

 * *Files 22% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: colrev
-Version: 0.9.0
+Version: 0.9.2
 Summary: CoLRev: An open-source environment for collaborative reviews
 Home-page: https://colrev.readthedocs.io/en/latest/
 License: MIT
 Keywords: research,reproducible research,open science,literature,literature review,systematic review,systematic literature review
 Author: Gerit Wagner
 Author-email: gerit.wagner@hec.ca
 Requires-Python: >=3.8,<4
@@ -20,21 +20,23 @@
 Classifier: Topic :: Scientific/Engineering
 Classifier: Typing :: Typed
 Requires-Dist: GitPython (>=3.1.29,<4.0.0)
 Requires-Dist: Jinja2 (>=3.1.2,<4.0.0)
 Requires-Dist: PyPDF2 (>=1.28.6,<2.0.0)
 Requires-Dist: PyYAML (>=6.0.0,<7.0.0)
 Requires-Dist: alphabet-detector (>=0.0.7,<0.0.8)
-Requires-Dist: asreview (>=1.2,<2.0)
 Requires-Dist: beautifulsoup4 (>=4.11.1,<5.0.0)
+Requires-Dist: click-repl (>=0.3.0,<0.4.0)
 Requires-Dist: click8 (>=8.0.1,<9.0.0)
 Requires-Dist: click_completion (>=0.5.2,<0.6.0)
+Requires-Dist: colrev-asreview (>=0.1.0,<0.2.0)
 Requires-Dist: crossrefapi (>=1.5.0,<2.0.0)
 Requires-Dist: dacite (>=1.6.0,<2.0.0)
 Requires-Dist: daff (>=1.3.46,<2.0.0)
+Requires-Dist: dash (>=2.11.1,<3.0.0)
 Requires-Dist: dataclasses-jsonschema (>=2.15.3,<3.0.0)
 Requires-Dist: dedupe (>=2.0.20,<3.0.0)
 Requires-Dist: defusedxml (>=0.7.1,<0.8.0)
 Requires-Dist: dictdiffer (>=0.9.0,<0.10.0)
 Requires-Dist: docker (==6.0.0)
 Requires-Dist: glom (>=22.1.0,<23.0.0)
 Requires-Dist: imagehash (>=4.3.1,<5.0.0)
@@ -44,21 +46,23 @@
 Requires-Dist: nameparser (>=1.1.2,<2.0.0)
 Requires-Dist: openpyxl (>=3.1.2,<4.0.0)
 Requires-Dist: pandas (>=1.5.0,<2.0.0)
 Requires-Dist: pandasql (>=0.7.3,<0.8.0)
 Requires-Dist: pdfminer.six (>=20220524,<20220525)
 Requires-Dist: pre-commit (>=2.20.0,<3.0.0)
 Requires-Dist: psutil (>=5.9.2,<6.0.0)
+Requires-Dist: pyalex (>=0.10,<0.11)
 Requires-Dist: pybtex (>=0.24.0,<0.25.0)
 Requires-Dist: pycountry (>=22.3.5,<23.0.0)
 Requires-Dist: pylint (>=2.17.2,<3.0.0)
 Requires-Dist: pymupdf (>=1.22.0,<2.0.0)
 Requires-Dist: requests (>=2.28.1,<3.0.0)
 Requires-Dist: requests-cache (>=0.9.6,<0.10.0)
 Requires-Dist: requests-mock (>=1.10.0,<2.0.0)
+Requires-Dist: rispy (>=0.7.1,<0.8.0)
 Requires-Dist: thefuzz (>=0.19.0,<0.20.0)
 Requires-Dist: tqdm (>=4.64.1,<5.0.0)
 Requires-Dist: transitions (>=0.8.11,<0.9.0)
 Requires-Dist: watchdog (>=2.2.1,<3.0.0)
 Requires-Dist: zope.interface (>=5.5.0,<6.0.0)
 Project-URL: Documentation, https://colrev.readthedocs.io/en/latest/
 Project-URL: Repository, https://github.com/CoLRev-Environment/colrev
@@ -82,17 +86,15 @@
 [![pre-commit.ci status](https://results.pre-commit.ci/badge/github/CoLRev-Ecosystem/colrev/main.svg)](https://results.pre-commit.ci/latest/github/CoLRev-Ecosystem/colrev/main)
 ![Coverage](https://raw.githubusercontent.com/CoLRev-Ecosystem/colrev/main/tests/coverage.svg)
 [![Codacy Badge](https://app.codacy.com/project/badge/Grade/bd4e44c6cda646e4b9e494c4c4d9487b)](https://app.codacy.com/gh/CoLRev-Environment/colrev/dashboard?utm_source=gh&utm_medium=referral&utm_content=&utm_campaign=Badge_grade)
 ![GitHub last commit](https://img.shields.io/github/last-commit/CoLRev-Ecosystem/colrev)
 [![Downloads](https://static.pepy.tech/badge/colrev/month)](https://pepy.tech/project/colrev)
 [![OpenSSF Best Practices](https://bestpractices.coreinfrastructure.org/projects/7148/badge)](https://bestpractices.coreinfrastructure.org/projects/7148)
 [![SWH](https://archive.softwareheritage.org/badge/origin/https://github.com/CoLRev-Environment/colrev/)](https://archive.softwareheritage.org/browse/origin/?origin_url=https://github.com/CoLRev-Environment/colrev/)<!-- ALL-CONTRIBUTORS-BADGE:START - Do not remove or modify this section -->
-[![All Contributors](https://img.shields.io/badge/all_contributors-4-orange.svg?style=flat-square)](#contributors-)
-[![Average time to resolve an issue](http://isitmaintained.com/badge/resolution/CoLRev-Environment/colrev.svg)](https://isitmaintained.com/project/CoLRev-Environment/colrev)
-[![Percentage of issues still open](http://isitmaintained.com/badge/open/CoLRev-Environment/colrev.svg)](https://isitmaintained.com/project/CoLRev-Environment/colrev)
+[![All Contributors](https://img.shields.io/badge/all_contributors-16-orange.svg?style=flat-square)](#contributors-)
 <!-- ALL-CONTRIBUTORS-BADGE:END -->
 <!-- ![PyPI](https://img.shields.io/pypi/v/colrev) -->
 <!-- [![](https://img.shields.io/badge/-documentation-green)](https://colrev.readthedocs.io/) -->
 
 </div>
 
 ## Summary
@@ -128,14 +130,30 @@
 <table>
   <tbody>
     <tr>
       <td align="center" valign="top" width="14.28%"><a href="https://github.com/geritwagner"><img src="https://avatars.githubusercontent.com/u/3872815?v=4?s=100" width="100px;" alt="Gerit Wagner"/><br /><sub><b>Gerit Wagner</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=geritwagner" title="Code">💻</a> <a href="https://github.com/CoLRev-Environment/colrev/commits?author=geritwagner" title="Documentation">📖</a> <a href="#data-geritwagner" title="Data">🔣</a> <a href="#content-geritwagner" title="Content">🖋</a> <a href="#example-geritwagner" title="Examples">💡</a></td>
       <td align="center" valign="top" width="14.28%"><a href="https://julianprester.com"><img src="https://avatars.githubusercontent.com/u/4706870?v=4?s=100" width="100px;" alt="Julian Prester"/><br /><sub><b>Julian Prester</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=julianprester" title="Code">💻</a> <a href="https://github.com/CoLRev-Environment/colrev/commits?author=julianprester" title="Documentation">📖</a> <a href="#data-julianprester" title="Data">🔣</a> <a href="#content-julianprester" title="Content">🖋</a> <a href="https://github.com/CoLRev-Environment/colrev/issues?q=author%3Ajulianprester" title="Bug reports">🐛</a> <a href="#ideas-julianprester" title="Ideas, Planning, & Feedback">🤔</a></td>
       <td align="center" valign="top" width="14.28%"><a href="https://github.com/tmahmood"><img src="https://avatars.githubusercontent.com/u/34904?v=4?s=100" width="100px;" alt="Tarin Mahmood"/><br /><sub><b>Tarin Mahmood</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=tmahmood" title="Code">💻</a> <a href="https://github.com/CoLRev-Environment/colrev/commits?author=tmahmood" title="Tests">⚠️</a> <a href="https://github.com/CoLRev-Environment/colrev/commits?author=tmahmood" title="Documentation">📖</a></td>
       <td align="center" valign="top" width="14.28%"><a href="https://github.com/dengdenglele"><img src="https://avatars.githubusercontent.com/u/28404427?v=4?s=100" width="100px;" alt="dengdenglele"/><br /><sub><b>dengdenglele</b></sub></a><br /><a href="#data-dengdenglele" title="Data">🔣</a> <a href="https://github.com/CoLRev-Environment/colrev/commits?author=dengdenglele" title="Documentation">📖</a> <a href="https://github.com/CoLRev-Environment/colrev/commits?author=dengdenglele" title="Tests">⚠️</a></td>
+      <td align="center" valign="top" width="14.28%"><a href="https://github.com/mhlbrsimon"><img src="https://avatars.githubusercontent.com/u/83401831?v=4?s=100" width="100px;" alt="mhlbrsimon"/><br /><sub><b>mhlbrsimon</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=mhlbrsimon" title="Code">💻</a></td>
+      <td align="center" valign="top" width="14.28%"><a href="https://github.com/ossendorfluca"><img src="https://avatars.githubusercontent.com/u/112037612?v=4?s=100" width="100px;" alt="ossendorfluca"/><br /><sub><b>ossendorfluca</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=ossendorfluca" title="Code">💻</a></td>
+      <td align="center" valign="top" width="14.28%"><a href="https://github.com/katharinaernst"><img src="https://avatars.githubusercontent.com/u/131549085?v=4?s=100" width="100px;" alt="katharinaernst"/><br /><sub><b>katharinaernst</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=katharinaernst" title="Code">💻</a></td>
+    </tr>
+    <tr>
+      <td align="center" valign="top" width="14.28%"><a href="https://github.com/einfachjessi"><img src="https://avatars.githubusercontent.com/u/131001755?v=4?s=100" width="100px;" alt="einfachjessi"/><br /><sub><b>einfachjessi</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=einfachjessi" title="Code">💻</a></td>
+      <td align="center" valign="top" width="14.28%"><a href="https://github.com/Janus678"><img src="https://avatars.githubusercontent.com/u/131582517?v=4?s=100" width="100px;" alt="Janus678"/><br /><sub><b>Janus678</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=Janus678" title="Code">💻</a></td>
+      <td align="center" valign="top" width="14.28%"><a href="https://github.com/frxdericz"><img src="https://avatars.githubusercontent.com/u/131789939?v=4?s=100" width="100px;" alt="frxdericz"/><br /><sub><b>frxdericz</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=frxdericz" title="Code">💻</a></td>
+      <td align="center" valign="top" width="14.28%"><a href="https://github.com/MalouSchmidt"><img src="https://avatars.githubusercontent.com/u/131263679?v=4?s=100" width="100px;" alt="MalouSchmidt"/><br /><sub><b>MalouSchmidt</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=MalouSchmidt" title="Code">💻</a></td>
+      <td align="center" valign="top" width="14.28%"><a href="https://github.com/RheaDoesStuff"><img src="https://avatars.githubusercontent.com/u/74066245?v=4?s=100" width="100px;" alt="RheaDoesStuff"/><br /><sub><b>RheaDoesStuff</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=RheaDoesStuff" title="Code">💻</a></td>
+      <td align="center" valign="top" width="14.28%"><a href="https://github.com/Cohen2000"><img src="https://avatars.githubusercontent.com/u/113113352?v=4?s=100" width="100px;" alt="Cohen2000"/><br /><sub><b>Cohen2000</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=Cohen2000" title="Code">💻</a></td>
+      <td align="center" valign="top" width="14.28%"><a href="https://github.com/RobertAhr"><img src="https://avatars.githubusercontent.com/u/131687952?v=4?s=100" width="100px;" alt="RobertAhr"/><br /><sub><b>RobertAhr</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=RobertAhr" title="Code">💻</a></td>
+    </tr>
+    <tr>
+      <td align="center" valign="top" width="14.28%"><a href="https://github.com/ThomasFleischmann"><img src="https://avatars.githubusercontent.com/u/131684139?v=4?s=100" width="100px;" alt="ThomasFleischmann"/><br /><sub><b>ThomasFleischmann</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=ThomasFleischmann" title="Code">💻</a></td>
+      <td align="center" valign="top" width="14.28%"><a href="https://github.com/AntonFrisch"><img src="https://avatars.githubusercontent.com/u/131719653?v=4?s=100" width="100px;" alt="AntonFrisch"/><br /><sub><b>AntonFrisch</b></sub></a><br /><a href="https://github.com/CoLRev-Environment/colrev/commits?author=AntonFrisch" title="Code">💻</a></td>
     </tr>
   </tbody>
 </table>
 
 <!-- markdownlint-restore -->
 <!-- prettier-ignore-end -->
```

