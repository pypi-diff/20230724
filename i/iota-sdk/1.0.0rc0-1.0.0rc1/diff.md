# Comparing `tmp/iota_sdk-1.0.0rc0-cp39-none-win_amd64.whl.zip` & `tmp/iota_sdk-1.0.0rc1-cp39-none-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,38 +1,48 @@
-Zip file size: 7409854 bytes, number of entries: 36
--rw-r--r--  4.6 unx     3512 b- defN 23-Jul-11 14:11 iota_sdk-1.0.0rc0.dist-info/METADATA
--rw-r--r--  4.6 unx       94 b- defN 23-Jul-11 14:11 iota_sdk-1.0.0rc0.dist-info/WHEEL
--rw-r--r--  4.6 unx    20184 b- defN 23-Jul-11 14:11 iota_sdk/client/client.py
--rw-r--r--  4.6 unx     6975 b- defN 23-Jul-11 14:11 iota_sdk/client/_high_level_api.py
--rw-r--r--  4.6 unx     6114 b- defN 23-Jul-11 14:11 iota_sdk/client/_node_core_api.py
--rw-r--r--  4.6 unx     4036 b- defN 23-Jul-11 14:11 iota_sdk/client/_node_indexer_api.py
--rw-r--r--  4.6 unx     1768 b- defN 23-Jul-11 14:11 iota_sdk/client/_utils.py
--rw-r--r--  4.6 unx      323 b- defN 23-Jul-11 14:11 iota_sdk/prefix_hex.py
--rw-r--r--  4.6 unx     8385 b- defN 23-Jul-11 14:11 iota_sdk/secret_manager/secret_manager.py
--rw-r--r--  4.6 unx     1494 b- defN 23-Jul-11 14:11 iota_sdk/types/address.py
--rw-r--r--  4.6 unx     1425 b- defN 23-Jul-11 14:11 iota_sdk/types/balance.py
--rw-r--r--  4.6 unx     2153 b- defN 23-Jul-11 14:11 iota_sdk/types/block.py
--rw-r--r--  4.6 unx     2006 b- defN 23-Jul-11 14:11 iota_sdk/types/burn.py
--rw-r--r--  4.6 unx     2190 b- defN 23-Jul-11 14:11 iota_sdk/types/common.py
--rw-r--r--  4.6 unx      303 b- defN 23-Jul-11 14:11 iota_sdk/types/event.py
--rw-r--r--  4.6 unx     2579 b- defN 23-Jul-11 14:11 iota_sdk/types/feature.py
--rw-r--r--  4.6 unx      224 b- defN 23-Jul-11 14:11 iota_sdk/types/native_token.py
--rw-r--r--  4.6 unx     2081 b- defN 23-Jul-11 14:11 iota_sdk/types/node_info.py
--rw-r--r--  4.6 unx     3142 b- defN 23-Jul-11 14:11 iota_sdk/types/output.py
--rw-r--r--  4.6 unx      553 b- defN 23-Jul-11 14:11 iota_sdk/types/output_data.py
--rw-r--r--  4.6 unx     1700 b- defN 23-Jul-11 14:11 iota_sdk/types/output_id.py
--rw-r--r--  4.6 unx     2566 b- defN 23-Jul-11 14:11 iota_sdk/types/payload.py
--rw-r--r--  4.6 unx      256 b- defN 23-Jul-11 14:11 iota_sdk/types/signature.py
--rw-r--r--  4.6 unx      760 b- defN 23-Jul-11 14:11 iota_sdk/types/token_scheme.py
--rw-r--r--  4.6 unx     1115 b- defN 23-Jul-11 14:11 iota_sdk/types/transaction.py
--rw-r--r--  4.6 unx     1858 b- defN 23-Jul-11 14:11 iota_sdk/types/transaction_options.py
--rw-r--r--  4.6 unx     3701 b- defN 23-Jul-11 14:11 iota_sdk/types/unlock_condition.py
--rw-r--r--  4.6 unx     7063 b- defN 23-Jul-11 14:11 iota_sdk/utils.py
--rw-r--r--  4.6 unx    17168 b- defN 23-Jul-11 14:11 iota_sdk/wallet/account.py
--rw-r--r--  4.6 unx     2514 b- defN 23-Jul-11 14:11 iota_sdk/wallet/common.py
--rw-r--r--  4.6 unx     2403 b- defN 23-Jul-11 14:11 iota_sdk/wallet/prepared_transaction_data.py
--rw-r--r--  4.6 unx     3010 b- defN 23-Jul-11 14:11 iota_sdk/wallet/sync_options.py
--rw-r--r--  4.6 unx     8695 b- defN 23-Jul-11 14:11 iota_sdk/wallet/wallet.py
--rw-r--r--  4.6 unx     1075 b- defN 23-Jul-11 14:11 iota_sdk/__init__.py
--rwxr-xr-x  4.6 unx 17735680 b- defN 23-Jul-11 14:11 iota_sdk/iota_sdk.cp39-win_amd64.pyd
--rw-r--r--  4.6 unx     3025 b- defN 23-Jul-11 14:11 iota_sdk-1.0.0rc0.dist-info/RECORD
-36 files, 17862130 bytes uncompressed, 7405038 bytes compressed:  58.5%
+Zip file size: 10232524 bytes, number of entries: 46
+-rw-r--r--  4.6 unx     4607 b- defN 23-Jul-21 12:08 iota_sdk-1.0.0rc1.dist-info/METADATA
+-rw-r--r--  4.6 unx       94 b- defN 23-Jul-21 12:08 iota_sdk-1.0.0rc1.dist-info/WHEEL
+-rw-r--r--  4.6 unx    21934 b- defN 23-Jul-21 12:08 iota_sdk/client/client.py
+-rw-r--r--  4.6 unx     9727 b- defN 23-Jul-21 12:08 iota_sdk/client/_high_level_api.py
+-rw-r--r--  4.6 unx     8166 b- defN 23-Jul-21 12:08 iota_sdk/client/_node_core_api.py
+-rw-r--r--  4.6 unx     7956 b- defN 23-Jul-21 12:08 iota_sdk/client/_node_indexer_api.py
+-rw-r--r--  4.6 unx     2158 b- defN 23-Jul-21 12:08 iota_sdk/client/_utils.py
+-rw-r--r--  4.6 unx      445 b- defN 23-Jul-21 12:08 iota_sdk/prefix_hex.py
+-rw-r--r--  4.6 unx    10039 b- defN 23-Jul-21 12:08 iota_sdk/secret_manager/secret_manager.py
+-rw-r--r--  4.6 unx     1810 b- defN 23-Jul-21 12:08 iota_sdk/types/address.py
+-rw-r--r--  4.6 unx     2381 b- defN 23-Jul-21 12:08 iota_sdk/types/balance.py
+-rw-r--r--  4.6 unx     4577 b- defN 23-Jul-21 12:08 iota_sdk/types/block.py
+-rw-r--r--  4.6 unx     1097 b- defN 23-Jul-21 12:08 iota_sdk/types/block_builder_options.py
+-rw-r--r--  4.6 unx     2073 b- defN 23-Jul-21 12:08 iota_sdk/types/burn.py
+-rw-r--r--  4.6 unx     4211 b- defN 23-Jul-21 12:08 iota_sdk/types/client_options.py
+-rw-r--r--  4.6 unx     2428 b- defN 23-Jul-21 12:08 iota_sdk/types/common.py
+-rw-r--r--  4.6 unx      764 b- defN 23-Jul-21 12:08 iota_sdk/types/event.py
+-rw-r--r--  4.6 unx     2021 b- defN 23-Jul-21 12:08 iota_sdk/types/feature.py
+-rw-r--r--  4.6 unx      540 b- defN 23-Jul-21 12:08 iota_sdk/types/filter_options.py
+-rw-r--r--  4.6 unx      990 b- defN 23-Jul-21 12:08 iota_sdk/types/input.py
+-rw-r--r--  4.6 unx      378 b- defN 23-Jul-21 12:08 iota_sdk/types/native_token.py
+-rw-r--r--  4.6 unx      376 b- defN 23-Jul-21 12:08 iota_sdk/types/network_info.py
+-rw-r--r--  4.6 unx     4512 b- defN 23-Jul-21 12:08 iota_sdk/types/node_info.py
+-rw-r--r--  4.6 unx    10044 b- defN 23-Jul-21 12:08 iota_sdk/types/output.py
+-rw-r--r--  4.6 unx     1244 b- defN 23-Jul-21 12:08 iota_sdk/types/output_data.py
+-rw-r--r--  4.6 unx     2183 b- defN 23-Jul-21 12:08 iota_sdk/types/output_id.py
+-rw-r--r--  4.6 unx     1491 b- defN 23-Jul-21 12:08 iota_sdk/types/output_params.py
+-rw-r--r--  4.6 unx     4619 b- defN 23-Jul-21 12:08 iota_sdk/types/payload.py
+-rw-r--r--  4.6 unx     3714 b- defN 23-Jul-21 12:08 iota_sdk/types/send_params.py
+-rw-r--r--  4.6 unx      982 b- defN 23-Jul-21 12:08 iota_sdk/types/signature.py
+-rw-r--r--  4.6 unx     1209 b- defN 23-Jul-21 12:08 iota_sdk/types/token_scheme.py
+-rw-r--r--  4.6 unx     2027 b- defN 23-Jul-21 12:08 iota_sdk/types/transaction.py
+-rw-r--r--  4.6 unx     3438 b- defN 23-Jul-21 12:08 iota_sdk/types/transaction_data.py
+-rw-r--r--  4.6 unx     3076 b- defN 23-Jul-21 12:08 iota_sdk/types/transaction_options.py
+-rw-r--r--  4.6 unx     1807 b- defN 23-Jul-21 12:08 iota_sdk/types/unlock.py
+-rw-r--r--  4.6 unx     4382 b- defN 23-Jul-21 12:08 iota_sdk/types/unlock_condition.py
+-rw-r--r--  4.6 unx      455 b- defN 23-Jul-21 12:08 iota_sdk/types/utxo_changes.py
+-rw-r--r--  4.6 unx     7172 b- defN 23-Jul-21 12:08 iota_sdk/utils.py
+-rw-r--r--  4.6 unx    19398 b- defN 23-Jul-21 12:08 iota_sdk/wallet/account.py
+-rw-r--r--  4.6 unx     2537 b- defN 23-Jul-21 12:08 iota_sdk/wallet/common.py
+-rw-r--r--  4.6 unx     3337 b- defN 23-Jul-21 12:08 iota_sdk/wallet/prepared_transaction.py
+-rw-r--r--  4.6 unx     5589 b- defN 23-Jul-21 12:08 iota_sdk/wallet/sync_options.py
+-rw-r--r--  4.6 unx     9442 b- defN 23-Jul-21 12:08 iota_sdk/wallet/wallet.py
+-rw-r--r--  4.6 unx     1429 b- defN 23-Jul-21 12:08 iota_sdk/__init__.py
+-rwxr-xr-x  4.6 unx 27893760 b- defN 23-Jul-21 12:08 iota_sdk/iota_sdk.cp39-win_amd64.pyd
+-rw-r--r--  4.6 unx     3894 b- defN 23-Jul-21 12:08 iota_sdk-1.0.0rc1.dist-info/RECORD
+46 files, 28080513 bytes uncompressed, 10226350 bytes compressed:  63.6%
```

## zipnote {}

```diff
@@ -1,11 +1,11 @@
-Filename: iota_sdk-1.0.0rc0.dist-info/METADATA
+Filename: iota_sdk-1.0.0rc1.dist-info/METADATA
 Comment: 
 
-Filename: iota_sdk-1.0.0rc0.dist-info/WHEEL
+Filename: iota_sdk-1.0.0rc1.dist-info/WHEEL
 Comment: 
 
 Filename: iota_sdk/client/client.py
 Comment: 
 
 Filename: iota_sdk/client/_high_level_api.py
 Comment: 
@@ -30,80 +30,110 @@
 
 Filename: iota_sdk/types/balance.py
 Comment: 
 
 Filename: iota_sdk/types/block.py
 Comment: 
 
+Filename: iota_sdk/types/block_builder_options.py
+Comment: 
+
 Filename: iota_sdk/types/burn.py
 Comment: 
 
+Filename: iota_sdk/types/client_options.py
+Comment: 
+
 Filename: iota_sdk/types/common.py
 Comment: 
 
 Filename: iota_sdk/types/event.py
 Comment: 
 
 Filename: iota_sdk/types/feature.py
 Comment: 
 
+Filename: iota_sdk/types/filter_options.py
+Comment: 
+
+Filename: iota_sdk/types/input.py
+Comment: 
+
 Filename: iota_sdk/types/native_token.py
 Comment: 
 
+Filename: iota_sdk/types/network_info.py
+Comment: 
+
 Filename: iota_sdk/types/node_info.py
 Comment: 
 
 Filename: iota_sdk/types/output.py
 Comment: 
 
 Filename: iota_sdk/types/output_data.py
 Comment: 
 
 Filename: iota_sdk/types/output_id.py
 Comment: 
 
+Filename: iota_sdk/types/output_params.py
+Comment: 
+
 Filename: iota_sdk/types/payload.py
 Comment: 
 
+Filename: iota_sdk/types/send_params.py
+Comment: 
+
 Filename: iota_sdk/types/signature.py
 Comment: 
 
 Filename: iota_sdk/types/token_scheme.py
 Comment: 
 
 Filename: iota_sdk/types/transaction.py
 Comment: 
 
+Filename: iota_sdk/types/transaction_data.py
+Comment: 
+
 Filename: iota_sdk/types/transaction_options.py
 Comment: 
 
+Filename: iota_sdk/types/unlock.py
+Comment: 
+
 Filename: iota_sdk/types/unlock_condition.py
 Comment: 
 
+Filename: iota_sdk/types/utxo_changes.py
+Comment: 
+
 Filename: iota_sdk/utils.py
 Comment: 
 
 Filename: iota_sdk/wallet/account.py
 Comment: 
 
 Filename: iota_sdk/wallet/common.py
 Comment: 
 
-Filename: iota_sdk/wallet/prepared_transaction_data.py
+Filename: iota_sdk/wallet/prepared_transaction.py
 Comment: 
 
 Filename: iota_sdk/wallet/sync_options.py
 Comment: 
 
 Filename: iota_sdk/wallet/wallet.py
 Comment: 
 
 Filename: iota_sdk/__init__.py
 Comment: 
 
 Filename: iota_sdk/iota_sdk.cp39-win_amd64.pyd
 Comment: 
 
-Filename: iota_sdk-1.0.0rc0.dist-info/RECORD
+Filename: iota_sdk-1.0.0rc1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## iota_sdk/client/client.py

```diff
@@ -3,34 +3,44 @@
 
 import iota_sdk
 from iota_sdk import call_client_method, listen_mqtt
 from iota_sdk.client._node_core_api import NodeCoreAPI
 from iota_sdk.client._node_indexer_api import NodeIndexerAPI
 from iota_sdk.client._high_level_api import HighLevelAPI
 from iota_sdk.client._utils import ClientUtils
+from iota_sdk.secret_manager.secret_manager import LedgerNanoSecretManager, MnemonicSecretManager, StrongholdSecretManager, SeedSecretManager
 from iota_sdk.types.block import Block
-from iota_sdk.types.common import HexStr, Node
+from iota_sdk.types.common import HexStr, Node, AddressAndAmount
 from iota_sdk.types.feature import Feature
 from iota_sdk.types.native_token import NativeToken
+from iota_sdk.types.network_info import NetworkInfo
 from iota_sdk.types.output import Output
-from iota_sdk.types.token_scheme import TokenScheme
+from iota_sdk.types.payload import Payload, TransactionPayload
+from iota_sdk.types.token_scheme import SimpleTokenScheme
 from iota_sdk.types.unlock_condition import UnlockCondition
+from iota_sdk.types.transaction_data import PreparedTransactionData
 from json import dumps, loads
 import humps
 from datetime import timedelta
 from typing import Any, Dict, List, Optional
 from dacite import from_dict
 
 
 class ClientError(Exception):
-    """client error"""
+    """Represents a client error."""
     pass
 
 
 class Client(NodeCoreAPI, NodeIndexerAPI, HighLevelAPI, ClientUtils):
+    """Represents an IOTA client.
+
+    Attributes:
+        handle: The handle to the inner client object.
+    """
+
     def __init__(
         self,
         nodes: Optional[str | List[str]] = None,
         primary_node: Optional[str] = None,
         primary_pow_node: Optional[str] = None,
         permanode: Optional[str] = None,
         ignore_node_health: Optional[bool] = None,
@@ -45,70 +55,74 @@
         local_pow: Optional[bool] = None,
         fallback_to_local_pow: Optional[bool] = None,
         pow_worker_count: Optional[int] = None,
         client_handle=None
     ):
         """Initialize the IOTA Client.
 
-        Parameters
-        ----------
-        nodes : string or array of string
+        **Arguments**
+        nodes :
             A single Node URL or an array of URLs.
-        primary_node : string
+        primary_node :
             Node which will be tried first for all requests.
-        primary_pow_node : string
+        primary_pow_node :
             Node which will be tried first when using remote PoW, even before the primary_node.
-        permanode : string
+        permanode :
             Permanode URL.
-        ignore_node_health : bool
+        ignore_node_health :
             If the node health should be ignored.
-        api_timeout : datetime.timedelta
+        api_timeout :
             Timeout for API requests.
-        node_sync_interval : datetime.timedelta
+        node_sync_interval :
             Interval in which nodes will be checked for their sync status and the [NetworkInfo](crate::NetworkInfo) gets updated.
-        remote_pow_timeout : datetime.timedelta
+        remote_pow_timeout :
             Timeout when sending a block that requires remote proof of work.
-        tips_interval : int
+        tips_interval :
             Tips request interval during PoW in seconds.
-        quorum : bool
-            If node quorum is enabled. Will compare the responses from multiple nodes 
-            and only returns the response if `quorum_threshold`% of the nodes return the same one.
-        min_quorum_size : int
+        quorum :
+            If node quorum is enabled. Will compare the responses from multiple nodes and only returns the response if 'quorum_threshold'% of the nodes return the same one.
+        min_quorum_size :
             Minimum amount of nodes required for request when quorum is enabled.
-        quorum_threshold : int
+        quorum_threshold :
             % of nodes that have to return the same response so it gets accepted.
-        user_agent : string
+        user_agent :
             The User-Agent header for requests.
-        local_pow : bool
+        local_pow :
             Local proof of work.
-        fallback_to_local_pow : bool
+        fallback_to_local_pow :
             Fallback to local proof of work if the node doesn't support remote PoW.
-        pow_worker_count : int
+        pow_worker_count :
             The amount of threads to be used for proof of work.
+        client_handle :
+            An instance of a node client.
         """
         client_config = dict(locals())
         del client_config['self']
-        # Delete client_handle, because it's not needed here and can't be serialized
+        # Delete client_handle, because it's not needed here and can't be
+        # serialized.
         if "client_handle" in client_config:
             del client_config["client_handle"]
 
         if isinstance(nodes, list):
             nodes = [node.as_dict() if isinstance(node, Node)
                      else node for node in nodes]
         elif nodes:
             if isinstance(nodes, Node):
                 nodes = [nodes.as_dict()]
             else:
                 nodes = [nodes]
         client_config['nodes'] = nodes
 
-        client_config = {k: v for k, v in client_config.items() if v != None}
+        client_config = {
+            k: v for k,
+            v in client_config.items() if v is not None}
 
         def get_remaining_nano_seconds(duration: timedelta):
-            return (int(duration/timedelta(microseconds=1))-int(duration.total_seconds())*1_000_000)*1_000
+            return (int(duration / timedelta(microseconds=1)) -
+                    int(duration.total_seconds()) * 1_000_000) * 1_000
 
         if 'api_timeout' in client_config:
             client_config['api_timeout'] = {'secs': int(client_config['api_timeout'].total_seconds(
             )), 'nanos': get_remaining_nano_seconds(client_config['api_timeout'])}
         if 'node_sync_interval' in client_config:
             client_config['node_sync_interval'] = {'secs': int(client_config['node_sync_interval'].total_seconds(
             )), 'nanos': get_remaining_nano_seconds(client_config['node_sync_interval'])}
@@ -122,15 +136,15 @@
         # Create the message handler
         if client_handle is None:
             self.handle = iota_sdk.create_client(client_config_str)
         else:
             self.handle = client_handle
 
     def _call_method(self, name, data=None):
-        """Dumps json string and call call_client_method()
+        """Dumps json string and calls `call_client_method()`
         """
         message = {
             'name': name
         }
         if data:
             message['data'] = data
         message = dumps(message)
@@ -146,52 +160,46 @@
 
         if "payload" in json_response:
             return json_response['payload']
         else:
             return response
 
     def get_handle(self):
+        """Get the client handle.
+
+        Returns:
+            The inner client object.
+        """
         return self.handle
 
     def build_alias_output(self,
                            alias_id: HexStr,
                            unlock_conditions: List[UnlockCondition],
                            amount: Optional[int] = None,
                            native_tokens: Optional[List[NativeToken]] = None,
                            state_index: Optional[int] = None,
                            state_metadata: Optional[str] = None,
                            foundry_counter: Optional[int] = None,
                            features: Optional[List[Feature]] = None,
                            immutable_features: Optional[List[Feature]] = None):
         """Build an AliasOutput.
 
-        Parameters
-        ----------
-        alias_id : string
-            Hex encoded alias id
-        unlock_conditions : array of UnlockCondition
-            The unlock conditions for this output
-        amount : int
-            Amount of base token
-        native_tokens : array of NativeToken
-            The native token to add to the output
-        state_index : int
-            Index of the state
-        state_metadata : string
-            Hex encoded state metadata
-        foundry_counter : int
-            Counter of foundry outputs created
-        features : array of Feature
-            Features for this outputs
-        immutable_features : array of Feature
-            Immutable features
-
-        Returns
-        -------
-        Output as dict
+        Args:
+            alias_id: A unique ID for the new alias.
+            unlock_conditions: The unlock conditions for the new output.
+            amount: The amount of base coins in the new output.
+            native_tokens: Native tokens added to the new output.
+            state_index: A counter that must increase by 1 every time the alias is state transitioned.
+            state_metadata: Metadata that can only be changed by the state controller.
+            foundry_counter: A counter that denotes the number of foundries created by this alias account.
+            features: A list of features.
+            immutable_features: A list of immutable features.
+
+        Returns:
+            The alias output as dict.
         """
 
         unlock_conditions = [unlock_condition.as_dict()
                              for unlock_condition in unlock_conditions]
 
         if native_tokens:
             native_tokens = [native_token.as_dict()
@@ -221,28 +229,22 @@
     def build_basic_output(self,
                            unlock_conditions: List[UnlockCondition],
                            amount: Optional[int] = None,
                            native_tokens: Optional[List[NativeToken]] = None,
                            features: Optional[List[Feature]] = None):
         """Build a BasicOutput.
 
-        Parameters
-        ----------
-        unlock_conditions : array of UnlockCondition
-            The unlock conditions for this output
-        amount : int
-            Amount of base token
-        native_tokens : array of NativeToken
-            The native token to add to the output
-        features : array of Feature
-            Features for this outputs
-
-        Returns
-        -------
-        Output as dict
+        Args:
+            unlock_conditions: The unlock conditions for the new output.
+            amount: The amount of base coins in the new output.
+            native_tokens: Native tokens added to the new output.
+            features: Features that add utility to the output but do not impose unlocking conditions.
+
+        Returns:
+            The basic output as dict.
         """
 
         unlock_conditions = [unlock_condition.as_dict()
                              for unlock_condition in unlock_conditions]
 
         if native_tokens:
             native_tokens = [native_token.as_dict()
@@ -259,42 +261,33 @@
             'amount': amount,
             'nativeTokens': native_tokens,
             'features': features,
         }))
 
     def build_foundry_output(self,
                              serial_number: int,
-                             token_scheme: TokenScheme,
+                             token_scheme: SimpleTokenScheme,
                              unlock_conditions: List[UnlockCondition],
                              amount: Optional[int] = None,
                              native_tokens: Optional[List[NativeToken]] = None,
                              features: Optional[List[Feature]] = None,
                              immutable_features: Optional[List[Feature]] = None):
         """Build a FoundryOutput.
 
-        Parameters
-        ----------
-        serial_number : int
-            The serial number of the foundry
-        token_scheme : TokenScheme
-            The Token scheme. Currently only a simple scheme is supported
-        unlock_conditions : array of UnlockCondition
-            The unlock conditions for this output
-        amount : int
-            Amount of base token
-        native_tokens : array of NativeToken
-            The native token to add to the output
-        features : array of Feature
-            Features for this outputs
-        immutable_features : array of Feature
-            Immutable features
-
-        Returns
-        -------
-        Output as dict
+        Args:
+            serial_number: The serial number of the foundry with respect to the controlling alias.
+            token_scheme: Defines the supply control scheme of the tokens controlled by the foundry. Currently only a simple scheme is supported.
+            unlock_conditions: The unlock conditions for the new output.
+            amount: The amount of base coins in the new output.
+            native_tokens: Native tokens added to the new output.
+            features: Features that add utility to the output but do not impose unlocking conditions.
+            immutable_features: Features that add utility to the output but do not impose unlocking conditions. These features need to be kept in future transitions of the UTXO state machine.
+
+        Returns:
+            The foundry output as dict.
         """
 
         unlock_conditions = [unlock_condition.as_dict()
                              for unlock_condition in unlock_conditions]
 
         if native_tokens:
             native_tokens = [native_token.__dict__
@@ -324,39 +317,31 @@
                          unlock_conditions: List[UnlockCondition],
                          amount: Optional[int] = None,
                          native_tokens: Optional[List[NativeToken]] = None,
                          features: Optional[List[Feature]] = None,
                          immutable_features: Optional[List[Feature]] = None):
         """Build an NftOutput.
 
-        Parameters
-        ----------
-        nft_id : string
-            Hex encoded nft id
-        unlock_conditions : array of UnlockCondition
-            The unlock conditions for this output
-        amount : int
-            Amount of base token
-        native_tokens : array of NativeToken
-            The native tokens to add to the output
-        features : array of Feature
-            Features for this outputs
-        immutable_features : array of Feature
-            Immutable features
-
-        Returns
-        -------
-        Output as dict
+        Args:
+            nft_id: A unique ID for the new NFT.
+            unlock_conditions: The unlock conditions for the new output.
+            amount: The amount of base coins in the new output.
+            native_tokens: Native tokens added to the new output.
+            features: Features that add utility to the output but do not impose unlocking conditions.
+            immutable_features: Features that add utility to the output but do not impose unlocking conditions. These features need to be kept in future transitions of the UTXO state machine.
+
+        Returns:
+            The NFT output as dict.
         """
 
         unlock_conditions = [unlock_condition.as_dict()
                              for unlock_condition in unlock_conditions]
 
         if native_tokens:
-            native_tokens = [native_token.as_dict()
+            native_tokens = [native_token.__dict__
                              for native_token in native_tokens]
 
         if features:
             features = [feature.as_dict() for feature in features]
         if immutable_features:
             immutable_features = [immutable_feature.as_dict()
                                   for immutable_feature in immutable_features]
@@ -370,68 +355,59 @@
             'amount': amount,
             'nativeTokens': native_tokens,
             'features': features,
             'immutableFeatures': immutable_features
         }))
 
     def build_and_post_block(self,
-                             secret_manager=None,
+                             secret_manager: Optional[LedgerNanoSecretManager | MnemonicSecretManager |
+                                                      SeedSecretManager | StrongholdSecretManager] = None,
                              account_index: Optional[int] = None,
                              coin_type: Optional[int] = None,
                              custom_remainder_address: Optional[str] = None,
                              data: Optional[HexStr] = None,
                              initial_address_index: Optional[int] = None,
                              input_range_start: Optional[int] = None,
                              input_range_end: Optional[int] = None,
                              inputs: Optional[List[Dict[str, Any]]] = None,
-                             output: Optional[Dict[str, Any]] = None,
+                             output: Optional[AddressAndAmount] = None,
                              outputs: Optional[List[Any]] = None,
                              tag: Optional[HexStr] = None) -> List[HexStr | Block]:
         """Build and post a block.
 
-        Parameters
-        ----------
-        account_index : int
-            Account Index
-        coin_type : int
-            Coin type. The CoinType enum can be used
-        custom_remainder_address : string
-            Address to send the remainder funds to
-        data : str
-            Hex encoded data
-        initial_address_index : int
-            Initial address index
-        input_range_start : int
-            Start of the input range
-        input_range_end : int
-            End of the input range
-        inputs : Array of Inputs
-            Inputs to use
-        output : Any # TODO: https://github.com/iotaledger/iota-sdk/issues/129
-            Address and amount to send to
-        outputs : Array of Outputs
-            Outputs to use
-        tag : string
-            Hex encoded tag
-
-        Returns
-        -------
-        Block as dict
+        **Arguments**
+        account_index : The account index to issue the block with.
+        coin_type : The type of base coin.
+        custom_remainder_address : Address to send the remainder funds to.
+        data : Hex encoded data.
+        initial_address_index : Initial address index.
+        input_range_start : Start of the input range.
+        input_range_end : End of the input range.
+        inputs : Inputs to use.
+        output : Address and amount to send to.
+        outputs : Outputs to use.
+        tag : Hex encoded tag.
 
+        Returns:
+            The created block as dict.
         """
+
         options = dict(locals())
 
         del options['self']
         del options['secret_manager']
 
-        options = {k: v for k, v in options.items() if v != None}
+        options = {k: v for k, v in options.items() if v is not None}
 
         if 'output' in options:
             options['output'] = options.pop('output').as_dict()
 
+        if 'outputs' in options:
+            options['outputs'] = [v.as_dict() for v in options['outputs']]
+
         if 'coin_type' in options:
             options['coin_type'] = int(options.pop('coin_type'))
 
         is_start_set = 'input_range_start' in options
         is_end_set = 'input_range_end' in options
         if is_start_set or is_end_set:
             options['range'] = {}
@@ -450,18 +426,18 @@
         return result
 
     def get_node(self) -> Dict[str, Any]:
         """Get a node candidate from the healthy node pool.
         """
         return self._call_method('getNode')
 
-    def get_network_info(self) -> Dict[str, Any]:
+    def get_network_info(self) -> NetworkInfo:
         """Gets the network related information such as network_id and min_pow_score.
         """
-        return self._call_method('getNetworkInfo')
+        return from_dict(NetworkInfo, self._call_method('getNetworkInfo'))
 
     def get_network_id(self) -> int:
         """Gets the network id of the node we're connecting to.
         """
         return int(self._call_method('getNetworkId'))
 
     def get_bech32_hrp(self) -> str:
@@ -490,43 +466,68 @@
         return self._call_method('getFallbackToLocalPow')
 
     def unhealthy_nodes(self) -> List[Dict[str, Any]]:
         """Returns the unhealthy nodes.
         """
         return self._call_method('unhealthyNodes')
 
-    def prepare_transaction(self, secret_manager=None, options=None):
+    def prepare_transaction(self,
+                            secret_manager: Optional[LedgerNanoSecretManager | MnemonicSecretManager |
+                                                     SeedSecretManager | StrongholdSecretManager] = None,
+                            options=None):
         """Prepare a transaction for signing.
+
+        Args:
+            secret_manager: One of the supported secret managers.
+            options: the transaction options.
         """
-        return self._call_method('prepareTransaction', {
+        return from_dict(PreparedTransactionData, self._call_method('prepareTransaction', {
             'secretManager': secret_manager,
             'options': options
-        })
+        }))
 
-    def sign_transaction(self, secret_manager, prepared_transaction_data):
+    def sign_transaction(self, secret_manager: LedgerNanoSecretManager | MnemonicSecretManager | SeedSecretManager |
+                         StrongholdSecretManager, prepared_transaction_data: PreparedTransactionData) -> TransactionPayload:
         """Sign a transaction.
+
+        Args:
+            secret_manager: One of the supported secret managers.
+            prepared_transaction_data: a prepared transaction to sign.
         """
-        return self._call_method('signTransaction', {
+        return from_dict(TransactionPayload, self._call_method('signTransaction', {
             'secretManager': secret_manager,
             'preparedTransactionData': prepared_transaction_data
-        })
+        }))
 
-    def submit_payload(self, payload) -> List[HexStr | Block]:
+    def submit_payload(self, payload: Payload) -> List[HexStr | Block]:
         """Submit a payload in a block.
+
+        Args:
+            payload : The payload to submit.
+
+        Returns:
+            List of HexStr or Block.
         """
         result = self._call_method('postBlockPayload', {
-            'payload': payload
+            'payload': payload.as_dict()
         })
         result[1] = Block.from_dict(result[1])
         return result
 
     def listen_mqtt(self, topics: List[str], handler):
         """Listen to MQTT events.
+
+        Args:
+            topics: The topics to listen to.
+            handler: A callback function for MQTT events.
         """
         listen_mqtt(self.handle, topics, handler)
 
     def clear_mqtt_listeners(self, topics: List[str]):
         """Removes all listeners for the provided MQTT topics.
+
+        Args:
+            topics: The topics to stop listening to.
         """
         return self._call_method('clearListeners', {
             'topics': topics
         })
```

## iota_sdk/client/_high_level_api.py

```diff
@@ -8,155 +8,254 @@
 from iota_sdk.types.output_id import OutputId
 from iota_sdk.types.common import CoinType
 from typing import List, Optional
 from dacite import from_dict
 
 
 class Range:
+    """Represents a range of address indexes.
+
+    Attributes:
+        start: The start index of the address range.
+        end: The end index of the address range.
+    """
+
     def __init__(self, start: int, end: int):
         self.start = start
         self.end = end
 
 
 class GenerateAddressOptions():
-    def __init__(self,  internal: bool, ledgerNanoPrompt: bool):
+    """Options for generating an address.
+
+    Attributes:
+        internal: Whether to generate an internal address.
+        ledgerNanoPrompt: Whether to display the generated address on Ledger Nano devices.
+    """
+
+    def __init__(self, internal: bool, ledgerNanoPrompt: bool):
+        """Initialize GenerateAddressOptions.
+        """
         self.internal = internal
         self.ledgerNanoPrompt = ledgerNanoPrompt
 
 
 class GenerateAddressesOptions():
+    """Options for generating addresses.
+
+    Attributes:
+        coinType: The type of coin.
+        range: The range of addresses to generate.
+        bech32Hrp: The bech32 HRP (human readable part) to use.
+        accountIndex: An account index.
+        options: An instance of `GenerateAddressOptions`.
+    """
+
     def __init__(self, coinType: CoinType,
                  range: range,
                  bech32Hrp: str,
                  accountIndex: Optional[int] = None,
                  options: Optional[GenerateAddressOptions] = None):
+        """Initialize GenerateAddressesOptions.
+
+        Args:
+            coinType: The type of coin.
+            range: The range of addresses to generate.
+            bech32Hrp: The bech32 HRP (human readable part) to use.
+            accountIndex: An account index.
+            options: An instance of `GenerateAddressOptions`.
+        """
         self.coinType = coinType
         self.range = Range(range.start, range.stop)
         self.bech32Hrp = bech32Hrp
         self.accountIndex = accountIndex
         self.options = options
 
     def as_dict(self):
-        config = {k: v for k, v in self.__dict__.items() if v != None}
+        config = {k: v for k, v in self.__dict__.items() if v is not None}
 
         config["range"] = config["range"].__dict__
         if "options" in config:
             config["options"] = config["options"].__dict__
         return config
 
 
 class HighLevelAPI():
+    """High level API.
+    """
 
-    def get_outputs(self, output_ids: List[OutputId]) -> List[OutputWithMetadata]:
+    def get_outputs(
+            self, output_ids: List[OutputId]) -> List[OutputWithMetadata]:
         """Fetch OutputWithMetadata from provided OutputIds (requests are sent in parallel).
+
+        Args:
+            output_ids: A list of output ids.
+
+        Returns:
+            A list of corresponding `OutputWithMetadata` objects.
         """
         outputs = self._call_method('getOutputs', {
             'outputIds': list(map(lambda o: o.output_id, output_ids))
         })
         return [from_dict(OutputWithMetadata, o) for o in outputs]
 
-    def get_outputs_ignore_errors(self, output_ids: List[OutputId]) -> List[OutputWithMetadata]:
+    def get_outputs_ignore_errors(
+            self, output_ids: List[OutputId]) -> List[OutputWithMetadata]:
         """Try to get OutputWithMetadata from provided OutputIds.
-           Requests are sent in parallel and errors are ignored, can be useful for spent outputs.
+        Requests are sent in parallel and errors are ignored, can be useful for spent outputs.
+
+        Args:
+            output_ids: A list of output ids.
+
+        Returns:
+            A list of corresponding `OutputWithMetadata` objects.
         """
         outputs = self._call_method('getOutputsIgnoreErrors', {
             'outputIds': list(map(lambda o: o.output_id, output_ids))
         })
         return [from_dict(OutputWithMetadata, o) for o in outputs]
 
     def find_blocks(self, block_ids: List[HexStr]) -> List[Block]:
         """Find all blocks by provided block IDs.
+
+        Args:
+            block_ids: A list of block ids.
+
+        Returns:
+            A list of corresponding `Block`s.
         """
         blocks = self._call_method('findBlocks', {
             'blockIds': block_ids
         })
         return [Block.from_dict(block) for block in blocks]
 
     def retry(self, block_id: HexStr) -> List[HexStr | Block]:
         """Retries (promotes or reattaches) a block for provided block id. Block should only be
-           retried only if they are valid and haven't been confirmed for a while.
+        retried only if they are valid and haven't been confirmed for a while.
+
+        Args:
+            block_id: A block id.
+
+        Returns:
+            A list where the first element is the block id and the second one the block.
         """
         result = self._call_method('retry', {'blockId': block_id})
         result[1] = Block.from_dict(result[1])
         return result
 
-    def retry_until_included(self, block_id: HexStr, interval: Optional[int] = None, max_attempts: Optional[int] = None) -> List[List[HexStr | Block]]:
+    def retry_until_included(
+            self, block_id: HexStr, interval: Optional[int] = None, max_attempts: Optional[int] = None) -> List[List[HexStr | Block]]:
         """Retries (promotes or reattaches) a block for provided block id until it's included (referenced by a
-           milestone). Default interval is 5 seconds and max attempts is 40. Returns the included block at first
-           position and additional reattached blocks.
+        milestone). Default interval is 5 seconds and max attempts is 40. Returns the included block at first
+        position and additional reattached blocks.
+
+        Args:
+            block_id: A block id.
+            interval: A retry interval in seconds. Defaults to 5.
+            max_attempts: A maximum number of retries. Defaults to 40.
+
+        Returns:
+            A list of lists where the first element is the block id and the second one the block.
         """
         result = self._call_method('retryUntilIncluded', {
             'blockId': block_id,
             'interval': interval,
             'maxAttempts': max_attempts
         })
 
         def block_class(block_id_and_block):
             block_id_and_block[1] = Block.from_dict(block_id_and_block[1])
             return block_id_and_block
         blockIdsAndBlocks = [block_class(block_id_and_block)
                              for block_id_and_block in result]
         return blockIdsAndBlocks
 
-    def consolidate_funds(self, secret_manager: LedgerNanoSecretManager | MnemonicSecretManager | SeedSecretManager | StrongholdSecretManager, generate_addresses_options: GenerateAddressesOptions) -> str:
-        """Function to consolidate all funds from a range of addresses to the address with the lowest index in that range
-           Returns the address to which the funds got consolidated, if any were available.
+    def consolidate_funds(self, secret_manager: LedgerNanoSecretManager | MnemonicSecretManager | SeedSecretManager |
+                          StrongholdSecretManager, generate_addresses_options: GenerateAddressesOptions) -> str:
+        """Function to consolidate all funds from a range of addresses to the address with the lowest index in that range.
+        Returns the address to which the funds got consolidated, if any were available.
+
+        Args:
+            secret_manager: A supported secret manager.
+            generate_addresses_options: Options to generate addresses.
+
+        Returns:
+            An address to which the funds got consolidated.
         """
         return self._call_method('consolidateFunds', {
             'secretManager': secret_manager,
             'generateAddressesOptions': generate_addresses_options.as_dict(),
         })
 
     def find_inputs(self, addresses: List[str], amount: int):
-        """Function to find inputs from addresses for a provided amount (useful for offline signing)
+        """Function to find inputs from addresses for a provided amount(useful for offline signing).
+
+        Args:
+            addresses: A list of included addresses.
+            amount: The amount to find inputs for.
         """
         return self._call_method('findInputs', {
             'addresses': addresses,
             'amount': amount
         })
 
-    def find_outputs(self, output_ids: List[OutputId], addresses: List[str]):
-        """Find all outputs based on the requests criteria. This method will try to query multiple nodes if
-           the request amount exceeds individual node limit.
-        """
-        return self._call_method('findOutputs', {
-            'outputIds': output_ids,
-            'addresses': addresses
-        })
-
     def reattach(self, block_id: HexStr) -> List[HexStr | Block]:
-        """Reattaches blocks for provided block id. Blocks can be reattached only if they are valid and haven't been
-           confirmed for a while.
+        """Reattaches blocks for a provided block id. Blocks can be reattached only if they are valid and
+        haven't been confirmed for a while .
+
+        Args:
+            block_id: A block id of a block that should be reattached.
+
+        Returns:
+            The reattached block id and block.
         """
         result = self._call_method('reattach', {
             'blockId': block_id
         })
         result[1] = Block.from_dict(result[1])
         return result
 
     def reattach_unchecked(self, block_id: HexStr) -> List[HexStr | Block]:
         """Reattach a block without checking if it should be reattached.
+
+        Args:
+            block_id: A block id of a block that should be reattached.
+
+        Returns:
+            The reattached block id and block.
         """
         result = self._call_method('reattachUnchecked', {
             'blockId': block_id
         })
         result[1] = Block.from_dict(result[1])
         return result
 
     def promote(self, block_id: HexStr) -> List[HexStr | Block]:
-        """Promotes a block. The method should validate if a promotion is necessary through get_block. If not, the
-           method should error out and should not allow unnecessary promotions.
+        """Promotes a block. The method should validate if a promotion is necessary through get_block.
+        If not, the method should error out and should not allow unnecessary promotions.
+
+        Args:
+            block_id: A block id of a block that should be promoted.
+
+        Returns:
+            The block id and block that promoted the provided block.
         """
         result = self._call_method('promote', {
             'blockId': block_id
         })
         result[1] = Block.from_dict(result[1])
         return result
 
     def promote_unchecked(self, block_id: HexStr) -> List[HexStr | Block]:
         """Promote a block without checking if it should be promoted.
+
+        Args:
+            block_id: A block id of a block that should be promoted.
+
+        Returns:
+            The block id and block that promoted the provided block.
         """
         result = self._call_method('promoteUnchecked', {
             'blockId': block_id
         })
         result[1] = Block.from_dict(result[1])
         return result
```

## iota_sdk/client/_node_core_api.py

```diff
@@ -3,175 +3,233 @@
 
 from iota_sdk.types.block import Block, BlockMetadata
 from iota_sdk.types.common import HexStr
 from iota_sdk.types.node_info import NodeInfo, NodeInfoWrapper
 from iota_sdk.types.output import OutputWithMetadata, OutputMetadata
 from iota_sdk.types.output_id import OutputId
 from iota_sdk.types.payload import MilestonePayload
+from iota_sdk.types.utxo_changes import UtxoChanges
 from typing import List
 from dacite import from_dict
 
+
 class NodeCoreAPI():
+    """Node core API.
+    """
 
     def get_health(self, url: str):
         """ Get node health.
+
+        Args:
+            url: The node's url.
         """
         return self._call_method('getHealth', {
             'url': url
         })
 
     def get_node_info(self, url: str, auth=None) -> NodeInfo:
         """Get node info.
+
+        Args:
+            url: The node's url.
+            auth: A JWT or username/password authentication object.
         """
         return from_dict(NodeInfo, self._call_method('getNodeInfo', {
             'url': url,
             'auth': auth
         }))
 
     def get_info(self) -> NodeInfoWrapper:
-        """Returns the node information together with the url of the used node.
+        """Return node information together with the url of the used node.
         """
         return from_dict(NodeInfoWrapper, self._call_method('getInfo'))
 
     def get_peers(self):
-        """Get peers.
+        """Get the peers of the node.
         """
         return self._call_method('getPeers')
 
     def get_tips(self) -> List[HexStr]:
-        """Get tips.
+        """Request tips from the node.
         """
         return self._call_method('getTips')
 
     def post_block(self, block: Block) -> HexStr:
-        """Post block.
+        """Post a block.
+
+        Args:
+            block: The block to post.
+
+        Returns:
+            The block id of the posted block.
         """
         return self._call_method('postBlock', {
             'block': block.__dict__
         })
 
     def get_block_data(self, block_id: HexStr) -> Block:
-        """Get a block.
+        """Get the block corresponding to the given block id.
         """
         return Block.from_dict(self._call_method('getBlock', {
             'blockId': block_id
         }))
 
     def get_block_metadata(self, block_id: HexStr) -> BlockMetadata:
-        """Get block metadata with block_id.
+        """Get the block metadata corresponding to the given block id.
         """
         return BlockMetadata.from_dict(self._call_method('getBlockMetadata', {
             'blockId': block_id
         }))
 
     def get_block_raw(self, block_id: HexStr) -> List[int]:
-        """Get block raw.
+        """Get the raw bytes of the block corresponding to the given block id.
         """
         return self._call_method('getBlockRaw', {
             'blockId': block_id
         })
 
     def post_block_raw(self, block_bytes: List[int]) -> HexStr:
-        """Post block raw.
+        """Post a block as raw bytes.
+
+        Returns:
+            The corresponding block id of the block.
         """
         return self._call_method('postBlockRaw', {
             'blockBytes': block_bytes
         })
 
-    def get_output(self, output_id: OutputId) -> OutputWithMetadata:
-        """Get output.
+    def get_output(self, output_id: OutputId | HexStr) -> OutputWithMetadata:
+        """Get the output corresponding to the given output id.
+
+        Returns:
+            The output itself with its metadata.
         """
+        output_id_str = output_id.output_id if isinstance(
+            output_id, OutputId) else output_id
         return from_dict(OutputWithMetadata, self._call_method('getOutput', {
-            'outputId': output_id
+            'outputId': output_id_str
         }))
 
-    def get_output_metadata(self, output_id: OutputId) -> OutputMetadata:
-        """Get output metadata.
+    def get_output_metadata(self, output_id: OutputId |
+                            HexStr) -> OutputMetadata:
+        """Get the output metadata corresponding to the given output id.
+
+        Returns:
+            The output metadata.
         """
+        output_id_str = output_id.output_id if isinstance(
+            output_id, OutputId) else output_id
         return from_dict(OutputMetadata, self._call_method('getOutputMetadata', {
-            'outputId': output_id
+            'outputId': output_id_str
         }))
 
     def get_milestone_by_id(self, milestone_id: HexStr) -> MilestonePayload:
-        """Get the milestone by the given milestone id.
+        """Get the milestone corresponding to the given milestone id.
+
+        Returns:
+            The milestone payload.
         """
         result = self._call_method('getMilestoneById', {
             'milestoneId': milestone_id
         })
         return MilestonePayload.from_dict(result)
 
     def get_milestone_by_id_raw(self, milestone_id: HexStr) -> List[int]:
-        """Get the raw milestone by the given milestone id.
+        """Get the raw bytes of the milestone corresponding to the given milestone id.
+
+        Returns:
+            The raw bytes of the milestone.
         """
         return self._call_method('getMilestoneByIdRaw', {
             'milestoneId': milestone_id
         })
 
     def get_milestone_by_index(self, index: int) -> MilestonePayload:
-        """Get the milestone by the given index.
+        """Get the milestone by the given milestone index.
+
+        Returns:
+            The milestone payload.
         """
         result = self._call_method('getMilestoneByIndex', {
             'index': index
         })
         return MilestonePayload.from_dict(result)
 
     def get_milestone_by_index_raw(self, index: int) -> List[int]:
-        """Get the milestone by the given index.
+        """Get the raw bytes of the milestone corresponding to the given milestone index.
+
+        Returns:
+            The raw bytes of the milestone.
         """
         return self._call_method('getMilestoneByIndexRaw', {
             'index': index
         })
 
-    def get_utxo_changes_by_id(self, milestone_id: HexStr):
-        """Get the UTXO changes by the given milestone id.
+    def get_utxo_changes_by_id(self, milestone_id: HexStr) -> UtxoChanges:
+        """Get the UTXO changes applied in the given milestone.
         """
-        return self._call_method('getUtxoChangesById', {
+        return from_dict(UtxoChanges, self._call_method('getUtxoChangesById', {
             'milestoneId': milestone_id
-        })
+        }))
 
-    def get_utxo_changes_by_index(self, index: int):
-        """Get the UTXO changes by the given milestone index.
+    def get_utxo_changes_by_index(self, index: int) -> UtxoChanges:
+        """Get the UTXO changes applied at the given milestone index.
         """
-        return self._call_method('getUtxoChangesByIndex', {
+        return from_dict(UtxoChanges, self._call_method('getUtxoChangesByIndex', {
             'index': index
-        })
+        }))
 
     def get_receipts(self):
         """Get all receipts.
         """
         return self._call_method('getReceipts')
 
     def get_receipts_migrated_at(self, milestone_index: int):
-        """Get the receipts by the given milestone index.
+        """Get the receipts that were migrated at the given milestone index.
         """
         return self._call_method('getReceiptsMigratedAt', {
             'milestoneIndex': milestone_index
         })
 
     def get_treasury(self):
         """Get the treasury output.
         """
         return self._call_method('getTreasury')
 
     def get_included_block(self, transaction_id: HexStr) -> Block:
-        """Returns the included block of the transaction.
+        """Returns the included block of the given transaction.
+
+        Returns:
+            The included block.
         """
         return Block.from_dict(self._call_method('getIncludedBlock', {
             'transactionId': transaction_id
         }))
 
-    def get_included_block_metadata(self, transaction_id: HexStr) -> BlockMetadata:
-        """Returns the metadata of the included block of the transaction.
+    def get_included_block_metadata(
+            self, transaction_id: HexStr) -> BlockMetadata:
+        """Returns the metadata of the included block of the given transaction.
+
+        Returns:
+            The metadata of the included block.
         """
         return BlockMetadata.from_dict(self._call_method('getIncludedBlockMetadata', {
             'transactionId': transaction_id
         }))
 
-    def call_plugin_route(self, base_plugin_path: str, method: str, endpoint: str, query_params: [str] = None, request: str = None):
+    def call_plugin_route(self, base_plugin_path: str, method: str,
+                          endpoint: str, query_params: [str] = None, request: str = None):
         """Extension method which provides request methods for plugins.
+
+        Args:
+            base_plugin_path: The base path of the routes provided by the plugin.
+            method: The HTTP method.
+            endpoint: The endpoint to query provided by the plugin.
+            query_params: The parameters of the query.
+            request: The request object sent to the endpoint of the plugin.
         """
         if query_params is None:
             query_params = []
         return self._call_method('callPluginRoute', {
             'basePluginPath': base_plugin_path,
             'method': method,
             'endpoint': endpoint,
```

## iota_sdk/client/_node_indexer_api.py

```diff
@@ -5,17 +5,72 @@
 from iota_sdk.types.output_id import OutputId
 from dataclasses import dataclass
 from typing import Dict, Optional
 import humps
 
 
 class NodeIndexerAPI():
+    """Node indexer API.
+    """
 
     @dataclass
     class QueryParameters:
+        """Query parameters
+
+        **Attributes:**
+        address :
+            Bech32-encoded address that should be searched for.
+        alias_address :
+            Filter foundry outputs based on bech32-encoded address of the controlling alias.
+        created_after :
+            Returns outputs that were created after a certain Unix timestamp.
+         created_before :
+            Returns outputs that were created before a certain Unix timestamp.
+         cursor :
+            Starts the search from the cursor (confirmationMS+outputId.pageSize).
+         expiration_return_address :
+            Filters outputs based on the presence of a specific Bech32-encoded return address in the expiration unlock
+            condition.
+         expires_after :
+            Returns outputs that expire after a certain Unix timestamp.
+         expires_before :
+            Returns outputs that expire before a certain Unix timestamp.
+         governor :
+            Filters outputs based on bech32-encoded governor (governance controller) address.
+         has_expiration :
+            Filters outputs based on the presence of expiration unlock condition.
+         has_native_tokens :
+            Filters outputs based on the presence of native tokens.
+         has_storage_deposit_return :
+            Filters outputs based on the presence of storage deposit return unlock condition.
+         has_timelock :
+            Filters outputs based on the presence of timelock unlock condition.
+         issuer:
+            Filters outputs based on bech32-encoded issuer address.
+         max_native_token_count :
+            Filters outputs that have at most a certain number of distinct native tokens.
+         min_native_token_count :
+            Filters outputs that have at least a certain number of distinct native tokens.
+         page_size :
+            The maximum amount of items returned in one call. If there are more items, a cursor to the next page is
+            returned too. The parameter is ignored when pageSize is defined via the cursor parameter.
+         sender :
+            Filters outputs based on the presence of validated Sender (bech32 encoded).
+         state_controller :
+            Filters outputs based on bech32-encoded state controller address.
+         storage_deposit_return_address :
+            Filters outputs based on the presence of a specific return address in the storage deposit return unlock
+            condition.
+         tag :
+            Filters outputs based on matching Tag Block.
+         timelocked_after :
+            Returns outputs that are timelocked after a certain Unix timestamp.
+         timelocked_before :
+            Returns outputs that are timelocked before a certain Unix timestamp.
+        """
         address: Optional[str] = None
         alias_address: Optional[str] = None
         created_after: Optional[int] = None
         created_before: Optional[int] = None
         cursor: Optional[str] = None
         expiration_return_address: Optional[str] = None
         expires_after: Optional[int] = None
@@ -33,80 +88,114 @@
         state_controller: Optional[str] = None
         storage_deposit_return_address: Optional[str] = None
         tag: Optional[str] = None
         timelocked_after: Optional[int] = None
         timelocked_before: Optional[int] = None
 
         def as_dict(self):
-            return humps.camelize([{k: v} for k, v in self.__dict__.items() if v != None])
+            return humps.camelize(
+                [{k: v} for k, v in self.__dict__.items() if v is not None])
 
     class OutputIdsResponse:
+        """Response type for output IDs.
+
+        Attributes:
+            ledger_index: The ledger index for which the response is valid.
+            cursor: The cursor to the next page of results.
+            items: The query results.
+        """
+
         def __init__(self, dict: Dict):
             self.ledgerIndex = dict["ledgerIndex"]
             self.cursor = dict["cursor"]
             self.items = [OutputId.from_string(
                 output_id) for output_id in dict["items"]]
 
-    def basic_output_ids(self, query_parameters: QueryParameters) -> OutputIdsResponse:
-        """Fetch basic output IDs.
+    def basic_output_ids(
+            self, query_parameters: QueryParameters) -> OutputIdsResponse:
+        """Fetch basic output IDs from the given query parameters.
+
+        Returns:
+            The corresponding output IDs of the basic outputs.
         """
 
         query_parameters_camelized = query_parameters.as_dict()
 
         response = self._call_method('basicOutputIds', {
             'queryParameters': query_parameters_camelized,
         })
         return self.OutputIdsResponse(response)
 
-    def alias_output_ids(self, query_parameters: QueryParameters) -> OutputIdsResponse:
-        """Fetch alias output IDs.
+    def alias_output_ids(
+            self, query_parameters: QueryParameters) -> OutputIdsResponse:
+        """Fetch alias output IDs from the given query parameters.
+
+        Returns:
+            The corresponding output IDs of the alias outputs.
         """
 
         query_parameters_camelized = query_parameters.as_dict()
 
         response = self._call_method('aliasOutputIds', {
             'queryParameters': query_parameters_camelized,
         })
         return self.OutputIdsResponse(response)
 
     def alias_output_id(self, alias_id: HexStr) -> OutputId:
-        """Fetch alias output ID.
+        """Fetch alias output ID from the given alias ID.
+
+        Returns:
+            The output ID of the alias output.
         """
         return OutputId.from_string(self._call_method('aliasOutputId', {
             'aliasId': alias_id
         }))
 
-    def nft_output_ids(self, query_parameters: QueryParameters) -> OutputIdsResponse:
-        """Fetch NFT output IDs.
+    def nft_output_ids(
+            self, query_parameters: QueryParameters) -> OutputIdsResponse:
+        """Fetch NFT output IDs from the given query parameters.
+
+        Returns:
+            The corresponding output IDs of the NFT outputs.
         """
 
         query_parameters_camelized = query_parameters.as_dict()
 
         response = self._call_method('nftOutputIds', {
             'queryParameters': query_parameters_camelized,
         })
         return self.OutputIdsResponse(response)
 
     def nft_output_id(self, nft_id: HexStr) -> OutputId:
-        """Fetch NFT output ID.
+        """Fetch NFT output ID from the given NFT ID.
+
+        Returns:
+            The output ID of the NFT output.
         """
         return OutputId.from_string(self._call_method('nftOutputId', {
             'nftId': nft_id
         }))
 
-    def foundry_output_ids(self, query_parameters: QueryParameters) -> OutputIdsResponse:
-        """Fetch foundry Output IDs.
+    def foundry_output_ids(
+            self, query_parameters: QueryParameters) -> OutputIdsResponse:
+        """Fetch foundry Output IDs from the given query parameters.
+
+        Returns:
+            The corresponding output IDs of the foundry outputs.
         """
 
         query_parameters_camelized = query_parameters.as_dict()
 
         response = self._call_method('foundryOutputIds', {
             'queryParameters': query_parameters_camelized,
         })
         return self.OutputIdsResponse(response)
 
     def foundry_output_id(self, foundry_id: HexStr) -> OutputId:
-        """Fetch foundry Output ID.
+        """Fetch foundry Output ID from the given foundry ID.
+
+        Returns:
+            The output ID of the foundry output.
         """
         return OutputId.from_string(self._call_method('foundryOutputId', {
             'foundryId': foundry_id
         }))
```

## iota_sdk/client/_utils.py

```diff
@@ -1,15 +1,18 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from iota_sdk.types.common import HexStr
+from iota_sdk.types.output import Output
 from typing import Optional
 
 
 class ClientUtils():
+    """Client utility functions.
+    """
 
     def hex_to_bech32(self, hex: HexStr, bech32_hrp: str) -> str:
         """Transforms a hex encoded address to a bech32 encoded address.
         """
         return self._call_method('hexToBech32', {
             'hex': hex,
             'bech32Hrp': bech32_hrp
@@ -27,22 +30,32 @@
         """Transforms an nft id to a bech32 encoded address.
         """
         return self._call_method('nftIdToBech32', {
             'nftId': nft_id,
             'bech32Hrp': bech32_hrp
         })
 
-    def hex_public_key_to_bech32_address(self, hex: HexStr, bech32_hrp: Optional[str] = None) -> str:
+    def hex_public_key_to_bech32_address(
+            self, hex: HexStr, bech32_hrp: Optional[str] = None) -> str:
         """Transforms a hex encoded public key to a bech32 encoded address.
         """
         return self._call_method('hexPublicKeyToBech32Address', {
             'hex': hex,
             'bech32Hrp': bech32_hrp
         })
 
+    def minimum_required_storage_deposit(self, output: Output) -> int:
+        """Minimum required storage deposit.
+        """
+        return int(self._call_method(
+            'minimumRequiredStorageDeposit', {
+                'output': output.as_dict()
+            }
+        ))
+
     def request_funds_from_faucet(self, url: str, address: str) -> str:
         """Requests funds from the faucet, for example `https://faucet.testnet.shimmer.network/api/enqueue` or `http://localhost:8091/api/enqueue`.
         """
         return self._call_method(
             'requestFundsFromFaucet', {
                 'url': url,
                 'address': address,
```

## iota_sdk/prefix_hex.py

```diff
@@ -1,12 +1,16 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from iota_sdk.types.common import HexStr
 
 
 def utf8_to_hex(utf8_data: str) -> HexStr:
-    return HexStr('0x'+utf8_data.encode('utf-8').hex())
+    """Convert a UTF-8 string to a hex string.
+    """
+    return HexStr('0x' + utf8_data.encode('utf-8').hex())
 
 
 def hex_to_utf8(hex_data: HexStr) -> str:
+    """Convert a given hex string to a UTF-8 string.
+    """
     return bytes.fromhex(hex_data[2:]).decode('utf-8')
```

## iota_sdk/secret_manager/secret_manager.py

```diff
@@ -1,71 +1,100 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from iota_sdk import create_secret_manager, call_secret_manager_method
 from iota_sdk.types.common import HexStr
-from iota_sdk.types.signature import Ed25519Signature
+from iota_sdk.types.signature import Ed25519Signature, Bip44
+from iota_sdk.types.transaction_data import PreparedTransactionData
+from iota_sdk.types.payload import TransactionPayload
 from json import dumps, loads
 import humps
-from typing import List, Optional
+from typing import Optional
 from dacite import from_dict
 
+
 class LedgerNanoSecretManager(dict):
-    """Secret manager that uses a Ledger Nano hardware wallet or Speculos simulator.
+    """Secret manager that uses a Ledger Nano hardware wallet or a Speculos simulator.
     """
 
     def __init__(self, is_simulator):
-        """Initialize a ledger nano secret manager.
+        """Initialize a Ledger Nano secret manager.
+
+        Args:
+            is_simulator: Whether this is a simulated Ledger Nano device.
         """
 
         dict.__init__(self, ledgerNano=is_simulator)
 
 
 class MnemonicSecretManager(dict):
-    """Secret manager that uses a mnemonic in plain memory. It's not recommended for production use. Use LedgerNano or Stronghold instead.
+    """Secret manager that uses a mnemonic held in memory.
+    This is not recommended in production. Use LedgerNano or Stronghold instead.
     """
 
     def __init__(self, mnemonic):
         """Initialize a mnemonic secret manager.
+
+        Args:
+            mnemonic: The root secret of this type of secret manager.
         """
 
         dict.__init__(self, mnemonic=mnemonic)
 
 
 class SeedSecretManager(dict):
+    """Secret manager that uses a seed.
+    """
+
     def __init__(self, seed):
         """Initialize a seed secret manager.
+
+        Args:
+            seed: The root secret of this type of secret manager.
         """
 
         dict.__init__(self, hexSeed=seed)
 
 
 class StrongholdSecretManager(dict):
     """Secret manager that uses Stronghold.
     """
 
     def __init__(self, snapshot_path, password):
         """Initialize a stronghold secret manager.
+
+        Args:
+            snapshot_path: The path to the Stronghold snapshot file.
+            password: The password to unlock the Stronghold snapshot file.
         """
 
         dict.__init__(self, stronghold=StrongholdSecretManager.Inner(
             snapshot_path, password))
 
     class Inner(dict):
         def __init__(self, snapshot_path, password):
             dict.__init__(self, password=password, snapshotPath=snapshot_path)
 
 
 class SecretManagerError(Exception):
-    """secret manager error"""
+    """Secret manager error.
+    """
     pass
 
 
 class SecretManager():
-    def __init__(self, secret_manager: Optional[LedgerNanoSecretManager | MnemonicSecretManager | SeedSecretManager | StrongholdSecretManager] = None, secret_manager_handle=None):
+    def __init__(self, secret_manager: Optional[LedgerNanoSecretManager | MnemonicSecretManager |
+                 SeedSecretManager | StrongholdSecretManager] = None, secret_manager_handle=None):
+        """Initialize a secret manager.
+
+        Args:
+            secret_manager: One of the supported secret managers.
+            secret_manager_handle: A handle to a secret manager.
+        """
+
         if secret_manager_handle is None:
             self.handle = create_secret_manager(dumps(secret_manager))
         else:
             self.handle = secret_manager_handle
 
     def _call_method(self, name, data=None):
         """Dumps json string and call call_secret_manager_method()
@@ -88,48 +117,39 @@
 
         if "payload" in json_response:
             return json_response['payload']
         else:
             return response
 
     def generate_ed25519_addresses(self,
-                           account_index: Optional[int] = None,
-                           start: Optional[int] = None,
-                           end: Optional[int] = None,
-                           internal: Optional[bool] = None,
-                           coin_type: Optional[int] = None,
-                           bech32_hrp: Optional[str] = None,
-                           ledger_nano_prompt: Optional[bool] = None):
-        """Generate ed25519 addresses.
-
-        Parameters
-        ----------
-        account_index : int
-            Account index.
-        start : int
-            Start index of generated addresses
-        end : int
-            End index of generated addresses
-        internal : bool
-            Internal addresses
-        coin_type : int
-            Coin type. The CoinType enum can be used
-        bech32_hrp : string
-            Bech32 human readable part.
-        ledger_nano_prompt : bool
-            Display the address on ledger devices.
-
-        Returns
-        -------
-        Addresses as array of strings.
+                                   account_index: Optional[int] = None,
+                                   start: Optional[int] = None,
+                                   end: Optional[int] = None,
+                                   internal: Optional[bool] = None,
+                                   coin_type: Optional[int] = None,
+                                   bech32_hrp: Optional[str] = None,
+                                   ledger_nano_prompt: Optional[bool] = None):
+        """Generate Ed25519 addresses.
+
+        Args:
+            account_index: An account index.
+            start: The start index of the addresses to generate.
+            end: The end index of the addresses to generate.
+            internal: Whether the generated addresses should be internal.
+            coin_type: The coin type to generate addresses for.
+            bech32_hrp: The bech32 HRP (human readable part) to use.
+            ledger_nano_prompt: Whether to display the address on Ledger Nano devices.
+
+        Returns:
+            The generated Ed25519 addresses.
         """
         options = dict(locals())
         del options['self']
 
-        options = {k: v for k, v in options.items() if v != None}
+        options = {k: v for k, v in options.items() if v is not None}
 
         is_start_set = 'start' in options
         is_end_set = 'end' in options
         if is_start_set or is_end_set:
             options['range'] = {}
             if is_start_set:
                 options['range']['start'] = options.pop('start')
@@ -140,54 +160,47 @@
         if 'internal' in options:
             if 'options' not in options:
                 options['options'] = {}
             options['options']['internal'] = options.pop('internal')
         if 'ledger_nano_prompt' in options:
             if 'options' not in options:
                 options['options'] = {}
-            options['options']['ledger_nano_prompt'] = options.pop('ledger_nano_prompt')
+            options['options']['ledger_nano_prompt'] = options.pop(
+                'ledger_nano_prompt')
 
         options = humps.camelize(options)
 
         return self._call_method('generateEd25519Addresses', {
             'options': options
         })
 
     def generate_evm_addresses(self,
-                           account_index=None,
-                           start=None,
-                           end=None,
-                           internal=None,
-                           coin_type=None,
-                           ledger_nano_prompt=None):
+                               account_index: Optional[int] = None,
+                               start: Optional[int] = None,
+                               end: Optional[int] = None,
+                               internal: Optional[bool] = None,
+                               coin_type: Optional[int] = None,
+                               ledger_nano_prompt: Optional[bool] = None):
         """Generate EVM addresses.
 
-        Parameters
-        ----------
-        account_index : int
-            Account index.
-        start : int
-            Start index of generated addresses
-        end : int
-            End index of generated addresses
-        internal : bool
-            Internal addresses
-        coin_type : int
-            Coin type. The CoinType enum can be used
-        ledger_nano_prompt : bool
-            Display the address on ledger devices.
-
-        Returns
-        -------
-        Addresses as array of strings.
+        Args:
+            account_index: An account index.
+            start: The start index of the addresses to generate.
+            end: The end index of the addresses to generate.
+            internal: Whether the generated addresses should be internal.
+            coin_type: The coin type to generate addresses for.
+            ledger_nano_prompt: Whether to display the address on Ledger Nano devices.
+
+        Returns:
+            The generated EVM addresses.
         """
         options = dict(locals())
         del options['self']
 
-        options = {k: v for k, v in options.items() if v != None}
+        options = {k: v for k, v in options.items() if v is not None}
 
         is_start_set = 'start' in options
         is_end_set = 'end' in options
         if is_start_set or is_end_set:
             options['range'] = {}
             if is_start_set:
                 options['range']['start'] = options.pop('start')
@@ -202,48 +215,70 @@
         options = humps.camelize(options)
 
         return self._call_method('generateEvmAddresses', {
             'options': options
         })
 
     def get_ledger_nano_status(self):
-        """Returns the Ledger Status.
+        """Return the Ledger Status.
         """
         return self._call_method('getLedgerNanoStatus')
 
     def store_mnemonic(self, mnemonic: str):
-        """Store a mnemonic in the Stronghold vault.
+        """Store a mnemonic.
+
+        Args:
+            mnemonic: A mnemonic to store in the secret manager.
         """
         return self._call_method('storeMnemonic', {
             'mnemonic': mnemonic
         })
 
-    def sign_ed25519(self, message: HexStr, chain: List[int]) -> Ed25519Signature:
+    def sign_ed25519(self, message: HexStr, chain: Bip44) -> Ed25519Signature:
         """Signs a message with an Ed25519 private key.
+
+        Args:
+            message: The given message to sign.
+            chain: The chain to sign with.
+
+        Returns:
+            The Ed25519 signature.
         """
         return from_dict(Ed25519Signature, self._call_method('signEd25519', {
             'message': message,
-            'chain': chain,
+            'chain': chain.__dict__,
         }))
 
-    def sign_secp256k1_ecdsa(self, message: HexStr, chain: List[int]):
+    def sign_secp256k1_ecdsa(self, message: HexStr, chain: Bip44):
         """Signs a message with an Secp256k1Ecdsa private key.
+
+        Args:
+            message: The given message to sign.
+            chain: The chain to sign with.
         """
         return self._call_method('signSecp256k1Ecdsa', {
             'message': message,
-            'chain': chain,
+            'chain': chain.__dict__,
         })
 
-    def sign_transaction(self, prepared_transaction_data):
+    def sign_transaction(
+            self, prepared_transaction_data: PreparedTransactionData) -> TransactionPayload:
         """Sign a transaction.
+
+        Args:
+            prepare_transaction_data: The prepared transaction data that needs to be signed.
         """
-        return self._call_method('signTransaction', {
-            'preparedTransactionData': prepared_transaction_data
-        })
+        return from_dict(TransactionPayload, self._call_method('signTransaction', {
+            'preparedTransactionData': prepared_transaction_data.as_dict()
+        }))
 
-    def signature_unlock(self, transaction_essence_hash: HexStr, chain: List[int]):
+    def signature_unlock(self, transaction_essence_hash: HexStr, chain: Bip44):
         """Sign a transaction essence hash.
+
+        Args:
+            transaction_essence_hash: The transaction essence hash to sign.
+            chain: The chain to sign with.
         """
         return self._call_method('signatureUnlock', {
             'transactionEssenceHash': transaction_essence_hash,
-            'chain': chain
+            'chain': chain.__dict__,
         })
```

## iota_sdk/types/address.py

```diff
@@ -1,60 +1,85 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from iota_sdk.types.common import HexStr
-from dataclasses import dataclass
+from dataclasses import dataclass, field
 from enum import IntEnum
-from typing import Optional
 
 
 class AddressType(IntEnum):
+    """Address type variants.
+
+     Attributes:
+        ED25519 (0): Ed25519 address.
+        ALIAS (8): Alias address.
+        NFT (16): Nft address.
+    """
     ED25519 = 0
     ALIAS = 8
     NFT = 16
 
 
 @dataclass
 class Address():
+    """Base class for addresses.
+    """
     type: int
-    pubKeyHash: Optional[HexStr] = None
-    aliasId: Optional[HexStr] = None
-    nftId: Optional[HexStr] = None
 
     def as_dict(self):
-        return {k: v for k, v in self.__dict__.items() if v != None}
+        return {k: v for k, v in self.__dict__.items() if v is not None}
 
 
+@dataclass
 class Ed25519Address(Address):
-    def __init__(self, address: HexStr):
-        """Initialize an Ed25519Address
-
-        Parameters
-        ----------
-        address : string
-            The hex encoded address to use.
-        """
-        super().__init__(AddressType.ED25519, pubKeyHash=address)
+    """Represents an Ed25519 address.
+    Attributes:
+        pubKeyHash: The hex encoded Ed25519 public key hash.
+    """
+    pubKeyHash: HexStr
+    type: int = field(
+        default_factory=lambda: int(
+            AddressType.ED25519),
+        init=False)
 
 
+@dataclass
 class AliasAddress(Address):
-    def __init__(self, address_or_id: HexStr):
-        """Initialize an AliasAddress
-
-        Parameters
-        ----------
-        address_or_id : string
-            The hex encoded address to use.
-        """
-        super().__init__(AddressType.ALIAS, aliasId=address_or_id)
+    """Represents an Alias address.
+    Attributes:
+        aliasId: The hex encoded alias id.
+    """
+    aliasId: HexStr
+    type: int = field(
+        default_factory=lambda: int(
+            AddressType.ALIAS),
+        init=False)
 
 
+@dataclass
 class NFTAddress(Address):
-    def __init__(self, address_or_id: HexStr):
-        """Initialize an NFTokenAddress
+    """Represents an NFT address.
+    Attributes:
+        nftId: The hex encoded NFT id.
+    """
+    nftId: HexStr
+    type: int = field(default_factory=lambda: int(AddressType.NFT), init=False)
 
-        Parameters
-        ----------
-        address_or_id : string
-            The hex encoded address to use.
-        """
-        super().__init__(AddressType.NFT, nftId=address_or_id)
+
+@dataclass
+class AccountAddress():
+    """An Address of the Account.
+    """
+    address: str
+    keyIndex: int
+    internal: bool
+    used: bool
+
+
+@dataclass
+class AddressWithUnspentOutputs():
+    """An Address with unspent outputs.
+    """
+    address: str
+    keyIndex: int
+    internal: bool
+    outputIds: bool
```

## iota_sdk/types/balance.py

```diff
@@ -6,42 +6,67 @@
 from typing import List, Optional
 from iota_sdk.types.common import HexStr
 
 
 @dataclass
 class BaseCoinBalance:
     """Base coin fields for Balance.
+
+    Attributes:
+        total: The total balance.
+        available: The available amount of the total balance.
     """
     total: str
     available: str
 
 
 @dataclass
 class RequiredStorageDeposit:
     """Required storage deposit for the outputs in the account.
+
+    Attributes:
+        alias: The required amount for alias outputs.
+        basic: The required amount for basic outputs.
+        foundry: The required amount for foundry outputs.
+        nft: The required amount for nft outputs.
     """
     alias: str
     basic: str
     foundry: str
     nft: str
 
 
 @dataclass
 class NativeTokensBalance:
     """Native tokens fields for Balance.
+
+    Attributes:
+        tokenId: The native token id.
+        total: The total native token balance.
+        available: The available amount of the total native token balance.
+        metadata: Some metadata of the native token.
     """
     tokenId: HexStr
     total: HexStr
     available: HexStr
     metadata: Optional[HexStr]
 
 
 @dataclass
 class Balance:
     """The balance of an account.
+
+    Attributes:
+        baseCoin: The base coin balance.
+        requiredStorageDeposit: The required storage deposit.
+        nativeTokens: The balances of all native tokens.
+        nfts: All owned NFTs.
+        aliases: All owned aliases.
+        foundries: All owned foundries.
+        potentiallyLockedOutputs: A list of potentially locked outputs.
     """
     baseCoin: BaseCoinBalance
     requiredStorageDeposit: RequiredStorageDeposit
     nativeTokens: List[NativeTokensBalance]
     nfts: List[HexStr]
     aliases: List[HexStr]
     foundries: List[HexStr]
```

## iota_sdk/types/block.py

```diff
@@ -1,48 +1,85 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
 from dataclasses import dataclass
 from typing import Dict, List, Optional
 from iota_sdk.types.common import HexStr
-from iota_sdk.types.payload import Payload
+from iota_sdk.types.payload import TaggedDataPayload, TransactionPayload, MilestonePayload
 from iota_sdk.utils import Utils
 from enum import Enum
+from dacite import from_dict
 
 
 @dataclass
 class Block:
     """Represent the object that nodes gossip around the network.
+
+    Attributes:
+        protocolVersion: The protocol version with which this block was issued.
+        parents: The parents of this block.
+        nonce: The nonce of this block.
+        payload: The optional payload of this block.
     """
 
     protocolVersion: int
     parents: List[HexStr]
-    nonce: int
-    payload: Optional[Payload] = None
+    nonce: str
+    payload: Optional[TaggedDataPayload |
+                      TransactionPayload | MilestonePayload] = None
 
     @classmethod
     def from_dict(cls, block_dict: Dict) -> Block:
-        obj = cls.__new__(cls)
-        super(Block, obj).__init__()
-        for k, v in block_dict.items():
-            setattr(obj, k, v)
-        return obj
+        return from_dict(Block, block_dict)
 
     def id(self) -> HexStr:
         return Utils.block_id(self)
 
+    def as_dict(self):
+        config = {k: v for k, v in self.__dict__.items() if v is not None}
+
+        if 'payload' in config:
+            config['payload'] = config['payload'].as_dict()
+
+        return config
+
 
 class LedgerInclusionState(str, Enum):
+    """Represents whether a block is included in the ledger.
+
+    Attributes:
+        noTransaction: The block does not contain a transaction.
+        included: The block contains an included transaction.
+        conflicting: The block contains a conflicting transaction.
+    """
     noTransaction = 'noTransaction'
     included = 'included'
     conflicting = 'conflicting'
 
 
 class ConflictReason(Enum):
+    """Represents the possible reasons for a conflicting transaction.
+
+    Attributes:
+        none (0): The transaction does not conflict with the ledger.
+        inputUTXOAlreadySpent (1): The input UTXO is already spent.
+        inputUTXOAlreadySpentInThisMilestone (2): The input UTXO is already spent in this milestone.
+        inputUTXONotFound (3): The input UTXO was not found.
+        inputOutputSumMismatch (4): The sum of input and output amounts is not equal.
+        invalidSignature (5): The signature is invalid.
+        invalidTimelock (6): The timelock is invalid.
+        invalidNativeTokens (7): The native tokens are invalid.
+        returnAmountMismatch (8): The return amount is invalid.
+        invalidInputUnlock (9): Not all inputs can be unlocked.
+        invalidInputsCommitment (10): The inputs commitment hash is invalid.
+        invalidSender (11): The sender is invalid.
+        invalidChainState (12): The chain state is invalid.
+        semanticValidationFailed (255): The semantic validation failed.
+    """
     none = 0,
     inputUTXOAlreadySpent = 1,
     inputUTXOAlreadySpentInThisMilestone = 2,
     inputUTXONotFound = 3,
     inputOutputSumMismatch = 4,
     invalidSignature = 5,
     invalidTimelock = 6,
@@ -54,16 +91,26 @@
     invalidChainState = 12,
     semanticValidationFailed = 255,
 
 
 @dataclass
 class BlockMetadata:
     """Block Metadata.
-    """
 
+    Attributes:
+        blockId: The id of the block.
+        parents: The parents of the block.
+        isSolid: Whether the block is solid.
+        referencedByMilestoneIndex: The milestone index referencing the block.
+        milestoneIndex: The milestone index if the block contains a milestone payload.
+        ledgerInclusionState: The ledger inclusion state of the block.
+        conflictReason: The optional conflict reason of the block.
+        shouldPromote: Whether the block should be promoted.
+        shouldReattach: Whether the block should be reattached.
+    """
     blockId: HexStr
     parents: List[HexStr]
     isSolid: bool
     referencedByMilestoneIndex: Optional[int] = None
     milestoneIndex: Optional[int] = None
     ledgerInclusionState: Optional[LedgerInclusionState] = None
     conflictReason: Optional[ConflictReason] = None
```

## iota_sdk/types/burn.py

```diff
@@ -6,57 +6,61 @@
 from typing import List, Optional, Dict, Any
 from iota_sdk.types.native_token import NativeToken
 from iota_sdk.types.common import HexStr
 
 
 @dataclass
 class Burn:
-    """A DTO for [`Burn`]
+    """A DTO for `Burn`.
 
-    Parameters:
-    -----------
-    aliases: Optional[List[str]]
-        The aliases (hex encoded) to burn
-    nfts: Optional[List[str]]
-        The NFTs (hex encoded) to burn
-    foundries: Optional[List[str]]
-        The foundries (hex encoded) to burn
-    nativeTokens: Optional[List[NativeToken]]
-        The native tokens to burn
+    Attributes:
+        aliases: The aliases to burn.
+        nfts: The NFTs to burn.
+        foundries: The foundries to burn.
+        nativeTokens: The native tokens to burn.
     """
 
     aliases: Optional[List[HexStr]] = None
     nfts: Optional[List[HexStr]] = None
     foundries: Optional[List[HexStr]] = None
     nativeTokens: Optional[List[NativeToken]] = None
 
     def add_alias(self, alias: HexStr) -> Burn:
+        """Add an alias to the burn.
+        """
         if self.aliases is None:
             self.aliases = []
         self.aliases.append(alias)
         return self
 
     def add_nft(self, nft: HexStr) -> Burn:
+        """Add an NFT to the burn.
+        """
         if self.nfts is None:
             self.nfts = []
         self.nfts.append(nft)
         return self
 
     def add_foundry(self, foundry: HexStr) -> Burn:
+        """Add a foundry to the burn.
+        """
         if self.foundries is None:
             self.foundries = []
         self.foundries.append(foundry)
         return self
 
     def add_native_token(self, native_token: NativeToken) -> Burn:
+        """Add a native token to the burn.
+        """
         if self.nativeTokens is None:
             self.nativeTokens = [native_token]
         else:
             self.nativeTokens.append(native_token)
         return self
 
     def as_dict(self) -> Dict[str, Any]:
-        config = {k: v for k, v in self.__dict__.items() if v != None}
+        config = {k: v for k, v in self.__dict__.items() if v is not None}
 
         if "nativeTokens" in config:
-            config["nativeTokens"] = {nativeToken.__dict__["id"]: nativeToken.__dict__["amount"] for nativeToken in config["nativeTokens"]}
+            config["nativeTokens"] = {nativeToken.__dict__["id"]: nativeToken.__dict__[
+                "amount"] for nativeToken in config["nativeTokens"]}
         return config
```

## iota_sdk/types/common.py

```diff
@@ -2,51 +2,54 @@
 # SPDX-License-Identifier: Apache-2.0
 
 from enum import IntEnum
 from typing import NewType
 
 HexStr = NewType("HexStr", str)
 
-HD_WALLET_TYPE = 44
-HARDEN_MASK = 1 << 31;
 
 class CoinType(IntEnum):
+    """Coin types.
+
+    Attributes:
+        IOTA (4218): IOTA
+        SHIMMER (4219): SHIMMER
+        ETHER (60): ETHER
+    """
     IOTA = 4218
     SHIMMER = 4219
     ETHER = 60
 
     def __int__(self):
         return self.value
 
 
 class Node():
-    def __init__(self, url=None, jwt=None, username=None, password=None, disabled=None):
-        """Initialize a Node
+    """Represents a node in the network.
+    """
 
-        Parameters
-        ----------
-        url : string
-            Node url
-        jwt : string
-            JWT token
-        username : string
-            Username for basic authentication
-        password : string
-            Password for basic authentication
-        disabled : bool
-            Disable node
+    def __init__(self, url=None, jwt=None, username=None,
+                 password=None, disabled=None):
+        """Initialize a Node.
+
+        Args:
+            url: The node url.
+            jwt: A JWT token for authentication.
+            username: A username for basic authentication.
+            password: A password for basic authentication.
+            disabled: Whether the node should be used for API requests or not.
         """
         self.url = url
         self.jwt = jwt
         self.username = username
         self.password = password
         self.disabled = disabled
 
     def as_dict(self):
-        config = {k: v for k, v in self.__dict__.items() if v != None}
+        config = {k: v for k, v in self.__dict__.items() if v is not None}
 
         if 'jwt' in config or 'username' in config or 'password' in config:
             config['auth'] = {}
             if 'jwt' in config:
                 config['auth']['jwt'] = config.pop('jwt')
             if 'username' in config or 'password' in config:
                 basic_auth = config['auth']['basicAuthNamePwd'] = []
@@ -54,28 +57,28 @@
                     basic_auth.append(config.pop('username'))
                 if 'password' in config:
                     basic_auth.append(config.pop('password'))
 
         return config
 
 
-class SendParams():
-    def __init__(self, address, amount):
-        """Initialize SendParams
-
-        Parameters
-        ----------
-        address : string
-            Address of the output
-        amount : int
-            Amount of the output
+class AddressAndAmount():
+    """Parameters to send a certain amount of coins to an address.
+    """
+
+    def __init__(self, amount: int, address: str):
+        """Initialize AddressAndAmount for options in Client::build_and_post_block()
+
+        Args:
+            amount: The base coin amount to send.
+            address: The receive address.
         """
-        self.address = address
         self.amount = amount
+        self.address = address
 
     def as_dict(self):
-        config = {k: v for k, v in self.__dict__.items() if v != None}
+        config = {k: v for k, v in self.__dict__.items() if v is not None}
 
         if 'amount' in config:
             config['amount'] = str(config['amount'])
 
         return config
```

## iota_sdk/types/event.py

```diff
@@ -1,12 +1,23 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from enum import IntEnum
 
+
 class WalletEventType(IntEnum):
+    """Types of wallet events.
+
+    Attributes:
+        ConsolidationRequired (0): Consolidation is required.
+        LedgerAddressGeneration (1): Nano Ledger has generated an address.
+        NewOutput (2): A new output was created.
+        SpentOutput (3): An output was spent.
+        TransactionInclusion (4): A transaction was included into the ledger.
+        TransactionProgress (5): A progress update while submitting a transaction.
+    """
     ConsolidationRequired = 0,
     LedgerAddressGeneration = 1,
     NewOutput = 2,
     SpentOutput = 3,
     TransactionInclusion = 4,
     TransactionProgress = 5,
```

## iota_sdk/types/feature.py

```diff
@@ -1,100 +1,84 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
-from iota_sdk.types.address import Address
+from iota_sdk.types.address import Ed25519Address, AliasAddress, NFTAddress
 from iota_sdk.types.common import HexStr
-from dataclasses import dataclass
+from dataclasses import dataclass, field
 from enum import IntEnum
-from typing import Optional
 
 
 class FeatureType(IntEnum):
+    """Types of features.
+
+    Attributes:
+        Sender (0): The sender feature.
+        Issuer (1): The issuer feature.
+        Metadata (2): The metadata feature.
+        Tag (3): The tag feature.
+    """
     Sender = 0
     Issuer = 1
     Metadata = 2
     Tag = 3
 
+
 @dataclass
 class Feature():
-    """Initialize a feature
-
-    Parameters
-    ----------
-    type : FeatureType
-        The type of feature
-    address : Address
-        Issuer or Sender address
-    data : HexStr
-        Hex encoded metadata
-    tag : HexStr
-        Hex encoded tag used to index the output
+    """Base class of a feature.
     """
     type: int
-    address: Optional[Address] = None
-    data: Optional[HexStr] = None
-    tag: Optional[HexStr] = None
-
-    def into(self):
-        match FeatureType(self.type):
-            case FeatureType.Sender:
-                return SenderFeature(self.address)
-            case FeatureType.Issuer:
-                return IssuerFeature(self.address)
-            case FeatureType.Metadata:
-                return MetadataFeature(self.data)
-            case FeatureType.Metadata:
-                return TagFeature(self.tag)
-        
+
     def as_dict(self):
-        res = {k: v for k, v in self.__dict__.items() if v != None}
+        res = {k: v for k, v in self.__dict__.items() if v is not None}
         if 'address' in res:
             res['address'] = res['address'].as_dict()
         return res
 
 
+@dataclass
 class SenderFeature(Feature):
-    def __init__(self, sender):
-        """Initialize a SenderFeature
-
-        Parameters
-        ----------
-        sender : Address
-            Sender address
-        """
-        super().__init__(int(FeatureType.Sender), address=sender)
+    """Sender feature.
+    Attributes:
+        address: A given sender address.
+    """
+    address: Ed25519Address | AliasAddress | NFTAddress
+    type: int = field(
+        default_factory=lambda: int(
+            FeatureType.Sender),
+        init=False)
 
 
+@dataclass
 class IssuerFeature(Feature):
-    def __init__(self, issuer):
-        """Initialize an IssuerFeature
-
-        Parameters
-        ----------
-        issuer : Address
-            Issuer address
-        """
-        super().__init__(int(FeatureType.Issuer), address=issuer)
+    """Issuer feature.
+    Attributes:
+        address: A given issuer address.
+    """
+    address: Ed25519Address | AliasAddress | NFTAddress
+    type: int = field(
+        default_factory=lambda: int(
+            FeatureType.Issuer),
+        init=False)
 
 
+@dataclass
 class MetadataFeature(Feature):
-    def __init__(self, data: HexStr):
-        """Initialize a MetadataFeature
-
-        Parameters
-        ----------
-        data : HexStr
-            Hex encoded metadata
-        """
-        super().__init__(int(FeatureType.Metadata), data=data)
+    """Metadata feature.
+    Attributes:
+        data: Some hex encoded metadata.
+    """
+    data: HexStr
+    type: int = field(
+        default_factory=lambda: int(
+            FeatureType.Metadata),
+        init=False)
 
 
+@dataclass
 class TagFeature(Feature):
-    def __init__(self, tag: HexStr):
-        """Initialize a TagFeature
-
-        Parameters
-        ----------
-        tag : HexStr
-            Hex encoded tag used to index the output
-        """
-        super().__init__(int(FeatureType.Tag), tag=tag)
+    """Tag feature.
+    Attributes:
+        tag: A hex encoded tag used to index the output.
+    """
+    tag: HexStr
+    type: int = field(default_factory=lambda: int(FeatureType.Tag), init=False)
```

## iota_sdk/types/native_token.py

```diff
@@ -3,9 +3,15 @@
 
 from iota_sdk.types.common import HexStr
 from dataclasses import dataclass
 
 
 @dataclass
 class NativeToken():
+    """A native token.
+
+    Attributes:
+        id: The unique identifier of the native token.
+        amount: The amount of native tokens.
+    """
     id: HexStr
     amount: HexStr
```

## iota_sdk/types/node_info.py

```diff
@@ -6,91 +6,139 @@
 from typing import List, Optional
 from iota_sdk.types.common import HexStr
 
 
 @dataclass
 class NodeInfoMilestone:
     """Milestone info.
-    """
 
+    Attributes:
+        index: The milestone index.
+        timestamp: The milestone timestamp.
+        milestoneId: The milestone ID.
+    """
     index: int
     timestamp: Optional[int] = None
     milestoneId: Optional[HexStr] = None
 
 
 @dataclass
 class NodeInfoStatus:
     """Node status.
-    """
 
+    Attributes:
+        isHealthy: Whether the node is healthy.
+        latestMilestone: The latest milestone info.
+        confirmedMilestone: The latest confirmed milestone info.
+        pruningIndex: The pruning index of the node.
+    """
     isHealthy: bool
     latestMilestone: NodeInfoMilestone
     confirmedMilestone: NodeInfoMilestone
     pruningIndex: int
 
 
 @dataclass
 class NodeInfoMetrics:
     """Node metrics.
-    """
 
+    Attributes:
+        blocksPerSecond: The blocks per second gossiped in the network.
+        referencedBlocksPerSecond: The referenced blocks per second in the network.
+        referencedRate: The percentage of blocks that get referenced.
+    """
     blocksPerSecond: float
     referencedBlocksPerSecond: float
     referencedRate: float
 
 
 @dataclass
 class RentStructure:
     """Rent structure for the storage deposit.
+
+    Attributes:
+        vByteCost: The cost of base coin per virtual byte.
+        vByteFactorData: The weight factor used for key fields in the outputs.
+        vByteFactorKey: The weight factor used for data fields in the outputs.
     """
     vByteCost: int
     vByteFactorData: int
     vByteFactorKey: int
 
 
 @dataclass
 class NodeInfoProtocol:
     """Protocol info.
-    """
 
+    Attributes:
+        networkName: The human friendly name of the network.
+        bech32Hrp: The HRP prefix used for Bech32 addresses in the network.
+        tokenSupply: TokenSupply defines the current token supply on the network.
+        version: The version of the protocol running.
+        minPowScore: The minimum pow score of the network.
+        rentStructure: The rent structure used by given node/network.
+    """
     networkName: str
     bech32Hrp: str
     tokenSupply: str
     version: int
     minPowScore: float
     rentStructure: RentStructure
 
 
 @dataclass
 class PendingProtocolParameter:
     """Pending protocol parameters.
-    """
 
+    Attributes:
+        type: Type of change.
+        targetMilestoneIndex: Milestone index at which the new protocol parameters become active.
+        protocolVersion: The new protocol version.
+        params: The new protocol parameters.
+    """
     type: int
     targetMilestoneIndex: int
     protocolVersion: int
     params: str
 
 
 @dataclass
 class NodeInfoBaseToken:
-    """The base token info.
-    """
+    """The base coin info.
 
+    Attributes:
+        name: Name of the base coin.
+        tickerSymbol: Base coin ticker symbol.
+        unit: Base coin unit.
+        decimals: Number of decimals.
+        useMetricPrefix: Whether the coin uses a metric prefix.
+        subunit: Base coin subunit.
+    """
     name: str
     tickerSymbol: str
     unit: str
     decimals: int
     useMetricPrefix: bool
     subunit: Optional[str] = None
 
 
 @dataclass
 class NodeInfo:
     """Response from the /info endpoint.
+
+    Attributes:
+        name: The name of the node (e.g. Hornet).
+        version: The version of the node.
+        status: The status of the node.
+        metrics: Some node metrics.
+        supportedProtocolVersions: Supported protocol versions by the ndoe.
+        protocol: Information about the running protocol.
+        pendingProtocolParameters: A list of pending (not yet active) protocol parameters.
+        baseToken: Information about the base token.
+        features: List of features supported by the node.
     """
 
     name: str
     version: str
     status: NodeInfoStatus
     metrics: NodeInfoMetrics
     supportedProtocolVersions: List[int]
@@ -99,10 +147,14 @@
     baseToken: NodeInfoBaseToken
     features: List[str]
 
 
 @dataclass
 class NodeInfoWrapper:
     """NodeInfo wrapper which contains the node info and the url from the node.
+
+    Attributes:
+        nodeInfo: A NodeInfo object.
+        url: The URL of the node.
     """
     nodeInfo: NodeInfo
     url: str
```

## iota_sdk/types/output.py

```diff
@@ -1,50 +1,50 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
-from dataclasses import dataclass
+from dataclasses import dataclass, field
 from enum import IntEnum
 from typing import Dict, Optional, List
 from iota_sdk.types.common import HexStr
-from iota_sdk.types.feature import Feature
+from iota_sdk.types.feature import SenderFeature, IssuerFeature, MetadataFeature, TagFeature
 from iota_sdk.types.native_token import NativeToken
-from iota_sdk.types.token_scheme import TokenScheme
-from iota_sdk.types.unlock_condition import UnlockCondition
+from iota_sdk.types.token_scheme import SimpleTokenScheme
+from iota_sdk.types.unlock_condition import AddressUnlockCondition, StorageDepositReturnUnlockCondition, TimelockUnlockCondition, ExpirationUnlockCondition, StateControllerAddressUnlockCondition, GovernorAddressUnlockCondition, ImmutableAliasAddressUnlockCondition
 
 
 class OutputType(IntEnum):
+    """Output types.
+
+    Attributes:
+        Treasury (2): A treasury output.
+        Basic (3): A basic output.
+        Alias (4): An alias output.
+        Foundry (5): A foundry output.
+        Nft (6): An NFT output.
+    """
     Treasury = 2
     Basic = 3
     Alias = 4
     Foundry = 5
     Nft = 6
 
 
 @dataclass
 class Output():
+    """An output in a UTXO ledger.
+    """
     type: int
-    amount: str
-    unlockConditions: List[UnlockCondition]
-    aliasId: Optional[HexStr] = None
-    nftId: Optional[HexStr] = None
-    stateIndex: Optional[int] = None
-    stateMetadata: Optional[HexStr] = None
-    foundryCounter: Optional[int] = None
-    features: Optional[List[Feature]] = None
-    nativeTokens: Optional[List[NativeToken]] = None
-    immutableFeatures: Optional[List[Feature]] = None
-    serialNumber: Optional[int] = None
-    tokenScheme: Optional[TokenScheme] = None
 
     def as_dict(self):
-        config = {k: v for k, v in self.__dict__.items() if v != None}
+        config = {k: v for k, v in self.__dict__.items() if v is not None}
 
-        config['unlockConditions'] = list(map(
-            lambda x: x.as_dict(), config['unlockConditions']))
+        if 'unlockConditions' in config:
+            config['unlockConditions'] = list(map(
+                lambda x: x.as_dict(), config['unlockConditions']))
         if 'nativeTokens' in config:
             config['nativeTokens'] = list(map(
                 lambda x: x.__dict__, config['nativeTokens']))
         if 'features' in config:
             config['features'] = list(map(
                 lambda x: x.as_dict(), config['features']))
         if 'immutableFeatures' in config:
@@ -53,18 +53,180 @@
         if 'tokenScheme' in config:
             config['tokenScheme'] = config['tokenScheme'].__dict__
 
         return config
 
 
 @dataclass
+class TreasuryOutput(Output):
+    """Describes a treasury output.
+    Attributes:
+        amount :
+            The base coin amount of the output.
+        type :
+            The type of output.
+    """
+    amount: str
+    type: int = field(
+        default_factory=lambda: int(
+            OutputType.Treasury),
+        init=False)
+
+
+@dataclass
+class BasicOutput(Output):
+    """Describes a basic output.
+    Attributes:
+        amount :
+            The base coin amount of the output.
+        unlockConditions :
+            The conditions to unlock the output.
+        features :
+            Features that add utility to the output but do not impose unlocking conditions.
+        nativeTokens :
+            Native tokens added to the new output.
+        type :
+            The type of output.
+    """
+    amount: str
+    unlockConditions: List[AddressUnlockCondition | ExpirationUnlockCondition | StorageDepositReturnUnlockCondition |
+                           TimelockUnlockCondition]
+    features: Optional[List[SenderFeature |
+                            MetadataFeature | TagFeature]] = None
+    nativeTokens: Optional[List[NativeToken]] = None
+    type: int = field(
+        default_factory=lambda: int(
+            OutputType.Basic),
+        init=False)
+
+
+@dataclass
+class AliasOutput(Output):
+    """Describes an alias output.
+    Attributes:
+        amount :
+            The base coin amount of the output.
+        unlockConditions :
+            The conditions to unlock the output.
+        aliasId :
+            The alias ID if it's an alias output.
+        stateIndex :
+            A counter that must increase by 1 every time the alias is state transitioned.
+        stateMetadata :
+            Metadata that can only be changed by the state controller.
+        foundryCounter :
+            A counter that denotes the number of foundries created by this alias account.
+        features :
+            Features that add utility to the output but do not impose unlocking conditions.
+        nativeTokens :
+            Native tokens added to the new output.
+        immutableFeatures :
+            Features that add utility to the output but do not impose unlocking conditions. These features need to be kept in future transitions of the UTXO state machine.
+        type :
+            The type of output.
+    """
+    amount: str
+    aliasId: HexStr
+    stateIndex: int
+    foundryCounter: int
+    unlockConditions: List[StateControllerAddressUnlockCondition |
+                           GovernorAddressUnlockCondition]
+    features: Optional[List[SenderFeature |
+                            MetadataFeature]] = None
+    immutableFeatures: Optional[List[IssuerFeature |
+                                     MetadataFeature]] = None
+    stateMetadata: Optional[HexStr] = None
+    nativeTokens: Optional[List[NativeToken]] = None
+    type: int = field(
+        default_factory=lambda: int(
+            OutputType.Alias),
+        init=False)
+
+
+@dataclass
+class FoundryOutput(Output):
+    """Describes a foundry output.
+    Attributes:
+        amount :
+            The base coin amount of the output.
+        unlockConditions :
+            The conditions to unlock the output.
+        features :
+            Features that add utility to the output but do not impose unlocking conditions.
+        nativeTokens :
+            Native tokens added to the new output.
+        immutableFeatures :
+            Features that add utility to the output but do not impose unlocking conditions. These features need to be kept in future transitions of the UTXO state machine.
+        serialNumber :
+            The serial number of the foundry with respect to the controlling alias.
+        tokenScheme :
+            Defines the supply control scheme of the tokens controlled by the foundry. Currently only a simple scheme is supported.
+        type :
+            The type of output.
+    """
+    amount: str
+    serialNumber: int
+    tokenScheme: SimpleTokenScheme
+    unlockConditions: List[ImmutableAliasAddressUnlockCondition]
+    features: Optional[List[MetadataFeature]] = None
+    immutableFeatures: Optional[List[MetadataFeature]] = None
+    nativeTokens: Optional[List[NativeToken]] = None
+    type: int = field(
+        default_factory=lambda: int(
+            OutputType.Foundry),
+        init=False)
+
+
+@dataclass
+class NftOutput(Output):
+    """Describes an NFT output.
+    Attributes:
+        amount :
+            The base coin amount of the output.
+        unlockConditions :
+            The conditions to unlock the output.
+        nftId :
+            The NFT ID if it's an NFT output.
+        features :
+            Features that add utility to the output but do not impose unlocking conditions.
+        nativeTokens :
+            Native tokens added to the new output.
+        immutableFeatures :
+            Features that add utility to the output but do not impose unlocking conditions. These features need to be kept in future transitions of the UTXO state machine.
+        type :
+            The type of output.
+    """
+    amount: str
+    nftId: HexStr
+    unlockConditions: List[AddressUnlockCondition | ExpirationUnlockCondition |
+                           StorageDepositReturnUnlockCondition | TimelockUnlockCondition]
+    features: Optional[List[SenderFeature |
+                            MetadataFeature | TagFeature]] = None
+    immutableFeatures: Optional[List[
+        IssuerFeature | MetadataFeature]] = None
+    nativeTokens: Optional[List[NativeToken]] = None
+    type: int = field(default_factory=lambda: int(OutputType.Nft), init=False)
+
+
+@dataclass
 class OutputMetadata:
     """Metadata about an output.
-    """
 
+    Attributes:
+        blockId: The ID of the block in which the output appeared in.
+        transactionId: The ID of the transaction in which the output was created.
+        outputIndex: The index of the output within the corresponding transaction.
+        isSpent: Whether the output is already spent.
+        milestoneIndexBooked: The index of the milestone which booked/created the output.
+        milestoneTimestampBooked: The timestamp of the milestone which booked/created the output.
+        ledgerIndex: The current ledger index.
+        milestoneIndexSpent: The index of the milestone which spent the output.
+        milestoneTimestampSpent: The timestamp of the milestone which spent the output.
+        transactionIdSpent: The ID of the transaction that spent the output.
+    """
     blockId: HexStr
     transactionId: HexStr
     outputIndex: int
     isSpent: bool
     milestoneIndexBooked: int
     milestoneTimestampBooked: int
     ledgerIndex: int
@@ -76,22 +238,29 @@
     def from_dict(cls, dict: Dict) -> OutputMetadata:
         obj = cls.__new__(cls)
         super(OutputMetadata, obj).__init__()
         for k, v in dict.items():
             setattr(obj, k, v)
         return obj
 
+    def as_dict(self):
+        return {k: v for k, v in self.__dict__.items() if v is not None}
+
 
 @dataclass
 class OutputWithMetadata:
     """An output with its metadata.
+
+    Attributes:
+        metadata: The `OutputMetadata` object that belongs to `output`.
+        output: An `Output` object.
     """
 
     metadata: OutputMetadata
-    output: Output
+    output: AliasOutput | FoundryOutput | NftOutput | BasicOutput
 
     @classmethod
     def from_dict(cls, dict: Dict) -> OutputWithMetadata:
         obj = cls.__new__(cls)
         super(OutputWithMetadata, obj).__init__()
         for k, v in dict.items():
             setattr(obj, k, v)
```

## iota_sdk/types/output_data.py

```diff
@@ -1,21 +1,35 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
 from dataclasses import dataclass
-from typing import Optional, List
-from iota_sdk.types.address import Address
+from typing import Optional
+from iota_sdk.types.address import Ed25519Address, AliasAddress, NFTAddress
 from iota_sdk.types.common import HexStr
-from iota_sdk.types.output import Output, OutputMetadata
+from iota_sdk.types.output import BasicOutput, AliasOutput, FoundryOutput, NftOutput, OutputMetadata
+from iota_sdk.types.signature import Bip44
 
 
 @dataclass
 class OutputData():
+    """Output data.
+
+    Attributes:
+        outputId: With the output data corresponding output ID.
+        metadata: With the output corresponding metadata.
+        output: The output object itself.
+        isSpent: Whether the output is spent.
+        address: The address associated with the output.
+        networkId: The network ID the output belongs to.
+        remainder: Whether the output represents a remainder amount.
+        chain: A list of chain state indexes.
+    """
+
     outputId: HexStr
     metadata: OutputMetadata
-    output: Output
+    output: AliasOutput | FoundryOutput | NftOutput | BasicOutput
     isSpent: bool
-    address: Address
+    address: Ed25519Address | AliasAddress | NFTAddress
     networkId: str
     remainder: bool
-    chain: Optional[List[int]] = None
+    chain: Optional[Bip44] = None
```

## iota_sdk/types/output_id.py

```diff
@@ -1,14 +1,23 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from iota_sdk.types.common import HexStr
 
 
 class OutputId(dict):
+    """Represents an output ID.
+
+    Attributes:
+        output_id: The unique id of an output.
+        transaction_id: The transaction id associated with the output.
+        output_index: The index of the output within a transaction.
+
+    """
+
     def __init__(self, transaction_id: HexStr, output_index: int):
         """Initialize OutputId
         """
         if len(transaction_id) != 66:
             raise ValueError(
                 'transaction_id length must be 66 characters with 0x prefix')
         if not transaction_id.startswith('0x'):
@@ -20,14 +29,22 @@
         output_index_hex = (output_index).to_bytes(2, "little").hex()
         self.output_id = transaction_id + output_index_hex
         self.transaction_id = transaction_id
         self.output_index = output_index
 
     @classmethod
     def from_string(cls, output_id: HexStr):
+        """Creates an `OutputId` instance from a `HexStr`.
+
+        Args:
+            output_id: The unique id of an output as a hex string.
+
+        Returns:
+            OutputId: The unique id of an output.
+        """
         obj = cls.__new__(cls)
         super(OutputId, obj).__init__()
         if len(output_id) != 70:
             raise ValueError(
                 'output_id length must be 70 characters with 0x prefix')
         if not output_id.startswith('0x'):
             raise ValueError('transaction_id must start with 0x')
```

## iota_sdk/types/payload.py

```diff
@@ -1,86 +1,150 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from __future__ import annotations
 from iota_sdk.types.common import HexStr
+from iota_sdk.types.output import BasicOutput, AliasOutput, FoundryOutput, NftOutput
+from iota_sdk.types.input import UtxoInput
 from iota_sdk.types.signature import Ed25519Signature
-from dataclasses import dataclass
-from enum import Enum
+from iota_sdk.types.unlock import SignatureUnlock, ReferenceUnlock
+from dacite import from_dict
+from dataclasses import dataclass, field
+from enum import IntEnum
 from typing import Any, Optional, List
 
 
-class PayloadType(Enum):
+class PayloadType(IntEnum):
+    """Block payload types.
+
+    Attributes:
+        TreasuryTransaction (4): A treasury transaction payload.
+        TaggedData (5): A tagged data payload.
+        Transaction (6): A transaction payload.
+        Milestone (7): A milestone payload.
+    """
     TreasuryTransaction = 4
     TaggedData = 5
     Transaction = 6
     Milestone = 7
 
 
-class Payload():
-    def __init__(self, type,  milestone: Optional[Any] = None, tagged_data=None, transaction=None, treasury_transaction: Optional[Any] = None):
-        """Initialize a payload
-        """
-        self.type = type
-        self.milestone = milestone
-        self.tagged_data = tagged_data
-        self.transaction = transaction
-        self.treasury_transaction = treasury_transaction
+@dataclass
+class TransactionEssence:
+    type: int
+
+
+@dataclass
+class RegularTransactionEssence(TransactionEssence):
+    networkId: str
+    inputsCommitment: HexStr
+    inputs: List[UtxoInput]
+    outputs: List[AliasOutput | FoundryOutput | NftOutput | BasicOutput]
+    payload: Optional[TaggedDataPayload] = None
+    type: int = field(default_factory=lambda: 1, init=False)
 
     def as_dict(self):
-        config = {k: v for k, v in self.__dict__.items() if v != None}
+        config = {k: v for k, v in self.__dict__.items() if v is not None}
 
-        if "milestone" in config:
-            del config["milestone"]
-        if "tagged_data" in config:
-            del config["tagged_data"]
-        if "transaction" in config:
-            del config["transaction"]
-        if "treasury_transaction" in config:
-            del config["treasury_transaction"]
+        if 'payload' in config:
+            config['payload'] = config['payload'].as_dict()
 
-        config['type'] = config['type'].value
+        config['inputs'] = list(map(
+            lambda x: x.__dict__, config['inputs']))
+
+        config['outputs'] = list(map(
+            lambda x: x.as_dict(), config['outputs']))
+
+        return config
+
+
+@dataclass
+class Payload():
+    """Initialize a Payload.
+    """
+    type: int
+
+    def as_dict(self):
+        config = {k: v for k, v in self.__dict__.items() if v is not None}
+
+        if 'essence' in config:
+            config['essence'] = config['essence'].as_dict()
+        if 'unlocks' in config:
+            def convert_to_dict(c):
+                try:
+                    return c.as_dict()
+                except AttributeError:
+                    return c.__dict__
+            config['unlocks'] = list(map(convert_to_dict, config['unlocks']))
+        if 'signatures' in config:
+            config['signatures'] = list(map(
+                lambda x: x.__dict__, config['signatures']))
 
         return config
 
 
 @dataclass
 class MilestonePayload(Payload):
-    """Initialize a MilestonePayload
+    """A milestone payload.
+
+    Attributes:
+        index: The index of corresponding milestone.
+        timestamp: The timestamp of the corresponding milestone.
+        protocolVersion: The current protocol version.
+        previousMilestoneId: The ID of the previous milestone.
+        parents: The parents of the milestone.
+        inclusionMerkleRoot: The merkle root of all blocks included in the milestone cone.
+        appliedMerkleRoot: The merkle root of all applied transactions in the milestone cone.
+        signatures: The signatures that verify the milestone.
+        options: The milestone options (e.g. receipt milestone option).
+        metadata: Some hex encoded milestone metadata.
     """
     index: int
     timestamp: int
     protocolVersion: int
     previousMilestoneId: HexStr
     parents: List[HexStr]
     inclusionMerkleRoot: HexStr
     appliedMerkleRoot: HexStr
     signatures: List[Ed25519Signature]
     options: Optional[List[Any]] = None
     metadata: Optional[HexStr] = None
+    type: int = field(
+        default_factory=lambda: int(
+            PayloadType.Milestone),
+        init=False)
 
     @classmethod
-    def from_dict(cls, milestone) -> MilestonePayload:
-        obj = cls.__new__(cls)
-        super(MilestonePayload, obj).__init__(milestone["type"])
-        del milestone["type"]
-        for k, v in milestone.items():
-            setattr(obj, k, v)
-        return obj
+    def from_dict(cls, milestone_dict) -> MilestonePayload:
+        return from_dict(MilestonePayload, milestone_dict)
 
 
+@dataclass
 class TaggedDataPayload(Payload):
-    def __init__(self, tag: HexStr, data: HexStr):
-        """Initialize a TaggedDataPayload
-        """
-        self.tag = tag
-        self.data = data
-        super().__init__(PayloadType.TaggedData, tagged_data=self)
+    """A tagged data payload.
+
+    Attributes:
+        tag: The tag part of the tagged data payload.
+        data: The data part of the tagged data payload.
+    """
+    tag: HexStr
+    data: HexStr
+    type: int = field(
+        default_factory=lambda: int(
+            PayloadType.TaggedData),
+        init=False)
 
 
+@dataclass
 class TransactionPayload(Payload):
-    def __init__(self, essence, unlocks):
-        """Initialize a TransactionPayload
-        """
-        self.essence = essence
-        self.unlocks = unlocks
-        super().__init__(PayloadType.Transaction, transaction=self)
+    """A transaction payload.
+
+    Attributes:
+        essence: The transaction essence.
+        unlocks: The unlocks of the transaction.
+    """
+    essence: RegularTransactionEssence
+    unlocks: List[SignatureUnlock | ReferenceUnlock]
+    type: int = field(
+        default_factory=lambda: int(
+            PayloadType.Transaction),
+        init=False)
```

## iota_sdk/types/signature.py

```diff
@@ -1,11 +1,42 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
-from dataclasses import dataclass
-from iota_sdk.types.common import HexStr
+from dataclasses import dataclass, field
+from iota_sdk.types.common import HexStr, CoinType
+
 
 @dataclass
-class Ed25519Signature():
+class Signature():
+    """Base class of a signature.
+    """
+    type: int
+
+
+@dataclass
+class Ed25519Signature(Signature):
+    """An Ed25519 signature.
+
+    Attributes:
+        publicKey: The Ed25519 public key.
+        signature: The Ed25519 signature of some message.
+        type: The Ed25519 signature type.
+    """
     publicKey: HexStr
     signature: HexStr
-    type: int = 0
+    type: int = field(default_factory=lambda: 0, init=False)
+
+
+@dataclass
+class Bip44():
+    """A BIP44 chain.
+
+    Attributes:
+        coinType: The coin type segment.
+        account: The account segment.
+        change: The change segment.
+        addressIndex: The address index segment.
+    """
+    coinType: int = CoinType.IOTA
+    account: int = 0
+    change: int = 0
+    addressIndex: int = 0
```

## iota_sdk/types/token_scheme.py

```diff
@@ -1,24 +1,39 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
-from dataclasses import dataclass
+from dataclasses import dataclass, field
 from iota_sdk.types.common import HexStr
 
 
 @dataclass
 class TokenScheme():
+    """Base class of a token scheme.
+    """
+    type: int
+
+
+@dataclass
+class SimpleTokenScheme(TokenScheme):
+    """A simple token scheme.
+
+    Attributes:
+        mintedTokens: The number of tokens that were minted.
+        meltedTokens: The number of tokens that were melted.
+        maximumSupply: The maximum supply of the token.
+        type: The type code of the token scheme.
+    """
     mintedTokens: HexStr
     meltedTokens: HexStr
     maximumSupply: HexStr
-    type: int = 0
+    type: int = field(default_factory=lambda: 0, init=False)
 
     def as_dict(self):
         config = dict(self.__dict__)
-        
+
         if isinstance(config['mintedTokens'], int):
             config['mintedTokens'] = str(hex(config['mintedTokens']))
         if isinstance(config['meltedTokens'], int):
             config['meltedTokens'] = str(hex(config['meltedTokens']))
         if isinstance(config['maximumSupply'], int):
             config['maximumSupply'] = str(hex(config['maximumSupply']))
```

## iota_sdk/types/transaction.py

```diff
@@ -7,25 +7,43 @@
 from iota_sdk.types.common import HexStr
 from iota_sdk.types.output import OutputWithMetadata
 from iota_sdk.types.payload import TransactionPayload
 from enum import Enum
 
 
 class InclusionState(str, Enum):
+    """Inclusion state variants of a transaction.
+
+    Attributes:
+        Pending: The transaction is pending.
+        Confirmed: The transaction is confirmed.
+        Conflicting: The transaction is conflicting.
+        UnknownPruned: The transaction is unknown or already pruned.
+    """
     Pending = 'pending'
     Confirmed = 'confirmed'
     Conflicting = 'conflicting'
     UnknownPruned = 'unknownPruned'
 
 
 @dataclass
 class Transaction:
-    """The transaction payload with metadata.
-    """
+    """A transaction with some metadata.
 
+    Attributes:
+        payload: The transaction payload.
+        inclusionState: The inclusion state of the transaction.
+        timestamp: The timestamp of the transaction.
+        transactionId: The ID of the corresponding transaction.
+        networkId: The ID of the network this transaction was issued in.
+        incoming: Indicates whether the transaction was created by the wallet or whether it was sent by someone else and is incoming.
+        inputs: The inputs of the transaction.
+        note: A note attached to the transaction.
+        blockId: The ID of the block that holds the transaction.
+    """
     payload: TransactionPayload
     inclusionState: InclusionState
     timestamp: int
     transactionId: HexStr
     networkId: int
     incoming: bool
     inputs = List[OutputWithMetadata]
```

## iota_sdk/types/transaction_options.py

```diff
@@ -5,14 +5,23 @@
 from iota_sdk.types.output_id import OutputId
 from iota_sdk.types.payload import TaggedDataPayload
 from enum import Enum
 from typing import Optional, List
 
 
 class RemainderValueStrategyCustomAddress:
+    """Remainder value strategy for custom addresses.
+
+    Attributes:
+        address: An address to move the remainder value to.
+        key_index: The address key index.
+        internal: Determines if an address is a public or an internal (change) address.
+        used: Indicates whether an address has been used already.
+    """
+
     def __init__(self,
                  address: str,
                  key_index: int,
                  internal: bool,
                  used: bool):
         self.address = address
         self.keyIndex = key_index
@@ -20,30 +29,48 @@
         self.used = used
 
     def as_dict(self):
         return dict({"strategy": "CustomAddress", "value": self.__dict__})
 
 
 class RemainderValueStrategy(Enum):
+    """Remainder value stragegy variants.
+
+    Attributes:
+        ChangeAddress: Allows to move the remainder value to a change address.
+        ReuseAddress: Allows to keep the remainder value on the source address.
+    """
     ChangeAddress = None,
     ReuseAddress = None,
 
     def as_dict(self):
         return dict({"strategy": self.name, "value": self.value[0]})
 
 
 class TransactionOptions():
+    """Transaction options.
+
+    Attributes:
+        remainder_value_strategy: The strategy applied for base coin remainders.
+        tagged_data_payload: An optional tagged data payload.
+        custom_inputs: If custom inputs are provided only those are used. If also other additional inputs should be used, `mandatory_inputs` should be used instead.
+        mandatory_inputs: Inputs that must be used for the transaction.
+        burn: Specifies what needs to be burned during input selection.
+        note: A string attached to the transaction.
+        allow_micro_amount: Whether to allow sending a micro amount.
+    """
+
     def __init__(self, remainder_value_strategy: Optional[RemainderValueStrategy | RemainderValueStrategyCustomAddress] = None,
                  tagged_data_payload: Optional[TaggedDataPayload] = None,
                  custom_inputs: Optional[List[OutputId]] = None,
                  mandatory_inputs: Optional[List[OutputId]] = None,
                  burn: Optional[Burn] = None,
                  note: Optional[str] = None,
                  allow_micro_amount: Optional[bool] = None):
-        """Initialize TransactionOptions
+        """Initialize transaction options.
         """
         self.remainder_value_strategy = remainder_value_strategy
         self.tagged_data_payload = tagged_data_payload
         self.custom_inputs = custom_inputs
         self.mandatory_inputs = mandatory_inputs
         self.burn = burn
         self.note = note
```

## iota_sdk/types/unlock_condition.py

```diff
@@ -1,127 +1,137 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
-from iota_sdk.types.address import Address
+from iota_sdk.types.address import Ed25519Address, AliasAddress, NFTAddress
 from enum import IntEnum
-from typing import Optional
-from dataclasses import dataclass
+from dataclasses import dataclass, field
 
 
 class UnlockConditionType(IntEnum):
+    """Unlock condition variants.
+
+    Attributes:
+        Address (0): An address unlock condition.
+        StorageDepositReturn (1): A storage deposit return unlock condition.
+        Timelock (2): A timelock unlock condition.
+        Expiration (3): An expiration unlock condition.
+        StateControllerAddress (4): A state controller address unlock condition.
+        GovernorAddress (5): A governor address unlock condition.
+        ImmutableAliasAddress (6): An immutable alias address unlock condition.
+    """
     Address = 0
     StorageDepositReturn = 1
     Timelock = 2
     Expiration = 3
     StateControllerAddress = 4
     GovernorAddress = 5
     ImmutableAliasAddress = 6
 
 
 @dataclass
 class UnlockCondition():
+    """Base class for unlock conditions.
+    """
     type: int
-    amount: Optional[str] = None
-    address: Optional[Address] = None
-    unixTime: Optional[int] = None
-    returnAddress: Optional[Address] = None
 
     def as_dict(self):
-        config = {k: v for k, v in self.__dict__.items() if v != None}
+        config = {k: v for k, v in self.__dict__.items() if v is not None}
+
+        if 'amount' in config:
+            if isinstance(config['amount'], int):
+                config['amount'] = str(config['amount'])
 
         if 'address' in config:
             config['address'] = config['address'].as_dict()
 
         if 'returnAddress' in config:
             config['returnAddress'] = config['returnAddress'].as_dict()
 
         return config
 
 
+@dataclass
 class AddressUnlockCondition(UnlockCondition):
-    def __init__(self, address):
-        """Initialize an AddressUnlockCondition
+    """An address unlock condition.
 
-        Parameters
-        ----------
-        address : Address
-            Address
-        """
-        super().__init__(type=UnlockConditionType.Address, address=address)
+    Args:
+        address: An address unlocked with a private key.
+    """
+    address: Ed25519Address | AliasAddress | NFTAddress
+    type: int = field(
+        default_factory=lambda: int(
+            UnlockConditionType.Address),
+        init=False)
 
 
+@dataclass
 class StorageDepositReturnUnlockCondition(UnlockCondition):
-    def __init__(self, amount, return_address):
-        """Initialize a StorageDepositReturnUnlockCondition
-
-        Parameters
-        ----------
-        amount : int
-            Amount
-        return_address : Address
-            Return address
-        """
-        super().__init__(type=UnlockConditionType.StorageDepositReturn,
-                         amount=str(amount), returnAddress=return_address)
+    """A storage-deposit-return unlock condition.
+    Args:
+        amount: The amount of base coins the consuming transaction must deposit to `return_address`.
+        return_address: The address to return the amount to.
+    """
+    amount: str
+    returnAddress: Ed25519Address | AliasAddress | NFTAddress
+    type: int = field(default_factory=lambda: int(
+        UnlockConditionType.StorageDepositReturn), init=False)
 
 
+@dataclass
 class TimelockUnlockCondition(UnlockCondition):
-    def __init__(self, unix_time):
-        """Initialize a TimelockUnlockCondition
-
-        Parameters
-        ----------
-        unix_time : int
-            Unix timestamp at which to unlock output
-        """
-        super().__init__(type=UnlockConditionType.Timelock, unixTime=unix_time)
+    """A timelock unlock condition.
+    Args:
+        unix_time: The Unix timestamp marking the end of the timelock.
+    """
+    unixTime: int
+    type: int = field(
+        default_factory=lambda: int(
+            UnlockConditionType.Timelock),
+        init=False)
 
 
+@dataclass
 class ExpirationUnlockCondition(UnlockCondition):
-    def __init__(self, unix_time, return_address):
-        """Initialize an ExpirationUnlockCondition
-
-        Parameters
-        ----------
-        unix_time : int
-            Unix timestamp
-        return_address : Address
-            Return address
-        """
-        super().__init__(type=UnlockConditionType.Expiration,
-                         unixTime=unix_time, returnAddress=return_address)
+    """An expiration unlock condition.
+    Args:
+        unix_time: Unix timestamp marking the expiration of the claim.
+        return_address: The return address if the output was not claimed in time.
+    """
+    unixTime: int
+    returnAddress: Ed25519Address | AliasAddress | NFTAddress
+    type: int = field(
+        default_factory=lambda: int(
+            UnlockConditionType.Expiration),
+        init=False)
 
 
+@dataclass
 class StateControllerAddressUnlockCondition(UnlockCondition):
-    def __init__(self, address):
-        """Initialize a StateControllerAddressUnlockCondition
-
-        Parameters
-        ----------
-        address : Address
-            Address for unlock condition
-        """
-        super().__init__(type=UnlockConditionType.StateControllerAddress, address=address)
+    """A state controller address unlock condition.
+    Args:
+        address: The state controller address that owns the output.
+    """
+    address: Ed25519Address | AliasAddress | NFTAddress
+    type: int = field(default_factory=lambda: int(
+        UnlockConditionType.StateControllerAddress), init=False)
 
 
+@dataclass
 class GovernorAddressUnlockCondition(UnlockCondition):
-    def __init__(self, address):
-        """Initialize a GovernorAddressUnlockCondition
-
-        Parameters
-        ----------
-        address : Address
-            Address for unlock condition
-        """
-        super().__init__(type=UnlockConditionType.GovernorAddress, address=address)
+    """A governor address unlock condition.
+    Args:
+        address: The governor address that owns the output.
+    """
+    address: Ed25519Address | AliasAddress | NFTAddress
+    type: int = field(default_factory=lambda: int(
+        UnlockConditionType.GovernorAddress), init=False)
 
 
+@dataclass
 class ImmutableAliasAddressUnlockCondition(UnlockCondition):
-    def __init__(self, address):
-        """Initialize an ImmutableAliasAddressUnlockCondition
-
-        Parameters
-        ----------
-        address : Address
-            Address for unlock condition
-        """
-        super().__init__(type=UnlockConditionType.ImmutableAliasAddress, address=address)
+    """An immutable alias address unlock condition.
+    Args:
+        address: The permanent alias address that owns this output.
+    """
+    address: AliasAddress
+    type: int = field(default_factory=lambda: int(
+        UnlockConditionType.ImmutableAliasAddress), init=False)
```

## iota_sdk/utils.py

```diff
@@ -12,195 +12,202 @@
 from typing import TYPE_CHECKING, List
 from dacite import from_dict
 
 # Required to prevent circular import
 if TYPE_CHECKING:
     from iota_sdk.types.block import Block
 
+
 class Utils():
+    """Utility functions.
+    """
 
     @staticmethod
     def bech32_to_hex(bech32: str) -> HexStr:
-        """Transforms bech32 to hex.
+        """Convert a Bech32 string to a hex string.
         """
         return _call_method('bech32ToHex', {
             'bech32': bech32
         })
 
     @staticmethod
     def hex_to_bech32(hex: HexStr, bech32_hrp: str) -> str:
-        """Transforms a hex encoded address to a bech32 encoded address.
+        """Convert a hex encoded address to a Bech32 encoded address.
         """
         return _call_method('hexToBech32', {
             'hex': hex,
             'bech32Hrp': bech32_hrp
         })
 
     @staticmethod
     def alias_id_to_bech32(alias_id: HexStr, bech32_hrp: str) -> str:
-        """Transforms an alias id to a bech32 encoded address.
+        """Convert an alias id to a Bech32 encoded address.
         """
         return _call_method('aliasIdToBech32', {
             'aliasId': alias_id,
             'bech32Hrp': bech32_hrp
         })
 
     @staticmethod
     def nft_id_to_bech32(nft_id: HexStr, bech32_hrp: str) -> str:
-        """Transforms an nft id to a bech32 encoded address.
+        """Convert an NFT ID to a Bech32 encoded address.
         """
         return _call_method('nftIdToBech32', {
             'nftId': nft_id,
             'bech32Hrp': bech32_hrp
         })
 
     @staticmethod
     def hex_public_key_to_bech32_address(hex: HexStr, bech32_hrp: str) -> str:
-        """Transforms a hex encoded public key to a bech32 encoded address.
+        """Convert a hex encoded public key to a Bech32 encoded address.
         """
         return _call_method('hexPublicKeyToBech32Address', {
             'hex': hex,
             'bech32Hrp': bech32_hrp
         })
 
     @staticmethod
     def parse_bech32_address(address: str) -> Address:
-        """Returns a valid Address parsed from a String.
+        """Parse a string into a valid address.
         """
         return from_dict(Address, _call_method('parseBech32Address', {
             'address': address
         }))
 
     @staticmethod
     def is_address_valid(address: str) -> bool:
-        """Checks if a String is a valid bech32 encoded address.
+        """Check whether a string is a valid Bech32 encoded address.
         """
         return _call_method('isAddressValid', {
             'address': address
         })
 
     @staticmethod
     def generate_mnemonic() -> str:
-        """Generates a new mnemonic.
+        """Generate a new mnemonic.
         """
         return _call_method('generateMnemonic')
 
     @staticmethod
     def mnemonic_to_hex_seed(mnemonic: str) -> HexStr:
-        """Returns a hex encoded seed for a mnemonic.
+        """Convert a mnemonic to a hex encoded seed.
         """
         return _call_method('mnemonicToHexSeed', {
             'mnemonic': mnemonic
         })
 
     @staticmethod
     def compute_alias_id(output_id: OutputId) -> HexStr:
-        """Computes the alias id for the given alias output id.
+        """Compute the alias id for the given alias output id.
         """
         return _call_method('computeAliasId', {
             'outputId': repr(output_id)
         })
 
     @staticmethod
-    def compute_foundry_id(alias_id: HexStr, serial_number: int, token_scheme_kind: int) -> HexStr:
-        """Computes the foundry id.
+    def compute_foundry_id(alias_id: HexStr, serial_number: int,
+                           token_scheme_kind: int) -> HexStr:
+        """Compute the foundry id.
         """
         return _call_method('computeFoundryId', {
             'aliasId': alias_id,
             'serialNumber': serial_number,
             'tokenSchemeKind': token_scheme_kind
         })
 
     @staticmethod
     def compute_inputs_commitment(inputs: List[Output]) -> HexStr:
-        """Computes the input commitment from the output objects that are used as inputs to fund the transaction.
+        """Compute the input commitment from the output objects that are used as inputs to fund the transaction.
         """
         return _call_method('computeInputsCommitment', {
             'inputs': [i.as_dict() for i in inputs]
         })
 
     @staticmethod
     def compute_storage_deposit(output, rent) -> HexStr:
-        """Computes the required storage deposit of an output.
+        """Compute the required storage deposit of an output.
         """
         return _call_method('computeStorageDeposit', {
             'output': output,
             'rent': rent
         })
 
     @staticmethod
     def compute_nft_id(output_id: OutputId) -> HexStr:
-        """Computes the NFT id for the given NFT output id.
+        """Compute the NFT id for the given NFT output id.
         """
         return _call_method('computeNftId', {
             'outputId': repr(output_id)
         })
 
     @staticmethod
     def compute_output_id(transaction_id: HexStr, index: int) -> OutputId:
-        """Computes the output id from transaction id and output index.
+        """Compute the output id from transaction id and output index.
         """
         return OutputId.from_string(_call_method('computeOutputId', {
             'id': transaction_id,
             'index': index,
         }))
 
     @staticmethod
-    def compute_token_id(alias_id: HexStr, serial_number: int, token_scheme_kind: int) -> HexStr:
-        """Computes a token id from the alias id, serial number and token scheme type.
+    def compute_token_id(alias_id: HexStr, serial_number: int,
+                         token_scheme_kind: int) -> HexStr:
+        """Compute a token id from the alias id, serial number and token scheme type.
         """
         return _call_method('computeTokenId', {
             'aliasId': alias_id,
             'serialNumber': serial_number,
             'tokenSchemeKind': token_scheme_kind
         })
 
     @staticmethod
     def block_id(block: Block) -> HexStr:
-        """ Returns a block ID (Blake2b256 hash of block bytes) from a block.
+        """ Return a block ID (Blake2b256 hash of block bytes) from a block.
         """
         return _call_method('blockId', {
-            'block': block.__dict__
+            'block': block.as_dict()
         })
 
     @staticmethod
     def hash_transaction_essence(essence) -> HexStr:
         """ Compute the hash of a transaction essence.
         """
         return _call_method('hashTransactionEssence', {
             'essence': essence
         })
 
     @staticmethod
-    def verify_ed25519_signature(signature: Ed25519Signature, message: HexStr) -> bool:
-        """Verifies an ed25519 signature against a message.
+    def verify_ed25519_signature(
+            signature: Ed25519Signature, message: HexStr) -> bool:
+        """Verify an Ed25519 signature against a message.
         """
         return _call_method('verifyEd25519Signature', {
             'signature': signature.__dict__,
             'message': message,
         })
 
     @staticmethod
-    def verify_secp256k1_ecdsa_signature(public_key: HexStr, signature: HexStr, message: HexStr) -> bool:
-        """Verifies a Secp256k1Ecdsa signature against a message.
+    def verify_secp256k1_ecdsa_signature(
+            public_key: HexStr, signature: HexStr, message: HexStr) -> bool:
+        """Verify a Secp256k1Ecdsa signature against a message.
         """
         return _call_method('verifySecp256k1EcdsaSignature', {
             'publicKey': public_key,
             'signature': signature,
             'message': message,
         })
 
 
 class UtilsError(Exception):
-    """utils error"""
+    """A utils error."""
     pass
 
 
 def _call_method(name: str, data=None):
-    """Dumps json string and call call_utils_method()
+    """Dumps json string and call call_utils_method().
     """
     message = {
         'name': name
     }
     if data:
         message['data'] = data
     message_str: str = dumps(message)
```

## iota_sdk/wallet/account.py

```diff
@@ -1,157 +1,190 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from iota_sdk.wallet.common import _call_method_routine
-from iota_sdk.wallet.prepared_transaction_data import PreparedTransactionData, PreparedCreateTokenTransaction
+from iota_sdk.wallet.prepared_transaction import PreparedTransaction, PreparedCreateTokenTransaction
 from iota_sdk.wallet.sync_options import SyncOptions
+from iota_sdk.types.address import AccountAddress, AddressWithUnspentOutputs
 from iota_sdk.types.balance import Balance
 from iota_sdk.types.burn import Burn
 from iota_sdk.types.common import HexStr
+from iota_sdk.types.filter_options import FilterOptions
 from iota_sdk.types.native_token import NativeToken
 from iota_sdk.types.output_data import OutputData
 from iota_sdk.types.output_id import OutputId
+from iota_sdk.types.output import Output
+from iota_sdk.types.output_params import OutputParams
+from iota_sdk.types.transaction_data import PreparedTransactionData, SignedTransactionData
+from iota_sdk.types.send_params import CreateAliasOutputParams, CreateNativeTokenParams, MintNftParams, SendNativeTokensParams, SendNftParams, SendParams
 from iota_sdk.types.transaction import Transaction
 from iota_sdk.types.transaction_options import TransactionOptions
 from typing import List, Optional
 from dacite import from_dict
+from dataclasses import dataclass
+
+
+@dataclass
+class AccountMetadata:
+    """Account metadata.
+
+    Attributes:
+        alias: The alias name of the account.
+        coinType: The type of coin managed with the account.
+        index: The account index.
+    """
+    alias: str
+    coinType: int
+    index: int
+
 
 class Account:
-    def __init__(self, account_id: str | int, handle):
-        self.account_id = account_id
-        self.handle = handle
+    """A wallet account.
 
-    @_call_method_routine
-    def __str__(self):
-        message = {
-            'name': 'getAccount',
-            'data': {
-                'accountId': self.account_id,
-            }
-        }
-        return message
+    Attributes:
+        meta: Some account metadata.
+        handle: The account handle.
+    """
+
+    def __init__(self, meta: dict, handle):
+        """Initializes an account.
+
+        Args:
+            meta: The account data.
+            handle: The account handle.
+        """
+        self.meta = meta
+        self.handle = handle
 
     @_call_method_routine
     def _call_account_method(self, method, data=None):
         message = {
             'name': 'callAccountMethod',
             'data': {
-                'accountId': self.account_id,
+                'accountId': self.meta["index"],
                 'method': {
                     'name': method,
                 }
             }
         }
         if data:
             message['data']['method']['data'] = data
 
         return message
 
-    def prepare_burn(self, burn: Burn, options: Optional[TransactionOptions] = None) -> PreparedTransactionData:
+    def get_metadata(self) -> AccountMetadata:
+        """Get the accounts metadata.
         """
-        A generic `prepare_burn()` function that can be used to prepare the burn of native tokens, nfts, foundries and aliases.
+        return AccountMetadata(
+            self.meta["alias"], self.meta["coinType"], self.meta["index"])
+
+    def prepare_burn(
+            self, burn: Burn, options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """A generic `prepare_burn()` function that can be used to prepare the burn of native tokens, nfts, foundries and aliases.
         """
         prepared = self._call_account_method(
             'prepareBurn', {
                 'burn': burn.as_dict(),
                 'options': options
             },
         )
-        return PreparedTransactionData(self, prepared)
+        return PreparedTransaction(self, prepared)
 
     def prepare_burn_native_token(self,
                                   token_id: HexStr,
                                   burn_amount: int,
-                                  options: Optional[TransactionOptions] = None) -> PreparedTransactionData:
+                                  options: Optional[TransactionOptions] = None) -> PreparedTransaction:
         """Burn native tokens. This doesn't require the foundry output which minted them, but will not increase
         the foundries `melted_tokens` field, which makes it impossible to destroy the foundry output. Therefore it's
         recommended to use melting, if the foundry output is available.
         """
         prepared = self._call_account_method(
             'prepareBurn', {
                 'burn': Burn().add_native_token(NativeToken(token_id, hex(burn_amount))).as_dict(),
                 'options': options
             },
         )
-        return PreparedTransactionData(self, prepared)
+        return PreparedTransaction(self, prepared)
 
     def prepare_burn_nft(self,
                          nft_id: HexStr,
-                         options: Optional[TransactionOptions] = None) -> PreparedTransactionData:
+                         options: Optional[TransactionOptions] = None) -> PreparedTransaction:
         """Burn an nft output.
         """
         prepared = self._call_account_method(
             'prepareBurn', {
                 'burn': Burn().add_nft(nft_id).as_dict(),
                 'options': options
             },
         )
-        return PreparedTransactionData(self, prepared)
+        return PreparedTransaction(self, prepared)
 
     def prepare_consolidate_outputs(self,
                                     force: bool,
-                                    output_consolidation_threshold: Optional[int] = None) -> PreparedTransactionData:
+                                    output_consolidation_threshold: Optional[int] = None) -> PreparedTransaction:
         """Consolidate outputs.
         """
         prepared = self._call_account_method(
             'prepareConsolidateOutputs', {
                 'force': force,
                 'outputConsolidationThreshold': output_consolidation_threshold
             }
         )
-        return PreparedTransactionData(self, prepared)
+        return PreparedTransaction(self, prepared)
 
     def prepare_create_alias_output(self,
-                                    params,
-                                    options: Optional[TransactionOptions] = None) -> PreparedTransactionData:
+                                    params: Optional[CreateAliasOutputParams] = None,
+                                    options: Optional[TransactionOptions] = None) -> PreparedTransaction:
         """Create an alias output.
         """
         prepared = self._call_account_method(
             'prepareCreateAliasOutput', {
                 'params': params,
                 'options': options
             }
         )
-        return PreparedTransactionData(self, prepared)
+        return PreparedTransaction(self, prepared)
 
     def prepare_destroy_alias(self,
                               alias_id: HexStr,
-                              options: Optional[TransactionOptions] = None) -> PreparedTransactionData:
+                              options: Optional[TransactionOptions] = None) -> PreparedTransaction:
         """Destroy an alias output.
         """
         prepared = self._call_account_method(
             'prepareBurn', {
                 'burn': Burn().add_alias(alias_id).as_dict(),
                 'options': options
             },
         )
-        return PreparedTransactionData(self, prepared)
+        return PreparedTransaction(self, prepared)
 
     def prepare_destroy_foundry(self,
                                 foundry_id: HexStr,
-                                options: Optional[TransactionOptions] = None) -> PreparedTransactionData:
+                                options: Optional[TransactionOptions] = None) -> PreparedTransaction:
         """Destroy a foundry output with a circulating supply of 0.
         """
         prepared = self._call_account_method(
             'prepareBurn', {
                 'burn': Burn().add_foundry(foundry_id).as_dict(),
                 'options': options
             },
         )
-        return PreparedTransactionData(self, prepared)
+        return PreparedTransaction(self, prepared)
 
-    def generate_ed25519_addresses(self, amount: int, options=None):
+    def generate_ed25519_addresses(
+            self, amount: int, options=None) -> List[AccountAddress]:
         """Generate new addresses.
         """
-        return self._call_account_method(
+        addresses = self._call_account_method(
             'generateEd25519Addresses', {
                 'amount': amount,
                 'options': options
             }
         )
+        return [from_dict(AccountAddress, address) for address in addresses]
 
     def claimable_outputs(self, outputs_to_claim: List[OutputId]):
         """Get outputs with additional unlock conditions.
         """
         return self._call_account_method(
             'claimableOutputs', {
                 'outputsToClaim': outputs_to_claim
@@ -172,39 +205,45 @@
         """
         return Transaction.from_dict(self._call_account_method(
             'getTransaction', {
                 'transactionId': transaction_id
             }
         ))
 
-    def addresses(self):
+    def addresses(self) -> List[AccountAddress]:
         """List addresses.
         """
-        return self._call_account_method(
+        addresses = self._call_account_method(
             'addresses'
         )
+        return [from_dict(AccountAddress, address) for address in addresses]
 
-    def addresses_with_unspent_outputs(self):
+    def addresses_with_unspent_outputs(
+            self) -> List[AddressWithUnspentOutputs]:
         """Returns only addresses of the account with unspent outputs.
         """
-        return self._call_account_method(
+        addresses = self._call_account_method(
             'addressesWithUnspentOutputs'
         )
+        return [from_dict(AddressWithUnspentOutputs, address)
+                for address in addresses]
 
-    def outputs(self, filter_options=None) -> List[OutputData]:
+    def outputs(
+            self, filter_options: Optional[FilterOptions] = None) -> List[OutputData]:
         """Returns all outputs of the account.
         """
         outputs = self._call_account_method(
             'outputs', {
                 'filterOptions': filter_options
             }
         )
         return [from_dict(OutputData, o) for o in outputs]
 
-    def unspent_outputs(self, filter_options=None) -> List[OutputData]:
+    def unspent_outputs(
+            self, filter_options: Optional[FilterOptions] = None) -> List[OutputData]:
         """Returns all unspent outputs of the account.
         """
         outputs = self._call_account_method(
             'unspentOutputs', {
                 'filterOptions': filter_options
             }
         )
@@ -230,228 +269,247 @@
         """Returns all pending transactions of the account.
         """
         transactions = self._call_account_method(
             'pendingTransactions'
         )
         return [Transaction.from_dict(tx) for tx in transactions]
 
-    def prepare_create_native_token(self, params, options: Optional[TransactionOptions] = None) -> PreparedTransactionData:
+    def prepare_create_native_token(self, params: CreateNativeTokenParams,
+                                    options: Optional[TransactionOptions] = None) -> PreparedTransaction:
         """Create native token.
         """
         prepared = self._call_account_method(
             'prepareCreateNativeToken', {
                 'params': params,
                 'options': options
             }
         )
-        return PreparedCreateTokenTransaction(account=self, prepared_transaction_data=prepared)
+        return PreparedCreateTokenTransaction(
+            account=self, prepared_transaction_data=prepared)
 
     def prepare_melt_native_token(self,
                                   token_id: HexStr,
                                   melt_amount: int,
-                                  options: Optional[TransactionOptions] = None) -> PreparedTransactionData:
+                                  options: Optional[TransactionOptions] = None) -> PreparedTransaction:
         """Melt native tokens. This happens with the foundry output which minted them, by increasing it's
         `melted_tokens` field.
         """
         prepared = self._call_account_method(
             'prepareMeltNativeToken', {
                 'tokenId': token_id,
                 'meltAmount': hex(melt_amount),
                 'options': options
             }
         )
-        return PreparedTransactionData(self, prepared)
+        return PreparedTransaction(self, prepared)
 
-    def prepare_mint_native_token(self, token_id: HexStr, mint_amount: int, options: Optional[TransactionOptions] = None) -> PreparedTransactionData:
+    def prepare_mint_native_token(self, token_id: HexStr, mint_amount: int,
+                                  options: Optional[TransactionOptions] = None) -> PreparedTransaction:
         """Mint additional native tokens.
         """
         prepared = self._call_account_method(
             'prepareMintNativeToken', {
                 'tokenId': token_id,
                 'mintAmount': hex(mint_amount),
                 'options': options
             }
         )
-        return PreparedTransactionData(self, prepared)
+        return PreparedTransaction(self, prepared)
 
-    def minimum_required_storage_deposit(self, output) -> int:
-        """Minimum required storage deposit.
-        """
-        return int(self._call_account_method(
-            'minimumRequiredStorageDeposit', {
-                'output': output
-            }
-        ))
-
-    def prepare_mint_nfts(self, params, options: Optional[TransactionOptions] = None) -> PreparedTransactionData:
-        """Mint nfts.
+    def prepare_mint_nfts(self, params: List[MintNftParams],
+                          options: Optional[TransactionOptions] = None) -> PreparedTransaction:
+        """Mint NFTs.
         """
         prepared = self._call_account_method(
             'prepareMintNfts', {
                 'params': params,
                 'options': options
             }
         )
-        return PreparedTransactionData(self, prepared)
+        return PreparedTransaction(self, prepared)
 
     def get_balance(self) -> Balance:
         """Get account balance information.
         """
         return from_dict(Balance, self._call_account_method(
             'getBalance'
         ))
 
-    def prepare_output(self, output_options, transaction_options: Optional[TransactionOptions] = None):
-        """Prepare an output for sending
+    def prepare_output(self, params: OutputParams,
+                       transaction_options: Optional[TransactionOptions] = None):
+        """Prepare an output for sending.
            If the amount is below the minimum required storage deposit, by default the remaining amount will automatically
            be added with a StorageDepositReturn UnlockCondition, when setting the ReturnStrategy to `gift`, the full
            minimum required storage deposit will be sent to the recipient.
            When the assets contain an nft_id, the data from the existing nft output will be used, just with the address
            unlock conditions replaced
         """
-        return self._call_account_method(
+        return from_dict(Output, self._call_account_method(
             'prepareOutput', {
-                'params': output_options,
+                'params': params,
                 'transactionOptions': transaction_options
             }
-        )
+        ))
 
-    def prepare_send(self, params, options: Optional[TransactionOptions] = None) -> PreparedTransactionData:
+    def prepare_send(self, params: List[SendParams],
+                     options: Optional[TransactionOptions] = None) -> PreparedTransaction:
         """Prepare to send base coins.
         """
         prepared = self._call_account_method(
             'prepareSend', {
                 'params': params,
                 'options': options
             }
         )
-        return PreparedTransactionData(self, prepared)
+        return PreparedTransaction(self, prepared)
 
-    def prepare_transaction(self, outputs, options: Optional[TransactionOptions] = None) -> PreparedTransactionData:
+    def prepare_transaction(
+            self, outputs: List[Output], options: Optional[TransactionOptions] = None) -> PreparedTransaction:
         """Prepare transaction.
         """
         prepared = self._call_account_method(
             'prepareTransaction', {
                 'outputs': outputs,
                 'options': options
             }
         )
-        return PreparedTransactionData(self, prepared)
+        return PreparedTransaction(self, prepared)
 
-    def retry_transaction_until_included(self, transaction_id: HexStr, interval=None, max_attempts=None) -> HexStr:
+    def retry_transaction_until_included(
+            self, transaction_id: HexStr, interval=None, max_attempts=None) -> HexStr:
         """Retries (promotes or reattaches) a transaction sent from the account for a provided transaction id until it's
         included (referenced by a milestone). Returns the included block id.
         """
         return self._call_account_method(
             'retryTransactionUntilIncluded', {
                 'transactionId': transaction_id,
                 'interval': interval,
                 'maxAttempts': max_attempts
             }
         )
 
     def sync(self, options: Optional[SyncOptions] = None) -> Balance:
         """Sync the account by fetching new information from the nodes.
-           Will also retry pending transactions and consolidate outputs if necessary.
-           A custom default can be set using set_default_sync_options
+        Will also retry pending transactions and consolidate outputs if necessary.
+        A custom default can be set using set_default_sync_options.
         """
         return from_dict(Balance, self._call_account_method(
             'sync', {
                 'options': options,
             }
         ))
 
-    def send(self, params, options: Optional[TransactionOptions] = None) -> Transaction:
+    def send(self, amount: str, address: str,
+             options: Optional[TransactionOptions] = None) -> Transaction:
         """Send base coins.
         """
         return Transaction.from_dict(self._call_account_method(
             'send', {
+                'amount': amount,
+                'address': address,
+                'options': options
+            }
+        ))
+
+    def send_with_params(
+            self, params: List[SendParams], options: Optional[TransactionOptions] = None) -> Transaction:
+        """Send base coins to multiple addresses or with additional parameters.
+        """
+        return Transaction.from_dict(self._call_account_method(
+            'sendWithParams', {
                 'params': params,
                 'options': options
             }
         ))
 
-    def prepare_send_native_tokens(self, params, options: Optional[TransactionOptions] = None) -> PreparedTransactionData:
+    def prepare_send_native_tokens(
+            self, params: List[SendNativeTokensParams], options: Optional[TransactionOptions] = None) -> PreparedTransaction:
         """Send native tokens.
         """
         prepared = self._call_account_method(
             'prepareSendNativeTokens', {
                 'params': params,
                 'options': options
             }
         )
-        return PreparedTransactionData(self, prepared)
+        return PreparedTransaction(self, prepared)
 
-    def prepare_send_nft(self, params, options: Optional[TransactionOptions] = None) -> PreparedTransactionData:
+    def prepare_send_nft(self, params: List[SendNftParams],
+                         options: Optional[TransactionOptions] = None) -> PreparedTransaction:
         """Send nft.
         """
         prepared = self._call_account_method(
             'prepareSendNft', {
                 'params': params,
                 'options': options
             }
         )
-        return PreparedTransactionData(self, prepared)
+        return PreparedTransaction(self, prepared)
 
     def set_alias(self, alias: str):
         """Set alias.
         """
         return self._call_account_method(
             'setAlias', {
                 'alias': alias
             }
         )
 
     def set_default_sync_options(self, options: SyncOptions):
         """Set the fallback SyncOptions for account syncing.
-           If storage is enabled, will persist during restarts.
+        If storage is enabled, will persist during restarts.
         """
         return self._call_account_method(
             'setDefaultSyncOptions', {
                 'options': options
             }
         )
 
-    def sign_transaction_essence(self, prepared_transaction_data):
+    def sign_transaction_essence(
+            self, prepared_transaction_data: PreparedTransactionData) -> SignedTransactionData:
         """Sign a transaction essence.
         """
-        return self._call_account_method(
+        return from_dict(SignedTransactionData, self._call_account_method(
             'signTransactionEssence', {
                 'preparedTransactionData': prepared_transaction_data
             }
-        )
+        ))
 
-    def sign_and_submit_transaction(self, prepared_transaction_data) -> Transaction:
+    def sign_and_submit_transaction(
+            self, prepared_transaction_data: PreparedTransactionData) -> Transaction:
         """Validate the transaction, sign it, submit it to a node and store it in the account.
         """
         return Transaction.from_dict(self._call_account_method(
             'signAndSubmitTransaction', {
                 'preparedTransactionData': prepared_transaction_data
             }
         ))
 
-    def submit_and_store_transaction(self, signed_transaction_data) -> Transaction:
+    def submit_and_store_transaction(
+            self, signed_transaction_data: SignedTransactionData) -> Transaction:
         """Submit and store transaction.
         """
         return Transaction.from_dict(self._call_account_method(
             'submitAndStoreTransaction', {
                 'signedTransactionData': signed_transaction_data
             }
         ))
 
-    def claim_outputs(self, output_ids_to_claim: List[OutputId]) -> Transaction:
+    def claim_outputs(
+            self, output_ids_to_claim: List[OutputId]) -> Transaction:
         """Claim outputs.
         """
         return Transaction.from_dict(self._call_account_method(
             'claimOutputs', {
                 'outputIdsToClaim': output_ids_to_claim
             }
         ))
 
-    def send_outputs(self, outputs, options: Optional[TransactionOptions] = None) -> Transaction:
+    def send_outputs(
+            self, outputs: List[Output], options: Optional[TransactionOptions] = None) -> Transaction:
         """Send outputs in a transaction.
         """
         return Transaction.from_dict(self._call_account_method(
             'sendOutputs', {
                 'outputs': outputs,
                 'options': options,
             }
```

## iota_sdk/wallet/common.py

```diff
@@ -5,15 +5,15 @@
 import humps
 import json
 from json import dumps, JSONEncoder
 from enum import Enum
 
 
 def _call_method_routine(func):
-    """The routine of dump json string and call call_wallet_method()
+    """The routine of dump json string and call call_wallet_method().
     """
     def wrapper(*args, **kwargs):
         class MyEncoder(JSONEncoder):
             def default(self, obj):
                 as_dict_method = getattr(obj, "as_dict", None)
                 if callable(as_dict_method):
                     return obj.as_dict()
@@ -31,28 +31,28 @@
                         for k, v in obj_dict.items():
                             obj_dict[k] = dumps(v, cls=MyEncoder)
                             return obj_dict
                     return obj_dict
                 return obj
         message = func(*args, **kwargs)
 
-        message = dumps(list(message.values()), cls=MyEncoder)
-        deserialized = json.loads(message)
+        for k, v in message.items():
+            if not isinstance(v, str):
+                message[k] = json.loads(dumps(v, cls=MyEncoder))
 
         def remove_none(obj):
             if isinstance(obj, (list, tuple, set)):
                 return type(obj)(remove_none(x) for x in obj if x is not None)
             elif isinstance(obj, dict):
                 return type(obj)((remove_none(k), remove_none(v))
                                  for k, v in obj.items() if k is not None and v is not None)
             else:
                 return obj
-        deserialized_null_filtered = remove_none(deserialized)
-
-        message = dumps(humps.camelize(deserialized_null_filtered))
+        message_null_filtered = remove_none(message)
+        message = dumps(humps.camelize(message_null_filtered))
         # Send message to the Rust library
         response = call_wallet_method(args[0].handle, message)
 
         json_response = json.loads(response)
 
         if "type" in json_response:
             if json_response["type"] == "error" or json_response["type"] == "panic":
@@ -62,9 +62,9 @@
             return json_response['payload']
         else:
             return response
     return wrapper
 
 
 class WalletError(Exception):
-    """wallet error"""
+    """A wallet error."""
     pass
```

## iota_sdk/wallet/sync_options.py

```diff
@@ -1,74 +1,124 @@
 from typing import List, Optional
 
 
 class AccountSyncOptions():
-    """Sync options for Ed25519 addresses from the account
+    """Sync options for addresses from the account.
+
+    Attributes:
+        basic_outputs: Whether to sync basic outputs.
+        nft_outputs: Whether to sync NFT outputs.
+        alias_outputs: whether to sync alias outputs.
     """
 
     def __init__(self,
                  basic_outputs: Optional[bool] = None,
                  nft_outputs: Optional[bool] = None,
                  alias_outputs: Optional[bool] = None):
-        """Initialize AccountSyncOptions
+        """Initialize `Self`.
         """
         self.basicOutputs = basic_outputs
         self.nftOutputs = nft_outputs
         self.aliasOutputs = alias_outputs
 
 
 class AliasSyncOptions():
-    """Sync options for addresses from alias outputs
+    """Sync options for addresses from alias outputs.
+
+    Attributes:
+        basic_outputs: Whether to sync basic outputs.
+        nft_outputs: Whether to sync NFT outputs.
+        alias_outputs: Whether to sync alias outputs.
+        foundry_outputs: Whether to sync foundry outputs.
     """
 
     def __init__(self,
                  basic_outputs: Optional[bool] = None,
                  nft_outputs: Optional[bool] = None,
                  alias_outputs: Optional[bool] = None,
                  foundry_outputs: Optional[bool] = None):
-        """Initialize AliasSyncOptions
+        """Initialize `Self`.
         """
         self.basicOutputs = basic_outputs
         self.nftOutputs = nft_outputs
         self.aliasOutputs = alias_outputs
         self.foundryOutputs = foundry_outputs
 
 
 class NftSyncOptions():
-    """Sync options for addresses from NFT outputs
+    """Sync options for addresses from NFT outputs.
+
+    Attributes:
+        basic_outputs: Whether to sync basic outputs.
+        nft_outputs: Whether to sync NFT outputs.
+        alias_outputs: Whether to sync alias outputs.
     """
 
     def __init__(self,
                  basic_outputs: Optional[bool] = None,
                  nft_outputs: Optional[bool] = None,
                  alias_outputs: Optional[bool] = None):
-        """Initialize NftSyncOptions
+        """Initialize `Self`.
         """
         self.basicOutputs = basic_outputs
         self.nftOutputs = nft_outputs
         self.aliasOutputs = alias_outputs
 
 
 class SyncOptions():
-    """The synchronization options
+    """The synchronization options.
+
+    **Attributes**
+    addresses :
+        Specific Bech32 encoded addresses of the account to sync. If addresses are provided,
+        then `address_start_index` will be ignored.
+    address_start_index :
+        Address index from which to start syncing addresses. 0 by default.
+        Using a higher index will be faster because addresses with a lower index will be skipped,
+        but this could result in a wrong balance for that reason.
+    address_start_index_internal :
+        Address index from which to start syncing internal addresses. 0 by default.
+        Using a higher index will be faster because addresses with a lower index will be skipped,
+        but this could result in a wrong balance for internal addresses for that reason.
+    force_syncing :
+        Usually syncing is skipped if it's called in between 200ms, because there can only be new
+        changes every milestone and calling it twice "at the same time" will not return new data.
+        When this is set to true, we will sync anyways, even if it's called 0ms after the last sync
+        finished.
+    sync_incoming_transactions :
+        Try to sync transactions from incoming outputs with their inputs. Some data may not be obtained
+        if it has been pruned.
+    sync_pending_transactions :
+        Checks pending transactions and promotes/reattaches them if necessary.
+    account :
+        Specifies what outputs should be synced for the Ed25519 addresses from the account.
+    alias :
+        Specifies what outputs should be synced for the address of an alias output.
+    nft :
+        Specifies what outputs should be synced for the address of an nft output.
+    sync_only_most_basic_outputs :
+        Specifies if only basic outputs with just an address unlock condition should be synced.
+        This will overwrite the `account`, `alias` and `nft` options.
+    sync_native_token_foundries :
+        Sync native token foundries, so their metadata can be returned in the balance.
     """
 
     def __init__(self,
                  addresses: Optional[List[str]] = None,
                  address_start_index: Optional[int] = None,
                  address_start_index_internal: Optional[int] = None,
                  force_syncing: Optional[bool] = None,
                  sync_incoming_transactions: Optional[bool] = None,
                  sync_pending_transactions: Optional[bool] = None,
                  account: Optional[AccountSyncOptions] = None,
                  alias: Optional[AliasSyncOptions] = None,
                  nft: Optional[NftSyncOptions] = None,
                  sync_only_most_basic_outputs: Optional[bool] = None,
                  sync_native_token_foundries: Optional[bool] = None):
-        """Initialize SyncOptions
+        """Initialize `Self`.
         """
         self.addresses = addresses
         self.addressStartIndex = address_start_index
         self.addressStartIndexInternal = address_start_index_internal
         self.forceSyncing = force_syncing
         self.syncIncomingTransactions = sync_incoming_transactions
         self.syncPendingTransactions = sync_pending_transactions
```

## iota_sdk/wallet/wallet.py

```diff
@@ -1,89 +1,118 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
 from iota_sdk import destroy_wallet, create_wallet, listen_wallet, get_client_from_wallet, get_secret_manager_from_wallet, Client
 from iota_sdk.secret_manager.secret_manager import LedgerNanoSecretManager, MnemonicSecretManager, StrongholdSecretManager, SeedSecretManager, SecretManager
+from iota_sdk.types.client_options import ClientOptions
+from iota_sdk.types.address import AccountAddress
 from iota_sdk.wallet.account import Account, _call_method_routine
 from iota_sdk.wallet.sync_options import SyncOptions
 from json import dumps
 from typing import Any, Dict, List, Optional
 
 
 class Wallet():
-    def __init__(self, storage_path: Optional[str] = None, client_options: Optional[Dict[str, Any]] = None, coin_type: Optional[int] = None, secret_manager: Optional[LedgerNanoSecretManager | MnemonicSecretManager | SeedSecretManager | StrongholdSecretManager] = None):
-        """Initialize the IOTA Wallet.
+    """An IOTA Wallet.
+
+    Attributes:
+        handle: The wallet handle.
+    """
+
+    def __init__(self, storage_path: Optional[str] = None, client_options: Optional[Dict[str, Any]] = None, coin_type: Optional[int] = None,
+                 secret_manager: Optional[LedgerNanoSecretManager | MnemonicSecretManager | SeedSecretManager | StrongholdSecretManager] = None):
+        """Initialize `self`.
         """
 
         # Setup the options
         options: Dict[str, Any] = {'storagePath': storage_path}
         if client_options:
-            options['clientOptions'] = client_options
+            options['clientOptions'] = client_options.as_dict()
         if coin_type:
             options['coinType'] = coin_type
         if secret_manager:
             options['secretManager'] = secret_manager
 
         options_str: str = dumps(options)
 
         # Create the message handler
         self.handle = create_wallet(options_str)
 
     def get_handle(self):
+        """Return the wallet handle.
+        """
         return self.handle
 
-    def create_account(self, alias: Optional[str] = None, bech32_hrp: Optional[str] = None):
-        """Create a new account
+    def create_account(self, alias: Optional[str] = None, bech32_hrp: Optional[str]
+                       = None, addresses: Optional[AccountAddress] = None) -> Account:
+        """Create a new account.
+
+        Args:
+            alias: The alias of the newaccount.
+            bech32_hrp: The Bech32 HRP of the new account.
+
+        Returns:
+            An account object.
         """
-        return self._call_method(
+        account_data = self._call_method(
             'createAccount', {
                 'alias': self.__return_str_or_none(alias),
                 'bech32Hrp': self.__return_str_or_none(bech32_hrp),
+                'addresses': addresses,
             }
         )
+        return Account(account_data, self.handle)
 
     def get_account(self, account_id: str | int) -> Account:
-        """Get the account instance
+        """Get the account associated with the given account ID or index.
         """
-        return Account(account_id, self.handle)
+        account_data = self._call_method(
+            'getAccount', {
+                'accountId': account_id,
+            }
+        )
+        return Account(account_data, self.handle)
 
     def get_client(self):
-        """Get the client instance
+        """Get the client associated with the wallet.
         """
         return Client(client_handle=get_client_from_wallet(self.handle))
 
     def get_secret_manager(self):
-        """Get the secret manager instance
+        """Get the secret manager associated with the wallet.
         """
-        return SecretManager(secret_manager_handle=get_secret_manager_from_wallet(self.handle))
+        return SecretManager(
+            secret_manager_handle=get_secret_manager_from_wallet(self.handle))
 
     @_call_method_routine
     def _call_method(self, name: str, data=None):
         message = {
             'name': name
         }
         if data:
             message['data'] = data
         return message
 
     def get_account_data(self, account_id: str | int):
-        """Get account data
+        """Get account data associated with the given account ID or index.
         """
         return self._call_method(
             'getAccount', {
                 'accountId': account_id
             }
         )
 
     def get_accounts(self):
-        """Get accounts
+        """Get all accounts.
         """
-        return self._call_method(
+        accounts_data = self._call_method(
             'getAccounts',
         )
+        return [Account(account_data, self.handle)
+                for account_data in accounts_data]
 
     def backup(self, destination: str, password: str):
         """Backup storage.
         """
         return self._call_method(
             'backup', {
                 'destination': destination,
@@ -105,21 +134,22 @@
         """Clear stronghold password.
         """
         return self._call_method(
             'clearStrongholdPassword'
         )
 
     def is_stronghold_password_available(self) -> bool:
-        """Is stronghold password available.
+        """Return whether a Stronghold password is available.
         """
         return self._call_method(
             'isStrongholdPasswordAvailable'
         )
 
-    def recover_accounts(self, account_start_index: int, account_gap_limit: int, address_gap_limit: int, sync_options: Optional[SyncOptions] = None):
+    def recover_accounts(self, account_start_index: int, account_gap_limit: int,
+                         address_gap_limit: int, sync_options: Optional[SyncOptions] = None):
         """Recover accounts.
         """
         return self._call_method(
             'recoverAccounts', {
                 'accountStartIndex': account_start_index,
                 'accountGapLimit': account_gap_limit,
                 'addressGapLimit': address_gap_limit,
@@ -131,53 +161,39 @@
         """Remove latest account.
         """
         return self._call_method(
             'removeLatestAccount'
         )
 
     def restore_backup(self, source: str, password: str):
-        """Restore a backup from a Stronghold file
-           Replaces client_options, coin_type, secret_manager and accounts. Returns an error if accounts were already created
-           If Stronghold is used as secret_manager, the existing Stronghold file will be overwritten. If a mnemonic was
-           stored, it will be gone.
+        """Restore a backup from a Stronghold file.
+        Replaces `client_options`, `coin_type`, `secret_manager` and accounts.
+        Returns an error if accounts were already created. If Stronghold is used
+        as the secret_manager, the existing Stronghold file will be overwritten.
+        Be aware that if a mnemonic was stored, it will be lost.
         """
         return self._call_method(
             'restoreBackup', {
                 'source': source,
                 'password': password
             }
         )
 
-    def generate_mnemonic(self) -> str:
-        """Generates a new mnemonic.
-        """
-        return self._call_method(
-            'generateMnemonic'
-        )
-
-    def verify_mnemonic(self, mnemonic: str):
-        """Checks if the given mnemonic is valid.
-        """
-        return self._call_method(
-            'verifyMnemonic', {
-                'mnemonic': mnemonic
-            }
-        )
-
     def set_client_options(self, client_options):
-        """Updates the client options for all accounts.
+        """Update the client options for all accounts.
         """
         return self._call_method(
             'setClientOptions',
             {
-                'clientOptions': client_options
+                'clientOptions': client_options.as_dict()
             }
         )
 
-    def generate_ed25519_address(self, account_index: int, internal: bool, address_index: int, options=None, bech32_hrp: Optional[str] = None) -> List[str]:
+    def generate_ed25519_address(self, account_index: int, internal: bool, address_index: int,
+                                 options=None, bech32_hrp: Optional[str] = None) -> List[str]:
         """Generate an address without storing it.
         """
         return self._call_method(
             'generateEd25519Address', {
                 'accountIndex': account_index,
                 'internal': internal,
                 'addressIndex': address_index,
@@ -192,15 +208,16 @@
         return self._call_method(
             'setStrongholdPassword', {
                 'password': password
             }
 
         )
 
-    def set_stronghold_password_clear_interval(self, interval_in_milliseconds: int):
+    def set_stronghold_password_clear_interval(
+            self, interval_in_milliseconds: int):
         """Set stronghold password clear interval.
         """
         return self._call_method(
             'setStrongholdPasswordClearInterval', {
                 'intervalInMilliseconds': interval_in_milliseconds
             }
         )
@@ -211,16 +228,17 @@
         return self._call_method(
             'storeMnemonic', {
                 'mnemonic': mnemonic
             }
 
         )
 
-    def start_background_sync(self, options: Optional[SyncOptions] = None, interval_in_milliseconds: Optional[int] = None):
-        """Start background sync.
+    def start_background_sync(
+            self, options: Optional[SyncOptions] = None, interval_in_milliseconds: Optional[int] = None):
+        """Start background syncing.
         """
         return self._call_method(
             'startBackgroundSync', {
                 'options': options,
                 'intervalInMilliseconds': interval_in_milliseconds
             }
         )
@@ -229,23 +247,23 @@
         """Stop background syncing.
         """
         return self._call_method(
             'stopBackgroundSync',
         )
 
     def listen(self, handler, events: Optional[List[int]] = None):
-        """Listen to wallet events, empty array or None will listen to all events
-           The default value for events is None
+        """Listen to wallet events, empty array or None will listen to all events.
+        The default value for events is None.
         """
         events_array = [] if events is None else events
         listen_wallet(self.handle, events_array, handler)
 
     def clear_listeners(self, events: Optional[List[int]] = None):
-        """Remove wallet event listeners, empty array or None will remove all listeners
-           The default value for events is None
+        """Remove wallet event listeners, empty array or None will remove all listeners.
+        The default value for events is None.
         """
         events_array = [] if events is None else events
         return self._call_method(
             'clearListeners', {
                 'eventTypes': events_array
             }
         )
```

## iota_sdk/__init__.py

```diff
@@ -9,21 +9,31 @@
 from .wallet.common import WalletError
 from .wallet.sync_options import AccountSyncOptions, AliasSyncOptions, NftSyncOptions, SyncOptions
 from .secret_manager.secret_manager import *
 from .prefix_hex import *
 from .types.address import *
 from .types.balance import *
 from .types.block import *
+from .types.block_builder_options import *
 from .types.burn import *
+from .types.client_options import *
 from .types.common import *
 from .types.event import *
 from .types.feature import *
+from .types.filter_options import *
+from .types.input import *
 from .types.native_token import *
+from .types.network_info import *
 from .types.node_info import *
 from .types.output import *
 from .types.output_data import *
 from .types.output_id import *
+from .types.output_params import *
 from .types.payload import *
+from .types.send_params import *
 from .types.token_scheme import *
 from .types.transaction import *
+from .types.transaction_data import *
 from .types.transaction_options import *
+from .types.unlock import *
 from .types.unlock_condition import *
+from .types.utxo_changes import *
```

## Comparing `iota_sdk/wallet/prepared_transaction_data.py` & `iota_sdk/wallet/prepared_transaction.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,75 +1,93 @@
 # Copyright 2023 IOTA Stiftung
 # SPDX-License-Identifier: Apache-2.0
 
+from __future__ import annotations
 from iota_sdk.types.transaction import Transaction
+from iota_sdk.types.transaction_data import PreparedTransactionData
+from dacite import from_dict
+from typing import TYPE_CHECKING, Dict
+# Required to prevent circular import
+if TYPE_CHECKING:
+    from iota_sdk.wallet.wallet import Account
+
+
+class PreparedTransaction:
+    """A helper class for offline signing.
+
+    Attributes:
+        account: An account object used to continue building this transaction.
+        prepared_transaction_data_dto: A prepared transaction data object.
+    """
 
-class PreparedTransactionData:
     def __init__(
         self,
-        account,
-        prepared_transaction_data
+        account: Account,
+        prepared_transaction_data: PreparedTransactionData | Dict
     ):
-        """Helper struct for offline signing
-
-        Parameters
-        ----------
-        account : account object
-            An account object used to continue building this transaction.
-        prepared_transaction_data : dict of prepared data
-            The data of a prepared transaction object
+        """Initalize `Self`.
         """
         self.account = account
         self.prepared_transaction_data_dto = prepared_transaction_data
 
-    
     """
     The function returns the prepared transaction data.
 
     :returns: The method prepared_transaction_data() is returning an object of type PreparedTransaction
     """
-    def prepared_transaction_data(self):
-        return self.prepared_transaction_data_dto
 
+    def prepared_transaction_data(self) -> PreparedTransactionData:
+        """Get the prepared transaction data.
+        """
+        return self.prepared_transaction_data_dto if isinstance(
+            self.prepared_transaction_data_dto, PreparedTransactionData) else from_dict(PreparedTransactionData, self.prepared_transaction_data_dto)
 
     """
     The send function returns a promise that resolves to a Transaction object after signing
     and submitting the transaction. Internally just calls sign_and_submit_transaction.
 
     :returns: The send() method is returning a Transaction object after it has been signed and submitted.
     """
-    def send(self) -> Transaction:
-        return self.sign_and_submit_transaction()
 
+    def send(self) -> Transaction:
+        """Send a transaction. Internally just calls `sign_and_submit_transaction`.
 
-    """
-    This function signs a prepared transaction essence using the account's private key and returns
-    the signed transaction essence.
+        Returns:
+            The transaction after it has been signed and submitted.
+        """
+        return self.sign_and_submit_transaction()
 
-    :returns: A SignedTransactionEssence object.
-    """
     def sign(self):
-        return self.account.sign_transaction_essence(self.prepared_transaction_data())
+        """Sign a prepared transaction essence using the account's private key and returns
+        the signed transaction essence.
+        """
+        return self.account.sign_transaction_essence(
+            self.prepared_transaction_data())
 
-    
-    """
-    This function signs and submits a transaction using prepared transaction data.
+    def sign_and_submit_transaction(self) -> Transaction:
+        """Sign and submit a transaction using prepared transaction data.
 
-    Returns:
+        Returns:
+            The transaction after it has been signed and submitted.
+        """
+        return self.account.sign_and_submit_transaction(
+            self.prepared_transaction_data())
 
-    :returns: A Transaction object.
-    """
-    def sign_and_submit_transaction(self) -> Transaction:
-        return self.account.sign_and_submit_transaction(self.prepared_transaction_data())
 
-class PreparedCreateTokenTransaction(PreparedTransactionData):
+class PreparedCreateTokenTransaction(PreparedTransaction):
 
-    """
+    """A prepared transaction for creating a native token.
     The function returns the token_id as a string.
 
-    :returns: The token id of the PreparedCreateTokenTransaction.
+    Returns: The token id of the PreparedCreateTokenTransaction.
     """
+
     def token_id(self):
+        """Get the native token id as a string.
+        """
         return self.prepared_transaction_data_dto["tokenId"]
 
     def prepared_transaction_data(self):
-        return self.prepared_transaction_data_dto["transaction"]
+        """The function returns the prepared transaction data.
+        """
+        return from_dict(PreparedTransactionData,
+                         self.prepared_transaction_data_dto["transaction"])
```

